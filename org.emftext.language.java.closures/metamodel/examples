package example.closure2;


class Example{ 

	public class One {
  
	    public void test(String[] args) {
	      // function with no arguments; return value is always 42
	      int answer = {=> int} : = { => 42; }.invoke();;
	      System.out.println(answer);
	    }
	    
	    /*static*/ { => int } : answer2 = { => 42; }; // Closures mit modifier fÃ¼r innere methode
	    
  		 public void test2(String[] args) {
      		int i = answer2.invoke();  
      		System.out.println(i); 
    	}
  		
 	}

	public class Two {
	
		public void test(String[] args) {
			double log = {double => double} : = { double x => Math.log(x); }.invoke(10);;
		}
	}
   
   	public class Three {
		public void test (String [] args) {
			int half = {int => int} : ={ 
				    int x => 
				    if (x % 2 != 0) {System.out.printf("%d is odd%n", x); x / 2;}   
				  }.invoke(31);;

		}
	}
	
	public class Four {
		public void test (String [] args) {
			{char => void} : = { char c => System.out.println(c); }.invoke('@');    

		}
	}
	
	public class Five {
		public void test (String [] args) {
			String reversed = {String => String} : = { 
			    String s => 
			    new StringBuilder(s).reverse().toString(); 
			  }.invoke("abcd");; 

		}
	}
	
	public class Six {
		public void test (String [] args) {
			{=> void} Runnable : = { => System.out.println("hi from Prague");}.run(); 
		
			{=> Runnable} := { => new Runnable() {
								      public void run() {
								        System.out.println("hi from Prague");
								      }
		   						  };
		  					 }.invoke();//.run() -- Closure von Method Call Erben mit next() als reference auf run?
		}
	}
	
	public class Seven {
		public void test (String [] args) {
					 {int => void} := { int n => 
		    	int m = n + 1; System.out.println(m * m); 
		  		}.invoke(3);  // will print 16
		}
	}
	
	public class Eight {
		public void test (String [] args) {
			{ int => String } : toBinary = { int x => Integer.toBinaryString(x); };
  			String binary11 = toBinary.invoke(11);
		}
	}
	
	public class Nine {
		
		void doTwice({ => void } : block) {
    		block.invoke();  // Kopierfehler beim Erstellen ?
    		block.invoke();
  		}
  		
  		public void test(String[] args) {
    		doTwice({ => void } : = { => System.out.println("deja vu"); };);
  		}
	}
	
	public class Ten {
	
  		/*static*/ boolean makeCond() {
		    return {=>boolean} := { => Math.random() < 0.8; }.invoke();;
		  }
  
		  public void test(String[] args) {
			    boolean cond = makeCond();
			    while (cond) {
			      System.out.println("trying...");
			    }
		  }
  		
  	}
	
}


