epackage java.classifiers;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import java.types.*;

eclass Class {
	
	/**
	 * Recursively collects all super types (extended classes and implemented interfaces)
	 * of the given class.
	 * 
	 * @param classifierList the list for the result
	 */
	getAllSuperClassifiers() {
		EList<ConcreteClassifier> result = 
			new BasicEList<ConcreteClassifier>();
					
		//collects all superclasses
		Class superClass = this;
		while (superClass != null && !superClass.eIsProxy() && 
				!superClass.equals(getObjectClass())) {
			superClass = superClass.getSuperClass();
			if (superClass != null) {
				result.add(superClass);
			}
		}
		
		//collect all implemented interfaces
		for (TypeReference typeArg : this.getImplements()) {
			ConcreteClassifier superInterface = (ConcreteClassifier) typeArg.getTarget();
			if (superInterface != null) {
				result.add(superInterface);
				if (superInterface instanceof Interface) {
					result.addAll(((Interface)superInterface).getAllSuperClassifiers());
				}
			}
		}
		
		//collect all implemented interfaces of super classes	
		if (superClass != null && !superClass.eIsProxy() && 
				!superClass.equals(getObjectClass())) {
			for (TypeReference typeArg : superClass.getImplements()) {
				ConcreteClassifier superInterface = (ConcreteClassifier) typeArg.getTarget();
				if (superInterface != null) {
					result.add(superInterface);
					if (superInterface instanceof Interface) {
						result.addAll(((Interface)superInterface).getAllSuperClassifiers());
					}
				}
			}
		}	

		return result;
	}
	
	/**
	 * @param this
	 * @return the direct super class
	 */
	getSuperClass() {
		TypeReference superClassReference = this.getExtends();
		if (superClassReference == null) {
			superClassReference = this.getDefaultExtends();
		}
		Type result = superClassReference.getTarget();
		if (result instanceof Class) {
			return (Class) result;
		}
		return null;
	}
	
	/**
	 * @param this
	 * @return primitive type, if the class can be wrapped
	 */
	unWrapPrimitiveType() {	
		if (getClass("Boolean").equals(this)) {
			return #Boolean;
		}
		if (getClass("Byte").equals(this)) {
			return #Byte;
		}
		if (getClass("Character").equals(this)) {
			return #Char;
		}
		if (getClass("Float").equals(this)) {
			return #Float;
		}
		if (getClass("Double").equals(this)) {
			return #Double;
		}
		if (getClass("Integer").equals(this)) {
			return #Int;
		}
		if (getClass("Long").equals(this)) {
			return #Long;
		}
		if (getClass("Short").equals(this)) {
			return #Short;
		}
		if (getClass("Void").equals(this)) {
			return #Void;
		}
		return null;
	}

}
