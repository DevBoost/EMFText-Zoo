--@atlcompiler atl2006 
module uml2java;
create OUT : java from  IN : uml;


rule Class {
	from i : uml!Class 
	to o : java!Class (
		name <- i.name,
		members <- i.ownedAttribute
		              ->union(i.ownedOperation)
		              ->union(
		              	 i.package.packagedElement
						   ->select(e | e.oclIsTypeOf(uml!Association))
						   ->select(e | e.memberEnd->select(end | end.type = i)->size() > 0)
						   ->collect(e | e.memberEnd)->flatten()->select(end | end.type <> i)
					  ),
		"extends" <-  if i.generalization->size() > 0 then typeRef
					  else OclUndefined endif
	),
    cu : java!CompilationUnit (
    	namespaces <- i.package.name.split('\\.'),
		classifiers <- Sequence{o}
	),
	typeRef : java!ClassifierReference (
		target <- if i.generalization->size() > 0
			then i.generalization->at(1).general
			else OclUndefined
			endif
	)
}

rule Property {
	from umlProperty : uml!Property
	to javaField : java!Field (
		name <- umlProperty.name,
		annotationsAndModifiers <- protected,
		typeReference <- typeRef1
	),
	protected : java!Protected(
	),
	typeRef1 : java!ClassifierReference (
		target <- if (umlProperty.upper = 1) then
			umlProperty.type
		else
			OclUndefined --done in do block
		endif,
		typeArguments <- if (umlProperty.upper = 1) then
					Sequence{}
				else
					Sequence{typeArgument}
				endif
	),
	typeArgument : java!QualifiedTypeArgument(
		typeReference <- typeRef2
	),
	typeRef2 : java!ClassifierReference (
		target <- umlProperty.type
	)
	do {
		typeRef1.target <-
			if (umlProperty.upper = 1) then
				typeRef1.target
			else
				typeRef1.getConcreteClassifier('java.lang.List')
			endif;
	}
}

rule Operation {
	from i : uml!Operation
	to o : java!ClassMethod (
		name <- i.name,
		typeReference <- if i.type = OclUndefined  then
					voidType
				  else
				  	typeRef
				  endif,
		statements <- body,
		annotationsAndModifiers <- Sequence{public} --TODO inspect visibility defined in UML
	),
	--return type
	typeRef : java!ClassifierReference (
		target <- if i.type = OclUndefined then OclUndefined else 
				if i.type.name = 'String' then
					OclUndefined -- replaced in do block
				else
					i.type	
				endif endif
	),
	voidType : java!Void (
	),
	-- empty body with slot
	body : java!Block ( 
	--	statements <- Sequence{slot}
	--),
	--slot : java!StatementSlot (
	--	pointName <- i.name, 
	--	portName <- i.class.package.name
	),
	public : java!Public (
	)
	do {
		typeRef.target <- if i.type = OclUndefined then typeRef.target else
				if i.type.name = 'String' then 
					typeRef.getStringClass() 
				else
					typeRef.target
				endif endif;
	}
	
}