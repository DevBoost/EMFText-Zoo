modeltype JAVA uses "http://www.emftext.org/java";

transformation Java2Closure(inout java : JAVA);

main() {
	java.objects()[JAVA::classifiers::Class]->map Classifiers_Class();
	java.objects()[JAVA::statements::StatementListContainer]->map Statements_StatementListContainer();
	java.objects()[JAVA::statements::StatementContainer]->map Statements_StatementContainer();
--	java.objects()[JAVA::statements::Return]->map Statements_Return();
--	java.objects()[JAVA::_references::MethodCall]->map References_MethodCall();
--	java.objects()[JAVA::statements::ExpressionStatement]->map Expressions_ExpressionStatement();
}

mapping JAVA::classifiers::Class::Classifiers_Class(){}

mapping inout JAVA::statements::StatementContainer::Statements_StatementContainer(){
	
	var localVar : JAVA::variables::LocalVariable;
	var lvCondition : JAVA::statements::Condition;
	var rCondition : JAVA::statements::Condition;
	var ret :  JAVA::statements::Return;
	
	if self.oclIsTypeOf(JAVA::statements::LocalVariableStatement) then
		localVar := self.oclAsType(JAVA::statements::LocalVariableStatement).variable
	endif;
	if self.oclIsTypeOf(JAVA::statements::Return) then
		ret := self.oclAsType(JAVA::statements::Return)
	endif;
	
	if not localVar.oclIsUndefined() then
		lvCondition := map CondExpr2Cond(localVar)
	endif;
	if not ret.oclIsUndefined() then
		rCondition := map CondExpr2Cond(ret)
	endif;
	
	if not lvCondition.oclIsUndefined() then
		self.statement := lvCondition
	endif;
	if not lvCondition.oclIsUndefined() then
		localVar.initialValue := null
	endif;
	
	if not rCondition.oclIsUndefined() then
		self.statement := rCondition
	endif;

}

mapping inout JAVA::statements::StatementListContainer::Statements_StatementListContainer(){
	
	self.statements->forEach(s){
		var localVar : JAVA::variables::LocalVariable;
		var lvCondition : JAVA::statements::Condition;
		var rCondition : JAVA::statements::Condition;
		var ret :  JAVA::statements::Return;
		
		if s.oclIsTypeOf(JAVA::statements::LocalVariableStatement) then
			localVar := s.oclAsType(JAVA::statements::LocalVariableStatement).variable
		endif;
		if s.oclIsTypeOf(JAVA::statements::Return) then
			ret := s.oclAsType(JAVA::statements::Return)
		endif;
		
		if not localVar.oclIsUndefined() then
			lvCondition := map CondExpr2Cond(localVar)
		endif;
		if not ret.oclIsUndefined() then
			rCondition := map CondExpr2Cond(ret)
		endif;
		
		if not lvCondition.oclIsUndefined() then
			self.statements := 
				self.statements->append(lvCondition)
		endif;
		if not lvCondition.oclIsUndefined() then
			localVar.initialValue := null
		endif;
		
		if not rCondition.oclIsUndefined() then
			self.statements := 
				self.statements->append(rCondition)->excluding(ret)
		endif;
	}
}

mapping CondExpr2Cond(in lv : JAVA::variables::LocalVariable) : 
	JAVA::statements::Condition 
	when {
		lv.initialValue.oclIsTypeOf(JAVA::expressions::ConditionalExpression)
	}
	{
	
	var condExpr : JAVA::expressions::ConditionalExpression :=
		lv.initialValue.oclAsType(JAVA::expressions::ConditionalExpression);
	
	condition := condExpr.child;
	statement := map statements_ExpressionStatement(condExpr.expressionIf,lv);
	elseStatement := map statements_ExpressionStatement(condExpr.expressionElse,lv);
}

mapping CondExpr2Cond(in r : JAVA::statements::Return) : 
	JAVA::statements::Condition 
	when {
		r.returnValue.oclIsTypeOf(JAVA::expressions::ConditionalExpression)
	}
	{
	
	var condExpr : JAVA::expressions::ConditionalExpression :=
		r.returnValue.oclAsType(JAVA::expressions::ConditionalExpression);
	
	condition := condExpr.child;
	statement := map statements_Return(condExpr.expressionIf);
	elseStatement := map statements_Return(condExpr.expressionElse);
}

mapping statements_ExpressionStatement(
	in ex : JAVA::expressions::Expression,in lv : JAVA::variables::LocalVariable) : 
	JAVA::statements::ExpressionStatement {
	
	expression := map expressions_AssignmentExpression(ex,lv);
}

mapping expressions_AssignmentExpression(
	in ex : JAVA::expressions::Expression,in lv : JAVA::variables::LocalVariable) : 
	JAVA::expressions::AssignmentExpression {
	
	child := object JAVA::_references::IdentifierReference{
		target := lv;
	};
	assignmentOperator := object JAVA::operators::Assignment{};
	value := ex;
}

mapping statements_Return(in ex : JAVA::expressions::Expression) : 
	JAVA::statements::Return {
	
	returnValue := ex;
}