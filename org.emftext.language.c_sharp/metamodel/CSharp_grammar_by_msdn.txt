
C# Language Specification
C. Grammar

This appendix contains summaries of the lexical and syntactic grammars found in the main document, and of the grammar extensions for unsafe code. Grammar productions appear here in the same order that they appear in the main document.
C.1 Lexical grammar

input:
    input-section *
    
input-section:
    input-element *   new-line
    pp-directive
    
input-element:
    whitespace
    comment
    token

C.1.1 Line terminators

new-line:
    Carriage return character (U+000D)
    Line feed character (U+000A)
    Carriage return character (U+000D) followed by line feed character (U+000A)
    Line separator character (U+2028)
    Paragraph separator character (U+2029)

C.1.2 White space

whitespace:
    Any character with Unicode class Zs
    Horizontal tab character (U+0009)
    Vertical tab character (U+000B)
    Form feed character (U+000C)

C.1.3 Comments

comment:
    single-line-comment
    delimited-comment
    
single-line-comment:
    '//'   input-character *

input-character:
    Any Unicode character except a new-line-character
    
new-line-character:
    Carriage return character (U+000D)
    Line feed character (U+000A)
    Line separator character (U+2028)
    Paragraph separator character (U+2029)
    
delimited-comment:
    /*   delimited-comment-character *   */

delimited-comment-character:
    not-asterisk
    '*'   not-slash
    
not-asterisk:
    Any Unicode character except *
    
not-slash:
    Any Unicode character except /

C.1.4 Tokens

token:
    identifier
    keyword
    integer-literal
    real-literal
    character-literal
    string-literal
    operator-or-punctuator

C.1.5 Unicode character escape sequences

unicode-escape-sequence:
    '\u'   hex-digit   hex-digit   hex-digit   hex-digit
    '\U'   hex-digit   hex-digit   hex-digit   hex-digit   hex-digit   hex-digit   hex-digit   hex-digit



C.1.6 Identifiers

//Identifier bisher als direkte Kopie von der Java-Grammatik -->siehe NamedElement ("name[]") 

//pre-done
identifier:  
    available-identifier
    '@'   identifier-or-keyword

//pre-done
available-identifier: 
    An identifier-or-keyword that is not a keyword

//pre-done    
identifier-or-keyword: 
    identifier-start-character   identifier-part-character *

//pre-done  
identifier-start-character: 
    letter-character
    '_' (the underscore character U+005F) 

//pre-done  
identifier-part-character: 
    letter-character
    decimal-digit-character
    connecting-character
    combining-character
    formatting-character

//pre-done
letter-character: 
    A Unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nl
    A unicode-escape-sequence representing a character of classes Lu, Ll, Lt, Lm, Lo, or Nl

//pre-done
combining-character: 
    A Unicode character of classes Mn or Mc
    A unicode-escape-sequence representing a character of classes Mn or Mc

//pre-done
decimal-digit-character: 
    A Unicode character of the class Nd 
    A unicode-escape-sequence representing a character of the class Nd

//pre-done
connecting-character: 
    A Unicode character of the class Pc
    A unicode-escape-sequence representing a character of the class Pc

//pre-done
formatting-character: 
    A Unicode character of the class Cf
    A unicode-escape-sequence representing a character of the class Cf

C.1.7 Keywords

keyword: one of
    abstract 	as 	base 	bool 	break 	byte 	case
    catch 	char 	checked 	class 	const 	continue 	decimal
    default 	delegate 	do 	double 	else 	enum 	event
    explicit 	extern 	false 	finally 	fixed 	float 	for
    foreach 	goto 	if 	implicit 	in 	int 	interface
    internal 	is 	lock 	long 	namespace 	new 	null
    object 	operator 	out 	override 	params 	private 	protected
    public 	readonly 	ref 	return 	sbyte 	sealed 	short
    sizeof 	stackalloc 	static 	string 	struct 	switch 	this
    throw 	true 	try 	typeof 	uint 	ulong 	unchecked
    unsafe 	ushort 	using 	virtual 	void 	volatile 	while

C.1.8 Literals

literal:
    boolean-literal
    integer-literal
    real-literal
    character-literal
    string-literal
    null-literal
    
boolean-literal:
    'true'
    'false'
    
integer-literal:
    decimal-integer-literal
    hexadecimal-integer-literal
    
decimal-integer-literal:
    decimal-digit *   integer-type-suffix ?
    
decimal-digit: one of
    0 1 2 3 4 5 6 7 8 9
    
integer-type-suffix: one of
    U u L l UL Ul uL ul LU Lu lU lu
    
hexadecimal-integer-literal:
    '0x'   hex-digit *   integer-type-suffix ?
    '0X'   hex-digit *   integer-type-suffix ?

hex-digit: one of
    0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f
    
real-literal:
    decimal-digit *   '.'   decimal-digit *   exponent-part ?   real-type-suffix ?
    '.'   decimal-digit *   exponent-part ?   real-type-suffix ?
    decimal-digit *   exponent-part   real-type-suffix ?
    decimal-digit *   real-type-suffix
    
exponent-part:
    'e'   sign ?   decimal-digit *
    'E'   sign ?   decimal-digit *
    
sign: one of
    + -
    
real-type-suffix: one of
    F f D d M m
    
character-literal:
   '''   character   ''' //also '
    
character:
    single-character
    simple-escape-sequence
    hexadecimal-escape-sequence
    unicode-escape-sequence
    
single-character:
    Any character except ' (U+0027), \ (U+005C), and new-line-character
    
simple-escape-sequence: one of
    \' \" \\ \0 \a \b \f \n \r \t \v
    
hexadecimal-escape-sequence:
    '\x'   hex-digit   hex-digit ?   hex-digit ?   hex-digit ?
    
string-literal:
    regular-string-literal
    verbatim-string-literal
    
regular-string-literal:
    '"'   regular-string-literal-character *   '"'

regular-string-literal-character:
    single-regular-string-literal-character
    simple-escape-sequence
    hexadecimal-escape-sequence
    unicode-escape-sequence
    
single-regular-string-literal-character:
    Any character except " (U+0022), \ (U+005C), and new-line-character
    
verbatim-string-literal:
    '@"'   verbatim-string-literal-character *   '"'
    
verbatim-string-literal-character:
    single-verbatim-string-literal-character
    quote-escape-sequence
    
single-verbatim-string-literal-character:
    any character except "
    
quote-escape-sequence:
    '""'
    
null-literal:
    'null'

C.1.9 Operators and punctuators

operator-or-punctuator: one of
    { } [ ] ( ) . , : ;
    + - * / % & | ^ ! ~
    = < > ? ++ -- && || << >>
    == != <= >= += -= *= /= %= &=
    |= ^= <<= >>= ->

C.1.10 Pre-processing directives

pp-directive:
    pp-declaration
    pp-conditional
    pp-line
    pp-diagnostic
    pp-region
    
pp-new-line:
    whitespace ?   single-line-comment ?   new-line

conditional-symbol:
    Any identifier-or-keyword except true or false

pp-expression:
    whitespace ?   pp-or-expression   whitespace ?
    
pp-or-expression:
    pp-and-expression
    pp-or-expression   whitespace ?   '||'   whitespace ?   pp-and-expression

pp-and-expression:
    pp-equality-expression
    pp-and-expression   whitespace ?   '&&'   whitespace ?   pp-equality-expression

pp-equality-expression:
    pp-unary-expression
    pp-equality-expression   whitespace ?   '=='   whitespace ?   pp-unary-expression
    pp-equality-expression   whitespace ?   '!='   whitespace ?   pp-unary-expression
 
pp-unary-expression:
    pp-primary-expression
    '!'   whitespace ?   pp-unary-expression
 
pp-primary-expression:
    'true'
    'false'
    conditional-symbol
    '('   whitespace ?   pp-expression   whitespace ?   ')'
    
pp-declaration:
    whitespace ?   '#'   whitespace ?   define   whitespace   conditional-symbol   pp-new-line
    whitespace ?   '#'   whitespace ?   undef   whitespace   conditional-symbol   pp-new-line

pp-conditional:
    pp-if-section   pp-elif-section *   pp-else-section ?   pp-endif

pp-if-section:
    whitespace ?   '#'   whitespace ?   'if'   whitespace   pp-expression   pp-new-line   conditional-section ?
 
pp-elif-section:
    whitespace ?   '#'   whitespace ?   'elif'   whitespace   pp-expression   pp-new-line   conditional-section ?
    
pp-else-section:
    whitespace ?   '#'   whitespace ?   'else'   pp-new-line   conditional-section ?
    
pp-endif:
    whitespace ?   '#'   whitespace ?   'endif'   pp-new-line

conditional-section:
    input-section
    skipped-section +
    
skipped-section:
    skipped-characters ?   new-line
    pp-directive
    
skipped-characters:
    whitespace ?   not-number-sign   input-character *
    
not-number-sign:
    Any input-character except '#'
    
pp-line:
    whitespace ?   '#'   whitespace ?   line   whitespace   line-indicator   pp-new-line
    
line-indicator:
    decimal-digit *   whitespace   file-name
    decimal-digit *
    'default'
    
file-name:
    '"'   file-name-character *   '"'
    
file-name-character:
    Any input-character except "
    
pp-diagnostic:
    whitespace ?   '#'   whitespace ?   error   pp-message
    whitespace ?   '#'   whitespace ?   warning   pp-message
    
pp-message:
    new-line
    whitespace   input-character *   new-line
    
pp-region:
    pp-start-region   conditional-section ?   pp-end-region
    
pp-start-region:
    whitespace ?   '#'   whitespace ?   region   pp-message
    
pp-end-region:
    whitespace ?   '#'   whitespace ?   endregion   pp-message
    

C.2 Syntactic grammar

C.2.1 Basic concepts

namespace-or-type-name: //done with namespaceOrTypeNameParts
    identifier ( '.' namespace-or-type-name) ? 


C.2.2 Types

type:
    value-type //done
    reference-type //done
    pointer-type
    
pointer-type: //achtung: Linksrekursiv
    type   '*'
    'void'   '*'

//done, splitt in SimpleType and ReferenceType    
value-type:
    struct-type
    enum-type

//done, splitt in SimpleType and ReferenceType  
struct-type:
    namespace-or-type-name 
    simple-type

//done as abstract  
simple-type:
    numeric-type
    'bool' //done as Simpletype

//done as Simpletype    
numeric-type:
    integral-type
    floating-point-type
    'decimal'

//done as Simpletype    
integral-type:
    sbyte
    byte
    short
    ushort
    int
    uint
    long
    ulong
    char

//done as Simpletype    
floating-point-type:
    float
    double
    
//done in ClassOrInterfaceOrDelegateOrEnumType   
enum-type:
    namespace-or-type-name

//pre-done as abstract, array-type fehlt
reference-type:		
    class-type
    interface-type
    array-type
    delegate-type

//done in ClassOrInterfaceOrDelegateOrEnumType    
class-type: 		
    namespace-or-type-name
    'object'
    'string'			

//done in ClassOrInterfaceOrDelegateOrEnumType 
interface-type:
    namespace-or-type-name
    
//done in ClassOrInterfaceOrDelegateOrEnumType
delegate-type:
    namespace-or-type-name



C.2.3 Variables

variable-reference:
    expression

C.2.4 Expressions

argument-list:
    argument ( ','   argument) * 
     
argument:		//Reihenfolge beachten 
    expression
    'ref'   variable-reference
    'out'   variable-reference
    
primary-expression:
    primary-no-array-creation-expression
    array-creation-expression
    
primary-no-array-creation-expression:
    literal
    identifier
    parenthesized-expression
    member-access
    invocation-expression
    element-access
    'this'
    base-access
    post-increment-expression
    post-decrement-expression
    object-creation-expression
    delegate-creation-expression
    typeof-expression
    sizeof-expression
    checked-expression
    unchecked-expression
    pointer-member-access
    pointer-element-access
    sizeof-expression
    
    
pointer-indirection-expression:
    '*'   unary-expression
    
pointer-member-access:		//achtung: Linksrekursiv, -> identifier  muss eventuell ausgelagert werden 
    primary-expression   '->'   identifier
    
pointer-element-access: 	//achtung: Linksrekursiv, '[' expression ] muss eventuell ausgelagert werden 
    primary-no-array-creation-expression   '['   expression   ]
    
addressof-expression:
    '&'   unary-expression
    
sizeof-expression:
    'sizeof'   (   type   )
    
    
parenthesized-expression:
    '('   expression   ')'
    
member-access:
    primary-expression   '.'   identifier
    predefined-type   '.'   identifier
    
predefined-type: one of
    bool byte char decimal double float int long
    object sbyte short string uint ulong ushort
    
invocation-expression:
    primary-expression   '('   argument-list ?   ')'

element-access:
    primary-no-array-creation-expression   '['   expression-list   '']''
    
expression-list:
    expression ( ','   expression )*
      
base-access:
    'base'   '.'   identifier
    'base'   '['   expression-list   ']'
    
post-increment-expression:
    primary-expression   '++'
    
post-decrement-expression:
    primary-expression   '--'
    
object-creation-expression:
    'new'   type   '('   argument-list ?   ')'
    
array-creation-expression:
    'new'   type   '['   expression-list   ']'   rank-specifier *   array-initializer ?
    'new'   array-type   array-initializer
    
delegate-creation-expression:
    'new'   delegate-type   (   expression   )

typeof-expression:
    'typeof'   '('   type   ')'
    'typeof'   '('   'void'   ')'
    
checked-expression:
    'checked'   '('   expression   ')'

unchecked-expression:
    'unchecked'   '('   expression   ')'
    
unary-expression:
    primary-expression
    '+'   unary-expression
    '-'   unary-expression
    '!'   unary-expression
    '~'   unary-expression
    '*'   unary-expression
    pre-increment-expression
    pre-decrement-expression
    cast-expression
    pointer-indirection-expression
    addressof-expression
    
pre-increment-expression:
    '++'   unary-expression
    
pre-decrement-expression:
    '--'   unary-expression
    
cast-expression:
    '('   type   ')'   unary-expression
    
multiplicative-expression:
    unary-expression   ( ( '*' | '/' | '%' )   unary-expression )*
    
additive-expression:
    multiplicative-expression ( ( '+' | '-' ) multiplicative-expression

shift-expression:
    additive-expression ( ( '<<' | '>>' | '%' )   additive-expression )?

relational-expression:
    shift-expression (( 'is' | 'as' ) type )? ( ( '<' | '>' | '<=' | '>=' )   shift-expression (( 'is' | 'as' ) type )? )* 
	//(( is | as ) type )? muss weiter unterschieden werden
    
equality-expression:
    relational-expression   (('==' | '!=')   relational-expression)*
   
and-expression:
    equality-expression   ('&'   equality-expression)*
    
exclusive-or-expression:
    and-expression  ( '^'   and-expression )*
    
inclusive-or-expression:
    exclusive-or-expression   ('|'   exclusive-or-expression)*
    
conditional-and-expression:
    inclusive-and-expression   ('&&'   inclusive-or-expression)*
    
conditional-or-expression:
    conditional-and-expression   ('||'   conditional-and-expression)*
    
conditional-expression:
    conditional-or-expression  ( '?'   expression   ':'   expression ) ?
    
assignment:
    unary-expression   assignment-operator   expression
    
assignment-operator: one of
    =   +=   -=   *=   /=   %=   &=   |=   ^=   <<=   >>=
    
//half-done, assignment is missing		Zehlike
expression:
    conditional-expression
    assignment


C.2.5 Statements

//done 		Zehlike
statement:
    labeled-statement
    declaration-statement
    embedded-statement
  
//done		Zehlike  
embedded-statement:
    ( 'unsafe' ) ?  block
    empty-statement
    expression-statement
    selection-statement
    iteration-statement
    jump-statement
    try-statement
    checked-statement
    unchecked-statement
    lock-statement
    using-statement
	fixed-statement

//done		Zehlike
block:
    '{'   statement *  '}'

//done		Zehlike
empty-statement:
    ';'

//done, while identifier is just a name[] of Type NamedElement		Zehlike
labeled-statement:
    identifier  ':'   statement

//done		Zehlike
declaration-statement:
    local-variable-declaration   ';'
    local-constant-declaration   ';'
    
//done		Zehlike
local-variable-declaration:
    type   local-variable-declarator +
   
//done		Zehlike 
local-variable-declarator:
    identifier ( '='   local-variable-initializer) ? 

//half-done, as abstract class, 
//array-initializer is missing		Range  
local-variable-initializer:
    expression
    array-initializer

//done		Zehlike   
local-constant-declaration:
    'const'   type   constant-declarators

//done		in local-constant-declaration		Range
constant-declarators:
    constant-declarator ( ','   constant-declarator)*

//done		Zehlike
constant-declarator:
    identifier   =   expression

//done
expression-statement:
    statement-expression   ';'

//pre-done as abstract, einzelne Expressions fehlen noch   
statement-expression:
    invocation-expression
    object-creation-expression
    assignment
    post-increment-expression
    post-decrement-expression
    pre-increment-expression
    pre-decrement-expression
    
selection-statement:
    if-statement
    switch-statement
    
if-statement:
    'if'   '('   expression   ')'   embedded-statement	( 'else'   embedded-statement ) ?
    
    
switch-statement:
    'switch'   '('   expression   ')'   switch-block
    
switch-block:
    '{'   switch-section *   '}'
    
switch-section:
    switch-label *   statement *

switch-label:
    'case'   expression  ':'
    'default'  ':'
    
iteration-statement:
    while-statement
    do-statement
    for-statement
    foreach-statement
    
while-statement:
    'while'   '('   expression   ')'   embedded-statement
    
do-statement:
    'do'   embedded-statement   'while'   '('   expression   ')'   ';'
    
for-statement:
    'for'   '('   for-initializer ?   ';'   expression ?   ';'   statement-expression-list ?   ')'   embedded-statement
    
for-initializer:
    local-variable-declaration
    statement-expression-list
    
statement-expression-list:
    statement-expression (  ','   statement-expression )*  
    
foreach-statement:
    'foreach'   '('   type   identifier   'in'   expression   ')'   embedded-statement
    
jump-statement:
    break-statement
    continue-statement
    goto-statement
    return-statement
    throw-statement
    
break-statement:
    'break'   ';'
    
continue-statement:
    'continue'   ';'
    
goto-statement:
    'goto'   identifier   ';'
    'goto'   'case'   expression   ';'
    'goto'   'default'   ';'
    
return-statement:
    'return'   expression ?   ';'
    
throw-statement:
    'throw'   expression ?   ';'
    
try-statement:
    'try'   block   catch-clauses
    'try'   block   finally-clause
    'try'   block   catch-clauses   finally-clause
    
catch-clauses:
    specific-catch-clauses +   general-catch-clause ?
    specific-catch-clauses *   general-catch-clause
    
specific-catch-clause:
    'catch'   '('   class-type   identifier ?   ')'   block
    
general-catch-clause:
    'catch'   block
    
finally-clause:
    'finally'   block
    
checked-statement:
    'checked'   block
    
unchecked-statement:
    'unchecked'   block
    
lock-statement:
    'lock'   '('   expression   ')'   embedded-statement
    
using-statement:
    'using'   '('    resource-acquisition   ')'    embedded-statement
    
resource-acquisition:
    local-variable-declaration
    expression

fixed-statement:
    'fixed'   '('   pointer-type   fixed-pointer-declarators   ')'   embedded-statement
    
fixed-pointer-declarators:
    fixed-pointer-declarator ( ','   fixed-pointer-declarator)*
 
fixed-pointer-declarator:
    identifier   =   fixed-pointer-initializer
    
fixed-pointer-initializer:
    &   variable-reference
    expression
    
    

C.2.6 Namespaces

compilation-unit:
    using-directive *   global-attribute *   namespace-member-declaration *

//done, merge alias and namespace
using-directive:  			
    using-alias-directive
    using-namespace-directive

//done
using-alias-directive: 		
    'using'   identifier   '='   namespace-or-type-name   ';'

//done 
using-namespace-directive: 	
    'using'   namespace-or-type-name   ';'
    
//done, abstract
namespace-member-declaration:
    namespace-declaration
    type-declaration

//done
namespace-declaration:
    'namespace'   qualified-identifier   namespace-body   ( ';' ) ?

//done as namespaceOrTypeName
qualified-identifier:
    identifier ('.'   identifier)*

//done
namespace-body:
    '{'   using-directive *   namespace-member-declaration *   '}'
        
       
type-declaration:
    class-declaration //done
    struct-declaration
    interface-declaration
    enum-declaration
    delegate-declaration



C.2.7 Classes

class-declaration:
    attribute *   class-modifier *   'class'   identifier   class-base ?   class-body   ( ';' ) ?

//done in Modifier
class-modifier:
    'new'
    'public'
    'protected'
    'internal'
    'private'
    'abstract'
    'sealed'
    'unsafe'

//done    
class-base:
   ':'   class-type
   ':'   interface-type-list
   ':'   class-type   ','   interface-type-list

//done in ClassBase
interface-type-list:
    interface-type (','   interface-type)*

//done
class-body:
    '{'   class-member-declaration *  '}'
    
class-member-declaration:
    constant-declaration
    field-declaration
    method-declaration
    property-declaration
    event-declaration
    indexer-declaration
    operator-declaration
    constructor-declaration
    destructor-declaration
    static-constructor-declaration
    type-declaration //done
    
constant-declaration:
    attribute *   constant-modifier *   'const'   type   constant-declarators   ';'

//done in Modifier
constant-modifier:
    'new'
    'public'
    'protected'
    'internal'
    'private'

field-declaration:
    attribute *   field-modifier *   type   variable-declarator (  ','   variable-declarator)*   ';'

//done in Modifier   
field-modifier:
    'new'
    'public'
    'protected'
    'internal'
    'private'
    'static'
    'readonly'
    'volatile'
    'unsafe'
    
variable-declarator:
    identifier  ( '='   variable-initializer) ?
    
variable-initializer:
    expression
    array-initializer
    
method-declaration:
    attribute *   method-modifier *   return-type   ( interface-type   '.') ?   identifier   (   formal-parameter-list ?   )   block   

//done in Modifier
method-modifier:
    'new'
    'public'
    'protected'
    'internal'
    'private'
    'static'
    'virtual'
    'sealed'
    override
    'abstract'
    'extern'
    'unsafe'
    
//done in Method
return-type:
    type
    'void'
    
    
    
formal-parameter-list:
    fixed-parameter  ( ','   fixed-parameter)*
    fixed-parameter  ( ','   fixed-parameter)*   ','   parameter-array
    parameter-array  
 
fixed-parameter:
    attribute *   parameter-modifier ?   type   identifier
    
parameter-modifier:
    'ref'
    'out'
    
parameter-array:
    attribute *   'params'   array-type   identifier
    
property-declaration:
    attribute *   property-modifier *   type   ( interface-type   '.') ?   identifier   '{'   accessor-declarations   '}'

//done in Modifier
property-modifier:
    'new'
    'public'
    'protected'
    'internal'
    'private'
    'static'
    'virtual'
    'sealed'
    override
    'abstract'
    'extern'
    'unsafe'
    
    
accessor-declarations: 		//soll accessor-declaration+(abstract) beinhalten
    get-accessor-declaration   set-accessor-declaration ?
    set-accessor-declaration   get-accessor-declaration ?
    
get-accessor-declaration:	//Ableitung von accessor-declaration
    attribute *   'get'   block
    
set-accessor-declaration:	//Ableitung von accessor-declaration
    attribute *   'set'   block
    
event-declaration:
    attribute *   event-modifier *   'event'   type   variable-declarator (  ','   variable-declarator)*   ';'
    attribute *   event-modifier *   'event'   type   ( interface-type   '.') ?   identifier   '{'   event-accessor-declarations   '}'

//done in Modifier    
event-modifier:
    'new'
    'public'
    'protected'
    'internal'
    'private'
    'static'
    'virtual'
    'sealed'
    'override'
    'abstract'
    'extern'
    'unsafe'
    
event-accessor-declarations: 	//soll event-accessor-declaration(abstract) 2mal beinhalten
    add-accessor-declaration   remove-accessor-declaration
    remove-accessor-declaration   add-accessor-declaration
    
add-accessor-declaration:		//Ableitung von event-accessor-declaration
    attribute *   add   block
    
remove-accessor-declaration:	//Ableitung von event-accessor-declaration
    attribute *   remove   block
    
indexer-declaration:
    attribute *   indexer-modifiers *   indexer-declarator   '{'   accessor-declarations   '}'

//done in Modifier    
indexer-modifier:
    'new'
    'public'
    'protected'
    'internal'
    'private'
    'virtual'
    'sealed'
    'override'
    'abstract'
    'extern'
    'unsafe'
    
indexer-declarator:
    type   (interface-type   '.') 'this'   '['   formal-parameter-list   ']'
    
operator-declaration:
    attribute *   operator-modifier +   operator-declarator   block

//done in Modifier    
operator-modifier:
    'public'
    'static'
    'extern'
    'unsafe'
    
operator-declarator:
    unary-operator-declarator
    binary-operator-declarator
    conversion-operator-declarator
    
unary-operator-declarator:
    type   'operator'   overloadable-unary-operator   '('   type   identifier   ')'
    
overloadable-unary-operator: one of
    +   -   !   ~   ++   --   true   false
    
binary-operator-declarator:
    type   'operator'   overloadable-binary-operator   '('   type   identifier   ','   type   identifier   ')'
    
overloadable-binary-operator: one of
    +   -   *   /   %   &   |   ^   <<   >>   ==   !=   >   <   >=   <=
    
conversion-operator-declarator:
    ( 'implicit' | 'explicit' )  'operator'   type   '('   type   identifier   ')'
    
constructor-declaration:
    attribute *   constructor-modifier *   constructor-declarator   block

//done in Modifier    
constructor-modifier:
    'public'
    'protected'
    'internal'
    'private'
    'extern'
    'unsafe'
    
constructor-declarator:
    identifier   '('   formal-parameter-list ?   ')'   constructor-initializer ?
    
constructor-initializer:
   ':'   ( 'base' | 'this' )   '('   argument-list ?   ')'

static-constructor-declaration:
    attribute *   static-constructor-modifiers   identifier   '('  ')'   block

//pre-done in Modifier, static-constructor-modifiers bekommt ein +    
static-constructor-modifiers
	extern ?   unsafe ?   static
    unsafe ?   extern ?   static
    extern ?   static   unsafe ?
    unsafe ?    static   extern ?
    static   extern ?   unsafeop
    static   unsafe ?   extern ?
    
destructor-declaration:
    attribute *   'extern' ?   'unsafe' ?   ~   identifier   '('   ')'    block
    attribute *   'unsafe' ?   'extern' ?   ~   identifier   '('   ')'    block



C.2.8 Structs

struct-declaration:
    attribute *   struct-modifier *   'struct'   identifier   interface-type-list ?   '{'   struct-member-declaration *   '}'   ( ';' ) ?

//done in Modifier   
struct-modifier:
    'new'
    'public'
    'protected'
    'internal'
    'private'
    'unsafe'
      
    
struct-member-declaration:
    constant-declaration
    field-declaration
    method-declaration
    property-declaration
    event-declaration
    indexer-declaration
    operator-declaration
    constructor-declaration
    static-constructor-declaration
    type-declaration



C.2.9 Arrays

array-type:
    type   rank-specifier +

rank-specifier:
    '['  (',') *   ']'
    
array-initializer:
    '{'  (variable-initializer ( ','   variable-initializer) *) ?   '}'
    '{'   variable-initializer ( ','   variable-initializer) *   ','   '}'
    
variable-initializer:
    expression
    array-initializer
    stackalloc-initializer
    
stackalloc-initializer:
    'stackalloc'   type   '['   expression   ']'


    
C.2.10 Interfaces

interface-declaration:
    attribute *   interface-modifier *   'interface'   identifier   interface-type-list ?   '{'   interface-member-declaration *  '}'   ( ';') ?

//done in Modifier       
interface-modifier:
    'new'
    'public'
    'protected'
    'internal'
    'private'
	'unsafe'
   

interface-member-declaration:
    interface-method-declaration
    interface-property-declaration
    interface-event-declaration
    interface-indexer-declaration
    
interface-method-declaration:
    attribute *   'new' ?   return-type   identifier   '('   formal-parameter-list ?   ')'   ';'
    
interface-property-declaration:
    attribute *   'new' ?   type   identifier   '{'   interface-accessors   '}'
    
interface-accessors:
    attribute *   get   ';'   ( attribute *   set   ';' )?
    attribute *   set   ';'   ( attribute *   get   ';' )?
    
interface-event-declaration:
    attribute *   'new' ?   'event'   type   identifier   ';'
    
interface-indexer-declaration:
    attribute *   'new' ?   type   'this'   '['   formal-parameter-list   ']'   '{'   interface-accessors   '}'



C.2.11 Enums

enum-declaration:
    attribute *   enum-modifier *   'enum'   identifier   integral-type ?   enum-body  ( ';' ) ?
    
enum-body:
    '{'  (enum-member-declaration  ( ','   enum-member-declaration) ?) ?   '}'
    '{'   enum-member-declaration  ( ','   enum-member-declaration) ?   ','   '}'

//done in Modifier      
enum-modifier:
    'new'
    'public'
    'protected'
    'internal'
    'private'
    
enum-member-declaration:
    attribute *   identifier (  '='   expression ) ?



C.2.12 Delegates

delegate-declaration:
    attribute *   delegate-modifier *   'delegate'   return-type   identifier   '('   formal-parameter-list ?   ')'   ';'

//done in Modifier       
delegate-modifier:
    'new'
    'public'
    'protected'
    'internal'
    'private'
	'unsafe'
	
	
	
C.2.13 Attributes
    
global-attribute:

    '['   global-attribute-target  ':'   attribute-list   ( ',' )? ']'
    
global-attribute-target:
    assembly
    module
    
attribute:
    '['   ( attribute-target  ':' )?   attribute-list   ( ',' )?   ']'
    
attribute-target:
    field
    'event'
    method
    param			//Schreibfehler? params?
    property		//keine Ahnung was genau gemeint ist, property-declaration?
    'return'
    type

attribute-list:
    attribute ( ','   attribute)*
       
attribute:
    namespace-or-type-name  attribute-arguments ?
    
attribute-arguments:
   	'('   expression-list ?   ')'
	'('   expression-list   ','   named-argument-list   ')'
	'('   named-argument-list   ')'
    
named-argument-list:
    named-argument ( ','   named-argument )*
    
named-argument:
    identifier   =   expression    

