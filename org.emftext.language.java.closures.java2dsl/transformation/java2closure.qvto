modeltype CLOSURES uses 'http://www.emftext.org/language/java/closures';  
--modeltype CLOSURES uses 'platform:/resource/org.emftext.language.java.closures/model/closures.ecore';
modeltype JAVA uses "http://www.emftext.org/java";

-- in place transformation funktioniert nun auch
-- 'inout' ist entscheidend
-- grundsätzlich werden alle methoden und attribute übernommen,
-- sie müssen manuell entfernt werden per 'exclude()' methode' 

transformation Java2Closure(inout java : CLOSURES);

main() {
	java.objects()[JAVA::classifiers::Class]->map Classifiers_Class();
	java.objects()[JAVA::instantiations::NewConstructorCall]->map Instantiations_NewConstructorCall();
	java.objects()[JAVA::_references::MethodCall]->map References_MethodCall();
	java.objects()[JAVA::statements::ExpressionStatement]->map Expressions_ExpressionStatement();
}

mapping inout JAVA::classifiers::Class::Classifiers_Class(){}

mapping inout JAVA::_references::MethodCall::References_MethodCall(){
	
	self.arguments->forEach(a){
		if a.oclIsTypeOf(JAVA::instantiations::NewConstructorCall) then
			let closure : CLOSURES::Closure =
				map Closures_Closure(a.oclAsType(JAVA::instantiations::NewConstructorCall)) in
			if closure <> null then
				self.arguments := self.arguments->append(closure)->
				asOrderedSet()->
				excluding(a)
			endif
		endif
	}
}

mapping inout JAVA::instantiations::NewConstructorCall::Instantiations_NewConstructorCall(){
	
	self.arguments->forEach(a){
		if a.oclIsTypeOf(JAVA::instantiations::NewConstructorCall) then
			let closure : CLOSURES::Closure =
				map Closures_Closure(a.oclAsType(JAVA::instantiations::NewConstructorCall)) in
			if closure <> null then
				self.arguments := self.arguments->append(closure)->
				asOrderedSet()->
				excluding(a)
			endif
		endif
	}

}

mapping inout JAVA::statements::ExpressionStatement::Expressions_ExpressionStatement(){
	
	if self.expression.oclIsTypeOf(JAVA::instantiations::NewConstructorCall) then
		let closure : CLOSURES::Closure =
			map Closures_Closure(self.expression.oclAsType(JAVA::instantiations::NewConstructorCall)) in
		if closure <> null then
			self.expression := closure
		endif
	endif
	
}

mapping Closures_Closure(in newConstructorCall : JAVA::instantiations::NewConstructorCall) : CLOSURES::Closure
	when{
		newConstructorCall.typeReference <> null
		and
		newConstructorCall.anonymousClass <> null
		and
		newConstructorCall.anonymousClass.members->size() = 1
		and
		newConstructorCall.anonymousClass.members->at(1).oclIsTypeOf(JAVA::members::ClassMethod) 
	}
	{
		var innerMethod : JAVA::members::ClassMethod := newConstructorCall.anonymousClass.members->at(1).oclAsType(JAVA::members::ClassMethod) ;
		var methodCall : JAVA::_references::MethodCall := newConstructorCall.next.oclAsType(JAVA::_references::MethodCall) ;
		
		annotationsAndModifiers := innerMethod.annotationsAndModifiers;
		innerMethod.parameters->forEach(p){
			parameterTypes := parameterTypes->append(p.typeReference.deepclone().oclAsType(JAVA::types::TypeReference));
			arrayDimensionsBefore := p.arrayDimensionsBefore.deepclone().oclAsType(JAVA::arrays::ArrayDimension);
		};
		valueType := innerMethod.typeReference;
		valueTypeArrayDimension := innerMethod.arrayDimensionsBefore;
		typeReference := newConstructorCall.typeReference;
		name := "";
		parameters := innerMethod.parameters;
		statements := innerMethod.statements;
		methodName := innerMethod.name;
		if methodCall <> null then
			arguments := methodCall.arguments
		endif
	}
/*
query copyTypeReference(typeReference : JAVA::types::TypeReference) : JAVA::types::TypeReference
	{
	var _return : JAVA::types::TypeReference;
	var new_ncr : JAVA::types::NamespaceClassifierReference;
	var new_c : JAVA::classifiers::Classifier;
	var new_cr : JAVA::types::ClassifierReference;
	
	if typeReference.oclIsTypeOf(JAVA::types::PrimitiveType) then
		_return := typeReference.clone().oclAsType(JAVA::types::TypeReference)
	else
		if typeReference.oclIsTypeOf(JAVA::types::NamespaceClassifierReference) then
			new_ncr := typeReference.oclAsType(JAVA::types::NamespaceClassifierReference)
		endif
	endif;
	if new_ncr <> null then
		let ncr : JAVA::types::NamespaceClassifierReference =
			typeReference.oclAsType(JAVA::types::NamespaceClassifierReference) in
		if ncr.classifierReferences->at(1).oclIsTypeOf(JAVA::types::ClassifierReference) then
			new_cr := ncr.classifierReferences->at(1).oclAsType(JAVA::types::ClassifierReference)
		endif
	endif;
	if new_cr <> null then
		let cr : JAVA::types::ClassifierReference =
			ncr.classifierReferences->at(1).oclIsTypeOf(JAVA::types::ClassifierReference).oclAsType(JAVA::types::ClassifierReference) in
		if ncr.classifierReferences->at(1).oclIsTypeOf(JAVA::types::ClassifierReference) then
			new_cr := ncr.classifierReferences->at(1).oclAsType(JAVA::types::ClassifierReference)
		endif
	endif; 
	return _return
	}*/
