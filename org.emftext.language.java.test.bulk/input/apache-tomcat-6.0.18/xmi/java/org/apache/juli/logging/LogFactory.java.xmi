<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../../../java.ecore#/9 http://www.emftext.org/java/members ../../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../../../java.ecore#/13 http://www.emftext.org/java/references ../../../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../../../java.ecore#/15 http://www.emftext.org/java/types ../../../../../java.ecore#/16" name="LogFactory.java">
  <comments>/*&#xA; * Licensed to the Apache Software Foundation (ASF) under one or more&#xA; * contributor license agreements.  See the NOTICE file distributed with&#xA; * this work for additional information regarding copyright ownership.&#xA; * The ASF licenses this file to You under the Apache License, Version 2.0&#xA; * (the &quot;License&quot;); you may not use this file except in compliance with&#xA; * the License.  You may obtain a copy of the License at&#xA; * &#xA; *      http://www.apache.org/licenses/LICENSE-2.0&#xA; * &#xA; * Unless required by applicable law or agreed to in writing, software&#xA; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&#xA; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA; * See the License for the specific language governing permissions and&#xA; * limitations under the License.&#xA; */</comments>
  <namespaces>org</namespaces>
  <namespaces>apache</namespaces>
  <namespaces>juli</namespaces>
  <namespaces>logging</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../util/Properties.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="LogFactory">
    <comments>/* abstract */</comments>
    <members xsi:type="members:Field" name="FACTORY_PROPERTY">
      <initialValue xsi:type="references:StringReference" value="org.apache.commons.logging.LogFactory"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// ----------------------------------------------------- Manifest Constants</comments>
        <comments>/**&#xA;     * The name of the property used to identify the LogFactory implementation&#xA;     * class name.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="FACTORY_DEFAULT">
      <initialValue xsi:type="references:StringReference" value="org.apache.commons.logging.impl.LogFactoryImpl"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The fully qualified class name of the fallback &lt;code>LogFactory&lt;/code>&#xA;     * implementation class to use, if no other can be found.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="FACTORY_PROPERTIES">
      <initialValue xsi:type="references:StringReference" value="commons-logging.properties"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The name of the properties file to search for.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="HASHTABLE_IMPLEMENTATION_PROPERTY">
      <initialValue xsi:type="references:StringReference" value="org.apache.commons.logging.LogFactory.HashtableImpl"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;p>Setting this system property value allows the &lt;code>Hashtable&lt;/code> used to store&#xA;     * classloaders to be substituted by an alternative implementation.&#xA;     * &lt;/p>&#xA;     * &lt;p>&#xA;     * &lt;strong>Note:&lt;/strong> &lt;code>LogFactory&lt;/code> will print:&#xA;     * &lt;code>&lt;pre>&#xA;     * [ERROR] LogFactory: Load of custom hashtable failed&lt;/em>&#xA;     * &lt;/code>&lt;/pre>&#xA;     * to system error and then continue using a standard Hashtable.&#xA;     * &lt;/p>&#xA;     * &lt;p>&#xA;     * &lt;strong>Usage:&lt;/strong> Set this property when Java is invoked&#xA;     * and &lt;code>LogFactory&lt;/code> will attempt to load a new instance &#xA;     * of the given implementation class.&#xA;     * For example, running the following ant scriplet:&#xA;     * &lt;code>&lt;pre>&#xA;     *  &amp;lt;java classname=&quot;${test.runner}&quot; fork=&quot;yes&quot; failonerror=&quot;${test.failonerror}&quot;&amp;gt;&#xA;     *     ...&#xA;     *     &amp;lt;sysproperty &#xA;     *        key=&quot;org.apache.commons.logging.LogFactory.HashtableImpl&quot;&#xA;     *        value=&quot;org.apache.commons.logging.AltHashtable&quot;/&amp;gt;&#xA;     *  &amp;lt;/java&amp;gt;&#xA;     * &lt;/pre>&lt;/code>&#xA;     * will mean that &lt;code>LogFactory&lt;/code> will load an instance of&#xA;     * &lt;code>org.apache.commons.logging.AltHashtable&lt;/code>.&#xA;     * &lt;/p>&#xA;     * &lt;p>&#xA;     * A typical use case is to allow a custom&#xA;     * Hashtable implementation using weak references to be substituted.&#xA;     * This will allow classloaders to be garbage collected without&#xA;     * the need to release them (on 1.3+ JVMs only, of course ;)&#xA;     * &lt;/p>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="singleton">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="logConfig">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../util/Properties.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Constructor" name="LogFactory">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../../util/Properties.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </value>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// ----------------------------------------------------------- Constructors</comments>
        <comments>/**&#xA;     * Protected constructor that is not available for public use.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="setLogConfig">
      <typeReference xsi:type="types:Void">
        <comments>// hook for syserr logger - class level</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="p">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../util/Properties.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../../../org/apache/juli/logging/Log.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../org/apache/juli/logging/LogConfigurationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// --------------------------------------------------------- Public Methods</comments>
        <comments>// only those 2 methods need to change to use a different direct logger.</comments>
        <comments>/**&#xA;     * &lt;p>Construct (if necessary) and return a &lt;code>Log&lt;/code> instance,&#xA;     * using the factory's current set of configuration attributes.&lt;/p>&#xA;     *&#xA;     * &lt;p>&lt;strong>NOTE&lt;/strong> - Depending upon the implementation of&#xA;     * the &lt;code>LogFactory&lt;/code> you are using, the &lt;code>Log&lt;/code>&#xA;     * instance you are returned may or may not be local to the current&#xA;     * application, and may or may not be returned again on a subsequent&#xA;     * call with the same name argument.&lt;/p>&#xA;     *&#xA;     * @param name Logical name of the &lt;code>Log&lt;/code> instance to be&#xA;     *  returned (the meaning of this name is only known to the underlying&#xA;     *  logging implementation that is being wrapped)&#xA;     *&#xA;     * @exception LogConfigurationException if a suitable &lt;code>Log&lt;/code>&#xA;     *  instance cannot be returned&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../../../org/apache/juli/logging/DirectJDKLog.class.xmi#//@classifiers.0/@members.25"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="../../../../../org/apache/juli/logging/DirectJDKLog.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="release">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Release any internal references to previously created {@link Log}&#xA;     * instances returned by this factory.  This is useful in environments&#xA;     * like servlet containers, which implement application reloading by&#xA;     * throwing away a ClassLoader.  Dangling references to objects in that&#xA;     * class loader would prevent garbage collection.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../../../org/apache/juli/logging/DirectJDKLog.class.xmi#//@classifiers.0/@members.24"/>
          </next>
          <target xsi:type="classifiers:Class" href="../../../../../org/apache/juli/logging/DirectJDKLog.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAttribute">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return the configuration attribute with the specified name (if any),&#xA;     * or &lt;code>null&lt;/code> if there is no such attribute.&#xA;     *&#xA;     * @param name Name of the attribute to return&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../../util/Hashtable.class.xmi#//@classifiers.0/@members.25"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAttributeNames">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return an array containing the names of all currently defined&#xA;     * configuration attributes.  If there are no such attributes, a zero&#xA;     * length array is returned.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../../../../util/Set.class.xmi#//@classifiers.0/@members.4"/>
              </next>
              <target xsi:type="members:ClassMethod" href="../../../../util/Hashtable.class.xmi#//@classifiers.0/@members.35"/>
            </next>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeAttribute">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Remove any configuration attribute associated with the specified name.&#xA;     * If there is no such attribute, no action is taken.&#xA;     *&#xA;     * @param name Name of the attribute to remove&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../../util/Hashtable.class.xmi#//@classifiers.0/@members.28"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setAttribute">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set the configuration attribute with the specified name.  Calling&#xA;     * this with a &lt;code>null&lt;/code> value is equivalent to calling&#xA;     * &lt;code>removeAttribute(name)&lt;/code>.&#xA;     *&#xA;     * @param name Name of the attribute to set&#xA;     * @param value Value of the attribute to set, or &lt;code>null&lt;/code>&#xA;     *  to remove any setting for this attribute&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../../util/Hashtable.class.xmi#//@classifiers.0/@members.27"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../../../org/apache/juli/logging/Log.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="clazz">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../lang/Class.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../org/apache/juli/logging/LogConfigurationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Convenience method to derive a name from the specified class and&#xA;     * call &lt;code>getInstance(String)&lt;/code> with it.&#xA;     *&#xA;     * @param clazz Class for which a suitable Log name will be derived&#xA;     *&#xA;     * @exception LogConfigurationException if a suitable &lt;code>Log&lt;/code>&#xA;     *  instance cannot be returned&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.8">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../../lang/Class.class.xmi#//@classifiers.0/@members.44"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getFactory">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../org/apache/juli/logging/LogConfigurationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// ------------------------------------------------------- Static Variables</comments>
        <comments>// --------------------------------------------------------- Static Methods</comments>
        <comments>/**&#xA;     * &lt;p>Construct (if necessary) and return a &lt;code>LogFactory&lt;/code>&#xA;     * instance, using the following ordered lookup procedure to determine&#xA;     * the name of the implementation class to be loaded.&lt;/p>&#xA;     * &lt;ul>&#xA;     * &lt;li>The &lt;code>org.apache.commons.logging.LogFactory&lt;/code> system&#xA;     *     property.&lt;/li>&#xA;     * &lt;li>The JDK 1.3 Service Discovery mechanism&lt;/li>&#xA;     * &lt;li>Use the properties file &lt;code>commons-logging.properties&lt;/code>&#xA;     *     file, if found in the class path of this class.  The configuration&#xA;     *     file is in standard &lt;code>java.util.Properties&lt;/code> format and&#xA;     *     contains the fully qualified name of the implementation class&#xA;     *     with the key being the system property defined above.&lt;/li>&#xA;     * &lt;li>Fall back to a default implementation class&#xA;     *     (&lt;code>org.apache.commons.logging.impl.LogFactoryImpl&lt;/code>).&lt;/li>&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>&lt;em>NOTE&lt;/em> - If the properties file method of identifying the&#xA;     * &lt;code>LogFactory&lt;/code> implementation class is utilized, all of the&#xA;     * properties defined in this file will be set as configuration attributes&#xA;     * on the corresponding &lt;code>LogFactory&lt;/code> instance.&lt;/p>&#xA;     *&#xA;     * @exception LogConfigurationException if the implementation class is not&#xA;     *  available or cannot be instantiated.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLog">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../../../org/apache/juli/logging/Log.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="clazz">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../lang/Class.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../org/apache/juli/logging/LogConfigurationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Convenience method to return a named logger, without the application&#xA;     * having to care about factories.&#xA;     *&#xA;     * @param clazz Class from which a log name will be derived&#xA;     *&#xA;     * @exception LogConfigurationException if a suitable &lt;code>Log&lt;/code>&#xA;     *  instance cannot be returned&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.14">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLog">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../../../org/apache/juli/logging/Log.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../org/apache/juli/logging/LogConfigurationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Convenience method to return a named logger, without the application&#xA;     * having to care about factories.&#xA;     *&#xA;     * @param name Logical name of the &lt;code>Log&lt;/code> instance to be&#xA;     *  returned (the meaning of this name is only known to the underlying&#xA;     *  logging implementation that is being wrapped)&#xA;     *&#xA;     * @exception LogConfigurationException if a suitable &lt;code>Log&lt;/code>&#xA;     *  instance cannot be returned&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.8">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="release">
      <comments>// nothing - we don't use any class loaders</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="classLoader">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../lang/ClassLoader.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Release any internal references to previously created {@link LogFactory}&#xA;     * instances that have been associated with the specified class loader&#xA;     * (if any), after calling the instance method &lt;code>release()&lt;/code> on&#xA;     * each of them.&#xA;     *&#xA;     * @param classLoader ClassLoader for which to release the LogFactory&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="releaseAll">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Release any internal references to previously created {@link LogFactory}&#xA;     * instances, after calling the instance method &lt;code>release()&lt;/code> on&#xA;     * each of them.  This is useful in environments like servlet containers,&#xA;     * which implement application reloading by throwing away a ClassLoader.&#xA;     * Dangling references to objects in that class loader would prevent&#xA;     * garbage collection.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.9"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="objectId">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string that uniquely identifies the specified object, including&#xA;     * its class.&#xA;     * &lt;p>&#xA;     * The returned string is of form &quot;classname@hashcode&quot;, ie is the same as&#xA;     * the return value of the Object.toString() method, but works even when&#xA;     * the specified object's class has overidden the toString method.&#xA;     * &#xA;     * @param o may be null.&#xA;     * @return a string of form classname@hashcode, or &quot;null&quot; if param o is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:StringReference" value="null"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../../lang/Class.class.xmi#//@classifiers.0/@members.44"/>
                  </next>
                  <target xsi:type="members:ClassMethod" href="../../../../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
                </next>
              </children>
              <children xsi:type="references:StringReference" value="@"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../../lang/System.class.xmi#//@classifiers.0/@members.21"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../../../lang/System.class.xmi#//@classifiers.0"/>
              </children>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </returnValue>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Modified LogFactory: removed all discovery, hardcode a specific implementation&#xA; * If you like a different logging implementation - use either the discovery-based&#xA; * commons-logging, or better - another implementation hardcoded to your favourite&#xA; * logging impl.&#xA; * &#xA; * Why ? Each application and deployment can choose a logging implementation - &#xA; * that involves configuration, installing the logger jar and optional plugins, etc.&#xA; * As part of this process - they can as well install the commons-logging implementation&#xA; * that corresponds to their logger of choice. This completely avoids any discovery&#xA; * problem, while still allowing the user to switch. &#xA; * &#xA; * Note that this implementation is not just a wrapper arround JDK logging ( like&#xA; * the original commons-logging impl ). It adds 2 features - a simpler configuration&#xA; * ( which is in fact a subset of log4j.properties ) and a formatter that is &#xA; * less ugly.   &#xA; * &#xA; * The removal of 'abstract' preserves binary backward compatibility. It is possible&#xA; * to preserve the abstract - and introduce another ( hardcoded ) factory - but I &#xA; * see no benefit. &#xA; * &#xA; * Since this class is not intended to be extended - and provides&#xA; * no plugin for other LogFactory implementation - all protected methods are removed.&#xA; * This can be changed - but again, there is little value in keeping dead code.&#xA; * Just take a quick look at the removed code ( and it's complexity)  &#xA; * &#xA; * --------------&#xA; * &#xA; * Original comment:&#xA; * &lt;p>Factory for creating {@link Log} instances, with discovery and&#xA; * configuration features similar to that employed by standard Java APIs&#xA; * such as JAXP.&lt;/p>&#xA; * &#xA; * &lt;p>&lt;strong>IMPLEMENTATION NOTE&lt;/strong> - This implementation is heavily&#xA; * based on the SAXParserFactory and DocumentBuilderFactory implementations&#xA; * (corresponding to the JAXP pluggability APIs) found in Apache Xerces.&lt;/p>&#xA; * &#xA; *&#xA; * @author Craig R. McClanahan&#xA; * @author Costin Manolache&#xA; * @author Richard A. Sitze&#xA; * @version $Revision: 467222 $ $Date: 2006-10-24 05:17:11 +0200 (Tue, 24 Oct 2006) $&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
