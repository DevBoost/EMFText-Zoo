<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../../../java.ecore#/7 http://www.emftext.org/java/literals ../../../../../java.ecore#/9 http://www.emftext.org/java/members ../../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../../../java.ecore#/13 http://www.emftext.org/java/types ../../../../../java.ecore#/16" name="Socket.java">
  <comments>/*&#xA; *  Licensed to the Apache Software Foundation (ASF) under one or more&#xA; *  contributor license agreements.  See the NOTICE file distributed with&#xA; *  this work for additional information regarding copyright ownership.&#xA; *  The ASF licenses this file to You under the Apache License, Version 2.0&#xA; *  (the &quot;License&quot;); you may not use this file except in compliance with&#xA; *  the License.  You may obtain a copy of the License at&#xA; *&#xA; *      http://www.apache.org/licenses/LICENSE-2.0&#xA; *&#xA; *  Unless required by applicable law or agreed to in writing, software&#xA; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&#xA; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA; *  See the License for the specific language governing permissions and&#xA; *  limitations under the License.&#xA; */</comments>
  <namespaces>org</namespaces>
  <namespaces>apache</namespaces>
  <namespaces>tomcat</namespaces>
  <namespaces>jni</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <comments>/* Import needed classes */</comments>
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../nio/ByteBuffer.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Socket">
    <members xsi:type="members:Field" name="SOCK_STREAM">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* Standard socket defines */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SOCK_DGRAM">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_SO_LINGER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/*&#xA;     * apr_sockopt Socket option definitions&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_SO_KEEPALIVE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Linger */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_SO_DEBUG">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Keepalive */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_SO_NONBLOCK">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Debug */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_SO_REUSEADDR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Non-blocking IO */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_SO_SNDBUF">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="64"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Reuse addresses */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_SO_RCVBUF">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="128"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Send buffer */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_SO_DISCONNECTED">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="256"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Receive buffer */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_TCP_NODELAY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="512"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Disconnected */</comments>
        <comments>/** For SCTP sockets, this is mapped to STCP_NODELAY internally. */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_TCP_NOPUSH">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1024"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_RESET_NODELAY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2048"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** No push */</comments>
        <comments>/** This flag is ONLY set internally when we set APR_TCP_NOPUSH with&#xA;     * APR_TCP_NODELAY set to tell us that APR_TCP_NODELAY should be turned on&#xA;     * again when NOPUSH is turned off&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_INCOMPLETE_READ">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4096"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Set on non-blocking sockets (timeout != 0) on which the&#xA;     * previous read() did not fill a buffer completely.  the next&#xA;     * apr_socket_recv()  will first call select()/poll() rather than&#xA;     * going straight into read().  (Can also be set by an application to&#xA;     * force a select()/poll() call before the next read, in cases where&#xA;     * the app expects that an immediate read would fail.)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_INCOMPLETE_WRITE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="8192"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** like APR_INCOMPLETE_READ, but for write&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_IPV6_V6ONLY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="16384"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Don't accept IPv4 connections on an IPv6 listening socket.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_TCP_DEFER_ACCEPT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="32768"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Delay accepting of new connections until data is available.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_SHUTDOWN_READ">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Define what type of socket shutdown should occur.&#xA;     * apr_shutdown_how_e enum&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_SHUTDOWN_WRITE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** no longer allow read request */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_SHUTDOWN_READWRITE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** no longer allow write requests */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_IPV4_ADDR_OK">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** no longer allow read or write requests */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_IPV6_ADDR_OK">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_UNSPEC">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* TODO: Missing:&#xA;     * APR_INET&#xA;     * APR_UNSPEC&#xA;     * APR_INET6&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_INET">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_INET6">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_PROTO_TCP">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_PROTO_UDP">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="17"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** TCP  */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_PROTO_SCTP">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="132"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** UDP  */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_LOCAL">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** SCTP */</comments>
        <comments>/**&#xA;     * Enum to tell us if we're interested in remote or local socket&#xA;     * apr_interface_e&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="APR_REMOTE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SOCKET_GET_POOL">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* Socket.get types */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SOCKET_GET_IMPL">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SOCKET_GET_APRS">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SOCKET_GET_TYPE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="create">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="family">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="protocol">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cont">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../lang/Exception.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a socket.&#xA;     * @param family The address family of the socket (e.g., APR_INET).&#xA;     * @param type The type of the socket (e.g., SOCK_STREAM).&#xA;     * @param protocol The protocol of the socket (e.g., APR_PROTO_TCP).&#xA;     * @param cont The parent pool to use&#xA;     * @return The new socket that has been set up.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="shutdown">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="thesocket">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="how">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Shutdown either reading, writing, or both sides of a socket.&#xA;     * &lt;br />&#xA;     * This does not actually close the socket descriptor, it just&#xA;     *      controls which calls are still valid on the socket.&#xA;     * @param thesocket The socket to close&#xA;     * @param how How to shutdown the socket.  One of:&#xA;     * &lt;PRE>&#xA;     * APR_SHUTDOWN_READ         no longer allow read requests&#xA;     * APR_SHUTDOWN_WRITE        no longer allow write requests&#xA;     * APR_SHUTDOWN_READWRITE    no longer allow read or write requests&#xA;     * &lt;/PRE>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="close">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="thesocket">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Close a socket.&#xA;     * @param thesocket The socket to close&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="destroy">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="thesocket">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Destroy a pool associated with socket&#xA;     * @param thesocket The destroy&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="bind">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sa">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Bind the socket to its associated port&#xA;     * @param sock The socket to bind&#xA;     * @param sa The socket address to bind to&#xA;     * This may be where we will find out if there is any other process&#xA;     *      using the selected port.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="listen">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="backlog">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Listen to a bound socket for connections.&#xA;     * @param sock The socket to listen on&#xA;     * @param backlog The number of outstanding connections allowed in the sockets&#xA;     *                listen queue.  If this value is less than zero, the listen&#xA;     *                queue size is set to zero.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="accept">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../lang/Exception.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Accept a new connection request&#xA;     * @param sock The socket we are listening on.&#xA;     * @param pool The pool for the new socket.&#xA;     * @return  A copy of the socket that is connected to the socket that&#xA;     *          made the connection request.  This is the socket which should&#xA;     *          be used for all future communication.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="acceptfilter">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="args">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set an OS level accept filter.&#xA;     * @param sock The socket to put the accept filter on.&#xA;     * @param name The accept filter&#xA;     * @param args Any extra args to the accept filter.  Passing NULL here removes&#xA;     *             the accept filter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="atmark">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Query the specified socket if at the OOB/Urgent data mark&#xA;     * @param sock The socket to query&#xA;     * @return True if socket is at the OOB/urgent mark,&#xA;     *         otherwise return false.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="connect">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sa">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Issue a connection request to a socket either on the same machine&#xA;     * or a different one.&#xA;     * @param sock The socket we wish to use for our side of the connection&#xA;     * @param sa The address of the machine we wish to connect to.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="send">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Send data over a network.&#xA;     * &lt;PRE>&#xA;     * This functions acts like a blocking write by default.  To change&#xA;     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK&#xA;     * socket option.&#xA;     *&#xA;     * It is possible for both bytes to be sent and an error to be returned.&#xA;     *&#xA;     * APR_EINTR is never returned.&#xA;     * &lt;/PRE>&#xA;     * @param sock The socket to send the data over.&#xA;     * @param buf The buffer which contains the data to be sent.&#xA;     * @param offset Offset in the byte buffer.&#xA;     * @param len The number of bytes to write; (-1) for full array.&#xA;     * @return The number of bytes send.&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="sendb">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../nio/ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Send data over a network.&#xA;     * &lt;PRE>&#xA;     * This functions acts like a blocking write by default.  To change&#xA;     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK&#xA;     * socket option.&#xA;     *&#xA;     * It is possible for both bytes to be sent and an error to be returned.&#xA;     *&#xA;     * APR_EINTR is never returned.&#xA;     * &lt;/PRE>&#xA;     * @param sock The socket to send the data over.&#xA;     * @param buf The Byte buffer which contains the data to be sent.&#xA;     * @param offset The offset within the buffer array of the first buffer from&#xA;     *               which bytes are to be retrieved; must be non-negative&#xA;     *               and no larger than buf.length&#xA;     * @param len The maximum number of buffers to be accessed; must be non-negative&#xA;     *            and no larger than buf.length - offset&#xA;     * @return The number of bytes send.&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="sendbb">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Send data over a network using internally set ByteBuffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="sendv">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="vec">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Send multiple packets of data over a network.&#xA;     * &lt;PRE>&#xA;     * This functions acts like a blocking write by default.  To change&#xA;     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK&#xA;     * socket option.&#xA;     * The number of bytes actually sent is stored in argument 3.&#xA;     *&#xA;     * It is possible for both bytes to be sent and an error to be returned.&#xA;     *&#xA;     * APR_EINTR is never returned.&#xA;     * &lt;/PRE>&#xA;     * @param sock The socket to send the data over.&#xA;     * @param vec The array from which to get the data to send.&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="sendto">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="where">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="flags">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * @param sock The socket to send from&#xA;     * @param where The apr_sockaddr_t describing where to send the data&#xA;     * @param flags The flags to use&#xA;     * @param buf  The data to send&#xA;     * @param offset Offset in the byte buffer.&#xA;     * @param len  The length of the data to send&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="recv">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nbytes">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Read data from a network.&#xA;     *&#xA;     * &lt;PRE>&#xA;     * This functions acts like a blocking read by default.  To change&#xA;     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK&#xA;     * socket option.&#xA;     * The number of bytes actually received is stored in argument 3.&#xA;     *&#xA;     * It is possible for both bytes to be received and an APR_EOF or&#xA;     * other error to be returned.&#xA;     *&#xA;     * APR_EINTR is never returned.&#xA;     * &lt;/PRE>&#xA;     * @param sock The socket to read the data from.&#xA;     * @param buf The buffer to store the data in.&#xA;     * @param offset Offset in the byte buffer.&#xA;     * @param nbytes The number of bytes to read (-1) for full array.&#xA;     * @return the number of bytes received.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="recvt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nbytes">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeout">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Read data from a network with timeout.&#xA;     *&#xA;     * &lt;PRE>&#xA;     * This functions acts like a blocking read by default.  To change&#xA;     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK&#xA;     * socket option.&#xA;     * The number of bytes actually received is stored in argument 3.&#xA;     *&#xA;     * It is possible for both bytes to be received and an APR_EOF or&#xA;     * other error to be returned.&#xA;     *&#xA;     * APR_EINTR is never returned.&#xA;     * &lt;/PRE>&#xA;     * @param sock The socket to read the data from.&#xA;     * @param buf The buffer to store the data in.&#xA;     * @param offset Offset in the byte buffer.&#xA;     * @param nbytes The number of bytes to read (-1) for full array.&#xA;     * @param timeout The socket timeout in microseconds.&#xA;     * @return the number of bytes received.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="recvb">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../nio/ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nbytes">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Read data from a network.&#xA;     *&#xA;     * &lt;PRE>&#xA;     * This functions acts like a blocking read by default.  To change&#xA;     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK&#xA;     * socket option.&#xA;     * The number of bytes actually received is stored in argument 3.&#xA;     *&#xA;     * It is possible for both bytes to be received and an APR_EOF or&#xA;     * other error to be returned.&#xA;     *&#xA;     * APR_EINTR is never returned.&#xA;     * &lt;/PRE>&#xA;     * @param sock The socket to read the data from.&#xA;     * @param buf The buffer to store the data in.&#xA;     * @param offset Offset in the byte buffer.&#xA;     * @param nbytes The number of bytes to read (-1) for full array.&#xA;     * @return the number of bytes received.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="recvbb">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nbytes">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Read data from a network using internally set ByteBuffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="recvbt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../nio/ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nbytes">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeout">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Read data from a network with timeout.&#xA;     *&#xA;     * &lt;PRE>&#xA;     * This functions acts like a blocking read by default.  To change&#xA;     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK&#xA;     * socket option.&#xA;     * The number of bytes actually received is stored in argument 3.&#xA;     *&#xA;     * It is possible for both bytes to be received and an APR_EOF or&#xA;     * other error to be returned.&#xA;     *&#xA;     * APR_EINTR is never returned.&#xA;     * &lt;/PRE>&#xA;     * @param sock The socket to read the data from.&#xA;     * @param buf The buffer to store the data in.&#xA;     * @param offset Offset in the byte buffer.&#xA;     * @param nbytes The number of bytes to read (-1) for full array.&#xA;     * @param timeout The socket timeout in microseconds.&#xA;     * @return the number of bytes received.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="recvbbt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nbytes">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeout">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Read data from a network with timeout using internally set ByteBuffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="recvFrom">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="from">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="flags">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nbytes">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * @param from The apr_sockaddr_t to fill in the recipient info&#xA;     * @param sock The socket to use&#xA;     * @param flags The flags to use&#xA;     * @param buf  The buffer to use&#xA;     * @param offset Offset in the byte buffer.&#xA;     * @param nbytes The number of bytes to read (-1) for full array.&#xA;     * @return the number of bytes received.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="optSet">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="opt">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="on">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Setup socket options for the specified socket&#xA;     * @param sock The socket to set up.&#xA;     * @param opt The option we would like to configure.  One of:&#xA;     * &lt;PRE>&#xA;     * APR_SO_DEBUG      --  turn on debugging information&#xA;     * APR_SO_KEEPALIVE  --  keep connections active&#xA;     * APR_SO_LINGER     --  lingers on close if data is present&#xA;     * APR_SO_NONBLOCK   --  Turns blocking on/off for socket&#xA;     *                       When this option is enabled, use&#xA;     *                       the APR_STATUS_IS_EAGAIN() macro to&#xA;     *                       see if a send or receive function&#xA;     *                       could not transfer data without&#xA;     *                       blocking.&#xA;     * APR_SO_REUSEADDR  --  The rules used in validating addresses&#xA;     *                       supplied to bind should allow reuse&#xA;     *                       of local addresses.&#xA;     * APR_SO_SNDBUF     --  Set the SendBufferSize&#xA;     * APR_SO_RCVBUF     --  Set the ReceiveBufferSize&#xA;     * &lt;/PRE>&#xA;     * @param on Value for the option.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="optGet">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="opt">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../lang/Exception.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Query socket options for the specified socket&#xA;     * @param sock The socket to query&#xA;     * @param opt The option we would like to query.  One of:&#xA;     * &lt;PRE>&#xA;     * APR_SO_DEBUG      --  turn on debugging information&#xA;     * APR_SO_KEEPALIVE  --  keep connections active&#xA;     * APR_SO_LINGER     --  lingers on close if data is present&#xA;     * APR_SO_NONBLOCK   --  Turns blocking on/off for socket&#xA;     * APR_SO_REUSEADDR  --  The rules used in validating addresses&#xA;     *                       supplied to bind should allow reuse&#xA;     *                       of local addresses.&#xA;     * APR_SO_SNDBUF     --  Set the SendBufferSize&#xA;     * APR_SO_RCVBUF     --  Set the ReceiveBufferSize&#xA;     * APR_SO_DISCONNECTED -- Query the disconnected state of the socket.&#xA;     *                       (Currently only used on Windows)&#xA;     * &lt;/PRE>&#xA;     * @return Socket option returned on the call.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="timeoutSet">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="t">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Setup socket timeout for the specified socket&#xA;     * @param sock The socket to set up.&#xA;     * @param t Value for the timeout in microseconds.&#xA;     * &lt;PRE>&#xA;     * t > 0  -- read and write calls return APR_TIMEUP if specified time&#xA;     *           elapsess with no data read or written&#xA;     * t == 0 -- read and write calls never block&#xA;     * t &lt; 0  -- read and write calls block&#xA;     * &lt;/PRE>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="timeoutGet">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../lang/Exception.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Query socket timeout for the specified socket&#xA;     * @param sock The socket to query&#xA;     * @return Socket timeout returned from the query.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="sendfile">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="file">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="headers">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="trailers">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="flags">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Send a file from an open file descriptor to a socket, along with&#xA;     * optional headers and trailers.&#xA;     * &lt;br />&#xA;     * This functions acts like a blocking write by default.  To change&#xA;     *         this behavior, use apr_socket_timeout_set() or the&#xA;     *         APR_SO_NONBLOCK socket option.&#xA;     * The number of bytes actually sent is stored in the len parameter.&#xA;     * The offset parameter is passed by reference for no reason; its&#xA;     * value will never be modified by the apr_socket_sendfile() function.&#xA;     * @param sock The socket to which we're writing&#xA;     * @param file The open file from which to read&#xA;     * @param headers Array containing the headers to send&#xA;     * @param trailers Array containing the trailers to send&#xA;     * @param offset Offset into the file where we should begin writing&#xA;     * @param len Number of bytes to send from the file&#xA;     * @param flags APR flags that are mapped to OS specific flags&#xA;     * @return Number of bytes actually sent, including headers,&#xA;     *         file, and trailers&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="sendfilen">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="file">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="flags">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Send a file without header and trailer arrays.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="pool">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="thesocket">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../lang/Exception.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a child pool from associated socket pool.&#xA;     * @param thesocket The socket to use&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="socket">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="what">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Private method for geting the socket struct members&#xA;     * @param socket The soocket to use&#xA;     * @param what Struct member to obtain&#xA;     * &lt;PRE>&#xA;     * SOCKET_GET_POOL  - The socket pool&#xA;     * SOCKET_GET_IMPL  - The socket implementation object&#xA;     * SOCKET_GET_APRS  - APR socket&#xA;     * SOCKET_GET_TYPE  - Socket type&#xA;     * &lt;/PRE>&#xA;     * @return The stucture member address&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setsbb">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../nio/ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set internal send ByteBuffer.&#xA;     * This function will preset internal Java ByteBuffer for&#xA;     * consecutive sendbb calls.&#xA;     * @param thesocket The socket to use&#xA;     * @param buf The ByteBuffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setrbb">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sock">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../nio/ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set internal receive ByteBuffer.&#xA;     * This function will preset internal Java ByteBuffer for&#xA;     * consecutive revcvbb/recvbbt calls.&#xA;     * @param thesocket The socket to use&#xA;     * @param buf The ByteBuffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/** Socket&#xA; *&#xA; * @author Mladen Turk&#xA; * @version $Revision: 467222 $, $Date: 2006-10-24 05:17:11 +0200 (Tue, 24 Oct 2006) $&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
