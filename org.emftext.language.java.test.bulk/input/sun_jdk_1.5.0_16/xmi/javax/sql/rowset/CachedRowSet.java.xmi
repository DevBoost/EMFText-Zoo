<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="CachedRowSet.java">
  <comments>/*&#xA; * @(#)CachedRowSet.java&#x9;1.7 04/05/29&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>sql</namespaces>
  <namespaces>rowset</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>sql</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>javax</namespaces>
    <namespaces>sql</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>javax</namespaces>
    <namespaces>naming</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>math</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>javax</namespaces>
    <namespaces>sql</namespaces>
    <namespaces>rowset</namespaces>
    <namespaces>spi</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="CachedRowSet">
    <members xsi:type="members:InterfaceMethod" name="populate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/sql/ResultSet.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Populates this &lt;code>CachedRowSet&lt;/code> object with data from&#xA;    * the given &lt;code>ResultSet&lt;/code> object. &#xA;    * &lt;P>&#xA;    * This method can be used as an alternative to the &lt;code>execute&lt;/code> method when an&#xA;    * application has a connection to an open &lt;code>ResultSet&lt;/code> object.&#xA;    * Using the method &lt;code>populate&lt;/code> can be more efficient than using&#xA;    * the version of the &lt;code>execute&lt;/code> method that takes no parameters&#xA;    * because it does not open a new connection and re-execute this&#xA;    * &lt;code>CachedRowSet&lt;/code> object's command. Using the &lt;code>populate&lt;/code>&#xA;    * method is more a matter of convenience when compared to using the version &#xA;    * of &lt;code>execute&lt;/code> that takes a &lt;code>ResultSet&lt;/code> object.&#xA;    *&#xA;    * @param data the &lt;code>ResultSet&lt;/code> object containing the data&#xA;    * &#x9;&#x9;to be read into this &lt;code>CachedRowSet&lt;/code> object&#xA;    * @throws SQLException if a null &lt;code>ResultSet&lt;/code> object is supplied&#xA;    *&#x9;&#x9;or this &lt;code>CachedRowSet&lt;/code> object cannot&#xA;    *&#x9;&#x9;retrieve the associated &lt;code>ResultSetMetaData&lt;/code> object&#xA;    * @see #execute&#xA;    * @see java.sql.ResultSet&#xA;    * @see java.sql.ResultSetMetaData&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="execute">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="conn">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/sql/Connection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Populates this &lt;code>CachedRowSet&lt;/code> object with data, using the &#xA;    * given connection to produce the result set from which the data will be read.&#xA;    * This method should close any database connections that it creates to&#xA;    * ensure that this &lt;code>CachedRowSet&lt;/code> object is disconnected except when&#xA;    * it is reading data from its data source or writing data to its data source.&#xA;    * &lt;P>&#xA;    * The reader for this &lt;code>CachedRowSet&lt;/code> object &#xA;    * will use &lt;i>conn&lt;/i> to establish a connection to the data source&#xA;    * so that it can execute the rowset's command and read data from the&#xA;    * the resulting &lt;code>ResultSet&lt;/code> object into this&#xA;    * &lt;code>CachedRowSet&lt;/code> object. This method also closes &lt;i>conn&lt;/i>&#xA;    * after it has populated this &lt;code>CachedRowSet&lt;/code> object.&#xA;    * &lt;P>&#xA;    * If this method is called when an implementation has already been&#xA;    * populated, the contents and the metadata are (re)set. Also, if this method is&#xA;    * called before the method &lt;code>acceptChanges&lt;/code> has been called&#xA;    * to commit outstanding updates, those updates are lost.&#xA;    * &#xA;    * @param conn a standard JDBC &lt;code>Connection&lt;/code> object with valid &#xA;    * &#x9;&#x9;properties&#xA;    * @throws SQLException if an invalid &lt;code>Connection&lt;/code> object is supplied&#xA;    * &#x9;&#x9;or an error occurs in establishing the connection to the &#xA;    * &#x9;&#x9;data source&#xA;    * @see #populate&#xA;    * @see java.sql.Connection&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="acceptChanges">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="spi/SyncProviderException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Propagates row update, insert and delete changes made to this&#xA;    * &lt;code>CachedRowSet&lt;/code> object to the underlying data source.&#xA;    * &lt;P>&#xA;    * This method calls on this &lt;code>CachedRowSet&lt;/code> object's writer&#xA;    * to do the work behind the scenes.&#xA;    * Standard &lt;code>CachedRowSet&lt;/code> implementations should use the &#xA;    * &lt;code>SyncFactory&lt;/code> singleton &#xA;    * to obtain a &lt;code>SyncProvider&lt;/code> instance providing a&#xA;    * &lt;code>RowSetWriter&lt;/code> object (writer).  The writer will attempt &#xA;    * to propagate changes made in this &lt;code>CachedRowSet&lt;/code> object &#xA;    * back to the data source.&#xA;    * &lt;P>&#xA;    * When the method &lt;code>acceptChanges&lt;/code> executes successfully, in&#xA;    * addition to writing changes to the data source, it&#xA;    * makes the values in the current row be the values in the original row.  &#xA;    * &lt;P>&#xA;    * Depending on the synchronization level of the &lt;code>SyncProvider&lt;/code> &#xA;    * implementation being used, the writer will compare the original values&#xA;    * with those in the data source to check for conflicts. When there is a conflict,&#xA;    * the &lt;code>RIOptimisticProvider&lt;/code> implementation, for example, throws a&#xA;    * &lt;code>SyncProviderException&lt;/code> and does not write anything to the &#xA;    * data source. &#xA;    * &lt;P>&#xA;    * An application may choose to catch the &lt;code>SyncProviderException&lt;/code>&#xA;    * object and retrieve the &lt;code>SyncResolver&lt;/code> object it contains.&#xA;    * The &lt;code>SyncResolver&lt;/code> object lists the conflicts row by row and&#xA;    * sets a lock on the data source to avoid further conflicts while the&#xA;    * current conflicts are being resolved.&#xA;    * Further, for each conflict, it provides methods for examining the conflict&#xA;    * and setting the value that should be persisted in the data source. &#xA;    * After all conflicts have been resolved, an application must call the &#xA;    * &lt;code>acceptChanges&lt;/code> method again to write resolved values to the&#xA;    * data source.  If all of the values in the data source are already the &#xA;    * values to be persisted, the method &lt;code>acceptChanges&lt;/code> does nothing.&#xA;    * &lt;P>&#xA;    * Some provider implementations may use locks to ensure that there are no&#xA;    * conflicts.  In such cases, it is guaranteed that the writer will succeed in&#xA;    * writing changes to the data source when the method &lt;code>acceptChanges&lt;/code>&#xA;    * is called.  This method may be called immediately after the methods&#xA;    * &lt;code>updateRow&lt;/code>, &lt;code>insertRow&lt;/code>, or &lt;code>deleteRow&lt;/code>&#xA;    * have been called, but it is more efficient to call it only once after&#xA;    * all changes have been made so that only one connection needs to be &#xA;    * established.&#xA;    * &lt;P>&#xA;    * Note: The &lt;code>acceptChanges()&lt;/code> method will determine if the&#xA;    * &lt;code>COMMIT_ON_ACCEPT_CHANGES&lt;/code> is set to true or not. If it is set&#xA;    * to true, all updates in the synchronization are committed to the data &#xA;    * source. Otherwise, the application &lt;b>must&lt;/b> explicity call the &#xA;    * &lt;code>commit()&lt;/code> or &lt;code>rollback()&lt;/code> methods as appropriate.&#xA;    *&#xA;    * @throws SQLException if the cursor is on the insert row &#xA;    * @throws SyncProviderException if the underlying&#xA;    *&#x9;&#x9;synchronization provider's writer fails to write the updates&#xA;    *&#x9;&#x9;back to the data source&#xA;    * @see #acceptChanges(java.sql.Connection)&#xA;    * @see javax.sql.RowSetWriter&#xA;    * @see javax.sql.rowset.spi.SyncFactory&#xA;    * @see javax.sql.rowset.spi.SyncProvider&#xA;    * @see javax.sql.rowset.spi.SyncProviderException&#xA;    * @see javax.sql.rowset.spi.SyncResolver&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="acceptChanges">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="con">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/sql/Connection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="spi/SyncProviderException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Propagates all row update, insert and delete changes to the&#xA;    * data source backing this &lt;code>CachedRowSet&lt;/code> object &#xA;    * using the specified &lt;code>Connection&lt;/code> object to establish a&#xA;    * connection to the data source.&#xA;    * &lt;P>&#xA;    * The other version of the &lt;code>acceptChanges&lt;/code> method is not passed&#xA;    * a connection because it uses&#xA;    * the &lt;code>Connection&lt;/code> object already defined within the &lt;code>RowSet&lt;/code>&#xA;    * object, which is the connection used for populating it initially.&#xA;    * &lt;P>&#xA;    * This form of the method &lt;code>acceptChanges&lt;/code> is similar to the&#xA;    * form that takes no arguments; however, unlike the other form, this form&#xA;    * can be used only when the underlying data source is a JDBC data source.&#xA;    * The updated &lt;code>Connection&lt;/code> properties must be used by the&#xA;    * &lt;code>SyncProvider&lt;/code> to reset the &lt;code>RowSetWriter&lt;/code>&#xA;    * configuration to ensure that the contents of the &lt;code>CachedRowSet&lt;/code> &#xA;    * object are synchronized correctly.&#xA;    * &lt;P> &#xA;    * When the method &lt;code>acceptChanges&lt;/code> executes successfully, in&#xA;    * addition to writing changes to the data source, it&#xA;    * makes the values in the current row be the values in the original row.  &#xA;    * &lt;P>&#xA;    * Depending on the synchronization level of the &lt;code>SyncProvider&lt;/code> &#xA;    * implementation being used, the writer will compare the original values&#xA;    * with those in the data source to check for conflicts. When there is a conflict,&#xA;    * the &lt;code>RIOptimisticProvider&lt;/code> implementation, for example, throws a&#xA;    * &lt;code>SyncProviderException&lt;/code> and does not write anything to the &#xA;    * data source. &#xA;    * &lt;P>&#xA;    * An application may choose to catch the &lt;code>SyncProviderException&lt;/code>&#xA;    * object and retrieve the &lt;code>SyncResolver&lt;/code> object it contains.&#xA;    * The &lt;code>SyncResolver&lt;/code> object lists the conflicts row by row and&#xA;    * sets a lock on the data source to avoid further conflicts while the&#xA;    * current conflicts are being resolved.&#xA;    * Further, for each conflict, it provides methods for examining the conflict&#xA;    * and setting the value that should be persisted in the data source. &#xA;    * After all conflicts have been resolved, an application must call the &#xA;    * &lt;code>acceptChanges&lt;/code> method again to write resolved values to the&#xA;    * data source.  If all of the values in the data source are already the &#xA;    * values to be persisted, the method &lt;code>acceptChanges&lt;/code> does nothing.&#xA;    * &lt;P>&#xA;    * Some provider implementations may use locks to ensure that there are no&#xA;    * conflicts.  In such cases, it is guaranteed that the writer will succeed in&#xA;    * writing changes to the data source when the method &lt;code>acceptChanges&lt;/code>&#xA;    * is called.  This method may be called immediately after the methods&#xA;    * &lt;code>updateRow&lt;/code>, &lt;code>insertRow&lt;/code>, or &lt;code>deleteRow&lt;/code>&#xA;    * have been called, but it is more efficient to call it only once after&#xA;    * all changes have been made so that only one connection needs to be &#xA;    * established.&#xA;    * &lt;P>&#xA;    * Note: The &lt;code>acceptChanges()&lt;/code> method will determine if the&#xA;    * &lt;code>COMMIT_ON_ACCEPT_CHANGES&lt;/code> is set to true or not. If it is set&#xA;    * to true, all updates in the synchronization are committed to the data &#xA;    * source. Otherwise, the application &lt;b>must&lt;/b> explicity call the &#xA;    * &lt;code>commit&lt;/code> or &lt;code>rollback&lt;/code> methods as appropriate.&#xA;    *&#xA;    * @param con a standard JDBC &lt;code>Connection&lt;/code> object&#xA;    * @throws SQLException if the cursor is on the insert row &#xA;    * @throws SyncProviderException if the underlying&#xA;    *&#x9;&#x9;synchronization provider's writer fails to write the updates&#xA;    *&#x9;&#x9;back to the data source&#xA;    * @see #acceptChanges()&#xA;    * @see javax.sql.RowSetWriter&#xA;    * @see javax.sql.rowset.spi.SyncFactory&#xA;    * @see javax.sql.rowset.spi.SyncProvider&#xA;    * @see javax.sql.rowset.spi.SyncProviderException&#xA;    * @see javax.sql.rowset.spi.SyncResolver&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="restoreOriginal">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Restores this &lt;code>CachedRowSet&lt;/code> object to its original&#xA;    * value, that is, its value before the last set of changes. If there&#xA;    * have been no changes to the rowset or only one set of changes, &#xA;    * the original value is the value with which this &lt;code>CachedRowSet&lt;/code> object&#xA;    * was populated; otherwise, the original value is &#xA;    * the value it had immediately before its current value.&#xA;    * &lt;P>&#xA;    * When this method is called, a &lt;code>CachedRowSet&lt;/code> implementation&#xA;    * must ensure that all updates, inserts, and deletes to the current&#xA;    * rowset instance are replaced by the previous values. In addition, &#xA;    * the cursor should be &#xA;    * reset to the first row and a &lt;code>rowSetChanged&lt;/code> event&#xA;    * should be fired to notify all registered listeners.&#xA;    *&#xA;    * @throws SQLException if an error occurs rolling back the current value of&#xA;    *       this &lt;code>CachedRowSet&lt;/code> object to its previous value&#xA;    * @see javax.sql.RowSetListener#rowSetChanged&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="release">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Releases the current contents of this &lt;code>CachedRowSet&lt;/code>&#xA;    * object and sends a &lt;code>rowSetChanged&lt;/code> event to all &#xA;    * registered listeners. Any outstanding updates are discarded and&#xA;    * the rowset contains no rows after this method is called. There&#xA;    * are no interactions with the underlying data source, and any rowset&#xA;    * content, metadata, and content updates should be non-recoverable.&#xA;    * &lt;P>&#xA;    * This &lt;code>CachedRowSet&lt;/code> object should lock until its contents and&#xA;    * associated updates are fully cleared, thus preventing 'dirty' reads by&#xA;    * other components that hold a reference to this &lt;code>RowSet&lt;/code> object.&#xA;    * In addition, the contents cannot be released &#xA;    * until all all components reading this &lt;code>CachedRowSet&lt;/code> object  &#xA;    * have completed their reads. This &lt;code>CachedRowSet&lt;/code> object&#xA;    * should be returned to normal behavior after firing the &#xA;    * &lt;code>rowSetChanged&lt;/code> event.&#xA;    * &lt;P>&#xA;    * The metadata, including JDBC properties and Synchronization SPI&#xA;    * properties, are maintained for future use. It is important that &#xA;    * properties such as the &lt;code>command&lt;/code> property be&#xA;    * relevant to the originating data source from which this &lt;code>CachedRowSet&lt;/code>&#xA;    * object was originally established.&#xA;    * &lt;P>&#xA;    * This method empties a rowset, as opposed to the &lt;code>close&lt;/code> method, &#xA;    * which marks the entire rowset as recoverable to allow the garbage collector&#xA;    * the rowset's Java VM resources.&#xA;    *&#xA;    * @throws SQLException if an error occurs flushing the contents of this&#xA;    * &#x9;&#x9;&lt;code>CachedRowSet&lt;/code> object&#xA;    * @see javax.sql.RowSetListener#rowSetChanged&#xA;    * @see java.sql.ResultSet#close&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="undoDelete">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Cancels the deletion of the current row and notifies listeners that &#xA;    * a row has changed. After this method is called, the current row is&#xA;    * no longer marked for deletion. This method can be called at any&#xA;    * time during the lifetime of the rowset.&#xA;    * &lt;P>&#xA;    * In addition, multiple cancellations of row deletions can be made &#xA;    * by adjusting the position of the cursor using any of the cursor&#xA;    * position control methods such as:&#xA;    * &lt;ul>&#xA;    * &lt;li>&lt;code>CachedRowSet.absolute&lt;/code>&#xA;    * &lt;li>&lt;code>CachedRowSet.first&lt;/code>&#xA;    * &lt;li>&lt;code>CachedRowSet.last&lt;/code>&#xA;    * &lt;/ul>&#xA;    *&#xA;    * @throws SQLException if (1) the current row has not been deleted or&#xA;    * (2) the cursor is on the insert row, before the first row, or  &#xA;    * after the last row&#xA;    * @see javax.sql.rowset.CachedRowSet#undoInsert&#xA;    * @see java.sql.ResultSet#cancelRowUpdates&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="undoInsert">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Immediately removes the current row from this &lt;code>CachedRowSet&lt;/code>&#xA;    * object if the row has been inserted, and also notifies listeners that a&#xA;    * row has changed. This method can be called at any time during the&#xA;    * lifetime of a rowset and assuming the current row is within&#xA;    * the exception limitations (see below), it cancels the row insertion&#xA;    * of the current row.&#xA;    * &lt;P>&#xA;    * In addition, multiple cancellations of row insertions can be made&#xA;    * by adjusting the position of the cursor using any of the cursor &#xA;    * position control methods such as:&#xA;    * &lt;ul>&#xA;    * &lt;li>&lt;code>CachedRowSet.absolute&lt;/code>&#xA;    * &lt;li>&lt;code>CachedRowSet.first&lt;/code>&#xA;    * &lt;li>&lt;code>CachedRowSet.last&lt;/code>&#xA;    * &lt;/ul>&#xA;    *&#xA;    * @throws SQLException if (1) the current row has not been inserted or (2)&#xA;    * the cursor is before the first row, after the last row, or on the&#xA;    * insert row&#xA;    * @see javax.sql.rowset.CachedRowSet#undoDelete&#xA;    * @see java.sql.ResultSet#cancelRowUpdates&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="undoUpdate">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Immediately reverses the last update operation if the &#xA;    * row has been modified. This method can be&#xA;    * called to reverse updates on all columns until all updates in a row have &#xA;    * been rolled back to their state just prior to the last synchronization&#xA;    * (&lt;code>acceptChanges&lt;/code>) or population. This method may also be called &#xA;    * while performing updates to the insert row.&#xA;    * &lt;P>&#xA;    * &lt;code>undoUpdate&lt;/code may be called at any time during the lifetime of a&#xA;    * rowset; however, after a synchronization has occurred, this method has no&#xA;    * effect until further modification to the rowset data has occurred.&#xA;    * &#xA;    * @throws SQLException if the cursor is before the first row or after the last&#xA;    *     row in in this &lt;code>CachedRowSet&lt;/code> object&#xA;    * @see #undoDelete&#xA;    * @see #undoInsert&#xA;    * @see java.sql.ResultSet#cancelRowUpdates&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="columnUpdated">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="idx">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Indicates whether the designated column in the current row of this&#xA;    * &lt;code>CachedRowSet&lt;/code> object has been updated.&#xA;    *&#xA;    * @param idx an &lt;code>int&lt;/code> identifying the column to be checked for updates&#xA;    * @return &lt;code>true&lt;/code> if the designated column has been visibly updated;&#xA;    * &#x9;&#x9;&lt;code>false&lt;/code> otherwise&#xA;    * @throws SQLException if the cursor is on the insert row, before the first row,&#xA;    *       or after the last row&#xA;    * @see java.sql.DatabaseMetaData#updatesAreDetected&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="columnUpdated">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="columnName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Indicates whether the designated column in the current row of this&#xA;    * &lt;code>CachedRowSet&lt;/code> object has been updated.&#xA;    *&#xA;    * @param columnName a &lt;code>String&lt;/code> object giving the name of the &#xA;    *        column to be checked for updates&#xA;    * @return &lt;code>true&lt;/code> if the column has been visibly updated;&#xA;    * &#x9;&#x9;&lt;code>false&lt;/code> otherwise&#xA;    * @throws SQLException if the cursor is on the insert row, before the first row,&#xA;    *       or after the last row&#xA;    * @see java.sql.DatabaseMetaData#updatesAreDetected&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toCollection">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:UnknownTypeArgument"/>
          <target xsi:type="classifiers:Interface" href="../../../java/util/Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Converts this &lt;code>CachedRowSet&lt;/code> object to a &lt;code>Collection&lt;/code> &#xA;    * object that contains all of this &lt;code>CachedRowSet&lt;/code> object's data. &#xA;    * Implementations have some latitude in&#xA;    * how they can represent this &lt;code>Collection&lt;/code> object because of the&#xA;    * abstract nature of the &lt;code>Collection&lt;/code> framework.&#xA;    * Each row must be fully represented in either a&#xA;    * general purpose &lt;code>Collection&lt;/code> implementation or a specialized &#xA;    * &lt;code>Collection&lt;/code> implementation, such as a &lt;code>TreeMap&lt;/code>&#xA;    * object or a &lt;code>Vector&lt;/code> object. &#xA;    * An SQL &lt;code>NULL&lt;/code> column value must be represented as a &lt;code>null&lt;/code>&#xA;    * in the Java programming language.&#xA;    * &lt;P>&#xA;    * The standard reference implementation for the &lt;code>CachedRowSet&lt;/code> &#xA;    * interface uses a &lt;code>TreeMap&lt;/code> object for the rowset, with the&#xA;    * values in each row being contained in  &lt;code>Vector&lt;/code> objects. It is&#xA;    * expected that most implementations will do the same.&#xA;    * &lt;P>&#xA;    * The &lt;code>TreeMap&lt;/code> type of collection guarantees that the map will be in&#xA;    * ascending key order, sorted according to the natural order for the&#xA;    * key's class.&#xA;    * Each key references a &lt;code>Vector&lt;/code> object that corresponds to one&#xA;    * row of a &lt;code>RowSet&lt;/code> object. Therefore, the size of each &#xA;    * &lt;code>Vector&lt;/code> object  must be exactly equal to the number of &#xA;    * columns in the &lt;code>RowSet&lt;/code> object. &#xA;    * The key used by the &lt;code>TreeMap&lt;/code> collection is determined by the&#xA;    * implementation, which may choose to leverage a set key that is &#xA;    * available within the internal &lt;code>RowSet&lt;/code> tabular structure by &#xA;    * virtue of a key already set either on the &lt;code>RowSet&lt;/code> object &#xA;    * itself or on the underlying SQL data. &#xA;    * &lt;P>&#xA;    *&#xA;    * @return a &lt;code>Collection&lt;/code> object that contains the values in &#xA;    * &#x9;&#x9;each row in this &lt;code>CachedRowSet&lt;/code> object&#xA;    * @throws SQLException if an error occurs generating the collection&#xA;    * @see #toCollection(int)&#xA;    * @see #toCollection(String)&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toCollection">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:UnknownTypeArgument"/>
          <target xsi:type="classifiers:Interface" href="../../../java/util/Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="column">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Converts the designated column in this &lt;code>CachedRowSet&lt;/code> object &#xA;    * to a &lt;code>Collection&lt;/code> object. Implementations have some latitude in&#xA;    * how they can represent this &lt;code>Collection&lt;/code> object because of the&#xA;    * abstract nature of the &lt;code>Collection&lt;/code> framework.&#xA;    * Each column value should be fully represented in either a&#xA;    * general purpose &lt;code>Collection&lt;/code> implementation or a specialized &#xA;    * &lt;code>Collection&lt;/code> implementation, such as a &lt;code>Vector&lt;/code> object.&#xA;    * An SQL &lt;code>NULL&lt;/code> column value must be represented as a &lt;code>null&lt;/code>&#xA;    * in the Java programming language.&#xA;    * &lt;P>&#xA;    * The standard reference implementation uses a &lt;code>Vector&lt;/code> object&#xA;    * to contain the column values, and it is expected &#xA;    * that most implementations will do the same. If a &lt;code>Vector&lt;/code> object&#xA;    * is used, it size must be exactly equal to the number of rows&#xA;    * in this &lt;code>CachedRowSet&lt;/code> object.&#xA;    *&#xA;    * @param column an &lt;code>int&lt;/code> indicating the column whose values&#xA;    *        are to be represented in a &lt;code>Collection&lt;/code> object&#xA;    * @return a &lt;code>Collection&lt;/code> object that contains the values&#xA;    * &#x9;&#x9;stored in the specified column of this &lt;code>CachedRowSet&lt;/code>&#xA;    *&#x9;&#x9;object&#xA;    * @throws SQLException if an error occurs generating the collection or&#xA;    * &#x9;&#x9;an invalid column id is provided&#xA;    * @see #toCollection&#xA;    * @see #toCollection(String)&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toCollection">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:UnknownTypeArgument"/>
          <target xsi:type="classifiers:Interface" href="../../../java/util/Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="column">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**      &#xA;    * Converts the designated column in this &lt;code>CachedRowSet&lt;/code> object &#xA;    * to a &lt;code>Collection&lt;/code> object. Implementations have some latitude in&#xA;    * how they can represent this &lt;code>Collection&lt;/code> object because of the&#xA;    * abstract nature of the &lt;code>Collection&lt;/code> framework.&#xA;    * Each column value should be fully represented in either a&#xA;    * general purpose &lt;code>Collection&lt;/code> implementation or a specialized &#xA;    * &lt;code>Collection&lt;/code> implementation, such as a &lt;code>Vector&lt;/code> object.&#xA;    * An SQL &lt;code>NULL&lt;/code> column value must be represented as a &lt;code>null&lt;/code>&#xA;    * in the Java programming language.&#xA;    * &lt;P>&#xA;    * The standard reference implementation uses a &lt;code>Vector&lt;/code> object&#xA;    * to contain the column values, and it is expected &#xA;    * that most implementations will do the same. If a &lt;code>Vector&lt;/code> object&#xA;    * is used, it size must be exactly equal to the number of rows&#xA;    * in this &lt;code>CachedRowSet&lt;/code> object.&#xA;    *&#xA;    * @param column a &lt;code>String&lt;/code> object giving the name of the &#xA;    *        column whose values are to be represented in a collection&#xA;    * @return a &lt;code>Collection&lt;/code> object that contains the values&#xA;    * &#x9;&#x9;stored in the specified column of this &lt;code>CachedRowSet&lt;/code>&#xA;    *&#x9;&#x9;object&#xA;    * @throws SQLException if an error occurs generating the collection or&#xA;    * &#x9;&#x9;an invalid column id is provided&#xA;    * @see #toCollection&#xA;    * @see #toCollection(int)&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSyncProvider">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="spi/SyncProvider.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Retrieves the &lt;code>SyncProvider&lt;/code> implementation for this&#xA;    * &lt;code>CachedRowSet&lt;/code> object. Internally, this method is used by a rowset&#xA;    * to trigger read or write actions between the rowset&#xA;    * and the data source. For example, a rowset may need to get a handle&#xA;    * on the the rowset reader (&lt;code>RowSetReader&lt;/code> object) from the &#xA;    * &lt;code>SyncProvider&lt;/code> to allow the rowset to be populated.&#xA;    * &lt;pre>&#xA;    *     RowSetReader rowsetReader = null;&#xA;    *     SyncProvider provider = &#xA;    *         SyncFactory.getInstance(&quot;javax.sql.rowset.provider.RIOptimisticProvider&quot;);&#xA;    *         if (provider instanceof RIOptimisticProvider) {&#xA;    *             rowsetReader = provider.getRowSetReader();&#xA;    *         }&#xA;    * &lt;/pre>&#xA;    * Assuming &lt;i>rowsetReader&lt;/i> is a private, accessible field within&#xA;    * the rowset implementation, when an application calls the &lt;code>execute&lt;/code> &#xA;    * method, it in turn calls on the reader's &lt;code>readData&lt;/code> method &#xA;    * to populate the &lt;code>RowSet&lt;/code> object.&#xA;    *&lt;pre>    &#xA;    *     rowsetReader.readData((RowSetInternal)this);&#xA;    * &lt;/pre>&#xA;    * &lt;P>&#xA;    * In addition, an application can use the &lt;code>SyncProvider&lt;/code> object&#xA;    * returned by this method to call methods that return information about the&#xA;    * &lt;code>SyncProvider&lt;/code> object, including information about the&#xA;    * vendor, version, provider identification, synchronization grade, and locks&#xA;    * it currently has set.&#xA;    *&#xA;    * @return the &lt;code>SyncProvider&lt;/code> object that was set when the rowset&#xA;    *      was instantiated, or if none was was set, the default provider&#xA;    * @throws SQLException if an error occurs while returning the &#xA;    * &#x9;&#x9;&lt;code>SyncProvider&lt;/code> object&#xA;    * @see #setSyncProvider&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setSyncProvider">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="provider">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Sets the &lt;code>SyncProvider&lt;/code> objec for this &lt;code>CachedRowSet&lt;/code>&#xA;    * object to the one specified.  This method&#xA;    * allows the &lt;code>SyncProvider&lt;/code> object to be reset.&#xA;    * &lt;P>&#xA;    * A &lt;code>CachedRowSet&lt;/code> implementation should always be instantiated&#xA;    * with an available &lt;code>SyncProvider&lt;/code> mechanism, but there are&#xA;    * cases where resetting the &lt;code>SyncProvider&lt;/code> object is desirable &#xA;    * or necessary. For example, an application might want to use the default&#xA;    * &lt;code>SyncProvider&lt;/code> object for a time and then choose to use a provider&#xA;    * that has more recently become available and better fits its needs.&#xA;    * &lt;P>&#xA;    * Resetting the &lt;code>SyncProvider&lt;/code> object causes the&#xA;    * &lt;code>RowSet&lt;/code> object to request a new &lt;code>SyncProvider&lt;/code> implementation &#xA;    * from the &lt;code>SyncFactory&lt;/code>. This has the effect of resetting&#xA;    * all previous connections and relationships with the originating&#xA;    * data source and can potentially drastically change the synchronization&#xA;    * behavior of a disconnected rowset.&#xA;    * &#xA;    * @param provider a &lt;code>String&lt;/code> object giving the fully qualified class&#xA;    *        name of a &lt;code>SyncProvider&lt;/code> implementation&#xA;    * @throws SQLException if an error occurs while attempting to reset the&#xA;    *&#x9;&#x9;&lt;code>SyncProvider&lt;/code> implementation&#xA;    * @see #getSyncProvider&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="size">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Returns the number of rows in this &lt;code>CachedRowSet&lt;/code>&#xA;    * object.&#xA;    *&#xA;    * @return number of rows in the rowset&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setMetaData">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="md">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../RowSetMetaData.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Sets the metadata for this &lt;code>CachedRowSet&lt;/code> object with&#xA;    * the given &lt;code>RowSetMetaData&lt;/code> object. When a &#xA;    * &lt;code>RowSetReader&lt;/code> object is reading the contents of a rowset,&#xA;    * it creates a &lt;code>RowSetMetaData&lt;/code> object and initializes&#xA;    * it using the methods in the &lt;code>RowSetMetaData&lt;/code> implementation.&#xA;    * The reference implementation uses the &lt;code>RowSetMetaDataImpl&lt;/code>&#xA;    * class. When the reader has completed reading the rowset contents,&#xA;    * this method is called internally to pass the &lt;code>RowSetMetaData&lt;/code> &#xA;    * object to the rowset.&#xA;    *&#xA;    * @param md a &lt;code>RowSetMetaData&lt;/code> object containing&#xA;    *&#x9;&#x9;metadata about the columns in this &lt;code>CachedRowSet&lt;/code> object&#xA;    * @throws SQLException if invalid metadata is supplied to the&#xA;    * &#x9;&#x9;rowset&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getOriginal">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../java/sql/ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Returns a &lt;code>ResultSet&lt;/code> object containing the original value of this&#xA;    * &lt;code>CachedRowSet&lt;/code> object.&#xA;    * &lt;P>&#xA;    * The cursor for the &lt;code>ResultSet&lt;/code>&#xA;    * object should be positioned before the first row.&#xA;    * In addition, the returned &lt;code>ResultSet&lt;/code> object should have the following&#xA;    * properties:&#xA;    * &lt;UL>&#xA;    * &lt;LI>ResultSet.TYPE_SCROLL_INSENSITIVE&#xA;    * &lt;LI>ResultSet.CONCUR_UPDATABLE&#xA;    * &lt;/UL>&#xA;    * &lt;P>&#xA;    * The original value for a &lt;code>RowSet&lt;/code> object is the value it had before&#xA;    * the last synchronization with the underlying data source.  If there have been&#xA;    * no synchronizations, the original value will be the value with which the&#xA;    * &lt;code>RowSet&lt;/code> object was populated.  This method is called internally&#xA;    * when an aplication calls the method &lt;code>acceptChanges&lt;/code> and the&#xA;    * &lt;code>SyncProvider&lt;/code> object has been implemented to check for conflicts.&#xA;    * If this is the case, the writer compares the original value with the value&#xA;    * currently in the data source to check for conflicts.&#xA;    *&#xA;    * @return a &lt;code>ResultSet&lt;/code> object that contains the original value for &#xA;    *         this &lt;code>CachedRowSet&lt;/code> object&#xA;    * @throws SQLException if an error occurs producing the &#xA;    *&#x9;&#x9;&lt;code>ResultSet&lt;/code> object&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getOriginalRow">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../java/sql/ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Returns a &lt;code>ResultSet&lt;/code> object containing the original value for the&#xA;    * current row only of this &lt;code>CachedRowSet&lt;/code> object.&#xA;    * &lt;P>&#xA;    * The cursor for the &lt;code>ResultSet&lt;/code>&#xA;    * object should be positioned before the first row.&#xA;    * In addition, the returned &lt;code>ResultSet&lt;/code> object should have the following&#xA;    * properties:&#xA;    * &lt;UL>&#xA;    * &lt;LI>ResultSet.TYPE_SCROLL_INSENSITIVE&#xA;    * &lt;LI>ResultSet.CONCUR_UPDATABLE&#xA;    * &lt;/UL>&#xA;    *&#xA;    * @return the original result set of the row&#xA;    * @throws SQLException if there is no current row&#xA;    * @see #setOriginalRow&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setOriginalRow">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Sets the current row in this &lt;code>CachedRowSet&lt;/code> object as the original&#xA;    * row.  &#xA;    * &lt;P>&#xA;    * This method is called internally after the any modified values in the current&#xA;    * row have been synchronized with the data source. The current row must be tagged &#xA;    * as no longer inserted, deleted or updated.&#xA;    * &lt;P>&#xA;    * A call to &lt;code>setOriginalRow&lt;/code> is irreversible.&#xA;    *&#xA;    * @throws SQLException if there is no current row or an error is &#xA;    * &#x9;&#x9;encountered resetting the contents of the original row&#xA;    * @see #getOriginalRow&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTableName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Returns an identifier for the object (table) that was used to&#xA;    * create this &lt;code>CachedRowSet&lt;/code> object. This name may be set on multiple occasions,&#xA;    * and the specification imposes no limits on how many times this&#xA;    * may occur or whether standard implementations should keep track&#xA;    * of previous table names.&#xA;    *&#xA;    * @return a &lt;code>String&lt;/code> object giving the name of the table that is the&#xA;    *         source of data for this &lt;code>CachedRowSet&lt;/code> object or &lt;code>null&lt;/code> &#xA;    *         if no name has been set for the table &#xA;    * @throws SQLException if an error is encountered returning the table name&#xA;    * @see javax.sql.RowSetMetaData#getTableName&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setTableName">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tabName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Sets the identifier for the table from which this &lt;code>CachedRowSet&lt;/code>&#xA;    * object was derived to the given table name. The writer uses this name to&#xA;    * determine which table to use when comparing the values in the data source with the&#xA;    * &lt;code>CachedRowSet&lt;/code> object's values during a synchronization attempt.&#xA;    * The table identifier also indicates where modified values from this&#xA;    * &lt;code>CachedRowSet&lt;/code> object should be written.&#xA;    * &lt;P>&#xA;    * The implementation of this &lt;code>CachedRowSet&lt;/code> object may obtain the&#xA;    * the name internally from the &lt;code>RowSetMetaDataImpl&lt;/code> object.&#xA;    *&#xA;    * @param tabName a &lt;code>String&lt;/code> object identifying the table from which this&#xA;             &lt;code>CachedRowSet&lt;/code> object was derived; cannot be &lt;code>null&lt;/code>&#xA;    *         but may be an empty string&#xA;    * @throws SQLException if an error is encountered naming the table or&#xA;    *     &lt;i>tabName&lt;/i> is &lt;code>null&lt;/code>&#xA;    * @see javax.sql.RowSetMetaData#setTableName&#xA;    * @see javax.sql.RowSetWriter&#xA;    * @see javax.sql.rowset.spi.SyncProvider &#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getKeyColumns">
      <typeReference xsi:type="types:Int"/>
      <arrayDimensionsBefore/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Returns an array containing one or more column numbers indicating the columns&#xA;    * that form a key that uniquely&#xA;    * identifies a row in this &lt;code>CachedRowSet&lt;/code> object.&#xA;    * &#xA;    * @return an array containing the column number or numbers that indicate which columns&#xA;    *       constitute a primary key &#xA;    *       for a row in this &lt;code>CachedRowSet&lt;/code> object. This array should be&#xA;    *       empty if no columns are representative of a primary key.&#xA;    * @throws SQLException if this &lt;code>CachedRowSet&lt;/code> object is empty&#xA;    * @see #setKeyColumns&#xA;    * @see Joinable#getMatchColumnIndexes&#xA;    * @see Joinable#getMatchColumnNames&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setKeyColumns">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="keys">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Sets this &lt;code>CachedRowSet&lt;/code> object's &lt;code>keyCols&lt;/code>&#xA;    * field with the given array of column numbers, which forms a key&#xA;    * for uniquely identifying a row in this &lt;code>CachedRowSet&lt;/code> object.&#xA;    * &lt;p>&#xA;    * If a &lt;code>CachedRowSet&lt;/code> object becomes part of a &lt;code>JoinRowSet&lt;/code>&#xA;    * object, the keys defined by this method and the resulting constraints are &#xA;    * maintained if the columns designated as key columns also become match&#xA;    * columns.&#xA;    *&#xA;    * @param keys an array of &lt;code>int&lt;/code> indicating the columns that form&#xA;    *        a primary key for this &lt;code>CachedRowSet&lt;/code> object; every&#xA;    *        element in the array must be greater than &lt;code>0&lt;/code> and&#xA;    *        less than or equal to the number of columns in this rowset&#xA;    * @throws SQLException if any of the numbers in the given array&#xA;    *            are not valid for this rowset&#xA;    * @see #getKeyColumns &#xA;    * @see Joinable#setMatchColumn(String)&#xA;    * @see Joinable#setMatchColumn(int)&#xA;    &#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createShared">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../RowSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Returns a new &lt;code>RowSet&lt;/code> object backed by the same data as&#xA;    * that of this &lt;code>CachedRowSet&lt;/code> object. In effect, both&#xA;    * &lt;code>CachedRowSet&lt;/code> objects have a cursor over the same data.&#xA;    * As a result, any changes made by a duplicate are visible to the original&#xA;    * and to any other duplicates, just as a change made by the original is visible&#xA;    * to all of its duplicates. If a duplicate calls a method that changes the &#xA;    * underlying data, the method it calls notifies all registered listeners&#xA;    * just as it would when it is called by the original &lt;code>CachedRowSet&lt;/code>&#xA;    * object.&#xA;    * &lt;P>&#xA;    * In addition, any &lt;code>RowSet&lt;/code> object&#xA;    * created by this method will have the same properties as this&#xA;    * &lt;code>CachedRowSet&lt;/code> object. For example, if this &lt;code>CachedRowSet&lt;/code>&#xA;    * object is read-only, all of its duplicates will also be read-only. If it is&#xA;    * changed to be updatable, the duplicates also become updatable.&#xA;    * &lt;P>&#xA;    * NOTE: If multiple threads access &lt;code>RowSet&lt;/code> objects created from&#xA;    * the &lt;code>createShared()&lt;/code> method, the following behavior is specified&#xA;    * to preserve shared data integrity: reads and writes of all &#xA;    * shared &lt;code>RowSet&lt;/code> objects should be made serially between each &#xA;    * object and the single underlying tabular structure.&#xA;    *&#xA;    * @return a new shared &lt;code>RowSet&lt;/code> object that has the same properties&#xA;    *         as this &lt;code>CachedRowSet&lt;/code> object and that has a cursor over&#xA;    *         the same data &#xA;    * @throws SQLException if an error occurs or cloning is not&#xA;    *&#x9;&#x9;supported in the underlying platform&#xA;    * @see javax.sql.RowSetEvent&#xA;    * @see javax.sql.RowSetListener&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createCopy">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Creates a &lt;code>RowSet&lt;/code> object that is a deep copy of the data in&#xA;    * this &lt;code>CachedRowSet&lt;/code> object. In contrast to &#xA;    * the &lt;code>RowSet&lt;/code> object generated from a &lt;code>createShared&lt;/code>&#xA;    * call, updates made to the copy of the original &lt;code>RowSet&lt;/code> object&#xA;    * must not be visible to the original &lt;code>RowSet&lt;/code> object. Also, any&#xA;    * event listeners that are registered with the original &#xA;    * &lt;code>RowSet&lt;/code> must not have scope over the new &#xA;    * &lt;code>RowSet&lt;/code> copies. In addition, any constraint restrictions&#xA;    * established must be maintained.&#xA;    *&#xA;    * @return a new &lt;code>RowSet&lt;/code> object that is a deep copy&#xA;    *&#x9;      of this &lt;code>CachedRowSet&lt;/code> object and is&#xA;    *&#x9;      completely independent of this &lt;code>CachedRowSet&lt;/code> object&#xA;    * @throws SQLException if an error occurs in generating the copy of&#xA;    *&#x9;      the of this &lt;code>CachedRowSet&lt;/code> object&#xA;    * @see #createShared&#xA;    * @see #createCopySchema&#xA;    * @see #createCopyNoConstraints&#xA;    * @see javax.sql.RowSetEvent&#xA;    * @see javax.sql.RowSetListener&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createCopySchema">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a &lt;code>CachedRowSet&lt;/code> object that is an empty copy of this&#xA;     * &lt;code>CachedRowSet&lt;/code> object.  The copy&#xA;     * must not contain any contents but only represent the table&#xA;     * structure of the original &lt;code>CachedRowSet&lt;/code> object. In addition, primary &#xA;     * or foreign key constraints set in the originating &lt;code>CachedRowSet&lt;/code> object must &#xA;     * be equally enforced in the new empty &lt;code>CachedRowSet&lt;/code> object. &#xA;     * In contrast to &#xA;     * the &lt;code>RowSet&lt;/code> object generated from a &lt;code>createShared&lt;/code> method&#xA;     * call, updates made to a copy of this &lt;code>CachedRowSet&lt;/code> object with the&#xA;     * &lt;code>createCopySchema&lt;/code> method must not be visible to it.&#xA;     * &lt;P>&#xA;     * Applications can form a &lt;code>WebRowSet&lt;/code> object from the &lt;code>CachedRowSet&lt;/code>&#xA;     * object returned by this method in order&#xA;     * to export the &lt;code>RowSet&lt;/code> schema definition to XML for future use.&#xA;     * &#xA;     * @throws SQLException if an error occurs in cloning the structure of this&#xA;     *         &lt;code>CachedRowSet&lt;/code> object&#xA;     * @see #createShared&#xA;     * @see #createCopySchema&#xA;     * @see #createCopyNoConstraints&#xA;     * @see javax.sql.RowSetEvent&#xA;     * @see javax.sql.RowSetListener&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createCopyNoConstraints">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a &lt;code>CachedRowSet&lt;/code> object that is a deep copy of &#xA;     * this &lt;code>CachedRowSet&lt;/code> object's data but is independent of it.&#xA;     * In contrast to &#xA;     * the &lt;code>RowSet&lt;/code> object generated from a &lt;code>createShared&lt;/code>&#xA;     * method call, updates made to a copy of this &lt;code>CachedRowSet&lt;/code> object&#xA;     * must not be visible to it. Also, any&#xA;     * event listeners that are registered with this&#xA;     * &lt;code>CachedRowSet&lt;/code> object must not have scope over the new &#xA;     * &lt;code>RowSet&lt;/code> object. In addition, any constraint restrictions&#xA;     * established for this &lt;code>CachedRowSet&lt;/code> object must &lt;b>not&lt;/b> be maintained&#xA;     * in the copy.&#xA;     *&#xA;     * @return a new &lt;code>CachedRowSet&lt;/code> object that is a deep copy&#xA;     *&#x9;      of this &lt;code>CachedRowSet&lt;/code> object and is&#xA;     *&#x9;      completely independent of this  &lt;code>CachedRowSet&lt;/code> object&#xA;     * @throws SQLException if an error occurs in generating the copy of&#xA;     *&#x9;      the of this &lt;code>CachedRowSet&lt;/code> object&#xA;     * @see #createCopy&#xA;     * @see #createShared&#xA;     * @see #createCopySchema&#xA;     * @see javax.sql.RowSetEvent&#xA;     * @see javax.sql.RowSetListener&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getRowSetWarnings">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RowSetWarning.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the first warning reported by calls on this &lt;code>RowSet&lt;/code> object.&#xA;     * Subsequent warnings on this &lt;code>RowSet&lt;/code> object will be chained to the&#xA;     * &lt;code>RowSetWarning&lt;/code> object that this method returns.&#xA;     *&#xA;     * The warning chain is automatically cleared each time a new row is read.&#xA;     * This method may not be called on a RowSet object that has been closed;&#xA;     * doing so will cause a &lt;code>SQLException&lt;/code> to be thrown.&#xA;     *&#xA;     * @return RowSetWarning the first &lt;code>RowSetWarning&lt;/code>&#xA;     * object reported or null if there are none&#xA;     * @throws SQLException if this method is called on a closed RowSet&#xA;     * @see RowSetWarning&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getShowDeleted">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves a &lt;code>boolean&lt;/code> indicating whether rows marked&#xA;     * for deletion appear in the set of current rows. If &lt;code>true&lt;/code> is &#xA;     * returned, deleted rows are visible with the current rows. If &#xA;     * &lt;code>false&lt;/code> is returned, rows are not visible with the set of &#xA;     * current rows. The default value is &lt;code>false&lt;/code>.&#xA;     * &lt;P>&#xA;     * Standard rowset implementations may choose to restrict this behavior&#xA;     * due to security considerations or to better fit certain deployment&#xA;     * scenarios. This is left as implementation defined and does not&#xA;     * represent standard behavior.          &#xA;     * &lt;P>&#xA;     * Note: Allowing deleted rows to remain visible complicates the behavior&#xA;     * of some standard JDBC &lt;code>RowSet&lt;/code> Implementations methods. &#xA;     * However, most rowset users can simply ignore this extra detail because &#xA;     * only very specialized applications will likely want to take advantage of&#xA;     * this feature.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if deleted rows are visible;&#xA;     *         &lt;code>false&lt;/code> otherwise&#xA;     * @throws SQLException if a rowset implementation is unable to&#xA;     *&#x9;&#x9;to determine whether rows marked for deletion are visible&#xA;     * @see #setShowDeleted&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setShowDeleted">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the property &lt;code>showDeleted&lt;/code> to the given&#xA;     * &lt;code>boolean&lt;/code> value, which determines whether&#xA;     * rows marked for deletion appear in the set of current rows.&#xA;     * If the value is set to &lt;code>true&lt;/code>, deleted rows are immediately&#xA;     * visible with the set of current rows. If the value is set to &#xA;     * &lt;code>false&lt;/code>, the deleted rows are set as invisible with the&#xA;     * current set of rows.&#xA;     * &lt;P>&#xA;     * Standard rowset implementations may choose to restrict this behavior&#xA;     * due to security considerations or to better fit certain deployment&#xA;     * scenarios. This is left as implementations defined and does not&#xA;     * represent standard behavior.&#xA;     *&#xA;     * @param b &lt;code>true&lt;/code> if deleted rows should be shown;&#xA;     *              &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a rowset implementation is unable to&#xA;     *&#x9;&#x9;to reset whether deleted rows should be visible&#xA;     * @see #getShowDeleted&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="commit">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Each &lt;code>CachedRowSet&lt;/code> object's &lt;code>SyncProvider&lt;/code> contains&#xA;     * a &lt;code>Connection&lt;/code> object from the &lt;code>ResultSet&lt;/code> or JDBC &#xA;     * properties passed to it's constructors. This method wraps the &#xA;     * &lt;code>Connection&lt;/code> commit method to allow flexible&#xA;     * auto commit or non auto commit transactional control support.&#xA;     * &lt;p>&#xA;     * Makes all changes that are performed by the &lt;code>acceptChanges()&lt;/code> &#xA;     * method since the previous commit/rollback permanent. This method should &#xA;     * be used only when auto-commit mode has been disabled.&#xA;     *&#xA;     * @throws SQLException if a database access error occurs or this &#xA;     * Connection object within this &lt;code>CachedRowSet&lt;/code> is in auto-commit mode&#xA;     * @see java.sql.Connection#setAutoCommit&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rollback">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Each &lt;code>CachedRowSet&lt;/code> object's &lt;code>SyncProvider&lt;/code> contains&#xA;     * a &lt;code>Connection&lt;/code> object from the original &lt;code>ResultSet&lt;/code>&#xA;     * or JDBC properties passed to it.&#xA;     * &lt;p>&#xA;     * Undoes all changes made in the current transaction.  This method &#xA;     * should be used only when auto-commit mode has been disabled.&#xA;     * &#xA;     * @throws SQLException if a database access error occurs or this Connection&#xA;     * object within this &lt;code>CachedRowSet&lt;/code> is in auto-commit mode.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rollback">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/sql/Savepoint.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Each &lt;code>CachedRowSet&lt;/code> object's &lt;code>SyncProvider&lt;/code> contains&#xA;     * a &lt;code>Connection&lt;/code> object from the original &lt;code>ResultSet&lt;/code>&#xA;     * or JDBC properties passed to it.&#xA;     * &lt;p>&#xA;     * Undoes all changes made in the current transaction back to the last&#xA;     * &lt;code>Savepoint&lt;/code> transaction marker. This method should be used only &#xA;     * when auto-commit mode has been disabled.&#xA;     * &#xA;     * @param s A &lt;code>Savepoint&lt;/code> transaction marker&#xA;     * @throws SQLException if a database access error occurs or this Connection&#xA;     * object within this &lt;code>CachedRowSet&lt;/code> is in auto-commit mode.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="COMMIT_ON_ACCEPT_CHANGES">
      <initialValue xsi:type="literals:BooleanLiteral" value="true"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Causes the &lt;code>CachedRowSet&lt;/code> object's &lt;code>SyncProvider&lt;/code>&#xA;     * to commit the changes when &lt;code>acceptChanges()&lt;/code> is called. If &#xA;     * set to false, the changes will &lt;b>not&lt;/b> be committed until one of the&#xA;     * &lt;code>CachedRowSet&lt;/code> interface transaction methods is called.&#xA;     *&#xA;     * @see #commit&#xA;     * @see #rollback     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rowSetPopulated">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="event">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../RowSetEvent.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="numRows">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Notifies registered listeners that a RowSet object in the given RowSetEvent&#xA;     * object has populated a number of additional rows. The &lt;code>numRows&lt;/code> parameter&#xA;     * ensures that this event will only be fired every &lt;code>numRow&lt;/code>.&#xA;     * &lt;p>&#xA;     * The source of the event can be retrieved with the method event.getSource.      &#xA;     *&#xA;     * @param event a &lt;code>RowSetEvent&lt;/code> object that contains the &#xA;     *     &lt;code>RowSet&lt;/code> object that is the source of the events&#xA;     * @param numRows when populating, the number of rows interval on which the&#xA;     *     &lt;code>CachedRowSet&lt;/code> populated should fire; the default value&#xA;     *     is zero; cannot be less than &lt;code>fetchSize&lt;/code> or zero     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="populate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/sql/ResultSet.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="startRow">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**   &#xA;     * Populates this &lt;code>CachedRowSet&lt;/code> object with data from&#xA;     * the given &lt;code>ResultSet&lt;/code> object. While related to the &lt;code>populate(ResultSet)&lt;/code>&#xA;     * method, an additional parameter is provided to allow starting position within&#xA;     * the &lt;code>ResultSet&lt;/code> from where to populate the CachedRowSet&#xA;     * instance.&#xA;     * &lt;P>&#xA;     * This method can be used as an alternative to the &lt;code>execute&lt;/code> method when an&#xA;     * application has a connection to an open &lt;code>ResultSet&lt;/code> object.&#xA;     * Using the method &lt;code>populate&lt;/code> can be more efficient than using&#xA;     * the version of the &lt;code>execute&lt;/code> method that takes no parameters&#xA;     * because it does not open a new connection and re-execute this&#xA;     * &lt;code>CachedRowSet&lt;/code> object's command. Using the &lt;code>populate&lt;/code>&#xA;     *  method is more a matter of convenience when compared to using the version &#xA;     * of &lt;code>execute&lt;/code> that takes a &lt;code>ResultSet&lt;/code> object.&#xA;     *&#xA;     * @param startRow the &#xA;     * @param rs the &lt;code>ResultSet&lt;/code> object containing the data&#xA;     * &#x9;&#x9;to be read into this &lt;code>CachedRowSet&lt;/code> object&#xA;     * @throws SQLException if a null &lt;code>ResultSet&lt;/code> object is supplied&#xA;     *&#x9;&#x9;or this &lt;code>CachedRowSet&lt;/code> object cannot&#xA;     *&#x9;&#x9;retrieve the associated &lt;code>ResultSetMetaData&lt;/code> object&#xA;     * @see #execute&#xA;     * @see #populate(ResultSet)&#xA;     * @see java.sql.ResultSet&#xA;     * @see java.sql.ResultSetMetaData&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setPageSize">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="size">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the &lt;code>CachedRowSet&lt;/code> object's page-size. A &lt;code>CachedRowSet&lt;/code>&#xA;     * may be configured to populate itself in page-size sized batches of rows. When&#xA;     * either &lt;code>populate()&lt;/code> or &lt;code>execute()&lt;/code> are called, the&#xA;     * &lt;code>CachedRowSet&lt;/code> fetches an additional page according to the&#xA;     * original SQL query used to populate the RowSet.&#xA;     *&#xA;     * @param size the page-size of the &lt;code>CachedRowSet&lt;/code>&#xA;     * @throws SQLException if an error occurs setting the &lt;code>CachedRowSet&lt;/code> &#xA;     *      page size or if the page size is less than 0.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPageSize">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the page-size for the &lt;code>CachedRowSet&lt;/code> object&#xA;     * &#xA;     * @return an &lt;code>int&lt;/code> page size     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="nextPage">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Increments the current page of the &lt;code>CachedRowSet&lt;/code>. This causes&#xA;     * the &lt;code>CachedRowSet&lt;/code> implementation to fetch the next page-size&#xA;     * rows and populate the RowSet, if remaining rows remain within scope of the&#xA;     * original SQL query used to populated the RowSet.&#xA;     *&#xA;     * @return true if more pages exist; false if this is the last page&#xA;     * @throws SQLException if an error occurs fetching the next page, or if this &#xA;     *     method is called prematurely before populate or execute.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="previousPage">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Decrements the current page of the &lt;code>CachedRowSet&lt;/code>. This causes&#xA;     * the &lt;code>CachedRowSet&lt;/code> implementation to fetch the previous page-size&#xA;     * rows and populate the RowSet. The amount of rows returned in the previous&#xA;     * page must always remain within scope of the original SQL query used to&#xA;     * populate the RowSet.     &#xA;     *&#xA;     * @return true if the previous page is successfully retrieved; false if this&#xA;     *     is the first page.&#xA;     * @throws SQLException if an error occurs fetching the previous page, or if&#xA;     *     this method is called prematurely before populate or execute.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The interface that all standard implementations of &#xA; * &lt;code>CachedRowSet&lt;/code> must implement.  &#xA; * &lt;P>&#xA; * The reference implementation of the &lt;code>CachedRowSet&lt;/code> interface provided&#xA; * by Sun Microsystems is a standard implementation. Developers may use this implementation&#xA; * just as it is, they may extend it, or they may choose to write their own implementations&#xA; * of this interface.  &#xA; * &lt;P>&#xA; * A &lt;code>CachedRowSet&lt;/code> object is a container for rows of data&#xA; * that caches its rows in memory, which makes it possible to operate without always being&#xA; * connected to its data source. Further, it is a &#xA; * JavaBeans&lt;sup>&lt;font size=-2>TM&lt;/font>&lt;/sup> component and is scrollable,&#xA; * updatable, and serializable. A &lt;code>CachedRowSet&lt;/code> object typically&#xA; * contains rows from a result set, but it can also contain rows from any file&#xA; * with a tabular format, such as a spread sheet.  The reference implementation&#xA; * supports getting data only from a &lt;code>ResultSet&lt;/code> object, but &#xA; * developers can extend the &lt;code>SyncProvider&lt;/code> implementations to provide&#xA; * access to other tabular data sources.&#xA; * &lt;P>&#xA; * An application can modify the data in a &lt;code>CachedRowSet&lt;/code> object, and&#xA; * those modifications can then be propagated back to the source of the data.&#xA; * &lt;P>&#xA; * A &lt;code>CachedRowSet&lt;/code> object is a &lt;i>disconnected&lt;/i> rowset, which means&#xA; * that it makes use of a connection to its data source only briefly. It connects to its&#xA; * data source while it is reading data to populate itself with rows and again&#xA; * while it is propagating changes back to its underlying data source. The rest&#xA; * of the time, a &lt;code>CachedRowSet&lt;/code> object is disconnected, including&#xA; * while its data is being modified. Being disconnected makes a &lt;code>RowSet&lt;/code>&#xA; * object much leaner and therefore much easier to pass to another component.  For&#xA; * example, a disconnected &lt;code>RowSet&lt;/code> object can be serialized and passed&#xA; * over the wire to a thin client such as a personal digital assistant (PDA).&#xA; * &lt;P>&#xA; *&#xA; * &lt;h3>1.0 Creating a &lt;code>CachedRowSet&lt;/code> Object&lt;/h3>&#xA; * The following line of code uses the default constructor for &#xA; * &lt;code>CachedRowSet&lt;/code>&#xA; * supplied in the reference implementation (RI) to create a default &#xA; * &lt;code>CachedRowSet&lt;/code> object.&#xA; * &lt;PRE>&#xA; *     CachedRowSetImpl crs = new CachedRowSetImpl();&#xA; * &lt;/PRE>&#xA; * This new &lt;code>CachedRowSet&lt;/code> object will have its properties set to the&#xA; * default properties of a &lt;code>BaseRowSet&lt;/code> object, and, in addition, it will&#xA; * have an &lt;code>RIOptimisticProvider&lt;/code> object as its synchronization provider.&#xA; * &lt;code>RIOptimisticProvider&lt;/code>, one of two &lt;code>SyncProvider&lt;/code>&#xA; * implementations included in the RI, is the default provider that the&#xA; * &lt;code>SyncFactory&lt;/code> singleton will supply when no synchronization&#xA; * provider is specified.&#xA; * &lt;P>&#xA; * A &lt;code>SyncProvider&lt;/code> object provides a &lt;code>CachedRowSet&lt;/code> object &#xA; * with a reader (a &lt;code>RowSetReader&lt;/code> object) for reading data from a &#xA; * data source to populate itself with data. A reader can be implemented to read &#xA; * data from a &lt;code>ResultSet&lt;/code> object or from a file with a tabular format.&#xA; * A &lt;code>SyncProvider&lt;/code> object also provides&#xA; * a writer (a &lt;code>RowSetWriter&lt;/code> object) for synchronizing any&#xA; * modifications to the &lt;code>CachedRowSet&lt;/code> object's data made while it was &#xA; * disconnected with the data in the underlying data source.&#xA; * &lt;P>&#xA; * A writer can be implemented to exercise various degrees of care in checking&#xA; * for conflicts and in avoiding them.&#xA; * (A conflict occurs when a value in the data source has been changed after&#xA; * the rowset populated itself with that value.)&#xA; * The &lt;code>RIOptimisticProvider&lt;/code> implementation assumes there will be&#xA; * few or no conflicts and therefore sets no locks. It updates the data source &#xA; * with values from the &lt;code>CachedRowSet&lt;/code> object only if there are no &#xA; * conflicts.&#xA; * Other writers can be implemented so that they always write modified data to&#xA; * the data source, which can be accomplished either by not checking for conflicts&#xA; * or, on the other end of the spectrum, by setting locks sufficient to prevent data&#xA; * in the data source from being changed. Still other writer implementations can be&#xA; * somewhere in between.&#xA; * &lt;P>&#xA; * A &lt;code>CachedRowSet&lt;/code> object may use any&#xA; * &lt;code>SyncProvider&lt;/code> implementation that has been registered&#xA; * with the &lt;code>SyncFactory&lt;/code> singleton. An application&#xA; * can find out which &lt;code>SyncProvider&lt;/code> implementations have been&#xA; * registered by calling the following line of code.&#xA; * &lt;PRE>&#xA; *      java.util.Enumeration providers = SyncFactory.getRegisteredProviders();&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; * There are two ways for a &lt;code>CachedRowSet&lt;/code> object to specify which &#xA; * &lt;code>SyncProvider&lt;/code> object it will use.&#xA; * &lt;UL)&#xA; *     &lt;LI>Supplying the name of the implementation to the constructor&lt;BR>&#xA; *     The following line of code creates the &lt;code>CachedRowSet&lt;/code>&#xA; *     object &lt;i>crs2&lt;/i> that is initialized with default values except that its &#xA; *     &lt;code>SyncProvider&lt;/code> object is the one specified.&#xA; *     &lt;PRE>&#xA; *          CachedRowSetImpl crs2 = new CachedRowSetImpl(&#xA; *                                 &quot;com.fred.providers.HighAvailabilityProvider&quot;);&#xA; *     &lt;/PRE>&#xA; *     &lt;LI>Setting the &lt;code>SyncProvider&lt;/code> using the &lt;code>CachedRowSet&lt;/code>&#xA; *         method &lt;code>setSyncProvider&lt;/code>&lt;BR>&#xA; *      The following line of code resets the &lt;code>SyncProvider&lt;/code> object&#xA; *      for &lt;i>crs&lt;/i>, the &lt;code>CachedRowSet&lt;/code> object created with the&#xA; *      default constructor. &#xA; *      &lt;PRE>&#xA; *           crs.setSyncProvider(&quot;com.fred.providers.HighAvailabilityProvider&quot;);&#xA; *      &lt;/PRE>&#xA; * &lt;/UL)&#xA; * See the comments for &lt;code>SyncFactory&lt;/code> and &lt;code>SyncProvider&lt;/code> for&#xA; * more details.&#xA; *&#xA; * &lt;P>&#xA; * &lt;h3>2.0 Retrieving Data from a &lt;code>CachedRowSet&lt;/code> Object&lt;/h3>&#xA; * Data is retrieved from a &lt;code>CachedRowSet&lt;/code> object by using the&#xA; * getter methods inherited from the &lt;code>ResultSet&lt;/code>&#xA; * interface.  The following examples, in which &lt;code>crs&lt;/code> is a&#xA; * &lt;code>CachedRowSet&lt;/code>&#xA; * object, demonstrate how to iterate through the rows, retrieving the column&#xA; * values in each row.  The first example uses the version of the&#xA; * getter methods that take a column number; the second example &#xA; * uses the version that takes a column name. Column numbers are generally &#xA; * used when the &lt;code>RowSet&lt;/code> object's command &#xA; * is of the form &lt;code>SELECT * FROM TABLENAME&lt;/code>; column names are most&#xA; * commonly used when the command specifies columns by name.&#xA; * &lt;PRE>&#xA; *    while (crs.next()) {&#xA; *        String name = crs.getString(1);&#xA; *        int id = crs.getInt(2);&#xA; *        Clob comment = crs.getClob(3);&#xA; *        short dept = crs.getShort(4);&#xA; *        System.out.println(name + &quot;  &quot; + id + &quot;  &quot; + comment + &quot;  &quot; + dept);&#xA; *    }&#xA; * &lt;/PRE>&#xA; *&#xA; * &lt;PRE>&#xA; *    while (crs.next()) {&#xA; *        String name = crs.getString(&quot;NAME&quot;);&#xA; *        int id = crs.getInt(&quot;ID&quot;);&#xA; *        Clob comment = crs.getClob(&quot;COM&quot;);&#xA; *        short dept = crs.getShort(&quot;DEPT&quot;);&#xA; *        System.out.println(name + &quot;  &quot; + id + &quot;  &quot; + comment + &quot;  &quot; + dept);&#xA; *    }&#xA; * &lt;/PRE>&#xA; * &lt;h4>2.1 Retrieving &lt;code>RowSetMetaData&lt;/code>&lt;/h4>&#xA; * An application can get information about the columns in a &lt;code>CachedRowSet&lt;/code> &#xA; * object by calling &lt;code>ResultSetMetaData&lt;/code> and &lt;code>RowSetMetaData&lt;/code>&#xA; * methods on a &lt;code>RowSetMetaData&lt;/code> object. The following code fragment, &#xA; * in which &lt;i>crs&lt;/i> is a &lt;code>CachedRowSet&lt;/code> object, illustrates the process.&#xA; * The first line creates a &lt;code>RowSetMetaData&lt;/code> object with information&#xA; * about the columns in &lt;i>crs&lt;/i>.  The method &lt;code>getMetaData&lt;/code>, &#xA; * inherited from the &lt;code>ResultSet&lt;/code> interface, returns a &#xA; * &lt;code>ResultSetMetaData&lt;/code> object, which is cast to a &#xA; * &lt;code>RowSetMetaData&lt;/code> object before being assigned to the variable&#xA; * &lt;i>rsmd&lt;/i>.  The second line finds out how many columns &lt;i>jrs&lt;/i> has, and&#xA; * the third line gets the JDBC type of values stored in the second column of&#xA; * &lt;code>jrs&lt;/code>.&#xA; * &lt;PRE>&#xA; *     RowSetMetaData rsmd = (RowSetMetaData)crs.getMetaData();&#xA; *     int count = rsmd.getColumnCount();&#xA; *     int type = rsmd.getColumnType(2);&#xA; * &lt;/PRE>&#xA; * The &lt;code>RowSetMetaData&lt;/code> interface differs from the &#xA; * &lt;code>ResultSetMetaData&lt;/code> interface in two ways.&#xA; * &lt;UL>&#xA; *   &lt;LI>&lt;i>It includes &lt;code>setter&lt;/code> methods:&lt;/i> A &lt;code>RowSet&lt;/code> &#xA; *   object uses these methods internally when it is populated with data from a&#xA; *   different &lt;code>ResultSet&lt;/code> object.&#xA; *   &lt;P>&#xA; *   &lt;LI>&lt;i>It contains fewer &lt;code>getter&lt;/code> methods:&lt;/i> Some &#xA; *   &lt;code>ResultSetMetaData&lt;/code> methods to not apply to a &lt;code>RowSet&lt;/code>&#xA; *   object. For example, methods retrieving whether a column value is writable&#xA; *   or read only do not apply because all of a &lt;code>RowSet&lt;/code> object's &#xA; *   columns will be writable or read only, depending on whether the rowset is &#xA; *   updatable or not.         &#xA; * &lt;/UL>&#xA; * NOTE: In order to return a &lt;code>RowSetMetaData&lt;/code> object, implementations must &#xA; * override the &lt;code>getMetaData()&lt;/code> method defined in &#xA; * &lt;code>java.sql.ResultSet&lt;/code> and return a &lt;code>RowSetMetaData&lt;/code> object.&#xA; *&#xA; * &lt;h3>3.0 Updating a &lt;code>CachedRowSet&lt;/code> Object&lt;/h3>&#xA; * Updating a &lt;code>CachedRowSet&lt;/code> object is similar to updating a&#xA; * &lt;code>ResultSet&lt;/code> object, but because the rowset is not connected to &#xA; * its data source while it is being updated, it must take an additional step&#xA; * to effect changes in its underlying data source. After calling the method&#xA; * &lt;code>updateRow&lt;/code> or &lt;code>insertRow&lt;/code>, a &#xA; * &lt;code>CachedRowSet&lt;/code>&#xA; * object must also call the method &lt;code>acceptChanges&lt;/code> to have updates&#xA; * written to the data source. The following example, in which the cursor is&#xA; * on a row in the &lt;code>CachedRowSet&lt;/code> object &lt;i>crs&lt;/i>, shows &#xA; * the code required to update two column values in the current row and also &#xA; * update the &lt;code>RowSet&lt;/code> object's underlying data source.&#xA; * &lt;PRE>&#xA; *     crs.updateShort(3, 58);&#xA; *     crs.updateInt(4, 150000);&#xA; *     crs.updateRow();&#xA; *     crs.acceptChanges();&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; * The next example demonstrates moving to the insert row, building a new &#xA; * row on the insert row, inserting it into the rowset, and then calling the &#xA; * method &lt;code>acceptChanges&lt;/code> to add the new row to the underlying data&#xA; * source.  Note that as with the getter methods, the  updater methods may take &#xA; * either a column index or a column name to designate the column being acted upon.&#xA; * &lt;PRE>&#xA; *     crs.moveToInsertRow();&#xA; *     crs.updateString(&quot;Name&quot;, &quot;Shakespeare&quot;);&#xA; *     crs.updateInt(&quot;ID&quot;, 10098347);&#xA; *     crs.updateShort(&quot;Age&quot;, 58);&#xA; *     crs.updateInt(&quot;Sal&quot;, 150000);&#xA; *     crs.insertRow();&#xA; *     crs.moveToCurrentRow();&#xA; *     crs.acceptChanges();&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; * NOTE: Where the &lt;code>insertRow()&lt;/code> method inserts the contents of a &#xA; * &lt;code>CachedRowSet&lt;/code> object's insert row is implementation-defined.&#xA; * The reference implementation for the &lt;code>CachedRowSet&lt;/code> interface&#xA; * inserts a new row immediately following the current row, but it could be&#xA; * implemented to insert new rows in any number of other places.&#xA; * &lt;P>&#xA; * Another thing to note about these examples is how they use the method&#xA; * &lt;code>acceptChanges&lt;/code>.  It is this method that propagates changes in&#xA; * a &lt;code>CachedRowSet&lt;/code> object back to the underlying data source,&#xA; * calling on the &lt;code>RowSet&lt;/code> object's writer internally to write&#xA; * changes to the data source. To do this, the writer has to incur the expense&#xA; * of establishing a connection with that data source. The&#xA; * preceding two code fragments call the method &lt;code>acceptChanges&lt;/code>&#xA; * immediately after calling &lt;code>updateRow&lt;/code> or &lt;code>insertRow&lt;/code>. &#xA; * However, when there are multiple rows being changed, it is more efficient to call &#xA; * &lt;code>acceptChanges&lt;/code> after all calls to &lt;code>updateRow&lt;/code>&#xA; * and &lt;code>insertRow&lt;/code> have been made.  If &lt;code>acceptChanges&lt;/code>&#xA; * is called only once, only one connection needs to be established.&#xA; * &lt;P>&#xA; * &lt;h3>4.0 Updating the Underlying Data Source&lt;/h3>&#xA; * When the method &lt;code>acceptChanges&lt;/code> is executed, the&#xA; * &lt;code>CachedRowSet&lt;/code> object's writer, a &lt;code>RowSetWriterImpl&lt;/code>&#xA; * object, is called behind the scenes to write the changes made to the &#xA; * rowset to the underlying data source. The writer is implemented to make a&#xA; * connection to the data source and write updates to it.&#xA; * &lt;P>&#xA; * A writer is made available through an implementation of the &#xA; * &lt;code>SyncProvider&lt;/code> interface, as discussed in section 1,&#xA; * &quot;Creating a &lt;code>CachedRowSet&lt;/code> Object.&quot;   &#xA; * The default reference implementation provider, &lt;code>RIOptimisticProvider&lt;/code>,&#xA; * has its writer implemented to use an optimistic concurrency control&#xA; * mechanism. That is, it maintains no locks in the underlying database while &#xA; * the rowset is disconnected from the database and simply checks to see if there&#xA; * are any conflicts before writing data to the data source.  If there are any&#xA; * conflicts, it does not write anything to the data source. &#xA; * &lt;P>&#xA; * The reader/writer facility &#xA; * provided by the &lt;code>SyncProvider&lt;/code> class is pluggable, allowing for the&#xA; * customization of data retrieval and updating. If a different concurrency&#xA; * control mechanism is desired, a different implementation of &#xA; * &lt;code>SyncProvider&lt;/code> can be plugged in using the method&#xA; * &lt;code>setSyncProvider&lt;/code>.&#xA; * &lt;P>&#xA; * In order to use the optimistic concurrency control routine, the &#xA; * &lt;code>RIOptismisticProvider&lt;/code> maintains both its current &#xA; * value and its original value (the value it had immediately preceding the&#xA; * current value). Note that if no changes have been made to the data in a&#xA; * &lt;code>RowSet&lt;/code> object, its current values and its original values are the same, &#xA; * both being the values with which the &lt;code>RowSet&lt;/code> object was initially&#xA; * populated.  However, once any values in the &lt;code>RowSet&lt;/code> object have been&#xA; * changed, the current values and the original values will be different, though at&#xA; * this stage, the original values are still the initial values. With any subsequent&#xA; * changes to data in a &lt;code>RowSet&lt;/code> object, its original values and current&#xA; * values will still differ, but its original values will be the values that&#xA; * were previously the current values.&#xA; * &lt;P>&#xA; * Keeping track of original values allows the writer to compare the &lt;code>RowSet&lt;/code>&#xA; * object's original value with the value in the database. If the values in&#xA; * the database differ from the &lt;code>RowSet&lt;/code> object's original values, which means that&#xA; * the values in the database have been changed, there is a conflict. &#xA; * Whether a writer checks for conflicts, what degree of checking it does, and how&#xA; * it handles conflicts all depend on how it is implemented.&#xA; * &lt;P>&#xA; * &lt;h3>5.0 Registering and Notifying Listeners&lt;/h3>&#xA; * Being JavaBeans components, all rowsets participate in the JavaBeans event&#xA; * model, inheriting methods for registering listeners and notifying them of&#xA; * changes from the &lt;code>BaseRowSet&lt;/code> class.  A listener for a&#xA; * &lt;code>CachedRowSet&lt;/code> object is a component that wants to be notified&#xA; * whenever there is a change in the rowset.  For example, if a&#xA; * &lt;code>CachedRowSet&lt;/code> object contains the results of a query and &#xA; * those&#xA; * results are being displayed in, say, a table and a bar graph, the table and&#xA; * bar graph could be registered as listeners with the rowset so that they can&#xA; * update themselves to reflect changes. To become listeners, the table and&#xA; * bar graph classes must implement the &lt;code>RowSetListener&lt;/code> interface.&#xA; * Then they can be added to the &lt;Code>CachedRowSet&lt;/code> object's list of&#xA; * listeners, as is illustrated in the following lines of code.&#xA; * &lt;PRE> &#xA; *    crs.addRowSetListener(table);&#xA; *    crs.addRowSetListener(barGraph);&#xA; * &lt;/PRE>&#xA; * Each &lt;code>CachedRowSet&lt;/code> method that moves the cursor or changes&#xA; * data also notifies registered listeners of the changes, so &#xA; * &lt;code>table&lt;/code> and &lt;code>barGraph&lt;/code> will be notified when there is&#xA; * a change in &lt;code>crs&lt;/code>.&#xA; * &lt;P>&#xA; * &lt;h3>6.0 Passing Data to Thin Clients&lt;/h3>&#xA; * One of the main reasons to use a &lt;code>CachedRowSet&lt;/code> object is to&#xA; * pass data between different components of an application. Because it is&#xA; * serializable, a &lt;code>CachedRowSet&lt;/code> object can be used, for example,&#xA; * to send the result of a query executed by an enterprise JavaBeans component&#xA; * running in a server environment over a network to a client running in a&#xA; * web browser.&#xA; * &lt;P>&#xA; * While a &lt;code>CachedRowSet&lt;/code> object is disconnected, it can be much &#xA; * leaner than a &lt;code>ResultSet&lt;/code> object with the same data.  &#xA; * As a result, it can be especially suitable for sending data to a thin client&#xA; * such as a PDA, where it would be inappropriate to use a JDBC driver&#xA; * due to resource limitations or security considerations.&#xA; * Thus, a &lt;code>CachedRowSet&lt;/code> object provides a means to &quot;get rows in&quot;&#xA; * without the need to implement the full JDBC API.&#xA; * &lt;P>&#xA; * &lt;h3>7.0 Scrolling and Updating&lt;/h3>&#xA; * A second major use for &lt;code>CachedRowSet&lt;/code> objects is to provide&#xA; * scrolling and updating for &lt;code>ResultSet&lt;/code> objects that&#xA; * do not provide these capabilities themselves.  In other words, a&#xA; * &lt;code>CachedRowSet&lt;/code> object can be used to augment the&#xA; * capabilities of a JDBC technology-enabled driver (hereafter called a&#xA; * &quot;JDBC driver&quot;) when the DBMS does not provide full support for scrolling and&#xA; * updating. To achieve the effect of making a non-scrollble and read-only&#xA; * &lt;code>ResultSet&lt;/code> object scrollable and updatable, a programmer&#xA; * simply needs to create a &lt;code>CachedRowSet&lt;/code> object populated&#xA; * with that &lt;code>ResultSet&lt;/code> object's data.  This is demonstrated&#xA; * in the following code fragment, where &lt;code>stmt&lt;/code> is a&#xA; * &lt;code>Statement&lt;/code> object.&#xA; * &lt;PRE>&#xA; *    ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM EMPLOYEES&quot;);&#xA; *    CachedRowSetImpl crs = new CachedRowSetImpl();&#xA; *    crs.populate(rs);&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; * The object &lt;code>crs&lt;/code> now contains the data from the table&#xA; * &lt;code>EMPLOYEES&lt;/code>, just as the object &lt;code>rs&lt;/code> does.&#xA; * The difference is that the cursor for &lt;code>crs&lt;/code> can be moved&#xA; * forward, backward, or to a particular row even if the cursor for&#xA; * &lt;code>rs&lt;/code> can move only forward.  In addition, &lt;code>crs&lt;/code> is&#xA; * updatable even if &lt;code>rs&lt;/code> is not because by default, a&#xA; * &lt;code>CachedRowSet&lt;/code> object is both scrollable and updatable.&#xA; * &lt;P>&#xA; * In summary, a &lt;code>CachedRowSet&lt;/code> object can be thought of as simply&#xA; * a disconnected set of rows that are being cached outside of a data source.&#xA; * Being thin and serializable, it can easily be sent across a wire,&#xA; * and it is well suited to sending data to a thin client. However, a&#xA; * &lt;code>CachedRowSet&lt;/code> object does have a limitation: It is limited in&#xA; * size by the amount of data it can store in memory at one time. &#xA; * &lt;P>&#xA; * &lt;h3>8.0 Getting Universal Data Access&lt;/h3>&#xA; * Another advantage of the &lt;code>CachedRowSet&lt;/code> class is that it makes it&#xA; * possible to retrieve and store data from sources other than a relational &#xA; * database. The reader for a rowset can be implemented to read and populate &#xA; * its rowset with data from any tabular data source, including a spreadsheet &#xA; * or flat file.&#xA; * Because both a &lt;code>CachedRowSet&lt;/code> object and its metadata can be&#xA; * created from scratch, a component that acts as a factory for rowsets&#xA; * can use this capability to create a rowset containing data from&#xA; * non-SQL data sources. Nevertheless, it is expected that most of the time,&#xA; * &lt;code>CachedRowSet&lt;/code> objects will contain data that was fetched&#xA; * from an SQL database using the JDBC API.&#xA; * &lt;P>&#xA; * &lt;h3>9.0 Setting Properties&lt;/h3>&#xA; * All rowsets maintain a set of properties, which will usually be set using&#xA; * a tool.  The number and kinds of properties a rowset has will vary,&#xA; * depending on what the rowset does and how it gets its data.  For example,&#xA; * rowsets that get their data from a &lt;code>ResultSet&lt;/code> object need to&#xA; * set the properties that are required for making a database connection.&#xA; * If a rowset uses the &lt;code>DriverManager&lt;/code> facility to make a &#xA; * connection, it needs to set a property for the JDBC URL that identifies &#xA; * the appropriate driver, and it needs to set the properties that give the &#xA; * user name and password.&#xA; * If, on the other hand, the rowset uses a &lt;code>DataSource&lt;/code> object&#xA; * to make the connection, which is the preferred method, it does not need to&#xA; * set the property for the JDBC URL.  Instead, it needs to set&#xA; * properties for the logical name of the data source, for the user name,&#xA; * and for the password.&#xA; * &lt;P>&#xA; * NOTE:  In order to use a &lt;code>DataSource&lt;/code> object for making a&#xA; * connection, the &lt;code>DataSource&lt;/code> object must have been registered&#xA; * with a naming service that uses the Java Naming and Directory&#xA; * Interface&lt;sup>&lt;font size=-2>TM&lt;/font>&lt;/sup> (JNDI) API.  This registration&#xA; * is usually done by a person acting in the capacity of a system&#xA; * administrator.&#xA; * &lt;P>&#xA; * In order to be able to populate itself with data from a database, a rowset&#xA; * needs to set a command property.  This property is a query that is a&#xA; * &lt;code>PreparedStatement&lt;/code> object, which allows the query to have&#xA; * parameter placeholders that are set at run time, as opposed to design time.&#xA; * To set these placeholder parameters with values, a rowset provides&#xA; * setter methods for setting values of each data type,&#xA; * similar to the setter methods provided by the &lt;code>PreparedStatement&lt;/code>&#xA; * interface. &#xA; * &lt;P>&#xA; * The following code fragment illustrates how the &lt;code>CachedRowSet&lt;/code>&#xA; * object &lt;code>crs&lt;/code> might have its command property set.  Note that if a&#xA; * tool is used to set properties, this is the code that the tool would use.&#xA; * &lt;PRE>&#xA; *    crs.setCommand(&quot;SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS &quot; +&#xA; *                   &quot;WHERE CREDIT_LIMIT > ? AND REGION = ?&quot;);&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; * The values that will be used to set the command's placeholder parameters are&#xA; * contained in the &lt;code>RowSet&lt;/code> object's &lt;code>params&lt;/code> field, which is a &#xA; * &lt;code>Vector&lt;/code> object.&#xA; * The &lt;code>CachedRowSet&lt;/code> class provides a set of setter&#xA; * methods for setting the elements in its &lt;code>params&lt;/code> field.  The &#xA; * following code fragment demonstrates setting the two parameters in the &#xA; * query from the previous example.&#xA; * &lt;PRE>&#xA; *    crs.setInt(1, 5000);&#xA; *    crs.setString(2, &quot;West&quot;);&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; * The &lt;code>params&lt;/code> field now contains two elements, each of which is &#xA; * an array two elements long.  The first element is the parameter number; &#xA; * the second is the value to be set.&#xA; * In this case, the first element of &lt;code>params&lt;/code> is&#xA; * &lt;code>1&lt;/code>, &lt;code>5000&lt;/code>, and the second element is &lt;code>2&lt;/code>,&#xA; * &lt;code>&quot;West&quot;&lt;/code>.  When an application calls the method &#xA; * &lt;code>execute&lt;/code>, it will in turn call on this &lt;code>RowSet&lt;/code> object's reader,&#xA; * which will in turn invoke its &lt;code>readData&lt;/code> method. As part of &#xA; * its implementation, &lt;code>readData&lt;/code> will get the values in &#xA; * &lt;code>params&lt;/code> and use them to set the command's placeholder&#xA; * parameters.&#xA; * The following code fragment gives an idea of how the reader&#xA; * does this, after obtaining the &lt;code>Connection&lt;/code> object &#xA; * &lt;code>con&lt;/code>.&#xA; * &lt;PRE>&#xA; *    PreparedStatement pstmt = con.prepareStatement(crs.getCommand());&#xA; *    reader.decodeParams();&#xA; *    // decodeParams figures out which setter methods to use and does something&#xA; *    // like the following:&#xA; *    //    for (i = 0; i &lt; params.length; i++) {&#xA; *    //        pstmt.setObject(i + 1, params[i]);&#xA; *    //    }&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; * At this point, the command for &lt;code>crs&lt;/code> is the query &lt;code>&quot;SELECT&#xA; * FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS WHERE CREDIT_LIMIT > 5000&#xA; * AND REGION = &quot;West&quot;&lt;/code>.  After the &lt;code>readData&lt;/code> method executes&#xA; * this command with the following line of code, it will have the data from&#xA; * &lt;code>rs&lt;/code> with which to populate &lt;code>crs&lt;/code>.&#xA; * &lt;PRE>&#xA; *     ResultSet rs = pstmt.executeQuery();&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; * The preceding code fragments give an idea of what goes on behind the&#xA; * scenes; they would not appear in an application, which would not invoke&#xA; * methods like &lt;code>readData&lt;/code> and &lt;code>decodeParams&lt;/code>.&#xA; * In contrast, the following code fragment shows what an application might do.&#xA; * It sets the rowset's command, sets the command's parameters, and executes&#xA; * the command. Simply by calling the &lt;code>execute&lt;/code> method, &#xA; * &lt;code>crs&lt;/code> populates itself with the requested data from the &#xA; * table &lt;code>CUSTOMERS&lt;/code>.&#xA; * &lt;PRE>&#xA; *    crs.setCommand(&quot;SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS&quot; +&#xA; *                   &quot;WHERE CREDIT_LIMIT > ? AND REGION = ?&quot;);&#xA; *    crs.setInt(1, 5000);&#xA; *    crs.setString(2, &quot;West&quot;);&#xA; *    crs.execute();&#xA; * &lt;/PRE>&#xA; *&#xA; * &lt;h3>10.0 Paging Data&lt;/h3>&#xA; * Because a &lt;code>CachedRowSet&lt;/code> object stores data in memory,&#xA; * the amount of data that it can contain at any one&#xA; * time is determined by the amount of memory available. To get around this limitation,&#xA; * a &lt;code>CachedRowSet&lt;/code> object can retrieve data from a &lt;code>ResultSet&lt;/code>&#xA; * object in chunks of data, called &lt;i>pages&lt;/i>. To take advantage of this mechanism,&#xA; * an application sets the number of rows to be included in a page using the method&#xA; * &lt;code>setPageSize&lt;/code>. In other words, if the page size is set to five, a chunk&#xA; * of five rows of&#xA; * data will be fetched from the data source at one time. An application can also &#xA; * optionally set the maximum number of rows that may be fetched at one time.  If the&#xA; * maximum number of rows is set to zero, or no maximum number of rows is set, there is&#xA; * no limit to the number of rows that may be fetched at a time.&#xA; * &lt;P>&#xA; * After properties have been set,&#xA; * the &lt;code>CachedRowSet&lt;/code> object must be populated with data&#xA; * using either the method &lt;code>populate&lt;/code> or the method &lt;code>execute&lt;/code>.&#xA; * The following lines of code demonstrate using the method &lt;code>populate&lt;/code>.&#xA; * Note that this version of the method takes two parameters, a &lt;code>ResultSet&lt;/code>&#xA; * handle and the row in the &lt;code>ResultSet&lt;/code> object from which to start&#xA; * retrieving rows.&#xA; * &lt;PRE>&#xA; *     CachedRowSet crs = new CachedRowSetImpl();&#xA; *     crs.setMaxRows(20);&#xA; *     crs.setPageSize(4);&#xA; *     crs.populate(rsHandle, 10);&#xA; * &lt;/PRE>&#xA; * When this code runs, &lt;i>crs&lt;/i> will be populated with four rows from &#xA; * &lt;i>rsHandle&lt;/i> starting with the tenth row.&#xA; * &lt;P>&#xA; * The next code fragment shows populating a &lt;code>CachedRowSet&lt;/code> object using the&#xA; * method &lt;code>execute&lt;/code>, which may or may not take a &lt;code>Connection&lt;/code>&#xA; * object as a parameter.  This code passes &lt;code>execute&lt;/code> the &lt;code>Connection&lt;/code>&#xA; * object &lt;i>conHandle&lt;/i>. &#xA; * &lt;P>&#xA; * Note that there are two differences between the following code&#xA; * fragment and the previous one. First, the method &lt;code>setMaxRows&lt;/code> is not&#xA; * called, so there is no limit set for the number of rows that &lt;i>crs&lt;/i> may contain.&#xA; * (Remember that &lt;i>crs&lt;/i> always has the overriding limit of how much data it can&#xA; * store in memory.) The second difference is that the you cannot pass the method &#xA; * &lt;code>execute&lt;/code> the number of the row in the &lt;code>ResultSet&lt;/code> object&#xA; * from which to start retrieving rows. This method always starts with the first row.&#xA; * &lt;PRE>&#xA; *     CachedRowSet crs = new CachedRowSetImpl();&#xA; *     crs.setPageSize(5);&#xA; *     crs.execute(conHandle);&#xA; * &lt;/PRE>&#xA; * After this code has run, &lt;i>crs&lt;/i> will contain five rows of data from the&#xA; * &lt;code>ResultSet&lt;/code> object produced by the command for &lt;i>crs&lt;/i>. The writer&#xA; * for &lt;i>crs&lt;/i> will use &lt;i>conHandle&lt;/i> to connect to the data source and&#xA; * execute the command for &lt;i>crs&lt;/i>. An application is then able to operate on the&#xA; * data in &lt;i>crs&lt;/i> in the same way that it would operate on data in any other&#xA; * &lt;code>CachedRowSet&lt;/code> object.&#xA; * &lt;P>&#xA; * To access the next page (chunk of data), an application calls the method &#xA; * &lt;code>nextPage&lt;/code>.  This method creates a new &lt;code>CachedRowSet&lt;/code> object&#xA; * and fills it with the next page of data.  For example, assume that the&#xA; * &lt;code>CachedRowSet&lt;/code> object's command returns a &lt;code>ResultSet&lt;/code> object&#xA; * &lt;i>rs&lt;/i> with 1000 rows of data.  If the page size has been set to 100, the first&#xA; *  call to the method &lt;code>nextPage&lt;/code> will create a &lt;code>CachedRowSet&lt;/code> object &#xA; * containing the first 100 rows of &lt;i>rs&lt;/i>. After doing what it needs to do with the&#xA; * data in these first 100 rows, the application can again call the method&#xA; * &lt;code>nextPage&lt;/code> to create another &lt;code>CachedRowSet&lt;/code> object&#xA; * with the second 100 rows from &lt;i>rs&lt;/i>. The data from the first &lt;code>CachedRowSet&lt;/code>&#xA; * object will no longer be in memory because it is replaced with the data from the&#xA; * second &lt;code>CachedRowSet&lt;/code> object. After the tenth call to the method &lt;code>nextPage&lt;/code>,&#xA; * the tenth &lt;code>CachedRowSet&lt;/code> object will contain the last 100 rows of data from&#xA; * &lt;i>rs&lt;/i>, which are stored in memory. At any given time, the data from only one &#xA; * &lt;code>CachedRowSet&lt;/code> object is stored in memory.&#xA; * &lt;P>&#xA; * The method &lt;code>nextPage&lt;/code> returns &lt;code>true&lt;/code> as long as the current&#xA; * page is not the last page of rows and &lt;code>false&lt;/code> when there are no more pages.&#xA; * It can therefore be used in a &lt;code>while&lt;/code> loop to retrieve all of the pages,&#xA; * as is demonstrated in the following lines of code.&#xA; * &lt;PRE>&#xA; *     CachedRowSet crs = CachedRowSetImpl();&#xA; *     crs.setPageSize(100);&#xA; *     crs.execute(conHandle);&#xA; *&#xA; *     while(crs.next() {&#xA; *     . . . // operate on first chunk of 100 rows in crs, row by row&#xA; *     }&#xA; *&#xA; *     while(crs.nextPage()) {&#xA; *         while(crs.next()) {&#xA; *             . . . // operate on the subsequent chunks (of 100 rows each) in crs, &#xA; *                   // row by row&#xA; *         }&#xA; *     }&#xA; * &lt;/PRE>&#xA; * After this code fragment has been run, the application will have traversed all&#xA; * 1000 rows, but it will have had no more than 100 rows in memory at a time.&#xA; * &lt;P>&#xA; * The &lt;code>CachedRowSet&lt;/code> interface also defines the method &lt;code>previousPage&lt;/code>.&#xA; * Just as the method &lt;code>nextPage&lt;/code> is analogous to the &lt;code>ResultSet&lt;/code> &#xA; * method &lt;code>next&lt;/code>, the method &lt;code>previousPage&lt;/code> is analogous to &#xA; * the &lt;code>ResultSet&lt;/code> method &lt;code>previous&lt;/code>.  Similar to the method&#xA; * &lt;code>nextPage&lt;/code>, &lt;code>previousPage&lt;/code> creates a &lt;code>CachedRowSet&lt;/code>&#xA; * object containing the number of rows set as the page size.  So, for instance, the&#xA; * method &lt;code>previousPage&lt;/code> could be used in a &lt;code>while&lt;/code> loop at&#xA; * the end of the preceding code fragment to navigate back through the pages from the last&#xA; * page to the first page.&#xA; * The method &lt;code>previousPage&lt;/code> is also similar to &lt;code>nextPage&lt;/code>&#xA; * in that it can be used in a &lt;code>while&lt;/code>&#xA; * loop, except that it returns &lt;code>true&lt;/code> as long as there is another page&#xA; * preceding it and &lt;code>false&lt;/code> when there are no more pages ahead of it.&#xA; * &lt;P>&#xA; * By positioning the cursor after the last row for each page,&#xA; * as is done in the following code fragment, the method &lt;code>previous&lt;/code> &#xA; * navigates from the last row to the first row in each page.&#xA; * The code could also have left the cursor before the first row on each page and then&#xA; * used the method &lt;code>next&lt;/code> in a &lt;code>while&lt;/code> loop to navigate each page&#xA; * from the first row to the last row.&#xA; * &lt;P>&#xA; * The following code fragment assumes a continuation from the previous code fragment,&#xA; * meaning that the cursor for the tenth &lt;code>CachedRowSet&lt;/code> object is on the&#xA; * last row.  The code moves the cursor to after the last row so that the first &#xA; * call to the method &lt;code>previous&lt;/code> will put the cursor back on the last row.&#xA; * After going through all of the rows in the last page (the &lt;code>CachedRowSet&lt;/code>&#xA; * object &lt;i>crs&lt;/i>), the code then enters&#xA; * the &lt;code>while&lt;/code> loop to get to the ninth page, go through the rows backwards,&#xA; * go to the eighth page, go through the rows backwards, and so on to the first row &#xA; * of the first page.&#xA; * &#xA; * &lt;PRE>&#xA; *     crs.afterLast();&#xA; *     while(crs.previous())  {&#xA; *         . . . // navigate through the rows, last to first&#xA; *     {&#xA; *     while(crs.previousPage())  {&#xA; *         crs.afterLast();&#xA; *         while(crs.previous())  {&#xA; *             . . . // go from the last row to the first row of each page&#xA; *         }&#xA; *     }&#xA; * &lt;/PRE>&#xA; * &#xA; * @author Jonathan Bruce&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../RowSet.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Joinable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
