<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="JoinRowSet.java">
  <comments>/*&#xA; * @(#)JoinRowSet.java&#x9;1.7 04/05/29&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>sql</namespaces>
  <namespaces>rowset</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>sql</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>javax</namespaces>
    <namespaces>sql</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>javax</namespaces>
    <namespaces>naming</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>math</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>javax</namespaces>
    <namespaces>sql</namespaces>
    <namespaces>rowset</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="JoinRowSet">
    <members xsi:type="members:InterfaceMethod" name="addRowSet">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rowset">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Joinable.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds the given &lt;code>RowSet&lt;/code> object to this &lt;code>JoinRowSet&lt;/code>&#xA;     * object. If the &lt;code>RowSet&lt;/code> object&#xA;     * is the first to be added to this &lt;code>JoinRowSet&lt;/code>&#xA;     * object, it forms the basis of the &lt;code>JOIN&lt;/code> relationship to be &#xA;     * established.&#xA;     * &lt;P>&#xA;     * This method should be used only when the given &lt;code>RowSet&lt;/code>&#xA;     * object already has a match column that was set with the &lt;code>Joinable&lt;/code>&#xA;     * method &lt;code>setMatchColumn&lt;/code>.&#xA;     * &lt;p>&#xA;     * Note: A &lt;code>Joinable&lt;/code> object is any &lt;code>RowSet&lt;/code> object&#xA;     * that has implemented the &lt;code>Joinable&lt;/code> interface. &#xA;     *&#xA;     * @param rowset the &lt;code>RowSet&lt;/code> object that is to be added to this&#xA;     *        &lt;code>JoinRowSet&lt;/code> object; it must implement the &#xA;     *        &lt;code>Joinable&lt;/code> interface and have a match column set&#xA;     * @throws SQLException if (1) an empty rowset is added to the to this&#xA;     *         &lt;code>JoinRowSet&lt;/code> object, (2) a match column has not been&#xA;     *         set for &lt;i>rowset&lt;/i>, or (3) &lt;i>rowset&lt;/i>&#xA;     *         violates the active &lt;code>JOIN&lt;/code>&#xA;     * @see Joinable#setMatchColumn&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addRowSet">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rowset">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../RowSet.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="columnIdx">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds the given &lt;code>RowSet&lt;/code> object to this &lt;code>JoinRowSet&lt;/code>&#xA;     * object and sets the designated column as the match column for&#xA;     * the &lt;code>RowSet&lt;/code> object. If the &lt;code>RowSet&lt;/code> object&#xA;     * is the first to be added to this &lt;code>JoinRowSet&lt;/code>&#xA;     * object, it forms the basis of the &lt;code>JOIN&lt;/code> relationship to be &#xA;     * established.&#xA;     * &lt;P>&#xA;     * This method should be used when &lt;i>RowSet&lt;/i> does not already have a match&#xA;     * column set.&#xA;     *&#xA;     * @param rowset the &lt;code>RowSet&lt;/code> object that is to be added to this&#xA;     *        &lt;code>JoinRowSet&lt;/code> object; it may implement the &#xA;     *        &lt;code>Joinable&lt;/code> interface &#xA;     * @param columnIdx an &lt;code>int&lt;/code> that identifies the column to become the&#xA;     *         match column&#xA;     * @throws SQLException if (1) &lt;i>rowset&lt;/i> is an empty rowset or&#xA;     *         (2) &lt;i>rowset&lt;/i> violates the active &lt;code>JOIN&lt;/code>&#xA;     * @see Joinable#unsetMatchColumn&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addRowSet">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rowset">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../RowSet.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="columnName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds &lt;i>rowset&lt;/i> to this &lt;code>JoinRowSet&lt;/code> object and&#xA;     * sets the designated column as the match column. If &lt;i>rowset&lt;/i>&#xA;     * is the first to be added to this &lt;code>JoinRowSet&lt;/code>&#xA;     * object, it forms the basis for the &lt;code>JOIN&lt;/code> relationship to be &#xA;     * established. &#xA;     * &lt;P>&#xA;     * This method should be used when the given &lt;code>RowSet&lt;/code> object&#xA;     * does not already have a match column.     &#xA;     * &#xA;     * @param rowset the &lt;code>RowSet&lt;/code> object that is to be added to this&#xA;     *        &lt;code>JoinRowSet&lt;/code> object; it may implement the &#xA;     *        &lt;code>Joinable&lt;/code> interface &#xA;     * @param columnName the &lt;code>String&lt;/code> object giving the name of the &#xA;     *        column to be set as the match column&#xA;     * @throws SQLException if (1) &lt;i>rowset&lt;/i> is an empty rowset or&#xA;     *         (2) the match column for &lt;i>rowset&lt;/i> does not satisfy the&#xA;     *         conditions of the &lt;code>JOIN&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addRowSet">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rowset">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../RowSet.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="columnIdx">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds one or more &lt;code>RowSet&lt;/code> objects contained in the given &#xA;     * array of &lt;code>RowSet&lt;/code> objects to this &lt;code>JoinRowSet&lt;/code> &#xA;     * object and sets the match column for&#xA;     * each of the &lt;code>RowSet&lt;/code> objects to the match columns &#xA;     * in the given array of column indexes. The first element in &#xA;     * &lt;i>columnIdx&lt;/i> is set as the match column for the first&#xA;     * &lt;code>RowSet&lt;/code> object in &lt;i>rowset&lt;/i>, the second element of&#xA;     * &lt;i>columnIdx&lt;/i> is set as the match column for the second element&#xA;     * in &lt;i>rowset&lt;/i>, and so on.&#xA;     * &lt;P>&#xA;     * The first &lt;code>RowSet&lt;/code> object added to this &lt;code>JoinRowSet&lt;/code>&#xA;     * object forms the basis for the &lt;code>JOIN&lt;/code> relationship.&#xA;     * &lt;P>&#xA;     * This method should be used when the given &lt;code>RowSet&lt;/code> object&#xA;     * does not already have a match column.&#xA;     *&#xA;     * @param rowset an array of one or more &lt;code>RowSet&lt;/code> objects &#xA;     *        to be added to the &lt;code>JOIN&lt;/code>; it may implement the &#xA;     *        &lt;code>Joinable&lt;/code> interface  &#xA;     * @param columnIdx an array of &lt;code>int&lt;/code> values indicating the index(es)&#xA;     *        of the columns to be set as the match columns for the &lt;code>RowSet&lt;/code>&#xA;     *        objects in &lt;i>rowset&lt;/i>&#xA;     * @throws SQLException if (1) an empty rowset is added to this &#xA;     *         &lt;code>JoinRowSet&lt;/code> object, (2) a match column is not set&#xA;     *         for a &lt;code>RowSet&lt;/code> object in &lt;i>rowset&lt;/i>, or (3) &#xA;     *         a &lt;code>RowSet&lt;/code> object being added violates the active&#xA;     *         &lt;code>JOIN&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addRowSet">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rowset">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../RowSet.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="columnName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds one or more &lt;code>RowSet&lt;/code> objects contained in the given &#xA;     * array of &lt;code>RowSet&lt;/code> objects to this &lt;code>JoinRowSet&lt;/code> &#xA;     * object and sets the match column for&#xA;     * each of the &lt;code>RowSet&lt;/code> objects to the match columns &#xA;     * in the given array of column names. The first element in &#xA;     * &lt;i>columnName&lt;/i> is set as the match column for the first&#xA;     * &lt;code>RowSet&lt;/code> object in &lt;i>rowset&lt;/i>, the second element of&#xA;     * &lt;i>columnName&lt;/i> is set as the match column for the second element&#xA;     * in &lt;i>rowset&lt;/i>, and so on.&#xA;     * &lt;P>&#xA;     * The first &lt;code>RowSet&lt;/code> object added to this &lt;code>JoinRowSet&lt;/code>&#xA;     * object forms the basis for the &lt;code>JOIN&lt;/code> relationship.&#xA;     * &lt;P>&#xA;     * This method should be used when the given &lt;code>RowSet&lt;/code> object(s)&#xA;     * does not already have a match column.&#xA;     *&#xA;     * @param rowset an array of one or more &lt;code>RowSet&lt;/code> objects &#xA;     *        to be added to the &lt;code>JOIN&lt;/code>; it may implement the &#xA;     *        &lt;code>Joinable&lt;/code> interface &#xA;     * @param columnName an array of &lt;code>String&lt;/code> values indicating the &#xA;     *        names of the columns to be set as the match columns for the &#xA;     *        &lt;code>RowSet&lt;/code> objects in &lt;i>rowset&lt;/i>&#xA;     * @throws SQLException if (1) an empty rowset is added to this &#xA;     *         &lt;code>JoinRowSet&lt;/code> object, (2) a match column is not set&#xA;     *         for a &lt;code>RowSet&lt;/code> object in &lt;i>rowset&lt;/i>, or (3) &#xA;     *         a &lt;code>RowSet&lt;/code> object being added violates the active&#xA;     *         &lt;code>JOIN&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getRowSets">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:UnknownTypeArgument"/>
          <target xsi:type="classifiers:Interface" href="../../../java/util/Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>Collection&lt;/code> object containing the &#xA;     * &lt;code>RowSet&lt;/code> objects that have been added to this&#xA;     * &lt;code>JoinRowSet&lt;/code> object.&#xA;     * This should return the 'n' number of RowSet contained&#xA;     * within the &lt;code>JOIN&lt;/code> and maintain any updates that have occured while in&#xA;     * this union.&#xA;     * &#xA;     * @return a &lt;code>Collection&lt;/code> object consisting of the &#xA;     *        &lt;code>RowSet&lt;/code> objects added to this &lt;code>JoinRowSet&lt;/code>&#xA;     *        object&#xA;     * @throws SQLException if an error occurs generating the &#xA;     *         &lt;code>Collection&lt;/code> object to be returned&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getRowSetNames">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <exceptions>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>String&lt;/code> array containing the names of the&#xA;     *         &lt;code>RowSet&lt;/code> objects added to this &lt;code>JoinRowSet&lt;/code>&#xA;     *         object.&#xA;     *&#xA;     * @return a &lt;code>String&lt;/code> array of the names of the&#xA;     *         &lt;code>RowSet&lt;/code> objects in this &lt;code>JoinRowSet&lt;/code>&#xA;     *         object&#xA;     * @throws SQLException if an error occurs retrieving the names of&#xA;     *         the &lt;code>RowSet&lt;/code> objects&#xA;     * @see CachedRowSet#setTableName&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toCachedRowSet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="CachedRowSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new &lt;code>CachedRowSet&lt;/code> object containing the &#xA;     * data in this &lt;code>JoinRowSet&lt;/code> object, which can be saved&#xA;     * to a data source using the &lt;code>SyncProvider&lt;/code> object for&#xA;     * the &lt;code>CachedRowSet&lt;/code> object.&#xA;     * &lt;P>&#xA;     * If any updates or modifications have been applied to the JoinRowSet&#xA;     * the CachedRowSet returned by the method will not be able to persist&#xA;     * it's changes back to the originating rows and tables in the &#xA;     * in the datasource. The CachedRowSet instance returned should not&#xA;     * contain modification data and it should clear all properties of&#xA;     * it's originating SQL statement. An application should reset the&#xA;     * SQL statement using the &lt;code>RowSet.setCommand&lt;/code> method.&#xA;     * &lt;p>&#xA;     * In order to allow changes to be persisted back to the datasource&#xA;     * to the originating tables, the &lt;code>acceptChanges&lt;/code> method&#xA;     * should be used and called on a JoinRowSet object instance. Implementations&#xA;     * can leverage the internal data and update tracking in their &#xA;     * implementations to interact with the SyncProvider to persist any&#xA;     * changes. &#xA;     *&#xA;     * @return a CachedRowSet containing the contents of the JoinRowSet&#xA;     * @throws SQLException if an error occurs assembling the CachedRowSet&#xA;     * object &#xA;     * @see javax.sql.RowSet&#xA;     * @see javax.sql.rowset.CachedRowSet&#xA;     * @see javax.sql.rowset.spi.SyncProvider&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsCrossJoin">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Indicates if CROSS_JOIN is supported by a JoinRowSet &#xA;     * implementation&#xA;     *&#xA;     * @return true if the CROSS_JOIN is supported; false otherwise&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsInnerJoin">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Indicates if INNER_JOIN is supported by a JoinRowSet &#xA;     * implementation&#xA;     *&#xA;     * @return true is the INNER_JOIN is supported; false otherwise&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsLeftOuterJoin">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Indicates if LEFT_OUTER_JOIN is supported by a JoinRowSet &#xA;     * implementation&#xA;     *&#xA;     * @return true is the LEFT_OUTER_JOIN is supported; false otherwise&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsRightOuterJoin">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Indicates if RIGHT_OUTER_JOIN is supported by a JoinRowSet &#xA;     * implementation&#xA;     *&#xA;     * @return true is the RIGHT_OUTER_JOIN is supported; false otherwise&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsFullJoin">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Indicates if FULL_JOIN is supported by a JoinRowSet &#xA;     * implementation&#xA;     *&#xA;     * @return true is the FULL_JOIN is supported; false otherwise&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setJoinType">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="joinType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allow the application to adjust the type of &lt;code>JOIN&lt;/code> imposed&#xA;     * on tables contained within the JoinRowSet object instance.&#xA;     * Implementations should throw a SQLException if they do &#xA;     * not support a given &lt;code>JOIN&lt;/code> type.&#xA;     *&#xA;     * @param joinType the standard JoinRowSet.XXX static field definition&#xA;     * of a SQL &lt;code>JOIN&lt;/code> to re-configure a JoinRowSet instance on&#xA;     * the fly.&#xA;     * @throws SQLException if an unsupported &lt;code>JOIN&lt;/code> type is set&#xA;     * @see #getJoinType&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getWhereClause">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return a SQL-like description of the WHERE clause being used&#xA;     * in a JoinRowSet object. An implementation can describe&#xA;     * the WHERE clause of the SQL &lt;code>JOIN&lt;/code> by supplying a SQL&#xA;     * strings description of &lt;code>JOIN&lt;/code> or provide a textual&#xA;     * description to assist applications using a &lt;code>JoinRowSet&lt;/code>&#xA;     *&#xA;     * @return whereClause a textual or SQL description of the logical&#xA;     * WHERE clause used in the JoinRowSet instance&#xA;     * @throws SQLException if an error occurs in generating a representation&#xA;     * of the WHERE clause.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getJoinType">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>int&lt;/code> describing the set SQL &lt;code>JOIN&lt;/code> type &#xA;     * governing this JoinRowSet instance. The returned type will be one of&#xA;     * standard JoinRowSet types: &lt;code>CROSS_JOIN&lt;/code>, &lt;code>INNER_JOIN&lt;/code>, &#xA;     * &lt;code>LEFT_OUTER_JOIN&lt;/code>, &lt;code>RIGHT_OUTER_JOIN&lt;/code> or &#xA;     * &lt;code>FULL_JOIN&lt;/code>.&#xA;     *&#xA;     * @return joinType one of the standard JoinRowSet static field &#xA;     *     definitions of a SQL &lt;code>JOIN&lt;/code>. &lt;code>JoinRowSet.INNER_JOIN&lt;/code>&#xA;     *     is returned as the default &lt;code>JOIN&lt;/code> type is no type has been&#xA;     *     explicitly set.&#xA;     * @throws SQLException if an error occurs determining the SQL &lt;code>JOIN&lt;/code>&#xA;     *     type supported by the JoinRowSet instance.&#xA;     * @see #setJoinType&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="CROSS_JOIN">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An ANSI-style &lt;code>JOIN&lt;/code> providing a cross product of two tables&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="INNER_JOIN">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An ANSI-style &lt;code>JOIN&lt;/code> providing a inner join between two tables. Any&#xA;     * unmatched rows in either table of the join should be discarded.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="LEFT_OUTER_JOIN">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An ANSI-style &lt;code>JOIN&lt;/code> providing a left outer join between two&#xA;     * tables. In SQL, this is described where all records should be &#xA;     * returned from the left side of the JOIN statement.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="RIGHT_OUTER_JOIN">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An ANSI-style &lt;code>JOIN&lt;/code> providing a right outer join between&#xA;     * two tables. In SQL, this is described where all records from the&#xA;     * table on the right side of the JOIN statement even if the table &#xA;     * on the left has no matching record.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="FULL_JOIN">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An ANSI-style &lt;code>JOIN&lt;/code> providing a a full JOIN. Specifies that all &#xA;     * rows from either table be returned regardless of matching&#xA;     * records on the other table.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>JoinRowSet&lt;/code> interface provides a mechanism for combining related&#xA; * data from different &lt;code>RowSet&lt;/code> objects into one &lt;code>JoinRowSet&lt;/code>&#xA; * object, which represents an SQL &lt;code>JOIN&lt;/code>.&#xA; * In other words, a &lt;code>JoinRowSet&lt;/code> object acts as a&#xA; * container for the data from &lt;code>RowSet&lt;/code> objects that form an SQL&#xA; * &lt;code>JOIN&lt;/code> relationship.&#xA; * &lt;P>&#xA; * The &lt;code>Joinable&lt;/code> interface provides the methods for setting,&#xA; * retrieving, and unsetting a match column, the basis for &#xA; * establishing an SQL &lt;code>JOIN&lt;/code> relationship. The match column may&#xA; * alternatively be set by supplying it to the appropriate version of the&#xA; * &lt;code>JointRowSet&lt;/code> method &lt;code>addRowSet&lt;/code>.&#xA; * &lt;P>&#xA; * &lt;p>&#xA; * &lt;h3>1.0 Overview&lt;/h3>&#xA; * Disconnected &lt;code>RowSet&lt;/code> objects (&lt;code>CachedRowSet&lt;/code> objects&#xA; * and implementations extending the &lt;code>CachedRowSet&lt;/code> interface)&#xA; * do not have a standard way to establish an SQL &lt;code>JOIN&lt;/code> between &#xA; * &lt;code>RowSet&lt;/code> objects without the expensive operation of &#xA; * reconnecting to the data source. The &lt;code>JoinRowSet&lt;/code> &#xA; * interface is specifically designed to address this need. &#xA; * &lt;P>&#xA; * Any &lt;code>RowSet&lt;/code> object &#xA; * can be added to a &lt;code>JoinRowSet&lt;/code> object to become&#xA; * part of an SQL &lt;code>JOIN&lt;/code> relationship. This means that both connected&#xA; * and disconnected &lt;code>RowSet&lt;/code> objects can be part of a &lt;code>JOIN&lt;/code>.&#xA; * &lt;code>RowSet&lt;/code> objects operating in a connected environment &#xA; * (&lt;code>JdbcRowSet&lt;/code> objects) are&#xA; * encouraged to use the database to which they are already &#xA; * connected to establish SQL &lt;code>JOIN&lt;/code> relationships between&#xA; * tables directly. However, it is possible for a&#xA; * &lt;code>JdbcRowSet&lt;/code> object to be added to a &lt;code>JoinRowSet&lt;/code> object &#xA; * if necessary.  &#xA; * &lt;P>&#xA; * Any number of &lt;code>RowSet&lt;/code> objects can be added to an&#xA; * instance of &lt;code>JoinRowSet&lt;/code> provided that they&#xA; * can be related in an SQL &lt;code>JOIN&lt;/code>.&#xA; * By definition, the SQL &lt;code>JOIN&lt;/code> statement is used to&#xA; * combine the data contained in two or more relational database tables based&#xA; * upon a common attribute. The &lt;code>Joinable&lt;/code> interface provides the methods&#xA; * for establishing a common attribute, which is done by setting a&#xA; * &lt;i>match column&lt;/i>. The match column commonly coincides with&#xA; * the primary key, but there is&#xA; * no requirement that the match column be the same as the primary key.&#xA; * By establishing and then enforcing column matches,&#xA; * a &lt;code>JoinRowSet&lt;/code> object establishes &lt;code>JOIN&lt;/code> relationships &#xA; * between &lt;code>RowSet&lt;/code> objects without the assistance of an available&#xA; * relational database.&#xA; * &lt;P>&#xA; * The type of &lt;code>JOIN&lt;/code> to be established is determined by setting&#xA; * one of the &lt;code>JoinRowSet&lt;/code> constants using the method&#xA; * &lt;code>setJoinType&lt;/code>. The following SQL &lt;code>JOIN&lt;/code> types can be set:&#xA; * &lt;UL>&#xA; *  &lt;LI>&lt;code>CROSS_JOIN&lt;/code>&#xA; *  &lt;LI>&lt;code>FULL_JOIN&lt;/code>&#xA; *  &lt;LI>&lt;code>INNER_JOIN&lt;/code> - the default if no &lt;code>JOIN&lt;/code> type has been set&#xA; *  &lt;LI>&lt;code>LEFT_OUTER_JOIN&lt;/code>&#xA; *  &lt;LI>&lt;code>RIGHT_OUTER_JOIN&lt;/code>&#xA; * &lt;/UL>&#xA; * Note that if no type is set, the &lt;code>JOIN&lt;/code> will automatically be an&#xA; * inner join. The comments for the fields in the&#xA; * &lt;code>JoinRowSet&lt;/code> interface explain these &lt;code>JOIN&lt;/code> types, which are&#xA; * standard SQL &lt;code>JOIN&lt;/code> types. &#xA; * &lt;P>&#xA; * &lt;h3>2.0 Using a &lt;code>JoinRowSet&lt;/code> Object for Creating a &lt;code>JOIN&lt;/code>&lt;/h3>&#xA; * When a &lt;code>JoinRowSet&lt;/code> object is created, it is empty.&#xA; * The first &lt;code>RowSet&lt;/code> object to be added becomes the basis for the&#xA; * &lt;code>JOIN&lt;/code> relationship.&#xA; * Applications must determine which column in each of the&#xA; * &lt;code>RowSet&lt;/code> objects to be added to the &lt;code>JoinRowSet&lt;/code> object &#xA; * should be the match column. All of the &#xA; * &lt;code>RowSet&lt;/code> objects must contain a match column, and the values in&#xA; * each match column must be ones that can be compared to values in the other match&#xA; * columns. The columns do not have to have the same name, though they often do, &#xA; * and they do not have to store the exact same data type as long as the data types&#xA; * can be compared.  &#xA; * &lt;P>&#xA; * A match column can be be set in two ways: &#xA; * &lt;ul>&#xA; *  &lt;li>By calling the &lt;code>Joinable&lt;/code> method &lt;code>setMatchColumn&lt;/code>&lt;br>&#xA; *  This is the only method that can set the match column before a &lt;code>RowSet&lt;/code> &#xA; *  object is added to a &lt;code>JoinRowSet&lt;/code> object. The &lt;code>RowSet&lt;/code> object&#xA; *  must have implemented the &lt;code>Joinable&lt;/code> interface in order to use the method&#xA; *  &lt;code>setMatchColumn&lt;/code>. Once the match column value&#xA; *  has been set, this method can be used to reset the match column at any time.&#xA; *  &lt;li>By calling one of the versions of the &lt;code>JoinRowSet&lt;/code> method &#xA; *  &lt;code>addRowSet&lt;/code> that takes a column name or number (or an array of&#xA; *  column names or numbers)&lt;BR>&#xA; *  Four of the five &lt;code>addRowSet&lt;/code> methods take a match column as a parameter.&#xA; *  These four methods set or reset the match column at the time a &lt;code>RowSet&lt;/code> &#xA; *  object is being added to a &lt;code>JoinRowSet&lt;/code> object.&#xA; * &lt;/ul>&#xA; * &lt;h3>3.0 Sample Usage&lt;/h3>&#xA; * &lt;p>&#xA; * The following code fragment adds two &lt;code>CachedRowSet&lt;/code> &#xA; * objects to a &lt;code>JoinRowSet&lt;/code> object. Note that in this example,&#xA; * no SQL &lt;code>JOIN&lt;/code> type is set, so the default &lt;code>JOIN&lt;/code> type,&#xA; * which is &lt;i>INNER_JOIN&lt;/i>, is established. &#xA; * &lt;p>&#xA; * In the following code fragment, the table &lt;code>EMPLOYEES&lt;/code>, whose match &#xA; * column is set to the first column (&lt;code>EMP_ID&lt;/code>), is added to the&#xA; * &lt;code>JoinRowSet&lt;/code> object &lt;i>jrs&lt;/i>. Then&#xA; * the table &lt;code>ESSP_BONUS_PLAN&lt;/code>, whose match column is likewise &#xA; * the &lt;code>EMP_ID&lt;/code> column, is added. When this second&#xA; * table is added to &lt;i>jrs&lt;/i>, only the rows in &#xA; * &lt;code>ESSP_BONUS_PLAN&lt;/code> whose &lt;code>EMP_ID&lt;/code> value matches an&#xA; * &lt;code>EMP_ID&lt;/code> value in the &lt;code>EMPLOYEES&lt;/code> table are added.&#xA; * In this case, everyone in the bonus plan is an employee, so all of the rows&#xA; * in the table &lt;code>ESSP_BONUS_PLAN&lt;/code> are added to the &lt;code>JoinRowSet&lt;/code>&#xA; * object.  In this example, both &lt;code>CachedRowSet&lt;/code> objects being added&#xA; * have implemented the &lt;code>Joinable&lt;/code> interface and can therefore call &#xA; * the &lt;code>Joinable&lt;/code> method &lt;code>setMatchColumn&lt;/code>.&#xA; * &lt;PRE>&#xA; *     JoinRowSet jrs = new JoinRowSetImpl();&#xA; * &#xA; *     ResultSet rs1 = stmt.executeQuery(&quot;SELECT * FROM EMPLOYEES&quot;);&#xA; *     CachedRowSet empl = new CachedRowSetImpl();&#xA; *     empl.populate(rs1);&#xA; *     empl.setMatchColumn(1); &#xA; *     jrs.addRowSet(empl);&#xA; * &#xA; *     ResultSet rs2 = stmt.executeQuery(&quot;SELECT * FROM ESSP_BONUS_PLAN&quot;);&#xA; *     CachedRowSet bonus = new CachedRowSetImpl();&#xA; *     bonus.populate(rs2);&#xA; *     bonus.setMatchColumn(1); // EMP_ID is the first column&#xA; *     jrs.addRowSet(bonus);&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; * At this point, &lt;i>jrs&lt;/i> is an inside JOIN of the two &lt;code>RowSet&lt;/code> objects&#xA; * based on their &lt;code>EMP_ID&lt;/code> columns. The application can now browse the&#xA; * combined data as if it were browsing one single &lt;code>RowSet&lt;/code> object.&#xA; * Because &lt;i>jrs&lt;/i> is itself a &lt;code>RowSet&lt;/code> object, an application can&#xA; * navigate or modify it using &lt;code>RowSet&lt;/code> methods.&#xA; * &lt;PRE>&#xA; *     jrs.first();&#xA; *     int employeeID = jrs.getInt(1);&#xA; *     String employeeName = jrs.getString(2);&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; * Note that because the SQL &lt;code>JOIN&lt;/code> must be enforced when an application&#xA; * adds a second or subsequent &lt;code>RowSet&lt;/code> object, there&#xA; * may be an initial degradation in performance while the &lt;code>JOIN&lt;/code> is&#xA; * being performed.&#xA; * &lt;P>&#xA; * The following code fragment adds an additional &lt;code>CachedRowSet&lt;/code> object.&#xA; * In this case, the match column (&lt;code>EMP_ID&lt;/code>) is set when the &#xA; * &lt;code>CachedRowSet&lt;/code> object is added to the &lt;code>JoinRowSet&lt;/code> object. &#xA; * &lt;PRE>&#xA; *     ResultSet rs3 = stmt.executeQuery(&quot;SELECT * FROM 401K_CONTRIB&quot;);&#xA; *     CachedRowSet fourO1k = new CachedRowSetImpl();&#xA; *     four01k.populate(rs3);&#xA; *     jrs.addRowSet(four01k, 1);&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; * The &lt;code>JoinRowSet&lt;/code> object &lt;i>jrs&lt;/i> now contains values from all three&#xA; * tables. The data in each row in &lt;i>four01k&lt;/i> in which the value for the &#xA; * &lt;code>EMP_ID&lt;/code> column matches a value for the &lt;code>EMP_ID&lt;/code> column &#xA; * in &lt;i>jrs&lt;/i> has been added to &lt;i>jrs&lt;/i>.&#xA; * &lt;P>&#xA; * &lt;h3>4.0 &lt;code>JoinRowSet&lt;/code> Methods&lt;/h3>&#xA; * The &lt;code>JoinRowSet&lt;/code> interface supplies several methods for adding &#xA; * &lt;code>RowSet&lt;/code> objects and for getting information about the &#xA; * &lt;code>JoinRowSet&lt;/code> object.&#xA; * &lt;UL>&#xA; *   &lt;LI>Methods for adding one or more &lt;code>RowSet&lt;/code> objects&lt;BR>&#xA; *       These methods allow an application to add one &lt;code>RowSet&lt;/code> object&#xA; *       at a time or to add multiple &lt;code>RowSet&lt;/code> objects at one time. In&#xA; *       either case, the methods may specify the match column for each &#xA; *       &lt;code>RowSet&lt;/code> object being added.&#xA; *   &lt;LI>Methods for getting information&lt;BR>&#xA; *       One method retrieves the &lt;code>RowSet&lt;/code> objects in the &#xA; *       &lt;code>JoinRowSet&lt;/code> object, and another method retrieves the &#xA; *       &lt;code>RowSet&lt;/code> names.  A third method retrieves either the SQL &#xA; *       &lt;code>WHERE&lt;/code> clause used behind the scenes to form the &#xA; *       &lt;code>JOIN&lt;/code> or a text description of what the &lt;code>WHERE&lt;/code>&#xA; *       clause does.&#xA; *   &lt;LI>Methods related to the type of &lt;code>JOIN&lt;/code>&lt;BR>&#xA; *       One method sets the &lt;code>JOIN&lt;/code> type, and five methods find out whether&#xA; *       the &lt;code>JoinRowSet&lt;/code> object supports a given type.&#xA; *   &lt;LI>A method to make a separate copy of the &lt;code>JoinRowSet&lt;/code> object&lt;BR>&#xA; *       This method creates a copy that can be persisted to the data source.&#xA; * &lt;/UL>&#xA; * &lt;P>&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="WebRowSet.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
