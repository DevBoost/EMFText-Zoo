<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../../java.ecore#/7 http://www.emftext.org/java/literals ../../../../java.ecore#/9 http://www.emftext.org/java/members ../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../../java.ecore#/13 http://www.emftext.org/java/types ../../../../java.ecore#/16" name="SyncResolver.java">
  <comments>/*&#xA; * @(#)SyncResolver.java&#x9;1.4 04/02/27&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>sql</namespaces>
  <namespaces>rowset</namespaces>
  <namespaces>spi</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>sql</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../RowSet.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>sql</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="SyncResolver">
    <members xsi:type="members:Field" name="UPDATE_ROW_CONFLICT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Indicates that a conflict occurred while the &lt;code>RowSet&lt;/code> object was&#xA;     * attempting to update a row in the data source. &#xA;     * The values in the data source row to be updated differ from the&#xA;     * &lt;code>RowSet&lt;/code> object's original values for that row, which means that&#xA;     * the row in the data source has been updated or deleted since the last &#xA;     * synchronization. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DELETE_ROW_CONFLICT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Indicates that a conflict occurred while the &lt;code>RowSet&lt;/code> object was&#xA;     * attempting to delete a row in the data source.&#xA;     * The values in the data source row to be updated differ from the&#xA;     * &lt;code>RowSet&lt;/code> object's original values for that row, which means that &#xA;     * the row in the data source has been updated or deleted since the last &#xA;     * synchronization. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="INSERT_ROW_CONFLICT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Indicates that a conflict occurred while the &lt;code>RowSet&lt;/code> object was&#xA;    * attempting to insert a row into the data source.  This means that a&#xA;    * row with the same primary key as the row to be inserted has been inserted&#xA;    * into the data source since the last synchronization.&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="NO_ROW_CONFLICT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Indicates that &lt;b>no&lt;/b> conflict occured while the &lt;code>RowSet&lt;/code> object&#xA;     * was attempting to update, delete or insert a row in the data source. The values in&#xA;     * the &lt;code>SyncResolver&lt;/code> will contain &lt;code>null&lt;/code> values only as an indication&#xA;     * that no information in pertitent to the conflict resolution in this row.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getStatus">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the conflict status of the current row of this &lt;code>SyncResolver&lt;/code>,&#xA;     * which indicates the operation&#xA;     * the &lt;code>RowSet&lt;/code> object was attempting when the conflict occurred.&#xA;     *&#xA;     * @return one of the following constants:&#xA;     *         &lt;code>SyncResolver.UPDATE_ROW_CONFLICT&lt;/code>,&#xA;     *         &lt;code>SyncResolver.DELETE_ROW_CONFLICT&lt;/code>, &#xA;     *         &lt;code>SyncResolver.INSERT_ROW_CONFLICT&lt;/code>, or&#xA;     *         &lt;code>SyncResolver.NO_ROW_CONFLICT&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getConflictValue">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the value in the designated column in the current row of this&#xA;     * &lt;code>SyncResolver&lt;/code> object, which is the value in the data source&#xA;     * that caused a conflict.&#xA;     *&#xA;     * @param index an &lt;code>int&lt;/code> designating the column in this row of this&#xA;     *        &lt;code>SyncResolver&lt;/code> object from which to retrieve the value &#xA;     *        causing a conflict&#xA;     * @return the value of the designated column in the current row of this&#xA;     *         &lt;code>SyncResolver&lt;/code> object &#xA;     * @throws SQLException if a database access error occurs     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getConflictValue">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="columnName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the value in the designated column in the current row of this&#xA;     * &lt;code>SyncResolver&lt;/code> object, which is the value in the data source&#xA;     * that caused a conflict.&#xA;     *&#xA;     * @param columnName a &lt;code>String&lt;/code> object designating the column in this row of this&#xA;     *        &lt;code>SyncResolver&lt;/code> object from which to retrieve the value &#xA;     *        causing a conflict&#xA;     * @return the value of the designated column in the current row of this&#xA;     *         &lt;code>SyncResolver&lt;/code> object &#xA;     * @throws SQLException if a database access error occurs     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setResolvedValue">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets &lt;i>obj&lt;/i> as the value in column &lt;i>index&lt;/i> in the current row of the&#xA;     * &lt;code>RowSet&lt;/code> object that is being synchronized. &lt;i>obj&lt;/i>&#xA;     * is set as the value in the data source internally.&#xA;     *&#xA;     * @param index an &lt;code>int&lt;/code> giving the number of the column into which to&#xA;     *        set the value to be persisted&#xA;     * @param obj an &lt;code>Object&lt;/code> that is the value to be set in the &#xA;     *        &lt;code>RowSet&lt;/code> object and persisted in the data source&#xA;     * @throws SQLException if a database access error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setResolvedValue">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="columnName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets &lt;i>obj&lt;/i> as the value in column &lt;i>columnName&lt;/i> in the current row of the&#xA;     * &lt;code>RowSet&lt;/code> object that is being synchronized. &lt;i>obj&lt;/i>&#xA;     * is set as the value in the data source internally.&#xA;     *&#xA;     * @param columnName a &lt;code>String&lt;/code> object giving the name of the column &#xA;     *        into which to set the value to be persisted&#xA;     * @param obj an &lt;code>Object&lt;/code> that is the value to be set in the &#xA;     *        &lt;code>RowSet&lt;/code> object and persisted in the data source&#xA;     * @throws SQLException if a database access error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="nextConflict">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Moves the cursor down from its current position to the next row that contains&#xA;     * a conflict value. A &lt;code>SyncResolver&lt;/code> object's&#xA;     * cursor is initially positioned before the first conflict row; the first call to the &#xA;     * method &lt;code>nextConflict&lt;/code> makes the first conflict row the current row; &#xA;     * the second call makes the second conflict row the current row, and so on.&#xA;     * &lt;p>&#xA;     * A call to the method &lt;code>nextConflict&lt;/code> will implicitly close &#xA;     * an input stream if one is open and will clear the &lt;code>SyncResolver&lt;/code> &#xA;     * object's warning chain.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if the new current row is valid; &lt;code>false&lt;/code>&#xA;     *         if there are no more rows&#xA;     * @throws SQLException if a database access error occurs or the result set type&#xA;     *     is &lt;code>TYPE_FORWARD_ONLY&lt;/code>&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="previousConflict">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Moves the cursor up from its current position to the previous conflict &#xA;     * row in this &lt;code>SyncResolver&lt;/code> object.&#xA;     * &lt;p>&#xA;     * A call to the method &lt;code>previousConflict&lt;/code> will implicitly close &#xA;     * an input stream if one is open and will clear the &lt;code>SyncResolver&lt;/code> &#xA;     * object's warning chain.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if the cursor is on a valid row; &lt;code>false&lt;/code>&#xA;     *     if it is off the result set &#xA;     * @throws SQLException if a database access error occurs or the result set type&#xA;     *     is &lt;code>TYPE_FORWARD_ONLY&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Defines a framework that allows applications to use a manual decision tree&#xA; * to decide what should be done when a synchronization conflict occurs.&#xA; * Although it is not mandatory for &#xA; * applications to resolve synchronization conflicts manually, this&#xA; * framework provides the means to delegate to the application when conflicts &#xA; * arise.&#xA; * &lt;p>&#xA; * Note that a conflict is a situation where the &lt;code>RowSet&lt;/code> object's original&#xA; * values for a row do not match the values in the data source, which indicates that &#xA; * the data source row has been modified since the last synchronization. Note also that&#xA; * a &lt;code>RowSet&lt;/code> object's original values are the values it had just prior to the&#xA; * the last synchronization, which are not necessarily its initial values.&#xA; * &lt;p>&#xA; *&#xA; * &lt;H2>Description of a &lt;code>SyncResolver&lt;/code> Object&lt;/H2>&#xA; * &#xA; * A &lt;code>SyncResolver&lt;/code> object is a specialized &lt;code>RowSet&lt;/code> object&#xA; * that implements the &lt;code>SyncResolver&lt;/code> interface. &#xA; * It &lt;b>may&lt;/b> operate as either a connected &lt;code>RowSet&lt;/code> object (an&#xA; * implementation of the &lt;code>JdbcRowSet&lt;/code> interface) or a connected&#xA; * &lt;code>RowSet&lt;/code> object (an implementation of the&#xA; * &lt;code>CachedRowSet&lt;/code> interface or one of its subinterfaces). For information&#xA; * on the subinterfaces, see the &#xA; * &lt;a href=&quot;../package-summary.html&quot;>&lt;code>javax.sql.rowset&lt;/code>&lt;/a> package&#xA; * description. The reference implementation for &lt;code>SyncResolver&lt;/code> implements&#xA; * the &lt;code>CachedRowSet&lt;/code> interface, but other implementations&#xA; * may choose to implement the &lt;code>JdbcRowSet&lt;/code> interface to satisfy &#xA; * particular needs.&#xA; * &lt;P> &#xA; * After an application has attempted to synchronize a &lt;code>RowSet&lt;/code> object with&#xA; * the data source (by calling the &lt;code>CachedRowSet&lt;/code>&#xA; * method &lt;code>acceptChanges&lt;/code>), and one or more conflicts have been found,&#xA; * a rowset's &lt;code>SyncProvider&lt;/code> object creates an instance of &#xA; * &lt;code>SyncResolver&lt;/code>. This new &lt;code>SyncResolver&lt;/code> object has&#xA; * the same number of rows and columns as the&#xA; * &lt;code>RowSet&lt;/code> object that was attempting the synchronization. The&#xA; * &lt;code>SyncResolver&lt;/code> object contains the values from the data source that caused&#xA; * the conflict(s) and &lt;code>null&lt;/code> for all other values.&#xA; * In addition, it contains information about each conflict.&#xA; * &lt;P>&#xA; *&#xA; * &lt;H2>Getting and Using a &lt;code>SyncResolver&lt;/code> Object&lt;/H2>&#xA; * &#xA; * When the method &lt;code>acceptChanges&lt;/code> encounters conflicts, the &#xA; * &lt;code>SyncProvider&lt;/code> object creates a &lt;code>SyncProviderException&lt;/code> &#xA; * object and sets it with the new &lt;code>SyncResolver&lt;/code> object. The method&#xA; * &lt;code>acceptChanges&lt;/code> will throw this exception, which&#xA; * the application can then catch and use to retrieve the &#xA; * &lt;code>SyncResolver&lt;/code> object it contains. The following code snippet uses the&#xA; * &lt;code>SyncProviderException&lt;/code> method &lt;code>getSyncResolver&lt;/code> to get&#xA; * the &lt;code>SyncResolver&lt;/code> object &lt;i>resolver&lt;/i>.  &#xA; * &lt;PRE>&#xA; *     } catch (SyncProviderException spe) {&#xA; *         SyncResolver resolver = spe.getSyncResolver();&#xA; *     ...&#xA; *     }&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; * With &lt;i>resolver&lt;/i> in hand, an application can use it to get the information&#xA; * it contains about the conflict or conflicts.  A &lt;code>SyncResolver&lt;/code> object&#xA; * such as &lt;i>resolver&lt;/i> keeps&#xA; * track of the conflicts for each row in which there is a conflict.  It also places a&#xA; * lock on the table or tables affected by the rowset's command so that no more&#xA; * conflicts can occur while the current conflicts are being resolved.&#xA; * &lt;P>&#xA; * The following kinds of information can be obtained from a &lt;code>SyncResolver&lt;/code>&#xA; * object: &#xA; * &lt;P>&#xA; *    &lt;LI>What operation was being attempted when a conflict occurred&lt;BR>&#xA; * The &lt;code>SyncProvider&lt;/code> interface defines four constants &#xA; * describing states that may occur. Three&#xA; * constants describe the type of operation (update, delete, or insert) that a &#xA; * &lt;code>RowSet&lt;/code> object was attempting to perform when a conflict was discovered,&#xA; * and the fourth indicates that there is no conflict. &#xA; * These constants are the possible return values when a &lt;code>SyncResolver&lt;/code> object&#xA; * calls the method &lt;code>getStatus&lt;/code>.&#xA; * &lt;PRE>&#xA; *     int operation = resolver.getStatus();&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; *    &lt;LI>The value in the data source that caused a conflict&lt;BR>&#xA; * A conflict exists when a value that a &lt;code>RowSet&lt;/code> object has changed&#xA; * and is attempting to write to the data source&#xA; * has also been changed in the data source since the last synchronization.  An&#xA; * application can call the &lt;code>SyncResolver&lt;/code> method &#xA; * &lt;code>getConflictValue&lt;/code > to retrieve the&#xA; * value in the data source that is the cause of the conflict because the values in a&#xA; * &lt;code>SyncResolver&lt;/code> object are the conflict values from the data source. &#xA; * &lt;PRE>&#xA; *     java.lang.Object conflictValue = resolver.getConflictValue(2);&#xA; * &lt;/PRE>&#xA; * Note that the column in &lt;i>resolver&lt;/i> can be designated by the column number,&#xA; * as is done in the preceding line of code, or by the column name.&#xA; * &lt;/UL>&#xA; * &lt;P>&#xA; * With the information retrieved from the methods &lt;code>getStatus&lt;/code> and&#xA; * &lt;code>getConflictValue&lt;/code>, the application may make a determination as to&#xA; * which value should be persisted in the data source. The application then calls the &#xA; * &lt;code>SyncResolver&lt;/code> method &lt;code>setResolvedValue&lt;/code>, which sets the value&#xA; * to be persisted in the &lt;code>RowSet&lt;/code> object and also in the data source.&#xA; * &lt;PRE>&#xA; *     resolver.setResolvedValue(&quot;DEPT&quot;, 8390426);&#xA; * &lt;/PRE>&#xA; * In the preceding line of code,&#xA; * the column name designates the column in the &lt;code>RowSet&lt;/code> object&#xA; * that is to be set with the given value. The column number can also be used to &#xA; * designate the column.&#xA; * &lt;P>&#xA; * An application calls the method &lt;code>setResolvedValue&lt;/code> after it has&#xA; * resolved all of the conflicts in the current conflict row and repeats this process&#xA; * for each conflict row in the &lt;code>SyncResolver&lt;/code> object.&#xA; * &lt;P>&#xA; *&#xA; * &lt;H2>Navigating a &lt;code>SyncResolver&lt;/code> Object&lt;/H2>&#xA; *&#xA; * Because a &lt;code>SyncResolver&lt;/code> object is a &lt;code>RowSet&lt;/code> object, an&#xA; * application can use all of the &lt;code>RowSet&lt;/code> methods for moving the cursor&#xA; * to navigate a &lt;code>SyncResolver&lt;/code> object. For example, an application can&#xA; * use the &lt;code>RowSet&lt;/code> method &lt;code>next&lt;/code> to get to each row and then &#xA; * call the &lt;code>SyncResolver&lt;/code> method &lt;code>getStatus&lt;/code> to see if the row&#xA; * contains a conflict.  In a row with one or more conflicts, the application can &#xA; * iterate through the columns to find any non-null values, which will be the values&#xA; * from the data source that are in conflict.&#xA; * &lt;P> &#xA; * To make it easier to navigate a &lt;code>SyncResolver&lt;/code> object, especially when &#xA; * there are large numbers of rows with no conflicts, the &lt;code>SyncResolver&lt;/code>&#xA; * interface defines the methods &lt;code>nextConflict&lt;/code> and&#xA; * &lt;code>previousConflict&lt;/code>, which move only to rows&#xA; * that contain at least one conflict value. Then an application can call the &#xA; * &lt;code>SyncResolver&lt;/code> method &lt;code>getConflictValue&lt;/code>, supplying it&#xA; * with the column number, to get the conflict value itself. The code fragment in the&#xA; * next section gives an example.&#xA; *&#xA; * &lt;H2>Code Example&lt;/H2>&#xA; * &#xA; * The following code fragment demonstrates how a disconnected &lt;code>RowSet&lt;/code>&#xA; * object &lt;i>crs&lt;/i> might attempt to synchronize itself with the&#xA; * underlying data source and then resolve the conflicts. In the &lt;code>try&lt;/code>&#xA; * block, &lt;i>crs&lt;/i> calls the method &lt;code>acceptChanges&lt;/code>, passing it the&#xA; * &lt;code>Connection&lt;/code> object &lt;i>con&lt;/i>.  If there are no conflicts, the&#xA; * changes in &lt;i>crs&lt;/i> are simply written to the data source.  However, if there&#xA; * is a conflict, the method &lt;code>acceptChanges&lt;/code> throws a&#xA; * &lt;code>SyncProviderException&lt;/code> object, and the &#xA; * &lt;code>catch&lt;/code> block takes effect.  In this example, which&#xA; * illustrates one of the many ways a &lt;code>SyncResolver&lt;/code> object can be used,&#xA; * the &lt;code>SyncResolver&lt;/code> method &lt;code>nextConflict&lt;/code> is used in a&#xA; * &lt;code>while&lt;/code> loop. The loop will end when &lt;code>nextConflict&lt;/code> returns&#xA; * &lt;code>false&lt;/code>, which will occur when there are no more conflict rows in the&#xA; * &lt;code>SyncResolver&lt;/code> object &lt;i>resolver&lt;/i>. In This particular code fragment,&#xA; * &lt;i>resolver&lt;/i> looks for rows that have update conflicts (rows with the status&#xA; * &lt;code>SyncResolver.UPDATE_ROW_CONFLICT&lt;/code>), and the rest of this code fragment&#xA; * executes only for rows where conflicts occurred because &lt;i>crs&lt;/i> was attempting an&#xA; * update.  &#xA; * &lt;P>&#xA; * After the cursor for &lt;i>resolver&lt;/i> has moved to the next conflict row that&#xA; * has an update conflict, the method &lt;code>getRow&lt;/code> indicates the number of the &#xA; * current row, and&#xA; * the cursor for the &lt;code>CachedRowSet&lt;/code> object &lt;i>crs&lt;/i> is moved to &#xA; * the comparable row in &lt;i>crs&lt;/i>. By iterating&#xA; * through the columns of that row in both &lt;i>resolver&lt;/i> and &lt;i>crs&lt;/i>, the conflicting&#xA; * values can be retrieved and compared to decide which one should be persisted. In this&#xA; * code fragment, the value in &lt;i>crs&lt;/i> is the one set as the resolved value, which means&#xA; * that it will be used to overwrite the conflict value in the data source.&#xA; * &#xA; * &lt;PRE>&#xA; *     try {&#xA; *&#xA; *         crs.acceptChanges(con);&#xA; *&#xA; *     } catch (SyncProviderException spe) {&#xA; *&#xA; *         SyncResolver resolver = spe.getSyncResolver();&#xA; *&#xA; *         Object crsValue;  // value in the &lt;code>RowSet&lt;/code> object &#xA; *         Object resolverValue:  // value in the &lt;code>SyncResolver&lt;/code> object&#xA; *         Object resolvedValue:  // value to be persisted&#xA; *&#xA; *         while(resolver.nextConflict())  {&#xA; *             if(resolver.getStatus() == SyncResolver.UPDATE_ROW_CONFLICT)  {&#xA; *                 int row = resolver.getRow();&#xA; *                 crs.absolute(row);&#xA; *&#xA; *                 int colCount = crs.getMetaData().getColumnCount();&#xA; *                 for(int j = 1; j &lt;= colCount; j++) {&#xA; *                     if (resolver.getConflictValue(j) != null)  {&#xA; *                         crsValue = crs.getObject(j);&#xA; *                         resolverValue = resolver.getConflictValue(j);&#xA; *                         . . . &#xA; *                         // compare crsValue and resolverValue to determine&#xA; *                         // which should be the resolved value (the value to persist)&#xA; *                         resolvedValue = crsValue;&#xA; *&#xA; *                         resolver.setResolvedValue(j, resolvedValue);&#xA; *                      } &#xA; *                  } &#xA; *              }&#xA; *          }&#xA; *      }&#xA; * &lt;/PRE>&#xA; * @author  Jonathan Bruce&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../RowSet.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
