<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="JdbcRowSet.java">
  <comments>/*&#xA; * @(#)JdbcRowSet.java&#x9;1.4 04/02/27&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>sql</namespaces>
  <namespaces>rowset</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>sql</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>javax</namespaces>
    <namespaces>sql</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>javax</namespaces>
    <namespaces>naming</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>math</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="JdbcRowSet">
    <members xsi:type="members:InterfaceMethod" name="getShowDeleted">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves a &lt;code>boolean&lt;/code> indicating whether rows marked&#xA;     * for deletion appear in the set of current rows. If &lt;code>true&lt;/code> is &#xA;     * returned, deleted rows are visible with the current rows. If &#xA;     * &lt;code>false&lt;/code> is returned, rows are not visible with the set of &#xA;     * current rows. The default value is &lt;code>false&lt;/code>.&#xA;     * &lt;P>&#xA;     * Standard rowset implementations may choose to restrict this behavior&#xA;     * for security considerations or for certain deployment&#xA;     * scenarios. The visibility of deleted rows is implementation-defined &#xA;     * and does not represent standard behavior.          &#xA;     * &lt;P>&#xA;     * Note: Allowing deleted rows to remain visible complicates the behavior&#xA;     * of some standard JDBC &lt;code>RowSet&lt;/code> implementations methods. &#xA;     * However, most rowset users can simply ignore this extra detail because &#xA;     * only very specialized applications will likely want to take advantage of&#xA;     * this feature.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if deleted rows are visible;&#xA;     *         &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a rowset implementation is unable to&#xA;     *&#x9;&#x9;to determine whether rows marked for deletion remain visible&#xA;     * @see #setShowDeleted&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setShowDeleted">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the property &lt;code>showDeleted&lt;/code> to the given&#xA;     * &lt;code>boolean&lt;/code> value. This property determines whether&#xA;     * rows marked for deletion continue to appear in the set of current rows.&#xA;     * If the value is set to &lt;code>true&lt;/code>, deleted rows are immediately&#xA;     * visible with the set of current rows. If the value is set to &#xA;     * &lt;code>false&lt;/code>, the deleted rows are set as invisible with the&#xA;     * current set of rows.&#xA;     * &lt;P>&#xA;     * Standard rowset implementations may choose to restrict this behavior&#xA;     * for security considerations or for certain deployment&#xA;     * scenarios. This is left as implementation-defined and does not&#xA;     * represent standard behavior.&#xA;     *&#xA;     * @param b &lt;code>true&lt;/code> if deleted rows should be shown;&#xA;     *              &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a rowset implementation is unable to&#xA;     *&#x9;&#x9;to reset whether deleted rows should be visible&#xA;     * @see #getShowDeleted&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getRowSetWarnings">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RowSetWarning.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the first warning reported by calls on this &lt;code>JdbcRowSet&lt;/code>&#xA;     * object.&#xA;     * If a second warning was reported on this &lt;code>JdbcRowSet&lt;/code> object,&#xA;     * it will be chained to the first warning and can be retrieved by&#xA;     * calling the method &lt;code>RowSetWarning.getNextWarning&lt;/code> on the&#xA;     * first warning. Subsequent warnings on this &lt;code>JdbcRowSet&lt;/code> &#xA;     * object will be chained to the &lt;code>RowSetWarning&lt;/code> objects&#xA;     * returned by the method &lt;code>RowSetWarning.getNextWarning&lt;/code>.&#xA;     *&#xA;     * The warning chain is automatically cleared each time a new row is read.&#xA;     * This method may not be called on a &lt;code>RowSet&lt;/code> object &#xA;     * that has been closed;&#xA;     * doing so will cause an &lt;code>SQLException&lt;/code> to be thrown.&#xA;     * &lt;P>&#xA;     * Because it is always connected to its data source, a &lt;code>JdbcRowSet&lt;/code>&#xA;     * object can rely on the presence of active &#xA;     * &lt;code>Statement&lt;/code>, &lt;code>Connection&lt;/code>, and &lt;code>ResultSet&lt;/code>&#xA;     * instances. This means that  applications can obtain additional &#xA;     * &lt;code>SQLWarning&lt;/code> &#xA;     * notifications by calling the &lt;code>getNextWarning&lt;/code> methods that &#xA;     * they provide.&#xA;     * Disconnected &lt;code>Rowset&lt;/code> objects, such as a &#xA;     * &lt;code>CachedRowSet&lt;/code> object, do not have access to &#xA;     * these &lt;code>getNextWarning&lt;/code> methods. &#xA;     * &#xA;     * @return the first &lt;code>RowSetWarning&lt;/code> &#xA;     * object reported on this &lt;code>JdbcRowSet&lt;/code> object&#xA;     * or &lt;code>null&lt;/code> if there are none&#xA;     * @throws SQLException if this method is called on a closed &#xA;     * &lt;code>JdbcRowSet&lt;/code> object&#xA;     * @see RowSetWarning&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="commit">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Each &lt;code>JdbcRowSet&lt;/code> contains a &lt;code>Connection&lt;/code> object from&#xA;    * the &lt;code>ResultSet&lt;/code> or JDBC properties passed to it's constructors.&#xA;    * This method wraps the &lt;code>Connection&lt;/code> commit method to allow flexible&#xA;    * auto commit or non auto commit transactional control support.&#xA;    * &lt;p>&#xA;    * Makes all changes made since the previous commit/rollback permanent &#xA;    * and releases any database locks currently held by this Connection &#xA;    * object. This method should be used only when auto-commit mode has &#xA;    * been disabled.&#xA;    *&#xA;    * @throws SQLException if a database access error occurs or this &#xA;    * Connection object within this &lt;code>JdbcRowSet&lt;/code> is in auto-commit mode&#xA;    * @see java.sql.Connection#setAutoCommit&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAutoCommit">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;    * Each &lt;code>JdbcRowSet&lt;/code> contains a &lt;code>Connection&lt;/code> object from&#xA;    * the original &lt;code>ResultSet&lt;/code> or JDBC properties passed to it. This &#xA;    * method wraps the &lt;code>Connection&lt;/code>'s &lt;code>getAutoCommit&lt;/code> method&#xA;    * to allow an application to determine the &lt;code>JdbcRowSet&lt;/code> transaction&#xA;    * behavior.&#xA;    * &lt;p>&#xA;    * Sets this connection's auto-commit mode to the given state. If a   &#xA;    * connection is in auto-commit mode, then all its SQL statements will   &#xA;    * be executed and committed as individual transactions. Otherwise, its  &#xA;    * SQL statements are grouped into transactions that are terminated by a &#xA;    * call to either the method commit or the method rollback. By default,  &#xA;    * new connections are in auto-commit mode.&#xA;    *&#xA;    * @throws SQLException if a database access error occurs&#xA;    * @see java.sql.Connection#getAutoCommit()&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setAutoCommit">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="autoCommit">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Each &lt;code>JdbcRowSet&lt;/code> contains a &lt;code>Connection&lt;/code> object from&#xA;    * the original &lt;code>ResultSet&lt;/code> or JDBC properties passed to it. This&#xA;    * method wraps the &lt;code>Connection&lt;/code>'s &lt;code>getAutoCommit&lt;/code> method&#xA;    * to allow an application to set the &lt;code>JdbcRowSet&lt;/code> transaction behavior.&#xA;    * &lt;p>&#xA;    * Sets the current auto-commit mode for this &lt;code>Connection&lt;/code> object.&#xA;    *&#xA;    * @return the current state of this internal &lt;code>Connection&lt;/code> object's &#xA;    * auto-commit mode &#xA;    * @throws SQLException if a database access error occurs&#xA;    * @see java.sql.Connection#setAutoCommit(boolean)&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rollback">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Each &lt;code>JdbcRowSet&lt;/code> contains a &lt;code>Connection&lt;/code> object from&#xA;     * the original &lt;code>ResultSet&lt;/code> or JDBC properties passed to it.&#xA;     * Undoes all changes made in the current transaction and releases any &#xA;     * database locks currently held by this &lt;code>Connection&lt;/code> object. This method &#xA;     * should be used only when auto-commit mode has been disabled.&#xA;     * &#xA;     * @throws SQLException if a database access error occurs or this &lt;code>Connection&lt;/code>&#xA;     * object within this &lt;code>JdbcRowSet&lt;/code> is in auto-commit mode.&#xA;     * @see #rollback(Savepoint)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rollback">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/sql/Savepoint.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/sql/SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Each &lt;code>JdbcRowSet&lt;/code> contains a &lt;code>Connection&lt;/code> object from&#xA;     * the original &lt;code>ResultSet&lt;/code> or JDBC properties passed to it.&#xA;     * Undoes all changes made in the current transaction to the last set savepoint&#xA;     * and releases any database locks currently held by this &lt;code>Connection&lt;/code>&#xA;     * object. This method should be used only when auto-commit mode has been disabled.&#xA;     * &#xA;     * @throws SQLException if a database access error occurs or this &lt;code>Connection&lt;/code>&#xA;     * object within this &lt;code>JdbcRowSet&lt;/code> is in auto-commit mode.&#xA;     * @see #rollback&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The standard interface that all standard implementations of &#xA; * &lt;code>JdbcRowSet&lt;/code> must implement.&#xA; *&#xA; * &lt;h3>1.0 Overview&lt;/h3>&#xA; * A wrapper around a &lt;code>ResultSet&lt;/code> object that makes it possible&#xA; * to use the result set as a JavaBeans&lt;sup>&lt;font size=-2>TM&lt;/font>&lt;/sup>&#xA; * component.  Thus, a &lt;code>JdbcRowSet&lt;/code> object can be one of the Beans that &#xA; * a tool makes available for composing an application.  Because &#xA; * a &lt;code>JdbcRowSet&lt;/code> is a connected rowset, that is, it continually&#xA; * maintains its connection to a database using a JDBC technology-enabled&#xA; * driver, it also effectively makes the driver a JavaBeans component.&#xA; * &lt;P>&#xA; * Because it is always connected to its database, an instance of &#xA; * &lt;code>JdbcRowSet&lt;/code>&#xA; * can simply take calls invoked on it and in turn call them on its&#xA; * &lt;code>ResultSet&lt;/code> object. As a consequence, a result set can, for&#xA; * example, be a component in a Swing application.&#xA; * &lt;P>&#xA; * Another advantage of a &lt;code>JdbcRowSet&lt;/code> object is that it can be&#xA; * used to make a &lt;code>ResultSet&lt;/code> object scrollable and updatable.  All&#xA; * &lt;code>RowSet&lt;/code> objects are by default scrollable and updatable. If&#xA; * the driver and database being used do not support scrolling and/or updating&#xA; * of result sets, an application can populate a &lt;code>JdbcRowSet&lt;/code> object&#xA; * with the data of a &lt;code>ResultSet&lt;/code> object and then operate on the&#xA; * &lt;code>JdbcRowSet&lt;/code> object as if it were the &lt;code>ResultSet&lt;/code>&#xA; * object.   &#xA; * &lt;P>&#xA; * &lt;h3>2.0 Creating a &lt;code>JdbcRowSet&lt;/code> Object&lt;/h3>&#xA; * The reference implementation of the &lt;code>JdbcRowSet&lt;/code> interface, &#xA; * &lt;code>JdbcRowSetImpl&lt;/code>, provides an implementation of&#xA; * the default constructor.  A new instance is initialized with&#xA; * default values, which can be set with new values as needed. A&#xA; * new instance is not really functional until its &lt;code>execute&lt;/code>&#xA; * method is called. In general, this method does the following:&#xA; * &lt;UL>&#xA; *   &lt;LI> establishes a connection with a database&#xA; *   &lt;LI> creates a &lt;code>PreparedStatement&lt;/code> object and sets any of its&#xA; *        placeholder parameters&#xA; *   &lt;LI> executes the statement to create a &lt;code>ResultSet&lt;/code> object&#xA; * &lt;/UL>&#xA; * If the &lt;code>execute&lt;/code> method is successful, it will set the &#xA; * appropriate private &lt;code>JdbcRowSet&lt;/code> fields with the following:&#xA; * &lt;UL>&#xA; *  &lt;LI> a &lt;code>Connection&lt;/code> object -- the connection between the rowset&#xA; *       and the database&#xA; *  &lt;LI> a &lt;code>PreparedStatement&lt;/code> object -- the query that produces&#xA; *       the result set&#xA; *  &lt;LI> a &lt;code>ResultSet&lt;/code> object -- the result set that the rowset's&#xA; *       command produced and that is being made, in effect, a JavaBeans&#xA; *       component       &#xA; * &lt;/UL>&#xA; * If these fields have not been set, meaning that the &lt;code>execute&lt;/code>&#xA; * method has not executed successfully, no methods other than&#xA; * &lt;code>execute&lt;/code> and &lt;code>close&lt;/code> may be called on the&#xA; * rowset.  All other public methods will throw an exception.&#xA; * &lt;P>&#xA; * Before calling the &lt;code>execute&lt;/code> method, however, the command&#xA; * and properties needed for establishing a connection must be set.&#xA; * The following code fragment creates a &lt;code>JdbcRowSetImpl&lt;/code> object,&#xA; * sets the command and connection properties, sets the placeholder parameter,&#xA; * and then invokes the method &lt;code>execute&lt;/code>.&#xA; * &lt;PRE>&#xA; *     JdbcRowSetImpl jrs = new JdbcRowSetImpl();&#xA; *     jrs.setCommand(&quot;SELECT * FROM TITLES WHERE TYPE = ?&quot;);&#xA; *     jrs.setURL(&quot;jdbc:myDriver:myAttribute&quot;);&#xA; *     jrs.setUsername(&quot;cervantes&quot;);&#xA; *     jrs.setPassword(&quot;sancho&quot;);&#xA; *     jrs.setString(1, &quot;BIOGRAPHY&quot;);&#xA; *     jrs.execute();&#xA; * &lt;/PRE>&#xA; * The variable &lt;code>jrs&lt;/code> now represents an instance of&#xA; * &lt;code>JdbcRowSetImpl&lt;/code> that is a thin wrapper around the&#xA; * &lt;code>ResultSet&lt;/code> object containing all the rows in the&#xA; * table &lt;code>TITLES&lt;/code> where the type of book is biography.&#xA; * At this point, operations called on &lt;code>jrs&lt;/code> will&#xA; * affect the rows in the result set, which is effectively a JavaBeans&#xA; * component.&#xA; * &lt;P>&#xA; * The implementation of the &lt;code>RowSet&lt;/code> method &lt;code>execute&lt;/code> in the  &#xA; * &lt;code>JdbcRowSet&lt;/code> reference implementation differs from that in the &#xA; * &lt;code>CachedRowSet&lt;/code>&lt;sup>&lt;font size=-2>TM&lt;/font>&lt;/sup> &#xA; * reference implementation to account for the different&#xA; * requirements of connected and disconnected &lt;code>RowSet&lt;/code> objects.&#xA; * &lt;p>&#xA; *&#xA; * @author Jonathan Bruce&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../RowSet.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Joinable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
