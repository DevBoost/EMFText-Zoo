<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/types ../../java.ecore#/16" name="Doc.java">
  <comments>/*&#xA; * @(#)Doc.java&#x9;1.7 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>print</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/io/InputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/io/Reader.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/io/UnsupportedEncodingException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>print</namespaces>
    <namespaces>attribute</namespaces>
    <classifier xsi:type="classifiers:Interface" href="attribute/AttributeSet.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>print</namespaces>
    <namespaces>attribute</namespaces>
    <classifier xsi:type="classifiers:Interface" href="attribute/DocAttributeSet.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="Doc">
    <members xsi:type="members:InterfaceMethod" name="getDocFlavor">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DocFlavor.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines the doc flavor in which this doc object will supply its&#xA;     * piece of print data. &#xA;     *&#xA;     * @return  Doc flavor.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPrintData">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the print data representation object that contains this doc &#xA;     * object's piece of print data in the format corresponding to the&#xA;     * supported doc flavor.&#xA;     * The &lt;CODE>getPrintData()&lt;/CODE> method returns an instance of &#xA;     * the representation class whose name is given by &lt;CODE>{@link &#xA;     * #getDocFlavor() getDocFlavor()}.{@link &#xA;     * DocFlavor#getRepresentationClassName() &#xA;     * getRepresentationClassName()}&lt;/CODE>, and the return value can be cast &#xA;     * from class Object to that representation class. &#xA;     *&#xA;     * @return  Print data representation object. &#xA;     *&#xA;     * @exception  IOException&#xA;     *     Thrown if the representation class is a stream and there was an I/O &#xA;     *     error while constructing the stream. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAttributes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="attribute/DocAttributeSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the set of printing attributes for this doc object. If the &#xA;     * returned attribute set includes an instance of a particular attribute &#xA;     * &lt;I>X,&lt;/I> the printer must use that attribute value for this doc, &#xA;     * overriding any value of attribute &lt;I>X&lt;/I> in the job's attribute set. &#xA;     * If the returned attribute set does not include an instance &#xA;     * of a particular attribute &lt;I>X&lt;/I> or if null is returned, the printer &#xA;     * must consult the job's attribute set to obtain the value for &#xA;     * attribute &lt;I>X,&lt;/I> and if not found there, the printer must use an &#xA;     * implementation-dependent default value. The returned attribute set is &#xA;     * unmodifiable. &#xA;     *&#xA;     * @return  Unmodifiable set of printing attributes for this doc, or null&#xA;     *          to obtain all attribute values from the job's attribute &#xA;     *          set. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getReaderForText">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/Reader.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains a reader for extracting character print data from this doc.&#xA;     * The Doc implementation is required to support this method if the &#xA;     * DocFlavor has one of the following print data representation classes,&#xA;     * and return null otherwise:&#xA;     * &lt;UL>&#xA;     * &lt;LI> char[]&#xA;     * &lt;LI> java.lang.String&#xA;     * &lt;LI> java.io.Reader&#xA;     * &lt;/UL>&#xA;     * The doc's print data representation object is used to construct and&#xA;     * return a Reader for reading the print data as a stream of characters&#xA;     * from the print data representation object.&#xA;     * However, if the print data representation object is itself a Reader,&#xA;     * then the print data representation object is simply returned.&#xA;     * &lt;P>&#xA;     * @return  Reader for reading the print data characters from this doc.&#xA;     *          If a reader cannot be provided because this doc does not meet&#xA;     *          the criteria stated above, null is returned. &#xA;     *&#xA;     * @exception  IOException&#xA;     *     Thrown if there was an I/O error while creating the reader.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getStreamForBytes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/InputStream.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains an input stream for extracting byte print data from this&#xA;     * doc.  The Doc implementation is required to support this method if&#xA;     * the DocFlavor has one of the following print data representation&#xA;     * classes, and return null otherwise:&#xA;     * &lt;UL>&#xA;     * &lt;LI> byte[]&#xA;     * &lt;LI> java.io.InputStream&#xA;     * &lt;/UL>&#xA;     * This doc's print data representation object is obtained, then an input &#xA;     * stream for reading the print data from the print data representation &#xA;     * object as a stream of bytes is created and returned. However, if the &#xA;     * print data representation object is itself an input stream, then the &#xA;     * print data representation object is simply returned. &#xA;     * &lt;P>&#xA;     * @return  Input stream for reading the print data bytes from this doc. If&#xA;     *          an input stream cannot be provided because this doc does not &#xA;     *          meet the criteria stated above, null is returned. &#xA;     *&#xA;     * @exception  IOException&#xA;     *     Thrown if there was an I/O error while creating the input stream.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Interface Doc specifies the interface for an object that supplies one piece &#xA; * of print data for a Print Job. &quot;Doc&quot; is a short, easy-to-pronounce term     &#xA; * that means &quot;a piece of print data.&quot; The client passes to the Print Job an&#xA; * object that implements interface Doc, and the Print Job calls methods on&#xA; * that object to obtain the print data. The Doc interface lets a Print Job: &#xA; * &lt;UL>&#xA; * &lt;LI>&#xA; * Determine the format, or &quot;doc flavor&quot; (class {@link DocFlavor DocFlavor}),&#xA; * in which the print data is available. A doc flavor designates the print &#xA; * data format (a MIME type) and the representation class of the object&#xA; * from which the print data comes. &#xA; * &lt;P>&#xA; * &lt;LI>&#xA; * Obtain the print data representation object, which is an instance of the  &#xA; * doc flavor's representation class. The Print Job can then obtain the actual&#xA; * print data from the representation object.&#xA; * &lt;P>&#xA; * &lt;LI>&#xA; * Obtain the printing attributes that specify additional characteristics of  &#xA; * the doc or that specify processing instructions to be applied to the doc. &#xA; * Printing attributes are defined in package {@link javax.print.attribute &#xA; * javax.print.attribute}. The doc returns its printing attributes stored in &#xA; * an {@link javax.print.attribute.DocAttributeSet javax.print.attribute.DocAttributeSet}. &#xA; * &lt;/UL>&#xA; * &lt;P>&#xA; * Each method in an implementation of interface Doc is permitted always to &#xA; * return the same object each time the method is called.&#xA; * This has implications &#xA; * for a Print Job or other caller of a doc object whose print data &#xA; * representation object &quot;consumes&quot; the print data as the caller obtains the &#xA; * print data, such as a print data representation object which is a stream. &#xA; * Once the Print Job has called {@link #getPrintData() &#xA; * &lt;CODE>getPrintData()&lt;/CODE>} and obtained the stream, any further calls to &#xA; * {@link #getPrintData() &lt;CODE>getPrintData()&lt;/CODE>} will return the same &#xA; * stream object upon which reading may already be in progress, &lt;I>not&lt;/I> a new &#xA; * stream object that will re-read the print data from the beginning. Specifying &#xA; * a doc object to behave this way simplifies the implementation of doc objects, &#xA; * and is justified on the grounds that a particular doc is intended to convey &#xA; * print data only to one Print Job, not to several different Print Jobs. (To &#xA; * convey the same print data to several different Print Jobs, you have to &#xA; * create several different doc objects on top of the same print data source.) &#xA; * &lt;P>&#xA; * Interface Doc affords considerable implementation flexibility. The print data &#xA; * might already be in existence when the doc object is constructed. In this &#xA; * case the objects returned by the doc's methods can be supplied to the doc's &#xA; * constructor, be stored in the doc ahead of time, and simply be returned when &#xA; * called for. Alternatively, the print data might not exist yet when the doc &#xA; * object is constructed. In this case the doc object might provide a &quot;lazy&quot; &#xA; * implementation that generates the print data representation object (and/or &#xA; * the print data) only when the Print Job calls for it (when the Print Job &#xA; * calls the {@link #getPrintData() &lt;CODE>getPrintData()&lt;/CODE>} method). &#xA; * &lt;P>&#xA; * There is no restriction on the number of client threads that may be &#xA; * simultaneously accessing the same doc. Therefore, all implementations of &#xA; * interface Doc must be designed to be multiple thread safe. &#xA; * &lt;p>&#xA; * However there can only be one consumer of the print data obtained from a&#xA; * Doc.&#xA; * &lt;p>&#xA; * If print data is obtained from the client as a stream, by calling Doc's&#xA; * &lt;code>getReaderForText()&lt;/code> or &lt;code>getStreamForBytes()&lt;/code>&#xA; * methods, or because the print data source is already an InputStream or&#xA; * Reader, then the print service should always close these streams for the&#xA; * client on all job completion conditions. With the following caveat.&#xA; * If the print data is itself a stream, the service will always close it.&#xA; * If the print data is otherwise something that can be requested as a stream,&#xA; * the service will only close the stream if it has obtained the stream before&#xA; * terminating. That is, just because a print service might request data as&#xA; * a stream does not mean that it will, with the implications that Doc&#xA; * implementors which rely on the service to close them should create such&#xA; * streams only in response to a request from the service.&#xA; * &lt;P>&#xA; * &lt;HR>&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
