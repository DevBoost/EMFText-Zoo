<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="EnumSyntax.java">
  <comments>/*&#xA; * @(#)EnumSyntax.java&#x9;1.5 04/01/07&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>print</namespaces>
  <namespaces>attribute</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/io/InvalidObjectException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/io/ObjectStreamException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../java/io/Serializable.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="EnumSyntax">
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="2739521845085831642"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="value">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * This enumeration value's integer value.&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="EnumSyntax">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Construct a new enumeration value with the given integer value.&#xA;     *&#xA;     * @param  value  Integer value.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getValue">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns this enumeration value's integer value.&#xA;     * @return the value&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a clone of this enumeration value, which to preserve the &#xA;     * semantics of enumeration values is the same object as this enumeration &#xA;     * value. &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a hash code value for this enumeration value. The hash code is&#xA;     * just this enumeration value's integer value.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string value corresponding to this enumeration value.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="theTable">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.8"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="theIndex">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.10"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </children>
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.1/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </children>
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </children>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.1/@variable"/>
            </arraySelectors>
          </expressionIf>
          <expressionElse xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../java/lang/Integer.class.xmi#//@classifiers.0/@members.15"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Integer.class.xmi#//@classifiers.0"/>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readResolve">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/ObjectStreamException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * During object input, convert this deserialized enumeration instance to&#xA;     * the proper enumeration value defined in the enumeration attribute class.&#xA;     *&#xA;     * @return  The enumeration singleton value stored at index&#xA;     *          &lt;I>i&lt;/I>-&lt;I>L&lt;/I> in the enumeration value table returned by &#xA;     *          {@link #getEnumValueTable() &lt;CODE>getEnumValueTable()&lt;/CODE>}, &#xA;     *          where &lt;I>i&lt;/I> is this enumeration value's integer value and &#xA;     *          &lt;I>L&lt;/I> is the value returned by {@link #getOffset() &#xA;     *          &lt;CODE>getOffset()&lt;/CODE>}. &#xA;     *&#xA;     * @throws ObjectStreamException if the stream can't be deserialised&#xA;     * @throws  InvalidObjectException&#xA;     *     Thrown if the enumeration value table is null, this enumeration &#xA;     *     value's integer value does not correspond to an element in the &#xA;     *     enumeration value table, or the corresponding element in the &#xA;     *     enumeration value table is null. (Note: {@link &#xA;     *     java.io.InvalidObjectException InvalidObjectException} is a subclass &#xA;     *     of {@link java.io.ObjectStreamException ObjectStreamException}, which &#xA;     *     &lt;CODE>readResolve()&lt;/CODE> is declared to throw.) &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="theTable">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.9"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/io/InvalidObjectException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Null enumeration value table for class "/>
                <children xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/Object.class.xmi#//@classifiers.0/@members.2"/>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="theOffset">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.10"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="theIndex">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/io/InvalidObjectException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Integer value = "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <children xsi:type="references:StringReference" value=" not in valid range "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable"/>
                <children xsi:type="references:StringReference" value=".."/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable">
                      <next xsi:type="references:IdentifierReference"/>
                    </children>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Subtraction"/>
                  </expression>
                </children>
                <children xsi:type="references:StringReference" value="for class "/>
                <children xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/Object.class.xmi#//@classifiers.0/@members.2"/>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.3/@variable"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.3/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.3/@variable"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/io/InvalidObjectException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="No enumeration value for integer value = "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <children xsi:type="references:StringReference" value="for class "/>
                <children xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/Object.class.xmi#//@classifiers.0/@members.2"/>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.5/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.5/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getStringTable">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>// Hidden operations to be implemented in a subclass.</comments>
        <comments>/**&#xA;     * Returns the string table for this enumeration value's enumeration class. &#xA;     * The enumeration class's integer values are assumed to lie in the range &#xA;     * &lt;I>L&lt;/I>..&lt;I>L&lt;/I>+&lt;I>N&lt;/I>-1, where &lt;I>L&lt;/I> is the value returned by &#xA;     * {@link #getOffset() &lt;CODE>getOffset()&lt;/CODE>} and &lt;I>N&lt;/I> is the length &#xA;     * of the string table. The element in the string table at index &#xA;     * &lt;I>i&lt;/I>-&lt;I>L&lt;/I> is the value returned by {@link #toString() &#xA;     * &lt;CODE>toString()&lt;/CODE>} for the enumeration value whose integer value &#xA;     * is &lt;I>i&lt;/I>. If an integer within the above range is not used by any &#xA;     * enumeration value, leave the corresponding table element null. &#xA;     * &lt;P>&#xA;     * The default implementation returns null. If the enumeration class (a &#xA;     * subclass of class EnumSyntax) does not override this method to return a &#xA;     * non-null string table, and the subclass does not override the {@link &#xA;     * #toString() &lt;CODE>toString()&lt;/CODE>} method, the base class {@link &#xA;     * #toString() &lt;CODE>toString()&lt;/CODE>} method will return just a string &#xA;     * representation of this enumeration value's integer value. &#xA;     * @return the string table&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getEnumValueTable">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns the enumeration value table for this enumeration value's &#xA;     * enumeration class. The enumeration class's integer values are assumed to &#xA;     * lie in the range &lt;I>L&lt;/I>..&lt;I>L&lt;/I>+&lt;I>N&lt;/I>-1, where &lt;I>L&lt;/I> is the &#xA;     * value returned by {@link #getOffset() &lt;CODE>getOffset()&lt;/CODE>} and &#xA;     * &lt;I>N&lt;/I> is the length of the enumeration value table. The element in the &#xA;     * enumeration value table at index &lt;I>i&lt;/I>-&lt;I>L&lt;/I> is the enumeration &#xA;     * value object whose integer value is &lt;I>i&lt;/I>; the {@link #readResolve() &#xA;     * &lt;CODE>readResolve()&lt;/CODE>} method needs this to preserve singleton &#xA;     * semantics during deserialization of an enumeration instance. If an &#xA;     * integer within the above range is not used by any enumeration value, &#xA;     * leave the corresponding table element null. &#xA;     * &lt;P>&#xA;     * The default implementation returns null. If the enumeration class (a &#xA;     * subclass of class EnumSyntax) does not override this method to return &#xA;     * a non-null enumeration value table, and the subclass does not override &#xA;     * the {@link #readResolve() &lt;CODE>readResolve()&lt;/CODE>} method, the base &#xA;     * class {@link #readResolve() &lt;CODE>readResolve()&lt;/CODE>} method will throw &#xA;     * an exception whenever an enumeration instance is deserialized from an &#xA;     * object input stream. &#xA;     * @return the value table&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getOffset">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns the lowest integer value used by this enumeration value's&#xA;     * enumeration class.&#xA;     * &lt;P>&#xA;     * The default implementation returns 0. If the enumeration class (a &#xA;     * subclass of class EnumSyntax) uses integer values starting at other than &#xA;     * 0, override this method in the subclass. &#xA;     * @return the offset of the lowest enumeration value.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Class EnumSyntax is an abstract base class providing the common &#xA; * implementation of all &quot;type safe enumeration&quot; objects. An enumeration class &#xA; * (which extends class EnumSyntax) provides a group of enumeration values &#xA; * (objects) that are singleton instances of the enumeration class; for example: &#xA; * &lt;PRE>&#xA; *     public class Bach extends EnumSyntax {&#xA; *         public static final Bach JOHANN_SEBASTIAN     = new Bach(0);&#xA; *         public static final Bach WILHELM_FRIEDEMANN   = new Bach(1);&#xA; *         public static final Bach CARL_PHILIP_EMMANUEL = new Bach(2);&#xA; *         public static final Bach JOHANN_CHRISTIAN     = new Bach(3);&#xA; *         public static final Bach P_D_Q                = new Bach(4);&#xA; *&#xA; *         private static final String[] stringTable = {&#xA; *             &quot;Johann Sebastian Bach&quot;,&#xA; *              &quot;Wilhelm Friedemann Bach&quot;,&#xA; *              &quot;Carl Philip Emmanuel Bach&quot;,&#xA; *              &quot;Johann Christian Bach&quot;,&#xA; *              &quot;P.D.Q. Bach&quot;&#xA; *         };&#xA; *&#xA; *         protected String[] getStringTable() {&#xA; *             return stringTable;&#xA; *         }&#xA; *&#xA; *         private static final Bach[] enumValueTable = {&#xA; *             JOHANN_SEBASTIAN,&#xA; *              WILHELM_FRIEDEMANN,&#xA; *              CARL_PHILIP_EMMANUEL,&#xA; *              JOHANN_CHRISTIAN,&#xA; *              P_D_Q&#xA; *         };&#xA; *&#xA; *         protected EnumSyntax[] getEnumValueTable() {&#xA; *             return enumValueTable;&#xA; *         }&#xA; *     }&#xA; * &lt;/PRE>&#xA; * You can then write code that uses the &lt;CODE>==&lt;/CODE> and &lt;CODE>!=&lt;/CODE> &#xA; * operators to test enumeration values; for example: &#xA; * &lt;PRE>&#xA; *     Bach theComposer;&#xA; *     . . .&#xA; *     if (theComposer == Bach.JOHANN_SEBASTIAN) {&#xA; *         System.out.println (&quot;The greatest composer of all time!&quot;);&#xA; *     }&#xA; * &lt;/PRE>&#xA; * The &lt;CODE>equals()&lt;/CODE> method for an enumeration class just does a test &#xA; * for identical objects (&lt;CODE>==&lt;/CODE>). &#xA; * &lt;P>&#xA; * You can convert an enumeration value to a string by calling {@link &#xA; * #toString() &lt;CODE>toString()&lt;/CODE>}. The string is obtained from a table &#xA; * supplied by the enumeration class.&#xA; * &lt;P>&#xA; * Under the hood, an enumeration value is just an integer, a different integer &#xA; * for each enumeration value within an enumeration class. You can get an &#xA; * enumeration value's integer value by calling {@link #getValue() &#xA; * &lt;CODE>getValue()&lt;/CODE>}. An enumeration value's integer value is established &#xA; * when it is constructed (see {@link #EnumSyntax(int) &#xA; * &lt;CODE>EnumSyntax(int)&lt;/CODE>}). Since the constructor is protected, the only &#xA; * possible enumeration values are the singleton objects declared in the &#xA; * enumeration class; additional enumeration values cannot be created at run &#xA; * time. &#xA; * &lt;P>&#xA; * You can define a subclass of an enumeration class that extends it with &#xA; * additional enumeration values. The subclass's enumeration values' integer &#xA; * values need not be distinct from the superclass's enumeration values' integer &#xA; * values; the &lt;CODE>==&lt;/CODE>, &lt;CODE>!=&lt;/CODE>, &lt;CODE>equals()&lt;/CODE>, and &#xA; * &lt;CODE>toString()&lt;/CODE> methods will still work properly even if the subclass &#xA; * uses some of the same integer values as the superclass. However, the &#xA; * application in which the enumeration class and subclass are used may need to &#xA; * have distinct integer values in the superclass and subclass. &#xA; * &lt;P>&#xA; *&#xA; * @author  David Mendenhall&#xA; * @author  Alan Kaminsky&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../../java/io/Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../../java/lang/Cloneable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
