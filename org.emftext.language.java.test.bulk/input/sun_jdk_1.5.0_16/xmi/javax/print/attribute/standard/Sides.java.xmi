<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../../java.ecore#/5 http://www.emftext.org/java/generics ../../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../../java.ecore#/9 http://www.emftext.org/java/members ../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../../java.ecore#/13 http://www.emftext.org/java/references ../../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../../java.ecore#/15 http://www.emftext.org/java/types ../../../../java.ecore#/16" name="Sides.java">
  <comments>/*&#xA; * @(#)Sides.java&#x9;1.8 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>print</namespaces>
  <namespaces>attribute</namespaces>
  <namespaces>standard</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>print</namespaces>
    <namespaces>attribute</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../Attribute.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>print</namespaces>
    <namespaces>attribute</namespaces>
    <classifier xsi:type="classifiers:Class" href="../EnumSyntax.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>print</namespaces>
    <namespaces>attribute</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../DocAttribute.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>print</namespaces>
    <namespaces>attribute</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../PrintRequestAttribute.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>print</namespaces>
    <namespaces>attribute</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../PrintJobAttribute.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Sides">
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="6890309414893262822"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ONE_SIDED">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Imposes each consecutive print-stream page upon the same side of &#xA;     * consecutive media sheets. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="TWO_SIDED_LONG_EDGE">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Imposes each consecutive pair of print-stream pages upon front and back &#xA;     * sides of consecutive media sheets, such that the orientation of each&#xA;     * pair of print-stream pages on the medium would be correct for the&#xA;     * reader as if for binding on the long edge. This imposition is also&#xA;     * known as &quot;duplex&quot; (see {@link #DUPLEX &lt;CODE>DUPLEX&lt;/CODE>}). &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="TWO_SIDED_SHORT_EDGE">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Imposes each consecutive pair of print-stream pages upon front and back &#xA;     * sides of consecutive media sheets, such that the orientation of each&#xA;     * pair of print-stream pages on the medium would be correct for the&#xA;     * reader as if for binding on the short edge. This imposition is also&#xA;     * known as &quot;tumble&quot; (see {@link #TUMBLE &lt;CODE>TUMBLE&lt;/CODE>}). &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DUPLEX">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An alias for &quot;two sided long edge&quot; (see {@link #TWO_SIDED_LONG_EDGE &#xA;     * &lt;CODE>TWO_SIDED_LONG_EDGE&lt;/CODE>}). &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="TUMBLE">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An alias for &quot;two sided short edge&quot; (see {@link #TWO_SIDED_SHORT_EDGE &#xA;     * &lt;CODE>TWO_SIDED_SHORT_EDGE&lt;/CODE>}). &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="Sides">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Construct a new sides enumeration value with the given integer value. &#xA;     *&#xA;     * @param  value  Integer value.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="myStringTable">
      <initialValue xsi:type="arrays:ArrayInstantiationByValues">
        <arrayInitializer>
          <initialValues xsi:type="references:StringReference" value="one-sided"/>
          <initialValues xsi:type="references:StringReference" value="two-sided-long-edge"/>
          <initialValues xsi:type="references:StringReference" value="two-sided-short-edge"/>
        </arrayInitializer>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="myEnumValueTable">
      <initialValue xsi:type="arrays:ArrayInstantiationByValues">
        <arrayInitializer>
          <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
        </arrayInitializer>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getStringTable">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns the string table for class Sides.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getEnumValueTable">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../EnumSyntax.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns the enumeration value table for class Sides.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCategory">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:ExtendsTypeArgument">
            <extendTypes xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Interface" href="../Attribute.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </extendTypes>
          </typeArguments>
          <target xsi:type="classifiers:Class" href="../../../../java/lang/Class.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Get the printing attribute class which is to be used as the &quot;category&quot; &#xA;     * for this printing attribute value.&#xA;     * &lt;P>&#xA;     * For class Sides, the category is class Sides itself. &#xA;     *&#xA;     * @return  Printing attribute class (category), an instance of class&#xA;     *          {@link java.lang.Class java.lang.Class}.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
          <next xsi:type="references:ReflectiveClassReference"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Get the name of the category of which this attribute value is an &#xA;     * instance. &#xA;     * &lt;P>&#xA;     * For class Sides, the category name is &lt;CODE>&quot;sides&quot;&lt;/CODE>. &#xA;     *&#xA;     * @return  Attribute category name.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:StringReference" value="sides"/>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Class Sides is a printing attribute class, an enumeration, that specifies&#xA; * how print-stream pages are to be imposed upon the sides of an instance of a &#xA; * selected medium, i.e., an impression. &#xA; * &lt;P>&#xA; * The effect of a Sides attribute on a multidoc print job (a job with multiple &#xA; * documents) depends on whether all the docs have the same sides values &#xA; * specified or whether different docs have different sides values specified, &#xA; * and on the (perhaps defaulted) value of the {@link MultipleDocumentHandling &#xA; * MultipleDocumentHandling} attribute. &#xA; * &lt;UL>&#xA; * &lt;LI>&#xA; * If all the docs have the same sides value &lt;I>n&lt;/I> specified, then any value &#xA; * of {@link MultipleDocumentHandling MultipleDocumentHandling} makes sense,&#xA; * and the printer's processing depends on the {@link MultipleDocumentHandling &#xA; * MultipleDocumentHandling} value: &#xA; * &lt;UL>&#xA; * &lt;LI>&#xA; * SINGLE_DOCUMENT -- All the input docs will be combined together into one &#xA; * output document. Each media sheet will consist of &lt;I>n&lt;/I> impressions from &#xA; * the output document. &#xA; * &lt;P>&#xA; * &lt;LI>&#xA; * SINGLE_DOCUMENT_NEW_SHEET -- All the input docs will be combined together &#xA; * into one output document. Each media sheet will consist of &lt;I>n&lt;/I> &#xA; * impressions from the output document. However, the first impression of each &#xA; * input doc will always start on a new media sheet; this means the last media &#xA; * sheet of an input doc may have only one impression on it. &#xA; * &lt;P>&#xA; * &lt;LI>&#xA; * SEPARATE_DOCUMENTS_UNCOLLATED_COPIES -- The input docs will remain separate. &#xA; * Each media sheet will consist of &lt;I>n&lt;/I> impressions from the input doc. &#xA; * Since the input docs are separate, the first impression of each input doc &#xA; * will always start on a new media sheet; this means the last media sheet of&#xA; * an input doc may have only one impression on it. &#xA; * &lt;P>&#xA; * &lt;LI>&#xA; * SEPARATE_DOCUMENTS_COLLATED_COPIES -- The input docs will remain separate. &#xA; * Each media sheet will consist of &lt;I>n&lt;/I> impressions from the input doc. &#xA; * Since the input docs are separate, the first impression of each input doc &#xA; * will always start on a new media sheet; this means the last media sheet of&#xA; * an input doc may have only one impression on it. &#xA; * &lt;/UL> &#xA; * &lt;P>&#xA; * &lt;UL>&#xA; * &lt;LI>&#xA; * SINGLE_DOCUMENT -- All the input docs will be combined together into one &#xA; * output document. Each media sheet will consist of &lt;I>n&lt;SUB>i&lt;/SUB>&lt;/I> &#xA; * impressions from the output document, where &lt;I>i&lt;/I> is the number of the &#xA; * input doc corresponding to that point in the output document. When the next &#xA; * input doc has a different sides value from the previous input doc, the first &#xA; * print-stream page of the next input doc goes at the start of the next media &#xA; * sheet, possibly leaving only one impression on the previous media sheet. &#xA; * &lt;P>&#xA; * &lt;LI>&#xA; * SINGLE_DOCUMENT_NEW_SHEET -- All the input docs will be combined together &#xA; * into one output document. Each media sheet will consist of &lt;I>n&lt;/I> &#xA; * impressions from the output document. However, the first impression of each &#xA; * input doc will always start on a new media sheet; this means the last &#xA; * impression of an input doc may have only one impression on it. &#xA; * &lt;P>&#xA; * &lt;LI>&#xA; * SEPARATE_DOCUMENTS_UNCOLLATED_COPIES -- The input docs will remain separate. &#xA; * For input doc &lt;I>i,&lt;/I> each media sheet will consist of &lt;I>n&lt;SUB>i&lt;/SUB>&lt;/I> &#xA; * impressions from the input doc. Since the input docs are separate, the first &#xA; * impression of each input doc will always start on a new media sheet; this &#xA; * means the last media sheet of an input doc may have only one impression on &#xA; * it. &#xA; * &lt;P>&#xA; * &lt;LI>&#xA; * SEPARATE_DOCUMENTS_COLLATED_COPIES -- The input docs will remain separate. &#xA; * For input doc &lt;I>i,&lt;/I> each media sheet will consist of &lt;I>n&lt;SUB>i&lt;/SUB>&lt;/I> &#xA; * impressions from the input doc. Since the input docs are separate, the first &#xA; * impression of each input doc will always start on a new media sheet; this &#xA; * means the last media sheet of an input doc may have only one impression on &#xA; * it. &#xA; * &lt;/UL>&#xA; * &lt;/UL>&#xA; * &lt;P>&#xA; * &lt;B>IPP Compatibility:&lt;/B> The category name returned by &#xA; * &lt;CODE>getName()&lt;/CODE> is the IPP attribute name.  The enumeration's &#xA; * integer value is the IPP enum value.  The &lt;code>toString()&lt;/code> method &#xA; * returns the IPP string representation of the attribute value.&#xA; * &lt;P>&#xA; *&#xA; * @author  Alan Kaminsky&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Final"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../DocAttribute.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../PrintRequestAttribute.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../PrintJobAttribute.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="../EnumSyntax.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
