<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16 http://www.emftext.org/java/variables ../../../java.ecore#/17" name="TabularDataSupport.java">
  <comments>/*&#xA; * @(#)TabularDataSupport.java&#x9;3.30 03/12/19&#xA; * &#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>management</namespaces>
  <namespaces>openmbean</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <comments>// java import</comments>
    <comments>//</comments>
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../java/io/Serializable.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/io/ObjectInputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../java/util/Iterator.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/util/HashMap.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../java/util/Map.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../java/util/Set.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../java/util/Collection.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/util/Collections.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/util/Arrays.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/util/ArrayList.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../java/util/List.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="TabularDataSupport">
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="5720150593236309827"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/* Serial version */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="dataMap">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../java/util/Map.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * @serial This tabular data instance's contents: a {@link HashMap}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="tabularType">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TabularType.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * @serial This tabular data instance's tabular type&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="indexNamesArray">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * @serial The array of item names that define the index used for rows (convenience field)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Constructor" name="TabularDataSupport">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="101"/>
          <arguments xsi:type="literals:DecimalFloatLiteral" decimalValue="0.75"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tabularType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TabularType.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* *** Constructors *** */</comments>
        <comments>/**&#xA;     * Creates an empty &lt;tt>TabularDataSupport&lt;/tt> instance whose open-type is &lt;var>tabularType&lt;/var>, &#xA;     * and whose underlying &lt;tt>HashMap&lt;/tt> has a default initial capacity (101) and default load factor (0.75).&#xA;     * &lt;p>&#xA;     * This constructor simply calls &lt;tt>this(tabularType, 101, 0.75f);&lt;/tt>&#xA;     *&#xA;     * @param  tabularType &#x9;&#x9; the &lt;i>tabular type&lt;/i> describing this &lt;tt>TabularData&lt;/tt> instance;&#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9; cannot be null.&#xA;     *&#xA;     * @throws IllegalArgumentException  if the tabular type is null. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="TabularDataSupport">
      <statements xsi:type="statements:Condition">
        <comments>// Check tabularType is not null</comments>
        <comments>//</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Argument tabularType cannot be null."/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This">
              <comments>// Initialize this.tabularType (and indexNamesArray for convenience)</comments>
              <comments>//</comments>
            </self>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="tmpNames">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../../java/util/List.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="TabularType.class.xmi#//@classifiers.0/@members.9"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@statements.2/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../../../java/util/List.class.xmi#//@classifiers.0/@members.5"/>
                <arguments xsi:type="arrays:ArrayInstantiationBySize">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@statements.2/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="../../../java/util/List.class.xmi#//@classifiers.0/@members.0"/>
                    </next>
                  </sizes>
                </arguments>
              </next>
            </child>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This">
              <comments>// Construct the empty contents HashMap</comments>
              <comments>//</comments>
            </self>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/util/HashMap.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.2"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tabularType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TabularType.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="initialCapacity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="loadFactor">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an empty &lt;tt>TabularDataSupport&lt;/tt> instance whose open-type is &lt;var>tabularType&lt;/var>, &#xA;     * and whose underlying &lt;tt>HashMap&lt;/tt> has the specified initial capacity and load factor.&#xA;     *&#xA;     * @param  tabularType&#x9;&#x9; the &lt;i>tabular type&lt;/i> describing this &lt;tt>TabularData&lt;/tt> instance;&#xA;     *&#x9;&#x9;&#x9;&#x9; cannot be null.&#xA;     *&#xA;     * @param  initialCapacity   the initial capacity of the HashMap.&#xA;     * &#xA;     * @param  loadFactor        the load factor of the HashMap&#xA;     * &#xA;     * @throws IllegalArgumentException  if the initial capacity is less than zero, &#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9; or the load factor is nonpositive,&#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9; or the tabular type is null.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getTabularType">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TabularType.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* *** TabularData specific information methods *** */</comments>
        <comments>/**&#xA;     * Returns the &lt;i>tabular type&lt;/i> describing this &lt;tt>TabularData&lt;/tt> instance.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="calculateIndex">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Calculates the index that would be used in this &lt;tt>TabularData&lt;/tt> instance to refer to the specified&#xA;     * composite data &lt;var>value&lt;/var> parameter if it were added to this instance.&#xA;     * This method checks for the type validity of the specified &lt;var>value&lt;/var>, &#xA;     * but does not check if the calculated index is already used to refer to a value in this &lt;tt>TabularData&lt;/tt> instance.&#xA;     *&#xA;     * @param  value&#x9;&#x9;&#x9;  the composite data value whose index in this &#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;  &lt;tt>TabularData&lt;/tt> instance is to be calculated;&#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;  must be of the same composite type as this instance's row type;&#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;  must not be null.&#xA;     *&#xA;     * @return the index that the specified &lt;var>value&lt;/var> would have in this &lt;tt>TabularData&lt;/tt> instance.&#xA;     * &#xA;     * @throws NullPointerException       if &lt;var>value&lt;/var> is &lt;tt>null&lt;/tt>. &#xA;     * &#xA;     * @throws InvalidOpenTypeException   if &lt;var>value&lt;/var> does not conform to this &lt;tt>TabularData&lt;/tt> instance's &#xA;     *&#x9;&#x9;&#x9;&#x9;          row type definition.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.32">
          <comments>// Check value is valid</comments>
          <comments>//</comments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// Return its calculated index</comments>
        <comments>//</comments>
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.30">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../../java/util/List.class.xmi#//@classifiers.0/@members.4"/>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="containsKey">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* *** Content information query methods *** */</comments>
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if and only if this &lt;tt>TabularData&lt;/tt> instance contains a &lt;tt>CompositeData&lt;/tt> value &#xA;     * (ie a row) whose index is the specified &lt;var>key&lt;/var>. If &lt;var>key&lt;/var> cannot be cast to a one dimension array&#xA;     * of Object instances, this method simply returns &lt;tt>false&lt;/tt>; otherwise it returns the the result of the call to&#xA;     * &lt;tt>this.containsKey((Object[]) key)&lt;/tt>.&#xA;     * &#xA;     * @param  key  the index value whose presence in this &lt;tt>TabularData&lt;/tt> instance is to be tested.&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if this &lt;tt>TabularData&lt;/tt> indexes a row value with the specified key.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="k">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// if key is not an array of Object instances, return false</comments>
              <comments>//</comments>
              <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arrayDimensionsBefore/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
            </value>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/lang/ClassCastException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.9">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
          </next>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="containsKey">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if and only if this &lt;tt>TabularData&lt;/tt> instance contains a &lt;tt>CompositeData&lt;/tt> value &#xA;     * (ie a row) whose index is the specified &lt;var>key&lt;/var>. If &lt;var>key&lt;/var> is &lt;tt>null&lt;/tt> or does not conform to&#xA;     * this &lt;tt>TabularData&lt;/tt> instance's &lt;tt>TabularType&lt;/tt> definition, this method simply returns &lt;tt>false&lt;/tt>.&#xA;     * &#xA;     * @param  key  the index value whose presence in this &lt;tt>TabularData&lt;/tt> instance is to be tested.&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if this &lt;tt>TabularData&lt;/tt> indexes a row value with the specified key.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </child>
            <expressionIf xsi:type="literals:BooleanLiteral"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.2"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../java/util/Arrays.class.xmi#//@classifiers.0/@members.93"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../../../java/util/Arrays.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
            </expressionElse>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="containsValue">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if and only if this &lt;tt>TabularData&lt;/tt> instance contains the specified&#xA;     * &lt;tt>CompositeData&lt;/tt> value. If &lt;var>value&lt;/var> is &lt;tt>null&lt;/tt> or does not conform to&#xA;     * this &lt;tt>TabularData&lt;/tt> instance's row type definition, this method simply returns &lt;tt>false&lt;/tt>.&#xA;     *&#xA;     * @param  value  the row value whose presence in this &lt;tt>TabularData&lt;/tt> instance is to be tested.&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if this &lt;tt>TabularData&lt;/tt> instance contains the specified row value.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="containsValue">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if and only if this &lt;tt>TabularData&lt;/tt> instance contains the specified&#xA;     * value.&#xA;     *&#xA;     * @param  value  the row value whose presence in this &lt;tt>TabularData&lt;/tt> instance is to be tested.&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if this &lt;tt>TabularData&lt;/tt> instance contains the specified row value.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * This method simply calls &lt;tt>get((Object[]) key)&lt;/tt>.&#xA;     *&#xA;     * @throws NullPointerException  if the &lt;var>key&lt;/var> is &lt;tt>null&lt;/tt> &#xA;     * @throws ClassCastException    if the &lt;var>key&lt;/var> is not of the type &lt;tt>Object[]&lt;/tt>&#xA;     * @throws InvalidKeyException   if the &lt;var>key&lt;/var> does not conform to this &lt;tt>TabularData&lt;/tt> instance's &#xA;     *&#x9;&#x9;&#x9;&#x9;     &lt;tt>TabularType&lt;/tt> definition &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;tt>CompositeData&lt;/tt> value whose index is&#xA;     * &lt;var>key&lt;/var>, or &lt;tt>null&lt;/tt> if there is no value mapping&#xA;     * to &lt;var>key&lt;/var>, in this &lt;tt>TabularData&lt;/tt> instance.&#xA;     *&#xA;     * @param key the index of the value to get in this&#xA;     * &lt;tt>TabularData&lt;/tt> instance; * must be valid with this&#xA;     * &lt;tt>TabularData&lt;/tt> instance's row type definition; * must not&#xA;     * be null.&#xA;     *&#xA;     * @return the value corresponding to &lt;var>key&lt;/var>.&#xA;     * &#xA;     * @throws NullPointerException  if the &lt;var>key&lt;/var> is &lt;tt>null&lt;/tt> &#xA;     * @throws InvalidKeyException   if the &lt;var>key&lt;/var> does not conform to this &lt;tt>TabularData&lt;/tt> instance's &#xA;     *&#x9;&#x9;&#x9;&#x9;     &lt;tt>TabularType&lt;/tt> type definition.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
          <comments>// Check key is not null and valid with tabularType </comments>
          <comments>// (throws NullPointerException, InvalidKeyException)</comments>
          <comments>//</comments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// Return the mapping stored in the parent HashMap</comments>
        <comments>//</comments>
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.4"/>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/util/Arrays.class.xmi#//@classifiers.0/@members.93"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../../java/util/Arrays.class.xmi#//@classifiers.0"/>
              </arguments>
            </next>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* *** Content modification operations (one element at a time) *** */</comments>
        <comments>/**&#xA;     * This method simply calls &lt;tt>put((CompositeData) value)&lt;/tt> and  &#xA;     * therefore ignores its &lt;var>key&lt;/var> parameter which can be &lt;tt>null&lt;/tt>.&#xA;     *&#xA;     * @param key an ignored parameter.&#xA;     * @param value the {@link CompositeData} to put.&#xA;     *&#xA;     * @return the value which is put&#xA;     *&#xA;     * @throws NullPointerException  if the &lt;var>value&lt;/var> is &lt;tt>null&lt;/tt> &#xA;     * @throws ClassCastException    if the &lt;var>value&lt;/var> is not of the type &lt;tt>CompositeData&lt;/tt>&#xA;     * @throws InvalidOpenTypeException   if the &lt;var>value&lt;/var> does not conform to this &lt;tt>TabularData&lt;/tt> instance's &#xA;     *&#x9;&#x9;&#x9;&#x9;          &lt;tt>TabularType&lt;/tt> definition &#xA;     * @throws KeyAlreadyExistsException   if the key for the &lt;var>value&lt;/var> parameter, calculated according to &#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;   this &lt;tt>TabularData&lt;/tt> instance's &lt;tt>TabularType&lt;/tt> definition &#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;   already maps to an existing value  &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="index">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Check value is not null, value's type is the same as this instance's row type, </comments>
              <comments>// and calculate the value's index according to this instance's tabularType and</comments>
              <comments>// check it is not already used for a mapping in the parent HashMap</comments>
              <comments>//</comments>
              <target xsi:type="classifiers:Interface" href="../../../java/util/List.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.33">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <comments>// store the (key, value) mapping in the dataMap HashMap</comments>
          <comments>//</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.5"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="remove">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * This method simply calls &lt;tt>remove((Object[]) key)&lt;/tt>.&#xA;     *&#xA;     * @param key an &lt;tt>Object[]&lt;/tt> representing the key to remove.&#xA;     *&#xA;     * @return previous value associated with specified key, or &lt;tt>null&lt;/tt>&#xA;     *&#x9;       if there was no mapping for key.  &#xA;     *&#xA;     * @throws NullPointerException  if the &lt;var>key&lt;/var> is &lt;tt>null&lt;/tt> &#xA;     * @throws ClassCastException    if the &lt;var>key&lt;/var> is not of the type &lt;tt>Object[]&lt;/tt>&#xA;     * @throws InvalidKeyException   if the &lt;var>key&lt;/var> does not conform to this &lt;tt>TabularData&lt;/tt> instance's &#xA;     *&#x9;&#x9;&#x9;&#x9;     &lt;tt>TabularType&lt;/tt> definition &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.17">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="remove">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes the &lt;tt>CompositeData&lt;/tt> value whose index is &lt;var>key&lt;/var> from this &lt;tt>TabularData&lt;/tt> instance,&#xA;     * and returns the removed value, or returns &lt;tt>null&lt;/tt> if there is no value whose index is &lt;var>key&lt;/var>.&#xA;     *&#xA;     * @param  key  the index of the value to get in this &lt;tt>TabularData&lt;/tt> instance;&#xA;     *&#x9;&#x9;    must be valid with this &lt;tt>TabularData&lt;/tt> instance's row type definition;&#xA;     *&#x9;&#x9;    must not be null.&#xA;     * &#xA;     * @return previous value associated with specified key, or &lt;tt>null&lt;/tt>&#xA;     *&#x9;       if there was no mapping for key.  &#xA;     *&#xA;     * @throws NullPointerException  if the &lt;var>key&lt;/var> is &lt;tt>null&lt;/tt> &#xA;     * @throws InvalidKeyException   if the &lt;var>key&lt;/var> does not conform to this &lt;tt>TabularData&lt;/tt> instance's &#xA;     *&#x9;&#x9;&#x9;&#x9;     &lt;tt>TabularType&lt;/tt> definition &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
          <comments>// Check key is not null and valid with tabularType </comments>
          <comments>// (throws NullPointerException, InvalidKeyException)</comments>
          <comments>//</comments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// Removes the (key, value) mapping in the parent HashMap</comments>
        <comments>//</comments>
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.6"/>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/util/Arrays.class.xmi#//@classifiers.0/@members.93"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../../java/util/Arrays.class.xmi#//@classifiers.0"/>
              </arguments>
            </next>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="putAll">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="t">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/util/Map.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* ***   Content modification bulk operations   *** */</comments>
        <comments>/**&#xA;     * Add all the values contained in the specified map &lt;var>t&lt;/var> to this &lt;tt>TabularData&lt;/tt> instance. &#xA;     * This method converts the collection of values contained in this map into an array of &lt;tt>CompositeData&lt;/tt> values,&#xA;     * if possible, and then call the method &lt;tt>putAll(CompositeData[])&lt;/tt>. Note that the keys used in the specified&#xA;     * map &lt;var>t&lt;/var> are ignored. This method allows, for example to add the content of another &lt;tt>TabularData&lt;/tt> &#xA;     * instance with the same row type (but possibly different index names) into this instance.&#xA;     *&#xA;     * @param  t  the map whose values are to be added as new rows to this &lt;tt>TabularData&lt;/tt> instance;&#xA;     *&#x9;&#x9;  if &lt;var>t&lt;/var> is &lt;tt>null&lt;/tt> or empty, this method returns without doing anything.&#xA;     * &#xA;     * @throws NullPointerException  if a value in &lt;var>t&lt;/var> is &lt;tt>null&lt;/tt>.&#xA;     * @throws ClassCastException    if a value in &lt;var>t&lt;/var> is not an instance of &lt;tt>CompositeData&lt;/tt>.&#xA;     * @throws InvalidOpenTypeException   if a value in &lt;var>t&lt;/var> does not conform to &#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;  this &lt;tt>TabularData&lt;/tt> instance's row type definition.&#xA;     * @throws KeyAlreadyExistsException  if the index for a value in &lt;var>t&lt;/var>, calculated according to &#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;  this &lt;tt>TabularData&lt;/tt> instance's &lt;tt>TabularType&lt;/tt> definition &#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;  already maps to an existing value in this instance,&#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;  or two values in &lt;var>t&lt;/var> have the same index.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// if t is null or empty, just return</comments>
        <comments>//</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="values">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Convert the values in t into an array of &lt;tt>CompositeData&lt;/tt></comments>
              <comments>//</comments>
              <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arrayDimensionsBefore/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../../java/util/Collection.class.xmi#//@classifiers.0/@members.5"/>
                    <arguments xsi:type="arrays:ArrayInstantiationBySize">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.0"/>
                        </next>
                      </sizes>
                    </arguments>
                  </next>
                  <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.10"/>
                </next>
              </child>
            </value>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/ClassCastException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Map argument t contains values which are not instances of &lt;tt>CompositeData&lt;/tt>"/>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <namespaces>java</namespaces>
              <namespaces>lang</namespaces>
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/lang/ArrayStoreException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <comments>// Add the array of values</comments>
          <comments>//</comments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@variable"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="putAll">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="values">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Add all the elements in &lt;var>values&lt;/var> to this &lt;tt>TabularData&lt;/tt> instance. &#xA;     * If any  element in &lt;var>values&lt;/var> does not satisfy the constraints defined in {@link #put(CompositeData) &lt;tt>put&lt;/tt>},&#xA;     * or if any two elements in &lt;var>values&lt;/var> have the same index calculated according to this &lt;tt>TabularData&lt;/tt> &#xA;     * instance's &lt;tt>TabularType&lt;/tt> definition, then an exception describing the failure is thrown &#xA;     * and no element of &lt;var>values&lt;/var> is added,  thus leaving this &lt;tt>TabularData&lt;/tt> instance unchanged.&#xA;     *&#xA;     * @param  values  the array of composite data values to be added as new rows to this &lt;tt>TabularData&lt;/tt> instance;&#xA;     *&#x9;&#x9;       if &lt;var>values&lt;/var> is &lt;tt>null&lt;/tt> or empty, this method returns without doing anything.&#xA;     * &#xA;     * @throws NullPointerException       if an element of &lt;var>values&lt;/var> is &lt;tt>null&lt;/tt> &#xA;     * @throws InvalidOpenTypeException   if an element of &lt;var>values&lt;/var> does not conform to &#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;  this &lt;tt>TabularData&lt;/tt> instance's row type definition &#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;  (ie its &lt;tt>TabularType&lt;/tt> definition)&#xA;     * @throws KeyAlreadyExistsException  if the index for an element of &lt;var>values&lt;/var>, calculated according to &#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;  this &lt;tt>TabularData&lt;/tt> instance's &lt;tt>TabularType&lt;/tt> definition &#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;  already maps to an existing value in this instance,&#xA;     *&#x9;&#x9;&#x9;&#x9;&#x9;  or two elements of &lt;var>values&lt;/var> have the same index&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// if values is null or empty, just return</comments>
        <comments>//</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="indexes">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// create the list of indexes corresponding to each value</comments>
              <target xsi:type="classifiers:Class" href="../../../java/util/ArrayList.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/util/ArrayList.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="index">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Check all elements in values and build index list </comments>
              <comments>//</comments>
              <target xsi:type="classifiers:Interface" href="../../../java/util/List.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable">
                <comments>// check value and calculate index</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.33">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@init"/>
                  </arraySelectors>
                </arguments>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// check index is different of those previously calculated</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="KeyAlreadyExistsException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value="Argument elements values["/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@init"/>
                    <children xsi:type="references:StringReference" value="] and values["/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../../java/util/ArrayList.class.xmi#//@classifiers.0/@members.11"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable"/>
                      </next>
                    </children>
                    <children xsi:type="references:StringReference" value="] have the same indexes, "/>
                    <children xsi:type="references:StringReference" value="calculated according to this TabularData instance's tabularType."/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/util/ArrayList.class.xmi#//@classifiers.0/@members.10"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable"/>
              </next>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable">
              <comments>// add to index list</comments>
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/util/ArrayList.class.xmi#//@classifiers.0/@members.18"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <comments>// store all (index, value) mappings in the dataMap HashMap</comments>
        <comments>//</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.5"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../java/util/ArrayList.class.xmi#//@classifiers.0/@members.16"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.4/@init"/>
                  </next>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.4/@init"/>
                  </arraySelectors>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.4/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.4/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clear">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes all rows from this &lt;code>TabularDataSupport&lt;/code> instance.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.8"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="size">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* ***  Informational methods from java.util.Map  *** */</comments>
        <comments>/**&#xA;     * Returns the number of rows in this &lt;code>TabularDataSupport&lt;/code> instance.&#xA;     *&#xA;     * @return the number of rows in this &lt;code>TabularDataSupport&lt;/code> instance.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isEmpty">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this &lt;code>TabularDataSupport&lt;/code> instance contains no rows.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if this &lt;code>TabularDataSupport&lt;/code> instance contains no rows.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.21"/>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="keySet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../java/util/Set.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* ***  Collection views from java.util.Map  *** */</comments>
        <comments>/**&#xA;     * Returns a set view of the keys contained in the underlying map of this &lt;code>TabularDataSupport&lt;/code> instance,&#xA;     * and used to index the rows. Each key contained in this set is an unmodifiable List.  &#xA;     * The set is backed by the underlying map of this &lt;code>TabularDataSupport&lt;/code> instance, &#xA;     * so changes to the &lt;code>TabularDataSupport&lt;/code> instance are reflected in the set, and vice-versa.&#xA;     *&#xA;     * The set supports element removal, which removes the&#xA;     * corresponding row from this &lt;code>TabularDataSupport&lt;/code> instance, via the &lt;tt>Iterator.remove&lt;/tt>,&#xA;     * &lt;tt>Set.remove&lt;/tt>, &lt;tt>removeAll&lt;/tt>, &lt;tt>retainAll&lt;/tt>, and&#xA;     * &lt;tt>clear&lt;/tt> operations.  &#xA;     * It does not support the &lt;tt>add&lt;/tt> or &lt;tt>addAll&lt;/tt> operations&#xA;     *&#xA;     * @return a set view of the keys used to index the rows of this &lt;code>TabularDataSupport&lt;/code> instance.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.9"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="values">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../java/util/Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a collection view of the rows contained in this &lt;code>TabularDataSupport&lt;/code> instance.  &#xA;     * The collection is backed by the underlying map, so changes to the &lt;code>TabularDataSupport&lt;/code> instance &#xA;     * are reflected in the collection, and vice-versa.&#xA;     *&#xA;     * The collection supports element removal, &#xA;     * which removes the corresponding index to row mapping from this &lt;code>TabularDataSupport&lt;/code> instance, &#xA;     * via the &lt;tt>Iterator.remove&lt;/tt>, &lt;tt>Collection.remove&lt;/tt>,&#xA;     * &lt;tt>removeAll&lt;/tt>, &lt;tt>retainAll&lt;/tt>, and &lt;tt>clear&lt;/tt> operations.&#xA;     * It does not support the &lt;tt>add&lt;/tt> or &lt;tt>addAll&lt;/tt> operations.&#xA;     *&#xA;     * @return a collection view of the values contained in this &lt;code>TabularDataSupport&lt;/code> instance.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.10"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="entrySet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../java/util/Set.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Returns a collection view of the index to row mappings contained in this &lt;code>TabularDataSupport&lt;/code> instance.  &#xA;     * Each element in the returned collection is a &lt;tt>Map.Entry&lt;/tt>.  &#xA;     * The collection is backed by the underlying map of this &lt;code>TabularDataSupport&lt;/code> instance,  in&#xA;     * so changes to the &lt;code>TabularDataSupport&lt;/code> instance are reflected the collection, and vice-versa.  &#xA;     * The collection supports element removal, which removes the corresponding mapping from the map, via the&#xA;     * &lt;tt>Iterator.remove&lt;/tt>, &lt;tt>Collection.remove&lt;/tt>,&#xA;     * &lt;tt>removeAll&lt;/tt>, &lt;tt>retainAll&lt;/tt>, and &lt;tt>clear&lt;/tt> operations.&#xA;     * It does not support the &lt;tt>add&lt;/tt> or &lt;tt>addAll&lt;/tt> operations.&#xA;     * &lt;p>&#xA;     * &lt;b>IMPORTANT NOTICE&lt;/b>: Do not use the &lt;tt>SetValue&lt;/tt> method of &lt;tt>Map.Entry&lt;/tt> elements contained in the returned&#xA;     * collection view. Doing so would corrupt the index to row mappings contained in this &lt;code>TabularDataSupport&lt;/code> instance.&#xA;     * &lt;p>&#xA;     *&#xA;     * @return a collection view of the mappings contained in this map.&#xA;     * @see java.util.Map.Entry&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.11"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* ***  Commodity methods from java.lang.Object  *** */</comments>
        <comments>/**&#xA;     * Returns a clone of this &lt;code>TabularDataSupport&lt;/code> instance: &#xA;     * the clone is obtained by calling &lt;tt>super.clone()&lt;/tt>, and then cloning the underlying map.&#xA;     * Only a shallow clone of the underlying map is made, i.e. no cloning of the indexes and row values is made as they are immutable.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="c">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <initialValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/Object.class.xmi#//@classifiers.0/@members.5"/>
                </next>
                <self xsi:type="literals:Super"/>
              </child>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/util/HashMap.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="expressions:NestedExpression">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/util/HashMap.class.xmi#//@classifiers.0/@members.44"/>
                </next>
                <expression xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../java/util/HashMap.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@statements.0/@variable">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                  </child>
                </expression>
              </child>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@statements.0/@variable"/>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/InternalError.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@catcheBlocks.0/@parameter">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/Throwable.class.xmi#//@classifiers.0/@members.13"/>
                </next>
              </arguments>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/lang/CloneNotSupportedException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares the specified &lt;var>obj&lt;/var> parameter with this &lt;code>TabularDataSupport&lt;/code> instance for equality. &#xA;     * &lt;p>&#xA;     * Returns &lt;tt>true&lt;/tt> if and only if all of the following statements are true:&#xA;     * &lt;ul>&#xA;     * &lt;li>&lt;var>obj&lt;/var> is non null,&lt;/li>&#xA;     * &lt;li>&lt;var>obj&lt;/var> also implements the &lt;code>TabularData&lt;/code> interface,&lt;/li>&#xA;     * &lt;li>their tabular types are equal&lt;/li>&#xA;     * &lt;li>their contents (ie all CompositeData values) are equal.&lt;/li>&#xA;     * &lt;/ul>&#xA;     * This ensures that this &lt;tt>equals&lt;/tt> method works properly for &lt;var>obj&lt;/var> parameters which are&#xA;     * different implementations of the &lt;code>TabularData&lt;/code> interface.&#xA;     * &lt;br>&amp;nbsp;&#xA;     * @param  obj  the object to be compared for equality with this &lt;code>TabularDataSupport&lt;/code> instance;&#xA;     * &#xA;     * @return  &lt;code>true&lt;/code> if the specified object is equal to this &lt;code>TabularDataSupport&lt;/code> instance.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// if obj is null, return false</comments>
        <comments>//</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="other">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// if obj is not a TabularData, return false</comments>
              <comments>//</comments>
              <target xsi:type="classifiers:Interface" href="TabularData.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="TabularData.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
            </value>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/lang/ClassCastException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Now, really test for equality between this TabularData implementation and the other:</comments>
        <comments>//</comments>
        <comments>// their tabularType should be equal</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="TabularType.class.xmi#//@classifiers.0/@members.11"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.1/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="TabularData.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                </arguments>
              </next>
            </next>
            <self xsi:type="literals:This"/>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// their contents should be equal: </comments>
        <comments>// . same size</comments>
        <comments>// . values in this instance are in the other (we know there are no duplicate elements possible)</comments>
        <comments>// (row values comparison is enough, because keys are calculated according to tabularType)</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.21"/>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="TabularData.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="value">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.5/@init">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../../java/util/Iterator.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.1/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="TabularData.class.xmi#//@classifiers.0/@members.5"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.5/@statement/@statements.0/@variable"/>
                </next>
              </child>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.5/@init">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../../java/util/Iterator.class.xmi#//@classifiers.0/@members.0"/>
          </next>
        </condition>
        <init xsi:type="variables:LocalVariable" name="iter">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../../java/util/Iterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../../../java/util/Collection.class.xmi#//@classifiers.0/@members.3"/>
              </next>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
        </init>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// All tests for equality were successfull</comments>
        <comments>//</comments>
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the hash code value for this &lt;code>TabularDataSupport&lt;/code> instance. &#xA;     * &lt;p>&#xA;     * The hash code of a &lt;code>TabularDataSupport&lt;/code> instance is the sum of the hash codes&#xA;     * of all elements of information used in &lt;code>equals&lt;/code> comparisons &#xA;     * (ie: its &lt;i>tabular type&lt;/i> and its content, where the content is defined as all the CompositeData values). &#xA;     * &lt;p>&#xA;     * This ensures that &lt;code> t1.equals(t2) &lt;/code> implies that &lt;code> t1.hashCode()==t2.hashCode() &lt;/code> &#xA;     * for any two &lt;code>TabularDataSupport&lt;/code> instances &lt;code>t1&lt;/code> and &lt;code>t2&lt;/code>, &#xA;     * as required by the general contract of the method&#xA;     * {@link Object#hashCode() Object.hashCode()}.&#xA;     * &lt;p>&#xA;     * However, note that another instance of a class implementing the &lt;code>TabularData&lt;/code> interface&#xA;     * may be equal to this &lt;code>TabularDataSupport&lt;/code> instance as defined by {@link #equals}, &#xA;     * but may have a different hash code if it is calculated differently.&#xA;     *&#xA;     * @return  the hash code value for this &lt;code>TabularDataSupport&lt;/code> instance&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@variable"/>
          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
          <value xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="TabularType.class.xmi#//@classifiers.0/@members.12"/>
              </next>
            </next>
            <self xsi:type="literals:This"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:AssignmentPlus"/>
              <value xsi:type="expressions:NestedExpression">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CompositeData.class.xmi#//@classifiers.0/@members.7"/>
                </next>
                <expression xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.2/@init">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="../../../java/util/Iterator.class.xmi#//@classifiers.0/@members.1"/>
                    </next>
                  </child>
                </expression>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.2/@init">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../../java/util/Iterator.class.xmi#//@classifiers.0/@members.0"/>
          </next>
        </condition>
        <init xsi:type="variables:LocalVariable" name="iter">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../../java/util/Iterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../../../java/util/Collection.class.xmi#//@classifiers.0/@members.3"/>
              </next>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
        </init>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string representation of this &lt;code>TabularDataSupport&lt;/code> instance. &#xA;     * &lt;p>&#xA;     * The string representation consists of the name of this class (ie &lt;code>javax.management.openmbean.TabularDataSupport&lt;/code>), &#xA;     * the string representation of the tabular type of this instance, and the string representation of the contents&#xA;     * (ie list the key=value mappings as returned by a call to&#xA;     * &lt;tt>dataMap.&lt;/tt>{@link java.util.HashMap#toString() toString()}).&#xA;     * &#xA;     * @return  a string representation of this &lt;code>TabularDataSupport&lt;/code> instance&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <next xsi:type="references:MethodCall">
                    <next xsi:type="references:MethodCall">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
                      </next>
                      <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                      <arguments xsi:type="references:StringReference" value=")"/>
                    </next>
                    <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../../java/lang/Object.class.xmi#//@classifiers.0/@members.6"/>
                      </next>
                    </arguments>
                  </next>
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="references:StringReference" value=",contents="/>
                </next>
                <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="TabularType.class.xmi#//@classifiers.0/@members.13"/>
                  </next>
                </arguments>
              </next>
              <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
              <arguments xsi:type="references:StringReference" value="(tabularType="/>
            </next>
            <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/Class.class.xmi#//@classifiers.0/@members.44"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../../../java/lang/Object.class.xmi#//@classifiers.0/@members.2"/>
              </next>
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="internalCalculateIndex">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../java/util/List.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/* *** TabularDataSupport internal utility methods *** */</comments>
        <comments>/**&#xA;     * Returns the index for value, assuming value is valid for this &lt;tt>TabularData&lt;/tt> instance &#xA;     * (ie value is not null, and its composite type is equal to row type).&#xA;     * &#xA;     * The index is a List, and not an array, so that an index.equals(otherIndex) call will actually compare contents,&#xA;     * not just the objects references as is done for an array object.&#xA;     *&#xA;     * The returned List is unmodifiable so that once a row has been put into the dataMap, its index cannot be modified,&#xA;     * for example by a user that would attempt to modify an index contained in the Set returned by keySet(). &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/util/Collections.class.xmi#//@classifiers.0/@members.43"/>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/util/Arrays.class.xmi#//@classifiers.0/@members.93"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="CompositeData.class.xmi#//@classifiers.0/@members.2"/>
                    <arguments xsi:type="references:SelfReference">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                      <self xsi:type="literals:This"/>
                    </arguments>
                  </next>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../../../java/util/Arrays.class.xmi#//@classifiers.0"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="../../../java/util/Collections.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkKeyType">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Checks if the specified key is valid for this &lt;tt>TabularData&lt;/tt> instance.&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     * @throws  InvalidOpenTypeException&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// Check key is neither null nor empty</comments>
        <comments>//</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Argument key cannot be null or empty."/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>/* Now check key is valid with tabularType index and row type definitions: */</comments>
        <comments>// key[] should have the size expected for an index </comments>
        <comments>//</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InvalidKeyException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Argument key's length="/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <children xsi:type="references:StringReference" value=" is different from the number of item values, which is "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <children xsi:type="references:StringReference" value=", specified for the indexing rows in this TabularData instance."/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
              <next xsi:type="references:IdentifierReference"/>
            </next>
            <self xsi:type="literals:This"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="keyElementType">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// each element in key[] should be a value for its corresponding open type specified in rowType</comments>
              <comments>//</comments>
              <target xsi:type="classifiers:Class" href="OpenType.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
                <next xsi:type="references:MethodCall">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="CompositeType.class.xmi#//@classifiers.0/@members.11"/>
                    <arguments xsi:type="references:SelfReference">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.3/@init"/>
                        </arraySelectors>
                      </next>
                      <self xsi:type="literals:This"/>
                    </arguments>
                  </next>
                  <target xsi:type="members:ClassMethod" href="TabularType.class.xmi#//@classifiers.0/@members.8"/>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="InvalidKeyException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value="Argument element key["/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.3/@init"/>
                    <children xsi:type="references:StringReference" value="] is not a value for the open type expected for "/>
                    <children xsi:type="references:StringReference" value="this element of the index, whose name is &quot;"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.3/@init"/>
                      </arraySelectors>
                    </children>
                    <children xsi:type="references:StringReference" value="&quot; and whose open type is "/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.2/@variable"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.3/@init"/>
                    </arraySelectors>
                  </children>
                  <children xsi:type="literals:NullLiteral"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Negate"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.2/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="OpenType.class.xmi#//@classifiers.0/@members.12"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.3/@init"/>
                        </arraySelectors>
                      </arguments>
                    </next>
                  </child>
                </expression>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkValueType">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Checks the specified value's type is valid for this &lt;tt>TabularData&lt;/tt> instance &#xA;     * (ie value is not null, and its composite type is equal to row type).&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     * @throws  InvalidOpenTypeException&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// Check value is not null</comments>
        <comments>//</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Argument value cannot be null."/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// if value's type is not the same as this instance's row type, throw InvalidOpenTypeException</comments>
        <comments>//</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InvalidOpenTypeException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Argument value's composite type ["/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="CompositeData.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                </children>
                <children xsi:type="references:StringReference" value="] is not equal to "/>
                <children xsi:type="references:StringReference" value="this TabularData instance's row type ["/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="TabularType.class.xmi#//@classifiers.0/@members.8"/>
                  </next>
                </children>
                <children xsi:type="references:StringReference" value="]."/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="CompositeType.class.xmi#//@classifiers.0/@members.14"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="TabularType.class.xmi#//@classifiers.0/@members.8"/>
                  </next>
                </arguments>
              </next>
              <target xsi:type="members:InterfaceMethod" href="CompositeData.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </child>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkValueAndIndex">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../java/util/List.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CompositeData.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Checks if the specified value can be put (ie added) in this &lt;tt>TabularData&lt;/tt> instance&#xA;     * (ie value is not null, its composite type is equal to row type, and its index is not already used),&#xA;     * and returns the index calculated for this value. &#xA;     * &#xA;     * The index is a List, and not an array, so that an index.equals(otherIndex) call will actually compare contents,&#xA;     * not just the objects references as is done for an array object.&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     * @throws  InvalidOpenTypeException&#xA;     * @throws  KeyAlreadyExistsException&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.32">
          <comments>// Check value is valid</comments>
          <comments>//</comments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="index">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Calculate value's index according to this instance's tabularType</comments>
              <comments>// and check it is not already used for a mapping in the parent HashMap</comments>
              <comments>//</comments>
              <target xsi:type="classifiers:Interface" href="../../../java/util/List.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.30">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="KeyAlreadyExistsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Argument value's index, calculated according to this TabularData "/>
                <children xsi:type="references:StringReference" value="instance's tabularType, already refers to a value in this table."/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../../java/util/Map.class.xmi#//@classifiers.0/@members.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.1/@variable"/>
          </next>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// The check is OK, so return the index</comments>
        <comments>//</comments>
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="in">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/ObjectInputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/ClassNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Deserializes a {@link TabularDataSupport} from an {@link ObjectInputStream}.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/io/ObjectInputStream.class.xmi#//@classifiers.0/@members.19"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="tmpNames">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../../java/util/List.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="TabularType.class.xmi#//@classifiers.0/@members.9"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../../../java/util/List.class.xmi#//@classifiers.0/@members.5"/>
                <arguments xsi:type="arrays:ArrayInstantiationBySize">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="../../../java/util/List.class.xmi#//@classifiers.0/@members.0"/>
                    </next>
                  </sizes>
                </arguments>
              </next>
            </child>
          </value>
        </expression>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>// jmx import</comments>
      <comments>//</comments>
      <comments>/**&#xA; * The &lt;tt>TabularDataSupport&lt;/tt> class is the &lt;i>open data&lt;/i> class which implements the &lt;tt>TabularData&lt;/tt> &#xA; * and the &lt;tt>Map&lt;/tt> interfaces, and which is internally based on a hash map data structure.&#xA; *&#xA; * @version     3.30  03/12/19&#xA; * @author      Sun Microsystems, Inc.&#xA; *&#xA; * @since 1.5&#xA; * @since.unbundled JMX 1.1&#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="TabularData.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../../java/util/Map.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../../java/lang/Cloneable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../../java/io/Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
