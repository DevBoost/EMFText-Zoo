<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16 http://www.emftext.org/java/variables ../../../java.ecore#/17" name="DataLine.java">
  <comments>/*&#xA; * @(#)DataLine.java&#x9;1.33 04/07/14&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>sound</namespaces>
  <namespaces>sampled</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="DataLine">
    <comments>// class Info</comments>
    <members xsi:type="members:InterfaceMethod" name="drain">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Drains queued data from the line by continuing data I/O until the&#xA;     * data line's internal buffer has been emptied.&#xA;     * This method blocks until the draining is complete.  Because this is a&#xA;     * blocking method, it should be used with care.  If &lt;code>drain()&lt;/code>&#xA;     * is invoked on a stopped line that has data in its queue, the method will&#xA;     * block until the line is running and the data queue becomes empty.  If&#xA;     * &lt;code>drain()&lt;/code> is invoked by one thread, and another continues to&#xA;     * fill the data queue, the operation will not complete.&#xA;     * This method always returns when the data line is closed.&#xA;     *&#xA;     * @see #flush()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="flush">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Flushes queued data from the line.  The flushed data is discarded.&#xA;     * In some cases, not all queued data can be discarded.  For example, a&#xA;     * mixer can flush data from the buffer for a specific input line, but any&#xA;     * unplayed data already in the output buffer (the result of the mix) will&#xA;     * still be played.  You can invoke this method after pausing a line (the&#xA;     * normal case) if you want to skip the &quot;stale&quot; data when you restart&#xA;     * playback or capture. (It is legal to flush a line that is not stopped,&#xA;     * but doing so on an active line is likely to cause a discontinuity in the&#xA;     * data, resulting in a perceptible click.)&#xA;     *&#xA;     * @see #stop()&#xA;     * @see #drain()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="start">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allows a line to engage in data I/O.  If invoked on a line&#xA;     * that is already running, this method does nothing.  Unless the data in&#xA;     * the buffer has been flushed, the line resumes I/O starting&#xA;     * with the first frame that was unprocessed at the time the line was&#xA;     * stopped. When audio capture or playback starts, a&#xA;     * &lt;code>{@link LineEvent.Type#START START}&lt;/code> event is generated.&#xA;     *&#xA;     * @see #stop()&#xA;     * @see #isRunning()&#xA;     * @see LineEvent&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="stop">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Stops the line.  A stopped line should cease I/O activity.&#xA;     * If the line is open and running, however, it should retain the resources required&#xA;     * to resume activity.  A stopped line should retain any audio data in its buffer&#xA;     * instead of discarding it, so that upon resumption the I/O can continue where it left off,&#xA;     * if possible.  (This doesn't guarantee that there will never be discontinuities beyond the&#xA;     * current buffer, of course; if the stopped condition continues&#xA;     * for too long, input or output samples might be dropped.)  If desired, the retained data can be&#xA;     * discarded by invoking the &lt;code>flush&lt;/code> method.&#xA;     * When audio capture or playback stops, a &lt;code>{@link LineEvent.Type#STOP STOP}&lt;/code> event is generated.&#xA;     *&#xA;     * @see #start()&#xA;     * @see #isRunning()&#xA;     * @see #flush()&#xA;     * @see LineEvent&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isRunning">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Indicates whether the line is running.  The default is &lt;code>false&lt;/code>.&#xA;     * An open line begins running when the first data is presented in response to an&#xA;     * invocation of the &lt;code>start&lt;/code> method, and continues&#xA;     * until presentation ceases in response to a call to &lt;code>stop&lt;/code> or&#xA;     * because playback completes.&#xA;     * @return &lt;code>true&lt;/code> if the line is running, otherwise &lt;code>false&lt;/code>&#xA;     * @see #start()&#xA;     * @see #stop()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isActive">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Indicates whether the line is engaging in active I/O (such as playback&#xA;     * or capture).  When an inactive line becomes active, it sends a&#xA;     * &lt;code>{@link LineEvent.Type#START START}&lt;/code> event to its listeners.  Similarly, when&#xA;     * an active line becomes inactive, it sends a&#xA;     * &lt;code>{@link LineEvent.Type#STOP STOP}&lt;/code> event.&#xA;     * @return &lt;code>true&lt;/code> if the line is actively capturing or rendering&#xA;     * sound, otherwise &lt;code>false&lt;/code>&#xA;     * @see #isOpen&#xA;     * @see #addLineListener&#xA;     * @see #removeLineListener&#xA;     * @see LineEvent&#xA;     * @see LineListener&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFormat">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="AudioFormat.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the current format (encoding, sample rate, number of channels,&#xA;     * etc.) of the data line's audio data.&#xA;     *&#xA;     * &lt;p>If the line is not open and has never been opened, it returns&#xA;     * the default format. The default format is an implementation&#xA;     * specific audio format, or, if the &lt;code>DataLine.Info&lt;/code>&#xA;     * object, which was used to retrieve this &lt;code>DataLine&lt;/code>,&#xA;     * specifies at least one fully qualified audio format, the&#xA;     * last one will be used as the default format. Opening the&#xA;     * line with a specific audio format (e.g.&#xA;     * {@link SourceDataLine#open(AudioFormat)}) will override the&#xA;     * default format.&#xA;     *&#xA;     * @return current audio data format&#xA;     * @see AudioFormat&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBufferSize">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the maximum number of bytes of data that will fit in the data line's&#xA;     * internal buffer.  For a source data line, this is the size of the buffer to&#xA;     * which data can be written.  For a target data line, it is the size of&#xA;     * the buffer from which data can be read.  Note that&#xA;     * the units used are bytes, but will always correspond to an integral&#xA;     * number of sample frames of audio data.&#xA;     *&#xA;     * @return the size of the buffer in bytes&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="available">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the number of bytes of data currently available to the&#xA;     * application for processing in the data line's internal buffer.  For a&#xA;     * source data line, this is the amount of data that can be written to the&#xA;     * buffer without blocking.  For a target data line, this is the amount of data&#xA;     * available to be read by the application.  For a clip, this value is always&#xA;     * 0 because the audio data is loaded into the buffer when the clip is opened,&#xA;     * and persists without modification until the clip is closed.&#xA;     * &lt;p>&#xA;     * Note that the units used are bytes, but will always&#xA;     * correspond to an integral number of sample frames of audio data.&#xA;     * &lt;p>&#xA;     * An application is guaranteed that a read or&#xA;     * write operation of up to the number of bytes returned from&#xA;     * &lt;code>available()&lt;/code> will not block; however, there is no guarantee&#xA;     * that attempts to read or write more data will block.&#xA;     *&#xA;     * @return the amount of data available, in bytes&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFramePosition">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the current position in the audio data, in sample frames.&#xA;     * The frame position measures the number of sample&#xA;     * frames captured by, or rendered from, the line since it was opened.&#xA;     * This return value will wrap around after 2^31 frames. It is recommended&#xA;     * to use &lt;code>getLongFramePosition&lt;/code> instead.&#xA;     *&#xA;     * @return the number of frames already processed since the line was opened&#xA;     * @see #getLongFramePosition()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLongFramePosition">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the current position in the audio data, in sample frames.&#xA;     * The frame position measures the number of sample&#xA;     * frames captured by, or rendered from, the line since it was opened.&#xA;     *&#xA;     * @return the number of frames already processed since the line was opened&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMicrosecondPosition">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the current position in the audio data, in microseconds.&#xA;     * The microsecond position measures the time corresponding to the number&#xA;     * of sample frames captured by, or rendered from, the line since it was opened.&#xA;     * The level of precision is not guaranteed.  For example, an implementation&#xA;     * might calculate the microsecond position from the current frame position&#xA;     * and the audio sample frame rate.  The precision in microseconds would&#xA;     * then be limited to the number of microseconds per sample frame.&#xA;     *&#xA;     * @return the number of microseconds of data processed since the line was opened&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLevel">
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the current volume level for the line.  This level is a measure&#xA;     * of the signal's current amplitude, and should not be confused with the&#xA;     * current setting of a gain control. The range is from 0.0 (silence) to&#xA;     * 1.0 (maximum possible amplitude for the sound waveform).  The units&#xA;     * measure linear amplitude, not decibels.&#xA;     *&#xA;     * @return the current amplitude of the signal in this line, or&#xA;     * &lt;code>{@link AudioSystem#NOT_SPECIFIED}&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="classifiers:Class" name="Info">
      <members xsi:type="members:Field" name="formats">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="AudioFormat.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Field" name="minBufferSize">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Field" name="maxBufferSize">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Constructor" name="Info">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@parameters.0"/>
            <callTarget xsi:type="literals:Super"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                  <self xsi:type="literals:This"/>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="arrays:ArrayInstantiationBySize">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="AudioFormat.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@parameters.1"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                  <self xsi:type="literals:This"/>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@parameters.1"/>
              </expression>
            </statements>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@parameters.2"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@parameters.3"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="lineClass">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <typeArguments xsi:type="generics:UnknownTypeArgument"/>
              <target xsi:type="classifiers:Class" href="../../../java/lang/Class.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="formats">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="AudioFormat.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="minBufferSize">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="maxBufferSize">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;&#x9; * Constructs a data line's info object from the specified information,&#xA;&#x9; * which includes a set of supported audio formats and a range for the buffer size.&#xA;&#x9; * This constructor is typically used by mixer implementations&#xA;&#x9; * when returning information about a supported line.&#xA;&#x9; *&#xA;&#x9; * @param lineClass the class of the data line described by the info object&#xA;&#x9; * @param formats set of formats supported&#xA;&#x9; * @param minBufferSize minimum buffer size supported by the data line, in bytes&#xA;&#x9; * @param maxBufferSize maximum buffer size supported by the data line, in bytes&#xA;&#x9; */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:Constructor" name="Info">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@parameters.0"/>
            <callTarget xsi:type="literals:Super"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                  <self xsi:type="literals:This"/>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="arrays:ArrayInstantiationBySize">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="AudioFormat.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@parameters.1"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="formats">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="AudioFormat.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arrayDimensionsBefore/>
                <initialValue xsi:type="arrays:ArrayInstantiationByValues">
                  <arrayInitializer>
                    <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@parameters.1"/>
                  </arrayInitializer>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                  <self xsi:type="literals:This"/>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@statements.1/@elseStatement/@statements.0/@variable"/>
              </expression>
            </statements>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@parameters.2"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@parameters.2"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="lineClass">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <typeArguments xsi:type="generics:UnknownTypeArgument"/>
              <target xsi:type="classifiers:Class" href="../../../java/lang/Class.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="format">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="AudioFormat.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="bufferSize">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;&#x9; * Constructs a data line's info object from the specified information,&#xA;&#x9; * which includes a single audio format and a desired buffer size.&#xA;&#x9; * This constructor is typically used by an application to&#xA;&#x9; * describe a desired line.&#xA;&#x9; *&#xA;&#x9; * @param lineClass the class of the data line described by the info object&#xA;&#x9; * @param format desired format&#xA;&#x9; * @param bufferSize desired buffer size in bytes&#xA;&#x9; */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:Constructor" name="Info">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.5/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.5/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="AudioSystem.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="AudioSystem.class.xmi#//@classifiers.0"/>
            </arguments>
            <callTarget xsi:type="literals:This"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="lineClass">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <typeArguments xsi:type="generics:UnknownTypeArgument"/>
              <target xsi:type="classifiers:Class" href="../../../java/lang/Class.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="format">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="AudioFormat.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;&#x9; * Constructs a data line's info object from the specified information,&#xA;&#x9; * which includes a single audio format.&#xA;&#x9; * This constructor is typically used by an application to&#xA;&#x9; * describe a desired line.&#xA;&#x9; *&#xA;&#x9; * @param lineClass the class of the data line described by the info object&#xA;&#x9; * @param format desired format&#xA;&#x9; */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:ClassMethod" name="getFormats">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="AudioFormat.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;&#x9; * Obtains a set of audio formats supported by the data line.&#xA;&#x9; * Note that &lt;code>isFormatSupported(AudioFormat)&lt;/code> might return&#xA;&#x9; * &lt;code>true&lt;/code> for certain additional formats that are missing from&#xA;&#x9; * the set returned by &lt;code>getFormats()&lt;/code>.  The reverse is not&#xA;&#x9; * the case: &lt;code>isFormatSupported(AudioFormat)&lt;/code> is guaranteed to return&#xA;&#x9; * &lt;code>true&lt;/code> for all formats returned by &lt;code>getFormats()&lt;/code>.&#xA;&#x9; *&#xA;&#x9; * Some fields in the AudioFormat instances can be set to&#xA;&#x9; * {@link javax.sound.sampled.AudioSystem#NOT_SPECIFIED NOT_SPECIFIED}&#xA;&#x9; * if that field does not apply to the format,&#xA;&#x9; * or if the format supports a wide range of values for that field.&#xA;&#x9; * For example, a multi-channel device supporting up to&#xA;&#x9; * 64 channels, could set the channel field in the&#xA;&#x9; * &lt;code>AudioFormat&lt;/code> instances returned by this&#xA;&#x9; * method to &lt;code>NOT_SPECIFIED&lt;/code>.&#xA;&#x9; *&#xA;&#x9; * @return a set of supported audio formats.&#xA;&#x9; * @see #isFormatSupported(AudioFormat)&#xA;&#x9; */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="returnedArray">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="AudioFormat.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <initialValue xsi:type="arrays:ArrayInstantiationBySize">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AudioFormat.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
                <next xsi:type="references:IdentifierReference"/>
              </sizes>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../java/lang/System.class.xmi#//@classifiers.0/@members.20"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.6/@statements.0/@variable"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
                <next xsi:type="references:IdentifierReference"/>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../../java/lang/System.class.xmi#//@classifiers.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.6/@statements.0/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="isFormatSupported">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="format">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="AudioFormat.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;&#x9; * Indicates whether this data line supports a particular audio format.&#xA;&#x9; * The default implementation of this method simply returns &lt;code>true&lt;/code> if&#xA;&#x9; * the specified format matches any of the supported formats.&#xA;&#x9; *&#xA;&#x9; * @param format the audio format for which support is queried.&#xA;&#x9; * @return &lt;code>true&lt;/code> if the format is supported, otherwise &lt;code>false&lt;/code>&#xA;&#x9; * @see #getFormats&#xA;&#x9; * @see AudioFormat#matches&#xA;&#x9; */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
                </statements>
              </statement>
              <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.7/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="AudioFormat.class.xmi#//@classifiers.0/@members.20"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.7/@statements.0/@init"/>
                    </arraySelectors>
                  </arguments>
                </next>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.7/@statements.0/@init"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
          <init xsi:type="variables:LocalVariable" name="i">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </init>
          <updates xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.7/@statements.0/@init"/>
            <operator xsi:type="operators:PlusPlus"/>
          </updates>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getMinBufferSize">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;&#x9; * Obtains the minimum buffer size supported by the data line.&#xA;&#x9; * @return minimum buffer size in bytes, or &lt;code>AudioSystem.NOT_SPECIFIED&lt;/code>&#xA;&#x9; */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getMaxBufferSize">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;&#x9; * Obtains the maximum buffer size supported by the data line.&#xA;&#x9; * @return maximum buffer size in bytes, or &lt;code>AudioSystem.NOT_SPECIFIED&lt;/code>&#xA;&#x9; */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="matches">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="info">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <namespaces>Line</namespaces>
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Line$Info.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;&#x9; * Determines whether the specified info object matches this one.&#xA;&#x9; * To match, the superclass match requirements must be met.  In&#xA;&#x9; * addition, this object's minimum buffer size must be at least as&#xA;&#x9; * large as that of the object specified, its maximum buffer size must&#xA;&#x9; * be at most as large as that of the object specified, and all of its&#xA;&#x9; * formats must match formats supported by the object specified.&#xA;&#x9; * @return &lt;code>true&lt;/code> if this object matches the one specified,&#xA;&#x9; * otherwise &lt;code>false&lt;/code>.&#xA;&#x9; */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="literals:BooleanLiteral"/>
            </statements>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Line$Info.class.xmi#//@classifiers.0/@members.3"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@parameters.0"/>
                </next>
                <self xsi:type="literals:Super"/>
              </expression>
            </child>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="dataLineInfo">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.13"/>
            </typeReference>
            <initialValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.13"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@parameters.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <comments>// treat anything &lt; 0 as NOT_SPECIFIED</comments>
          <comments>// demo code in old Java Sound Demo used a wrong buffer calculation</comments>
          <comments>// that would lead to arbitrary negative values</comments>
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="literals:BooleanLiteral"/>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.9"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@statements.1/@variable">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.9"/>
                </children>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.9"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@statements.1/@variable">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.9"/>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </expression>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="literals:BooleanLiteral"/>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.8"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@statements.1/@variable">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.8"/>
                </children>
                <relationOperators xsi:type="operators:LessThan"/>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.8"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@statements.1/@variable">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.8"/>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </expression>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="localFormats">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="AudioFormat.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.6"/>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ForLoop">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:Condition">
                      <statement xsi:type="statements:Block">
                        <statements xsi:type="statements:Return">
                          <returnValue xsi:type="literals:BooleanLiteral"/>
                        </statements>
                      </statement>
                      <condition xsi:type="expressions:UnaryExpression">
                        <operators xsi:type="operators:Negate"/>
                        <child xsi:type="expressions:NestedExpression">
                          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@statements.1/@variable">
                            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.7">
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@statements.4/@variable">
                                <arraySelectors>
                                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@statements.5/@statement/@statements.0/@init"/>
                                </arraySelectors>
                              </arguments>
                            </next>
                          </expression>
                        </child>
                      </condition>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:UnaryExpression">
                    <operators xsi:type="operators:Negate"/>
                    <child xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:EqualityExpression">
                        <equalityOperators xsi:type="operators:Equal"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@statements.4/@variable">
                          <arraySelectors>
                            <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@statements.5/@statement/@statements.0/@init"/>
                          </arraySelectors>
                        </children>
                        <children xsi:type="literals:NullLiteral"/>
                      </expression>
                    </child>
                  </condition>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@statements.5/@statement/@statements.0/@init"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@statements.4/@variable">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <relationOperators xsi:type="operators:LessThan"/>
              </condition>
              <init xsi:type="variables:LocalVariable" name="i">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </init>
              <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@statements.5/@statement/@statements.0/@init"/>
                <operator xsi:type="operators:PlusPlus"/>
              </updates>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.10/@statements.4/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="toString">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;&#x9; * Obtains a textual description of the data line info.&#xA;&#x9; * @return a string description&#xA;&#x9; */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="buf">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.11/@statements.0/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value=" supporting format "/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
                      <arraySelectors>
                        <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      </arraySelectors>
                    </children>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </next>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
                  <arraySelectors>
                    <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </arraySelectors>
                </children>
                <children xsi:type="literals:NullLiteral"/>
              </expression>
            </children>
          </condition>
          <elseStatement xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.11/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:StringReference" value=" supporting "/>
                      <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.6">
                        <next xsi:type="references:IdentifierReference"/>
                      </children>
                      <children xsi:type="references:StringReference" value=" audio formats"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.6">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.11/@statements.0/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value=", and buffers of "/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
                    <children xsi:type="references:StringReference" value=" to "/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2"/>
                    <children xsi:type="references:StringReference" value=" bytes"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </next>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="AudioSystem.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="AudioSystem.class.xmi#//@classifiers.0"/>
                </children>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2"/>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="AudioSystem.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="AudioSystem.class.xmi#//@classifiers.0"/>
                </children>
              </expression>
            </children>
          </condition>
          <elseStatement xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.11/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:StringReference" value=", and buffers of at least "/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
                      <children xsi:type="references:StringReference" value=" bytes"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="AudioSystem.class.xmi#//@classifiers.0/@members.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="AudioSystem.class.xmi#//@classifiers.0"/>
                  </children>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </expression>
              </children>
            </condition>
            <elseStatement xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.11/@statements.0/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:StringReference" value=", and buffers of up to "/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
                        <children xsi:type="references:StringReference" value=" bytes"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </arguments>
                    </next>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2"/>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="AudioSystem.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="AudioSystem.class.xmi#//@classifiers.0"/>
                </children>
              </condition>
            </elseStatement>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Line$Info.class.xmi#//@classifiers.0/@members.4"/>
                </next>
                <self xsi:type="literals:Super"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.11/@statements.0/@variable"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Besides the class information inherited from its superclass,&#xA;     * &lt;code>DataLine.Info&lt;/code> provides additional information specific to data lines.&#xA;     * This information includes:&#xA;     * &lt;ul>&#xA;     * &lt;li> the audio formats supported by the data line&#xA;     * &lt;li> the minimum and maximum sizes of its internal buffer&#xA;     * &lt;/ul>&#xA;     * Because a &lt;code>Line.Info&lt;/code> knows the class of the line its describes, a&#xA;     * &lt;code>DataLine.Info&lt;/code> object can describe &lt;code>DataLine&lt;/code>&#xA;     * subinterfaces such as &lt;code>{@link SourceDataLine}&lt;/code>,&#xA;     * &lt;code>{@link TargetDataLine}&lt;/code>, and &lt;code>{@link Clip}&lt;/code>.&#xA;     * You can query a mixer for lines of any of these types, passing an appropriate&#xA;     * instance of &lt;code>DataLine.Info&lt;/code> as the argument to a method such as&#xA;     * &lt;code>{@link Mixer#getLine Mixer.getLine(Line.Info)}&lt;/code>.&#xA;     *&#xA;     * @see Line.Info&#xA;     * @author Kara Kytle&#xA;     * @version 1.33, 04/07/14&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <namespaces>Line</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Line$Info.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </extends>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;code>DataLine&lt;/code> adds media-related functionality to its&#xA; * superinterface, &lt;code>{@link Line}&lt;/code>.  This functionality includes&#xA; * transport-control methods that start, stop, drain, and flush&#xA; * the audio data that passes through the line.  A data line can also&#xA; * report the current position, volume, and audio format of the media.&#xA; * Data lines are used for output of audio by means of the&#xA; * subinterfaces &lt;code>{@link SourceDataLine}&lt;/code> or&#xA; * &lt;code>{@link Clip}&lt;/code>, which allow an application program to write data.  Similarly,&#xA; * audio input is handled by the subinterface &lt;code>{@link TargetDataLine}&lt;/code>,&#xA; * which allows data to be read.&#xA; * &lt;p>&#xA; * A data line has an internal buffer in which&#xA; * the incoming or outgoing audio data is queued.  The&#xA; * &lt;code>{@link #drain()}&lt;/code> method blocks until this internal buffer&#xA; * becomes empty, usually because all queued data has been processed.  The&#xA; * &lt;code>{@link #flush()}&lt;/code> method discards any available queued data&#xA; * from the internal buffer.&#xA; * &lt;p>&#xA; * A data line produces &lt;code>{@link LineEvent.Type#START START}&lt;/code> and&#xA; * &lt;code>{@link LineEvent.Type#STOP STOP}&lt;/code> events whenever&#xA; * it begins or ceases active presentation or capture of data.  These events&#xA; * can be generated in response to specific requests, or as a result of&#xA; * less direct state changes.  For example, if &lt;code>{@link #start()}&lt;/code> is called&#xA; * on an inactive data line, and data is available for capture or playback, a&#xA; * &lt;code>START&lt;/code> event will be generated shortly, when data playback&#xA; * or capture actually begins.  Or, if the flow of data to an active data&#xA; * line is constricted so that a gap occurs in the presentation of data,&#xA; * a &lt;code>STOP&lt;/code> event is generated.&#xA; * &lt;p>&#xA; * Mixers often support synchronized control of multiple data lines.&#xA; * Synchronization can be established through the Mixer interface's&#xA; * &lt;code>{@link Mixer#synchronize synchronize}&lt;/code> method.&#xA; * See the description of the &lt;code>{@link Mixer Mixer}&lt;/code> interface&#xA; * for a more complete description.&#xA; *&#xA; * @author Kara Kytle&#xA; * @version 1.33, 04/07/14&#xA; * @see LineEvent&#xA; * @since 1.3&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Line.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
