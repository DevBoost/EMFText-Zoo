<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="MidiChannel.java">
  <comments>/*&#xA; * @(#)MidiChannel.java&#x9;1.43 04/04/22&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>sound</namespaces>
  <namespaces>midi</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="MidiChannel">
    <members xsi:type="members:InterfaceMethod" name="noteOn">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="noteNumber">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="velocity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Starts the specified note sounding.  The key-down velocity&#xA;     * usually controls the note's volume and/or brightness.&#xA;     * If &lt;code>velocity&lt;/code> is zero, this method instead acts like&#xA;     * {@link #noteOff(int)}, terminating the note.&#xA;     *&#xA;     * @param noteNumber the MIDI note number, from 0 to 127 (60 = Middle C)&#xA;     * @param velocity the speed with which the key was depressed&#xA;     *&#xA;     * @see #noteOff(int, int)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="noteOff">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="noteNumber">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="velocity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Turns the specified note off.  The key-up velocity, if not ignored, can&#xA;     * be used to affect how quickly the note decays.&#xA;     * In any case, the note might not die away instantaneously; its decay&#xA;     * rate is determined by the internals of the &lt;code>Instrument&lt;/code>.&#xA;     * If the Hold Pedal (a controller; see&#xA;     * {@link #controlChange(int, int) controlChange})&#xA;     * is down, the effect of this method is deferred until the pedal is&#xA;     * released.&#xA;     *&#xA;     *&#xA;     * @param noteNumber the MIDI note number, from 0 to 127 (60 = Middle C)&#xA;     * @param velocity the speed with which the key was released&#xA;     *&#xA;     * @see #noteOff(int)&#xA;     * @see #noteOn&#xA;     * @see #allNotesOff&#xA;     * @see #allSoundOff&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="noteOff">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="noteNumber">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Turns the specified note off.&#xA;     *&#xA;     * @param noteNumber the MIDI note number, from 0 to 127 (60 = Middle C)&#xA;     *&#xA;     * @see #noteOff(int, int)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setPolyPressure">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="noteNumber">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pressure">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reacts to a change in the specified note's key pressure.&#xA;     * Polyphonic key pressure&#xA;     * allows a keyboard player to press multiple keys simultaneously, each&#xA;     * with a different amount of pressure.  The pressure, if not ignored,&#xA;     * is typically used to vary such features as the volume, brightness,&#xA;     * or vibrato of the note.&#xA;     *&#xA;     * It is possible that the underlying synthesizer&#xA;     * does not support this MIDI message. In order&#xA;     * to verify that &lt;code>setPolyPressure&lt;/code>&#xA;     * was successful, use &lt;code>getPolyPressure&lt;/code>.&#xA;     *&#xA;     * @param noteNumber the MIDI note number, from 0 to 127 (60 = Middle C)&#xA;     * @param pressure value for the specified key, from 0 to 127 (127 =&#xA;     * maximum pressure)&#xA;     *&#xA;     * @see #getPolyPressure(int)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPolyPressure">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="noteNumber">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the pressure with which the specified key is being depressed.&#xA;     *&#xA;     * @param noteNumber the MIDI note number, from 0 to 127 (60 = Middle C)&#xA;     *&#xA;     * If the device does not support setting poly pressure,&#xA;     * this method always returns 0. Calling&#xA;     * &lt;code>setPolyPressure&lt;/code> will have no effect then.&#xA;     *&#xA;     * @return the amount of pressure for that note, from 0 to 127&#xA;     * (127 = maximum pressure)&#xA;     *&#xA;     * @see #setPolyPressure(int, int)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setChannelPressure">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pressure">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reacts to a change in the keyboard pressure.  Channel&#xA;     * pressure indicates how hard the keyboard player is depressing&#xA;     * the entire keyboard.  This can be the maximum or&#xA;     * average of the per-key pressure-sensor values, as set by&#xA;     * &lt;code>setPolyPressure&lt;/code>.  More commonly, it is a measurement of&#xA;     * a single sensor on a device that doesn't implement polyphonic key&#xA;     * pressure.  Pressure can be used to control various aspects of the sound,&#xA;     * as described under {@link #setPolyPressure(int, int) setPolyPressure}.&#xA;     *&#xA;     * It is possible that the underlying synthesizer&#xA;     * does not support this MIDI message. In order&#xA;     * to verify that &lt;code>setChannelPressure&lt;/code>&#xA;     * was successful, use &lt;code>getChannelPressure&lt;/code>.&#xA;     *&#xA;     * @param pressure the pressure with which the keyboard is being depressed,&#xA;     * from 0 to 127 (127 = maximum pressure)&#xA;     * @see #setPolyPressure(int, int)&#xA;     * @see #getChannelPressure&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getChannelPressure">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the channel's keyboard pressure.&#xA;     * If the device does not support setting channel pressure,&#xA;     * this method always returns 0. Calling&#xA;     * &lt;code>setChannelPressure&lt;/code> will have no effect then.&#xA;     *&#xA;     * @return the amount of pressure for that note,&#xA;     *         from 0 to 127 (127 = maximum pressure)&#xA;     *&#xA;     * @see #setChannelPressure(int)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="controlChange">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="controller">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reacts to a change in the specified controller's value.  A controller&#xA;     * is some control other than a keyboard key, such as a&#xA;     * switch, slider, pedal, wheel, or breath-pressure sensor.&#xA;     * The MIDI 1.0 Specification provides standard numbers for typical&#xA;     * controllers on MIDI devices, and describes the intended effect&#xA;     * for some of the controllers.&#xA;     * The way in which an&#xA;     * &lt;code>Instrument&lt;/code> reacts to a controller change may be&#xA;     * specific to the &lt;code>Instrument&lt;/code>.&#xA;     * &lt;p>&#xA;     * The MIDI 1.0 Specification defines both 7-bit controllers&#xA;     * and 14-bit controllers.  Continuous controllers, such&#xA;     * as wheels and sliders, typically have 14 bits (two MIDI bytes),&#xA;     * while discrete controllers, such as switches, typically have 7 bits&#xA;     * (one MIDI byte).  Refer to the specification to see the&#xA;     * expected resolution for each type of control.&#xA;     * &lt;p>&#xA;     * Controllers 64 through 95 (0x40 - 0x5F) allow 7-bit precision.&#xA;     * The value of a 7-bit controller is set completely by the&#xA;     * &lt;code>value&lt;/code> argument.  An additional set of controllers&#xA;     * provide 14-bit precision by using two controller numbers, one&#xA;     * for the most significant 7 bits and another for the least significant&#xA;     * 7 bits.  Controller numbers 0 through 31 (0x00 - 0x1F) control the&#xA;     * most significant 7 bits of 14-bit controllers; controller numbers&#xA;     * 32 through 63 (0x20 - 0x3F) control the least significant 7 bits of&#xA;     * these controllers.  For example, controller number 7 (0x07) controls&#xA;     * the upper 7 bits of the channel volume controller, and controller&#xA;     * number 39 (0x27) controls the lower 7 bits.&#xA;     * The value of a 14-bit controller is determined&#xA;     * by the interaction of the two halves.  When the most significant 7 bits&#xA;     * of a controller are set (using controller numbers 0 through 31), the&#xA;     * lower 7 bits are automatically set to 0.  The corresponding controller&#xA;     * number for the lower 7 bits may then be used to further modulate the&#xA;     * controller value.&#xA;     *&#xA;     * It is possible that the underlying synthesizer&#xA;     * does not support a specific controller message. In order&#xA;     * to verify that a call to &lt;code>controlChange&lt;/code>&#xA;     * was successful, use &lt;code>getController&lt;/code>.&#xA;     *&#xA;     * @param controller the controller number (0 to 127; see the MIDI&#xA;     * 1.0 Specification for the interpretation)&#xA;     * @param value the value to which the specified controller is changed (0 to 127)&#xA;     *&#xA;     * @see #getController(int)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getController">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="controller">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the current value of the specified controller.  The return&#xA;     * value is represented with 7 bits. For 14-bit controllers, the MSB and&#xA;     * LSB controller value needs to be obtained separately. For example,&#xA;     * the 14-bit value of the volume controller can be calculated by&#xA;     * multiplying the value of controller 7 (0x07, channel volume MSB)&#xA;     * with 128 and adding the&#xA;     * value of controller 39 (0x27, channel volume LSB).&#xA;     *&#xA;     * If the device does not support setting a specific controller,&#xA;     * this method returns 0 for that controller.&#xA;     * Calling &lt;code>controlChange&lt;/code> will have no effect then.&#xA;     *&#xA;     * @param controller the number of the controller whose value is desired.&#xA;     * The allowed range is 0-127; see the MIDI&#xA;     * 1.0 Specification for the interpretation.&#xA;     *&#xA;     * @return the current value of the specified controller (0 to 127)&#xA;     *&#xA;     * @see #controlChange(int, int)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="programChange">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="program">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Changes a program (patch).  This selects a specific&#xA;     * instrument from the currently selected bank of instruments.&#xA;     * &lt;p>&#xA;     * The MIDI specification does not&#xA;     * dictate whether notes that are already sounding should switch&#xA;     * to the new instrument (timbre) or continue with their original timbre&#xA;     * until terminated by a note-off.&#xA;     * &lt;p>&#xA;     * The program number is zero-based (expressed from 0 to 127).&#xA;     * Note that MIDI hardware displays and literature about MIDI&#xA;     * typically use the range 1 to 128 instead.&#xA;     *&#xA;     * It is possible that the underlying synthesizer&#xA;     * does not support a specific program. In order&#xA;     * to verify that a call to &lt;code>programChange&lt;/code>&#xA;     * was successful, use &lt;code>getProgram&lt;/code>.&#xA;     *&#xA;     * @param program the program number to switch to (0 to 127)&#xA;     *&#xA;     * @see #programChange(int, int)&#xA;     * @see #getProgram()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="programChange">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bank">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="program">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Changes the program using bank and program (patch) numbers.&#xA;     *&#xA;     * It is possible that the underlying synthesizer&#xA;     * does not support a specific bank, or program. In order&#xA;     * to verify that a call to &lt;code>programChange&lt;/code>&#xA;     * was successful, use &lt;code>getProgram&lt;/code> and&#xA;     * &lt;code>getController&lt;/code>.&#xA;     * Since banks are changed by way of control changes,&#xA;     * you can verify the current bank with the following&#xA;     * statement:&#xA;     * &lt;pre>&#xA;     *   int bank = (getController(0) * 128)&#xA;     *              + getController(32);&#xA;     * &lt;/pre>&#xA;     *&#xA;     * @param bank the bank number to switch to (0 to 16383)&#xA;     * @param program the program (patch) to use in the specified bank (0 to 127)&#xA;     * @see #programChange(int)&#xA;     * @see #getProgram()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getProgram">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the current program number for this channel.&#xA;     * @return the program number of the currently selected patch&#xA;     * @see Patch#getProgram&#xA;     * @see Synthesizer#loadInstrument&#xA;     * @see #programChange(int)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setPitchBend">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bend">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Changes the pitch offset for all notes on this channel.&#xA;     * This affects all currently sounding notes as well as subsequent ones.&#xA;     * (For pitch bend to cease, the value needs to be reset to the&#xA;     * center position.)&#xA;     * &lt;p> The MIDI specification&#xA;     * stipulates that pitch bend be a 14-bit value, where zero&#xA;     * is maximum downward bend, 16383 is maximum upward bend, and&#xA;     * 8192 is the center (no pitch bend).  The actual&#xA;     * amount of pitch change is not specified; it can be changed by&#xA;     * a pitch-bend sensitivity setting.  However, the General MIDI&#xA;     * specification says that the default range should be two semitones&#xA;     * up and down from center.&#xA;     *&#xA;     * It is possible that the underlying synthesizer&#xA;     * does not support this MIDI message. In order&#xA;     * to verify that &lt;code>setPitchBend&lt;/code>&#xA;     * was successful, use &lt;code>getPitchBend&lt;/code>.&#xA;     *&#xA;     * @param bend the amount of pitch change, as a nonnegative 14-bit value&#xA;     * (8192 = no bend)&#xA;     *&#xA;     * @see #getPitchBend&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPitchBend">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the upward or downward pitch offset for this channel.&#xA;     * If the device does not support setting pitch bend,&#xA;     * this method always returns 8192. Calling&#xA;     * &lt;code>setPitchBend&lt;/code> will have no effect then.&#xA;     *&#xA;     * @return bend amount, as a nonnegative 14-bit value (8192 = no bend)&#xA;     *&#xA;     * @see #setPitchBend(int)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="resetAllControllers">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Resets all the implemented controllers to their default values.&#xA;     *&#xA;     * @see #controlChange(int, int)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="allNotesOff">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Turns off all notes that are currently sounding on this channel.&#xA;     * The notes might not die away instantaneously; their decay&#xA;     * rate is determined by the internals of the &lt;code>Instrument&lt;/code>.&#xA;     * If the Hold Pedal controller (see&#xA;     * {@link #controlChange(int, int) controlChange})&#xA;     * is down, the effect of this method is deferred until the pedal is&#xA;     * released.&#xA;     *&#xA;     * @see #allSoundOff&#xA;     * @see #noteOff(int)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="allSoundOff">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Immediately turns off all sounding notes on this channel, ignoring the&#xA;     * state of the Hold Pedal and the internal decay rate of the current&#xA;     * &lt;code>Instrument&lt;/code>.&#xA;     *&#xA;     * @see #allNotesOff&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="localControl">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="on">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Turns local control on or off.  The default is for local control&#xA;     * to be on.  The &quot;on&quot; setting means that if a device is capable&#xA;     * of both synthesizing sound and transmitting MIDI messages,&#xA;     * it will synthesize sound in response to the note-on and&#xA;     * note-off messages that it itself transmits.  It will also respond&#xA;     * to messages received from other transmitting devices.&#xA;     * The &quot;off&quot; setting means that the synthesizer will ignore its&#xA;     * own transmitted MIDI messages, but not those received from other devices.&#xA;     *&#xA;     * It is possible that the underlying synthesizer&#xA;     * does not support local control. In order&#xA;     * to verify that a call to &lt;code>localControl&lt;/code>&#xA;     * was successful, check the return value.&#xA;     *&#xA;     * @param on &lt;code>true&lt;/code> to turn local control on, &lt;code>false&lt;/code>&#xA;     *  to turn local control off&#xA;     * @return the new local-control value, or false&#xA;     *         if local control is not supported&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setMono">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="on">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Turns mono mode on or off.  In mono mode, the channel synthesizes&#xA;     * only one note at a time.  In poly mode (identical to mono mode off),&#xA;     * the channel can synthesize multiple notes simultaneously.&#xA;     * The default is mono off (poly mode on).&#xA;     * &lt;p>&#xA;     * &quot;Mono&quot; is short for the word &quot;monophonic,&quot; which in this context&#xA;     * is opposed to the word &quot;polyphonic&quot; and refers to a single synthesizer&#xA;     * voice per MIDI channel.  It&#xA;     * has nothing to do with how many audio channels there might be&#xA;     * (as in &quot;monophonic&quot; versus &quot;stereophonic&quot; recordings).&#xA;     *&#xA;     * It is possible that the underlying synthesizer&#xA;     * does not support mono mode. In order&#xA;     * to verify that a call to &lt;code>setMono&lt;/code>&#xA;     * was successful, use &lt;code>getMono&lt;/code>.&#xA;     *&#xA;     * @param on &lt;code>true&lt;/code> to turn mono mode on, &lt;code>false&lt;/code> to&#xA;     * turn it off (which means turning poly mode on).&#xA;     *&#xA;     * @see #getMono&#xA;     * @see VoiceStatus&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMono">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the current mono/poly mode.&#xA;     * Synthesizers that do not allow changing mono/poly mode&#xA;     * will always return the same value, regardless&#xA;     * of calls to &lt;code>setMono&lt;/code>.&#xA;     * @return &lt;code>true&lt;/code> if mono mode is on, otherwise&#xA;     * &lt;code>false&lt;/code> (meaning poly mode is on).&#xA;     *&#xA;     * @see #setMono(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setOmni">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="on">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Turns omni mode on or off.  In omni mode, the channel responds&#xA;     * to messages sent on all channels.  When omni is off, the channel&#xA;     * responds only to messages sent on its channel number.&#xA;     * The default is omni off.&#xA;     *&#xA;     * It is possible that the underlying synthesizer&#xA;     * does not support omni mode. In order&#xA;     * to verify that &lt;code>setOmni&lt;/code>&#xA;     * was successful, use &lt;code>getOmni&lt;/code>.&#xA;     *&#xA;     * @param on &lt;code>true&lt;/code> to turn omni mode on, &lt;code>false&lt;/code> to&#xA;     * turn it off.&#xA;     *&#xA;     * @see #getOmni&#xA;     * @see VoiceStatus&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getOmni">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the current omni mode.&#xA;     * Synthesizers that do not allow changing the omni mode&#xA;     * will always return the same value, regardless&#xA;     * of calls to &lt;code>setOmni&lt;/code>.&#xA;     * @return &lt;code>true&lt;/code> if omni mode is on, otherwise&#xA;     * &lt;code>false&lt;/code> (meaning omni mode is off).&#xA;     *&#xA;     * @see #setOmni(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setMute">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mute">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the mute state for this channel. A value of&#xA;     * &lt;code>true&lt;/code> means the channel is to be muted, &lt;code>false&lt;/code>&#xA;     * means the channel can sound (if other channels are not soloed).&#xA;     * &lt;p>&#xA;     * Unlike {@link #allSoundOff()}, this method&#xA;     * applies to only a specific channel, not to all channels.  Further, it&#xA;     * silences not only currently sounding notes, but also subsequently&#xA;     * received notes.&#xA;     *&#xA;     * It is possible that the underlying synthesizer&#xA;     * does not support muting channels. In order&#xA;     * to verify that a call to &lt;code>setMute&lt;/code>&#xA;     * was successful, use &lt;code>getMute&lt;/code>.&#xA;     *&#xA;     * @param mute the new mute state&#xA;     *&#xA;     * @see #getMute&#xA;     * @see #setSolo(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMute">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the current mute state for this channel.&#xA;     * If the underlying synthesizer does not support&#xA;     * muting this channel, this method always returns&#xA;     * &lt;code>false&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> the channel is muted,&#xA;     *         or &lt;code>false&lt;/code> if not&#xA;     *&#xA;     * @see #setMute(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setSolo">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="soloState">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the solo state for this channel.&#xA;     * If &lt;code>solo&lt;/code> is &lt;code>true&lt;/code> only this channel&#xA;     * and other soloed channels will sound. If &lt;code>solo&lt;/code>&#xA;     * is &lt;code>false&lt;/code> then only other soloed channels will&#xA;     * sound, unless no channels are soloed, in which case all&#xA;     * unmuted channels will sound.&#xA;     *&#xA;     * It is possible that the underlying synthesizer&#xA;     * does not support solo channels. In order&#xA;     * to verify that a call to &lt;code>setSolo&lt;/code>&#xA;     * was successful, use &lt;code>getSolo&lt;/code>.&#xA;     *&#xA;     * @param soloState new solo state for the channel&#xA;     * @see #getSolo()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSolo">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the current solo state for this channel.&#xA;     * If the underlying synthesizer does not support&#xA;     * solo on this channel, this method always returns&#xA;     * &lt;code>false&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> the channel is solo,&#xA;     *         or &lt;code>false&lt;/code> if not&#xA;     *&#xA;     * @see #setSolo(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A &lt;code>MidiChannel&lt;/code> object represents a single MIDI channel.&#xA; * Generally, each &lt;code>MidiChannel&lt;/code> method processes a like-named MIDI&#xA; * &quot;channel voice&quot; or &quot;channel mode&quot; message as defined by the MIDI specification. However,&#xA; * &lt;code>MidiChannel&lt;/code> adds some &quot;get&quot; methods  that retrieve the value&#xA; * most recently set by one of the standard MIDI channel messages.  Similarly,&#xA; * methods for per-channel solo and mute have been added.&#xA; * &lt;p>&#xA; * A &lt;code>{@link Synthesizer}&lt;/code> object has a collection&#xA; * of &lt;code>MidiChannels&lt;/code>, usually one for each of the 16 channels&#xA; * prescribed by the MIDI 1.0 specification.  The &lt;code>Synthesizer&lt;/code>&#xA; * generates sound when its &lt;code>MidiChannels&lt;/code> receive&#xA; * &lt;code>noteOn&lt;/code> messages.&#xA; * &lt;p>&#xA; * See the MIDI 1.0 Specification for more information about the prescribed&#xA; * behavior of the MIDI channel messages, which are not exhaustively&#xA; * documented here.  The specification is titled &lt;code>MIDI Reference:&#xA; * The Complete MIDI 1.0 Detailed Specification&lt;/code>, and is published by&#xA; * the MIDI Manufacturer's Association (&lt;a href = http://www.midi.org>&#xA; * http://www.midi.org&lt;/a>).&#xA; * &lt;p>&#xA; * MIDI was originally a protocol for reporting the gestures of a keyboard&#xA; * musician.  This genesis is visible in the &lt;code>MidiChannel&lt;/code> API, which&#xA; * preserves such MIDI concepts as key number, key velocity, and key pressure.&#xA; * It should be understood that the MIDI data does not necessarily originate&#xA; * with a keyboard player (the source could be a different kind of musician, or&#xA; * software).  Some devices might generate constant values for velocity&#xA; * and pressure, regardless of how the note was performed.&#xA; * Also, the MIDI specification often leaves it up to the&#xA; * synthesizer to use the data in the way the implementor sees fit.  For&#xA; * example, velocity data need not always be mapped to volume and/or brightness.&#xA; *&#xA; * @see Synthesizer#getChannels&#xA; *&#xA; * @version 1.43, 04/22/04&#xA; * @author David Rivas&#xA; * @author Kara Kytle&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
