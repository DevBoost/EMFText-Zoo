<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="Synthesizer.java">
  <comments>/*&#xA; * @(#)Synthesizer.java&#x9;1.27 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>sound</namespaces>
  <namespaces>midi</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>sound</namespaces>
    <namespaces>sampled</namespaces>
    <classifier xsi:type="classifiers:Class" href="../sampled/Control.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="Synthesizer">
    <comments>// RECEIVER METHODS</comments>
    <comments>/**&#xA;     * Obtains the name of the receiver.&#xA;     * @return receiver name&#xA;     */</comments>
    <comments>//&#x9;public abstract String getName();</comments>
    <comments>/**&#xA;     * Opens the receiver.&#xA;     * @throws MidiUnavailableException if the receiver is cannot be opened, &#xA;     * usually because the MIDI device is in use by another application.&#xA;     * @throws SecurityException if the receiver cannot be opened due to security&#xA;     * restrictions.&#xA;     */</comments>
    <comments>//&#x9;public abstract void open() throws MidiUnavailableException, SecurityException;</comments>
    <comments>/**&#xA;     * Closes the receiver.&#xA;     */</comments>
    <comments>//&#x9;public abstract void close();</comments>
    <comments>/**&#xA;     * Sends a MIDI event to the receiver.&#xA;     * @param event event to send.&#xA;     * @throws IllegalStateException if the receiver is not open.&#xA;     */</comments>
    <comments>//&#x9;public void send(MidiEvent event) throws IllegalStateException {</comments>
    <comments>//</comments>
    <comments>//&#x9;}</comments>
    <comments>/**&#xA;     * Obtains the set of controls supported by the&#xA;     * element.  If no controls are supported, returns an&#xA;     * array of length 0.&#xA;     * @return set of controls&#xA;     */</comments>
    <comments>// $$kk: 03.04.99: josh bloch recommends getting rid of this: </comments>
    <comments>// what can you really do with a set of untyped controls??&#x9;</comments>
    <comments>// $$kk: 03.05.99: i am putting this back in.  for one thing,</comments>
    <comments>// you can check the length and know whether you should keep</comments>
    <comments>// looking.... </comments>
    <comments>// public Control[] getControls();</comments>
    <comments>/**&#xA;     * Obtains the specified control.&#xA;     * @param controlClass class of the requested control&#xA;     * @return requested control object, or null if the &#xA;     * control is not supported.&#xA;     */</comments>
    <comments>// public Control getControl(Class controlClass);</comments>
    <members xsi:type="members:InterfaceMethod" name="getMaxPolyphony">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// SYNTHESIZER METHODS</comments>
        <comments>/**&#xA;     * Obtains the maximum number of notes that this synthesizer can sound simultaneously.&#xA;     * @return the maximum number of simultaneous notes&#xA;     * @see #getVoiceStatus&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLatency">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the processing latency incurred by this synthesizer, expressed in &#xA;     * microseconds.  This latency measures the worst-case delay between the  &#xA;     * time a MIDI message is delivered to the synthesizer and the time that the&#xA;     * synthesizer actually produces the corresponding result.&#xA;     * &lt;p>&#xA;     * Although the latency is expressed in microseconds, a synthesizer's actual measured &#xA;     * delay may vary over a wider range than this resolution suggests.  For example,&#xA;     * a synthesizer might have a worst-case delay of a few milliseconds or more.&#xA;     *&#xA;     * @return the worst-case delay, in microseconds&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getChannels">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="MidiChannel.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the set of MIDI channels controlled by this synthesizer.  Each &#xA;     * non-null element in the returned array is a &lt;code>MidiChannel&lt;/code> that &#xA;     * receives the MIDI messages sent on that channel number.&#xA;     * &lt;p>&#xA;     * The MIDI 1.0 specification provides for 16 channels, so this &#xA;     * method returns an array of at least 16 elements.  However, if this synthesizer &#xA;     * doesn't make use of all 16 channels, some of the elements of the array&#xA;     * might be &lt;code>null&lt;/code>, so you should check each element&#xA;     * before using it.&#xA;     * @return an array of the &lt;code>MidiChannel&lt;/code> objects managed by this&#xA;     * &lt;code>Synthesizer&lt;/code>.  Some of the array elements may be &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getVoiceStatus">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="VoiceStatus.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the current status of the voices produced by this synthesizer.  &#xA;     * If this class of &lt;code>Synthesizer&lt;/code> does not provide voice &#xA;     * information, the returned array will always be of length 0.  Otherwise,&#xA;     * its length is always equal to the total number of voices, as returned by &#xA;     * &lt;code>getMaxPolyphony()&lt;/code>.  (See the &lt;code>VoiceStatus&lt;/code> class &#xA;     * description for an explanation of synthesizer voices.)&#xA;     *&#xA;     * @return an array of &lt;code>VoiceStatus&lt;/code> objects that supply &#xA;     * information about the corresponding synthesizer voices&#xA;     * @see #getMaxPolyphony&#xA;     * @see VoiceStatus&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isSoundbankSupported">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="soundbank">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Soundbank.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Informs the caller whether this synthesizer is capable of loading &#xA;     * instruments from the specified soundbank.&#xA;     * If the soundbank is unsupported, any attempts to load instruments from&#xA;     * it will result in an &lt;code>IllegalArgumentException&lt;/code>.&#xA;     * @param soundbank soundbank for which support is queried&#xA;     * @return &lt;code>true&lt;/code> if the soundbank is supported, otherwise &lt;code>false&lt;/code>&#xA;     * @see #loadInstruments&#xA;     * @see #loadAllInstruments&#xA;     * @see #unloadInstruments&#xA;     * @see #unloadAllInstruments&#xA;     * @see #getDefaultSoundbank&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="loadInstrument">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="instrument">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Instrument.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Makes a particular instrument available for synthesis.  This instrument&#xA;     * is loaded into the patch location specified by its &lt;code>Patch&lt;/code> &#xA;     * object, so that if a program-change message is &#xA;     * received (or has been received) that causes that patch to be selected,&#xA;     * subsequent notes will be played using the sound of &#xA;     * &lt;code>instrument&lt;/code>.  If the specified instrument is already loaded,&#xA;     * this method does nothing and returns &lt;code>true&lt;/code>.&#xA;     * &lt;p>&#xA;     * The instrument must be part of a soundbank &#xA;     * that this &lt;code>Synthesizer&lt;/code> supports.  (To make sure, you can use&#xA;     * the &lt;code>getSoundbank&lt;/code> method of &lt;code>Instrument&lt;/code> and the &#xA;     * &lt;code>isSoundbankSupported&lt;/code> method of &lt;code>Synthesizer&lt;/code>.)&#xA;     * @param instrument instrument to load&#xA;     * @return &lt;code>true&lt;/code> if the instrument is successfully loaded (or &#xA;     * already had been), &lt;code>false&lt;/code> if the instrument could not be &#xA;     * loaded (for example, if the synthesizer has insufficient&#xA;     * memory to load it)&#xA;     * @throws &lt;code>IllegalArgumentException&lt;/code> if this &#xA;     * &lt;code>Synthesizer&lt;/code> doesn't support the specified instrument's &#xA;     * soundbank &#xA;     * @see #unloadInstrument&#x9; &#xA;     * @see #loadInstruments&#x9; &#xA;     * @see #loadAllInstruments&#x9; &#xA;     * @see #remapInstrument&#xA;     * @see SoundbankResource#getSoundbank&#x9; &#xA;     * @see MidiChannel#programChange(int, int)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="unloadInstrument">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="instrument">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Instrument.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Unloads a particular instrument.&#xA;     * @param instrument instrument to unload&#xA;     * @throws &lt;code>IllegalArgumentException&lt;/code> if this &#xA;     * &lt;code>Synthesizer&lt;/code> doesn't support the specified instrument's &#xA;     * soundbank &#xA;     * @see #loadInstrument&#x9; &#xA;     * @see #unloadInstruments&#x9; &#xA;     * @see #unloadAllInstruments&#x9; &#xA;     * @see #getLoadedInstruments&#xA;     * @see #remapInstrument&#x9; &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="remapInstrument">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="from">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Instrument.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="to">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Instrument.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Remaps an instrument.  Instrument &lt;code>to&lt;/code> takes the &#xA;     * place of instrument &lt;code>from&lt;/code>.&#xA;     * For example, if &lt;code>from&lt;/code> was located at bank number 2,&#xA;     * program number 11, remapping causes&#xA;     * that bank and program location to be occupied instead by &#xA;     * &lt;code>to&lt;/code>.  Instrument &lt;code>from&lt;/code> is unloaded.&#xA;     * &#xA;     * @param from instrument to be replaced&#xA;     * @param to new instrument to be used in place of the old instrument&#xA;     * @return &lt;code>true&lt;/code> if the instrument could be remapped, &#xA;     * &lt;code>false&lt;/code> otherwise&#xA;     * @throws &lt;code>IllegalArgumentException&lt;/code> if the soundbank is not supported&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDefaultSoundbank">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Soundbank.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the default soundbank for the synthesizer, if one exists.&#xA;     * (Some synthesizers provide a default or built-in soundbank.)&#xA;     * If a synthesizer doesn't have a default soundbank, instruments must&#xA;     * be loaded explicitly from an external soundbank.  &#xA;     * @return default soundbank, or &lt;code>null&lt;/code> if one does not exist.&#xA;     * @see #isSoundbankSupported&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAvailableInstruments">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Instrument.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains a list of instruments that come with the synthesizer.  These&#xA;     * instruments might be built into the synthesizer, or they might be&#xA;     * part of a default soundbank provided with the synthesizer, etc.&#xA;     * &lt;p>  &#xA;     * Note that you don't use this method  to find out which instruments are &#xA;     * currently loaded onto the synthesizer; for that purpose, you use &#xA;     * &lt;code>getLoadedInstruments()&lt;/code>.&#xA;     * Nor does the method indicate all the instruments that can be loaded onto&#xA;     * the synthesizer; it only indicates the subset that come with the synthesizer.&#xA;     * To learn whether another instrument can be loaded, you can invoke &#xA;     * &lt;code>isSoundbankSupported()&lt;/code>, and if the instrument's &#xA;     * &lt;code>Soundbank&lt;/code> is supported, you can try loading the instrument.&#xA;     *  &#xA;     * @return list of available instruments.&#xA;     * @see #getLoadedInstruments&#x9; &#xA;     * @see #isSoundbankSupported(Soundbank)&#xA;     * @see #loadInstrument&#x9; &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLoadedInstruments">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Instrument.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains a list of the instruments that are currently loaded onto this &#xA;     * &lt;code>Synthesizer&lt;/code>.&#xA;     * @return a list of currently loaded instruments&#xA;     * @see #loadInstrument&#x9; &#xA;     * @see #getAvailableInstruments&#x9; &#xA;     * @see Soundbank#getInstruments&#x9; &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="loadAllInstruments">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="soundbank">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Soundbank.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Loads onto the &lt;code>Synthesizer&lt;/code> all instruments contained &#xA;     * in the specified &lt;code>Soundbank&lt;/code>.&#xA;     * @param soundbank the &lt;code>Soundbank&lt;/code> whose are instruments are &#xA;     * to be loaded&#xA;     * @return &lt;code>true&lt;/code> if the instruments are all successfully loaded (or &#xA;     * already had been), &lt;code>false&lt;/code> if any instrument could not be &#xA;     * loaded (for example, if the &lt;code>Synthesizer&lt;/code> had insufficient memory)&#xA;     * @throws IllegalArgumentException if the requested soundbank is &#xA;     * incompatible with this synthesizer.&#xA;     * @see #isSoundbankSupported&#xA;     * @see #loadInstrument&#x9; &#xA;     * @see #loadInstruments&#x9; &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="unloadAllInstruments">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="soundbank">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Soundbank.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Unloads all instruments contained in the specified &lt;code>Soundbank&lt;/code>.&#xA;     * @param soundbank soundbank containing instruments to unload&#xA;     * @throws IllegalArgumentException thrown if the soundbank is not supported.&#xA;     * @see #isSoundbankSupported&#xA;     * @see #unloadInstrument&#x9; &#xA;     * @see #unloadInstruments&#x9; &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="loadInstruments">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="soundbank">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Soundbank.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="patchList">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Patch.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Loads the instruments referenced by the specified patches, from the &#xA;     * specified &lt;code>Soundbank&lt;/code>.  Each of the &lt;code>Patch&lt;/code> objects&#xA;     * indicates a bank and program number; the &lt;code>Instrument&lt;/code> that&#xA;     * has the matching &lt;code>Patch&lt;/code> is loaded into that bank and program&#xA;     * location.&#xA;     * @param soundbank the &lt;code>Soundbank&lt;/code> containing the instruments to load&#xA;     * @param patchList list of patches for which instruments should be loaded&#xA;     * @return &lt;code>true&lt;/code> if the instruments are all successfully loaded (or &#xA;     * already had been), &lt;code>false&lt;/code> if any instrument could not be &#xA;     * loaded (for example, if the &lt;code>Synthesizer&lt;/code> had insufficient memory)&#xA;     * @throws IllegalArgumentException thrown if the soundbank is not supported.&#xA;     * @see #isSoundbankSupported&#xA;     * @see Instrument#getPatch&#xA;     * @see #loadAllInstruments&#xA;     * @see #loadInstrument&#x9; &#xA;     * @see Soundbank#getInstrument(Patch)&#xA;     * @see Sequence#getPatchList()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="unloadInstruments">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="soundbank">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Soundbank.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="patchList">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Patch.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Unloads the instruments referenced by the specified patches, from the MIDI sound bank specified.&#xA;     * @param soundbank soundbank containing instruments to unload&#xA;     * @param patchList list of patches for which instruments should be unloaded&#xA;     * @throws IllegalArgumentException thrown if the soundbank is not supported.&#xA;     *&#xA;     * @see #unloadInstrument&#x9; &#xA;     * @see #unloadAllInstruments&#x9; &#xA;     * @see #isSoundbankSupported&#xA;     * @see Instrument#getPatch&#xA;     * @see #loadInstruments&#x9; &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A &lt;code>Synthesizer&lt;/code> generates sound.  This usually happens when one of &#xA; * the &lt;code>Synthesizer&lt;/code>'s {@link MidiChannel} objects receives a &#xA; * {@link MidiChannel#noteOn(int, int) noteOn} message, either&#xA; * directly or via the &lt;code>Synthesizer&lt;/code> object.&#xA; * Many &lt;code>Synthesizer&lt;/code>s support &lt;code>Receivers&lt;/code>, through which&#xA; * MIDI events can be delivered to the &lt;code>Synthesizer&lt;/code>.  &#xA; * In such cases, the &lt;code>Synthesizer&lt;/code> typically responds by sending&#xA; * a corresponding message to the appropriate &lt;code>MidiChannel&lt;/code>, or by&#xA; * processing the event itself if the event isn't one of the MIDI channel &#xA; * messages.&#xA; * &lt;p>&#xA; * The &lt;code>Synthesizer&lt;/code> interface includes methods for loading and &#xA; * unloading instruments from soundbanks.  An instrument is a specification for synthesizing a&#xA; * certain type of sound, whether that sound emulates a traditional instrument or is&#xA; * some kind of sound effect or other imaginary sound. A soundbank is a collection of instruments, organized&#xA; * by bank and program number (via the instrument's &lt;code>Patch&lt;/code> object).  &#xA; * Different &lt;code>Synthesizer&lt;/code> classes might implement different sound-synthesis&#xA; * techniques, meaning that some instruments and not others might be compatible with a&#xA; * given synthesizer.&#xA; * Also, synthesizers may have a limited amount of memory for instruments, meaning&#xA; * that not every soundbank and instrument can be used by every synthesizer, even if&#xA; * the synthesis technique is compatible.&#xA; * To see whether the instruments from &#xA; * a certain soundbank can be played by a given synthesizer, invoke the&#xA; * {@link #isSoundbankSupported(Soundbank) isSoundbankSupported} method of &#xA; * &lt;code>Synthesizer&lt;/code>.&#xA; * &lt;p>&#xA; * &quot;Loading&quot; an instrument means that that instrument becomes available for &#xA; * synthesizing notes.  The instrument is loaded into the bank and &#xA; * program location specified by its &lt;code>Patch&lt;/code> object.  Loading does&#xA; * not necessarily mean that subsequently played notes will immediately have &#xA; * the sound of this newly loaded instrument.  For the instrument to play notes, &#xA; * one of the synthesizer's &lt;code>MidiChannel&lt;/code> objects must receive (or have received)&#xA; * a program-change message that causes that particular instrument's&#xA; * bank and program number to be selected.&#xA; *&#xA; * @see MidiSystem#getSynthesizer&#xA; * @see Soundbank&#xA; * @see Instrument&#xA; * @see MidiChannel#programChange(int, int)&#xA; * @see Receiver&#xA; * @see Transmitter&#xA; * @see MidiDevice&#xA; *&#xA; * @version 1.27, 03/12/19&#xA; * @author Kara Kytle&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="MidiDevice.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
