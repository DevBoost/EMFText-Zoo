<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="DirContext.java">
  <comments>/*&#xA; * @(#)DirContext.java&#x9;1.11 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>naming</namespaces>
  <namespaces>directory</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>javax</namespaces>
    <namespaces>naming</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="DirContext">
    <members xsi:type="members:InterfaceMethod" name="getAttributes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves all of the attributes associated with a named object.&#xA;     * See the class description regarding attribute models, attribute&#xA;     * type names, and operational attributes.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object from which to retrieve attributes&#xA;     * @return&#x9;the set of attributes associated with &lt;code>name&lt;/code>.&#xA;     *&#x9;&#x9;Returns an empty attribute set if name has no attributes;&#xA;     *&#x9;&#x9;never null.&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #getAttributes(String)&#xA;     * @see #getAttributes(Name, String[])&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAttributes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves all of the attributes associated with a named object.&#xA;     * See {@link #getAttributes(Name)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object from which to retrieve attributes&#xA;     * @return&#x9;the set of attributes associated with &lt;code>name&lt;/code>&#xA;     *&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAttributes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attrIds">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves selected attributes associated with a named object.&#xA;     * See the class description regarding attribute models, attribute&#xA;     * type names, and operational attributes.&#xA;     *&#xA;     * &lt;p> If the object does not have an attribute&#xA;     * specified, the directory will ignore the nonexistent attribute&#xA;     * and return those requested attributes that the object does have.&#xA;     *&#xA;     * &lt;p> A directory might return more attributes than was requested&#xA;     * (see &lt;strong>Attribute Type Names&lt;/strong> in the class description),&#xA;     * but is not allowed to return arbitrary, unrelated attributes.&#xA;     *&#xA;     * &lt;p> See also &lt;strong>Operational Attributes&lt;/strong> in the class&#xA;     * description.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object from which to retrieve attributes&#xA;     * @param attrIds&#xA;     *&#x9;&#x9;the identifiers of the attributes to retrieve.&#xA;     * &#x9;&#x9;null indicates that all attributes should be retrieved;&#xA;     *     &#x9;an empty array indicates that none should be retrieved.&#xA;     * @return&#x9;the requested attributes; never null&#xA;     *&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAttributes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attrIds">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves selected attributes associated with a named object.&#xA;     * See {@link #getAttributes(Name, String[])} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;The name of the object from which to retrieve attributes&#xA;     * @param attrIds&#xA;     *&#x9;&#x9;the identifiers of the attributes to retrieve.&#xA;     * &#x9;&#x9;null indicates that all attributes should be retrieved;&#xA;     *     &#x9;an empty array indicates that none should be retrieved.&#xA;     * @return&#x9;the requested attributes; never null&#xA;     *&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="ADD_ATTRIBUTE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * This constant specifies to add an attribute with the specified values.&#xA;     * &lt;p>&#xA;     * If attribute does not exist,&#xA;     * create the attribute.  The resulting attribute has a union of the&#xA;     * specified value set and the prior value set.&#xA;     * Adding an attribute with no value will throw&#xA;     * &lt;code>InvalidAttributeValueException&lt;/code> if the attribute must have&#xA;     * at least  one value.  For a single-valued attribute where that attribute&#xA;     * already exists, throws &lt;code>AttributeInUseException&lt;/code>.&#xA;     * If attempting to add more than one value to a single-valued attribute,&#xA;     * throws &lt;code>InvalidAttributeValueException&lt;/code>.&#xA;     * &lt;p>&#xA;     * The value of this constant is &lt;tt>1&lt;/tt>.&#xA;     *&#xA;     * @see ModificationItem&#xA;     * @see #modifyAttributes&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="REPLACE_ATTRIBUTE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * This constant specifies to replace an attribute with specified values.&#xA;     *&lt;p>&#xA;     * If attribute already exists,&#xA;     * replaces all existing values with new specified values.  If the&#xA;     * attribute does not exist, creates it.  If no value is specified,&#xA;     * deletes all the values of the attribute.&#xA;     * Removal of the last value will remove the attribute if the attribute&#xA;     * is required to have at least one value.  If&#xA;     * attempting to add more than one value to a single-valued attribute,&#xA;     * throws &lt;code>InvalidAttributeValueException&lt;/code>.&#xA;     * &lt;p>&#xA;     * The value of this constant is &lt;tt>2&lt;/tt>.&#xA;     *&#xA;     * @see ModificationItem&#xA;     * @see #modifyAttributes&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="REMOVE_ATTRIBUTE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * This constant specifies to delete&#xA;     * the specified attribute values from the attribute.&#xA;     *&lt;p>&#xA;     * The resulting attribute has the set difference of its prior value set&#xA;     * and the specified value set.&#xA;     * If no values are specified, deletes the entire attribute.&#xA;     * If the attribute does not exist, or if some or all members of the&#xA;     * specified value set do not exist, this absence may be ignored&#xA;     * and the operation succeeds, or a NamingException may be thrown to&#xA;     * indicate the absence.&#xA;     * Removal of the last value will remove the attribute if the&#xA;     * attribute is required to have at least one value.&#xA;     * &lt;p>&#xA;     * The value of this constant is &lt;tt>3&lt;/tt>.&#xA;     *&#xA;     * @see ModificationItem&#xA;     * @see #modifyAttributes&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="modifyAttributes">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mod_op">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attrs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Modifies the attributes associated with a named object.&#xA;     * The order of the modifications is not specified.  Where&#xA;     * possible, the modifications are performed atomically.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object whose attributes will be updated&#xA;     * @param mod_op&#xA;     *&#x9;&#x9;the modification operation, one of:&#xA;     *&#x9;&#x9;&#x9;&lt;code>ADD_ATTRIBUTE&lt;/code>,&#xA;     *&#x9;&#x9;&#x9;&lt;code>REPLACE_ATTRIBUTE&lt;/code>,&#xA;     *&#x9;&#x9;&#x9;&lt;code>REMOVE_ATTRIBUTE&lt;/code>.&#xA;     * @param attrs&#xA;     *&#x9;&#x9;the attributes to be used for the modification; may not be null&#xA;     *&#xA;     * @throws&#x9;AttributeModificationException if the modification cannot&#xA;     *&#x9;&#x9;be completed successfully&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #modifyAttributes(Name, ModificationItem[])&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="modifyAttributes">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mod_op">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attrs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Modifies the attributes associated with a named object.&#xA;     * See {@link #modifyAttributes(Name, int, Attributes)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object whose attributes will be updated&#xA;     * @param mod_op&#xA;     *&#x9;&#x9;the modification operation, one of:&#xA;     *&#x9;&#x9;&#x9;&lt;code>ADD_ATTRIBUTE&lt;/code>,&#xA;     *&#x9;&#x9;&#x9;&lt;code>REPLACE_ATTRIBUTE&lt;/code>,&#xA;     *&#x9;&#x9;&#x9;&lt;code>REMOVE_ATTRIBUTE&lt;/code>.&#xA;     * @param attrs&#xA;     *&#x9;&#x9;the attributes to be used for the modification; map not be null&#xA;     *&#xA;     * @throws&#x9;AttributeModificationException if the modification cannot&#xA;     *&#x9;&#x9;be completed successfully&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="modifyAttributes">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mods">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ModificationItem.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Modifies the attributes associated with a named object using&#xA;     * an ordered list of modifications.&#xA;     * The modifications are performed&#xA;     * in the order specified.  Each modification specifies a&#xA;     * modification operation code and an attribute on which to&#xA;     * operate.  Where possible, the modifications are&#xA;     * performed atomically.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object whose attributes will be updated&#xA;     * @param mods&#xA;     *&#x9;&#x9;an ordered sequence of modifications to be performed;&#xA;     *&#x9;&#x9;may not be null&#xA;     *&#xA;     * @throws&#x9;AttributeModificationException if the modifications&#xA;     *&#x9;&#x9;cannot be completed successfully&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #modifyAttributes(Name, int, Attributes)&#xA;     * @see ModificationItem&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="modifyAttributes">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mods">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ModificationItem.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Modifies the attributes associated with a named object using&#xA;     * an ordered list of modifications.&#xA;     * See {@link #modifyAttributes(Name, ModificationItem[])} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object whose attributes will be updated&#xA;     * @param mods&#xA;     *&#x9;&#x9;an ordered sequence of modifications to be performed;&#xA;     *&#x9;&#x9;may not be null&#xA;     *&#xA;     * @throws&#x9;AttributeModificationException if the modifications&#xA;     *&#x9;&#x9;cannot be completed successfully&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="bind">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attrs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Binds a name to an object, along with associated attributes.&#xA;     * If &lt;tt>attrs&lt;/tt> is null, the resulting binding will have&#xA;     * the attributes associated with &lt;tt>obj&lt;/tt> if &lt;tt>obj&lt;/tt> is a&#xA;     * &lt;tt>DirContext&lt;/tt>, and no attributes otherwise.&#xA;     * If &lt;tt>attrs&lt;/tt> is non-null, the resulting binding will have&#xA;     * &lt;tt>attrs&lt;/tt> as its attributes; any attributes associated with&#xA;     * &lt;tt>obj&lt;/tt> are ignored.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name to bind; may not be empty&#xA;     * @param obj&#xA;     *&#x9;&#x9;the object to bind; possibly null&#xA;     * @param attrs&#xA;     *&#x9;&#x9;the attributes to associate with the binding&#xA;     *&#xA;     * @throws&#x9;NameAlreadyBoundException if name is already bound&#xA;     * @throws&#x9;InvalidAttributesException if some &quot;mandatory&quot; attributes&#xA;     *&#x9;&#x9;of the binding are not supplied&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see Context#bind(Name, Object)&#xA;     * @see #rebind(Name, Object, Attributes)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="bind">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attrs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Binds a name to an object, along with associated attributes.&#xA;     * See {@link #bind(Name, Object, Attributes)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name to bind; may not be empty&#xA;     * @param obj&#xA;     *&#x9;&#x9;the object to bind; possibly null&#xA;     * @param attrs&#xA;     *&#x9;&#x9;the attributes to associate with the binding&#xA;     *&#xA;     * @throws&#x9;NameAlreadyBoundException if name is already bound&#xA;     * @throws&#x9;InvalidAttributesException if some &quot;mandatory&quot; attributes&#xA;     *&#x9;&#x9;of the binding are not supplied&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rebind">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attrs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Binds a name to an object, along with associated attributes,&#xA;     * overwriting any existing binding.&#xA;     * If &lt;tt>attrs&lt;/tt> is null and &lt;tt>obj&lt;/tt> is a &lt;tt>DirContext&lt;/tt>,&#xA;     * the attributes from &lt;tt>obj&lt;/tt> are used.&#xA;     * If &lt;tt>attrs&lt;/tt> is null and &lt;tt>obj&lt;/tt> is not a &lt;tt>DirContext&lt;/tt>,&#xA;     * any existing attributes associated with the object already bound&#xA;     * in the directory remain unchanged.&#xA;     * If &lt;tt>attrs&lt;/tt> is non-null, any existing attributes associated with&#xA;     * the object already bound in the directory are removed and &lt;tt>attrs&lt;/tt>&#xA;     * is associated with the named object.  If &lt;tt>obj&lt;/tt> is a&#xA;     * &lt;tt>DirContext&lt;/tt> and &lt;tt>attrs&lt;/tt> is non-null, the attributes&#xA;     * of &lt;tt>obj&lt;/tt> are ignored.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name to bind; may not be empty&#xA;     * @param obj&#xA;     *&#x9;&#x9;the object to bind; possibly null&#xA;     * @param attrs&#xA;     *&#x9;&#x9;the attributes to associate with the binding&#xA;     *&#xA;     * @throws&#x9;InvalidAttributesException if some &quot;mandatory&quot; attributes&#xA;     *&#x9;&#x9;of the binding are not supplied&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see Context#bind(Name, Object)&#xA;     * @see #bind(Name, Object, Attributes)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rebind">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attrs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Binds a name to an object, along with associated attributes,&#xA;     * overwriting any existing binding.&#xA;     * See {@link #rebind(Name, Object, Attributes)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name to bind; may not be empty&#xA;     * @param obj&#xA;     *&#x9;&#x9;the object to bind; possibly null&#xA;     * @param attrs&#xA;     *&#x9;&#x9;the attributes to associate with the binding&#xA;     *&#xA;     * @throws&#x9;InvalidAttributesException if some &quot;mandatory&quot; attributes&#xA;     *&#x9;&#x9;of the binding are not supplied&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createSubcontext">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attrs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates and binds a new context, along with associated attributes.&#xA;     * This method creates a new subcontext with the given name, binds it in&#xA;     * the target context (that named by all but terminal atomic&#xA;     * component of the name), and associates the supplied attributes&#xA;     * with the newly created object.&#xA;     * All intermediate and target contexts must already exist.&#xA;     * If &lt;tt>attrs&lt;/tt> is null, this method is equivalent to&#xA;     * &lt;tt>Context.createSubcontext()&lt;/tt>.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to create; may not be empty&#xA;     * @param attrs&#xA;     *&#x9;&#x9;the attributes to associate with the newly created context&#xA;     * @return&#x9;the newly created context&#xA;     *&#xA;     * @throws&#x9;NameAlreadyBoundException if the name is already bound&#xA;     * @throws&#x9;InvalidAttributesException if &lt;code>attrs&lt;/code> does not&#xA;     *&#x9;&#x9;contain all the mandatory attributes required for creation&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see Context#createSubcontext(Name)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createSubcontext">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attrs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates and binds a new context, along with associated attributes.&#xA;     * See {@link #createSubcontext(Name, Attributes)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to create; may not be empty&#xA;     * @param attrs&#xA;     *&#x9;&#x9;the attributes to associate with the newly created context&#xA;     * @return&#x9;the newly created context&#xA;     *&#xA;     * @throws&#x9;NameAlreadyBoundException if the name is already bound&#xA;     * @throws&#x9;InvalidAttributesException if &lt;code>attrs&lt;/code> does not&#xA;     *&#x9;&#x9;contain all the mandatory attributes required for creation&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSchema">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -------------------- schema operations</comments>
        <comments>/**&#xA;     * Retrieves the schema associated with the named object.&#xA;     * The schema describes rules regarding the structure of the namespace&#xA;     * and the attributes stored within it.  The schema&#xA;     * specifies what types of objects can be added to the directory and where&#xA;     * they can be added; what mandatory and optional attributes an object&#xA;     * can have. The range of support for schemas is directory-specific.&#xA;     *&#xA;     * &lt;p> This method returns the root of the schema information tree&#xA;     * that is applicable to the named object. Several named objects&#xA;     * (or even an entire directory) might share the same schema.&#xA;     *&#xA;     * &lt;p> Issues such as structure and contents of the schema tree,&#xA;     * permission to modify to the contents of the schema&#xA;     * tree, and the effect of such modifications on the directory&#xA;     * are dependent on the underlying directory.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object whose schema is to be retrieved&#xA;     * @return&#x9;the schema associated with the context; never null&#xA;     * @throws&#x9;OperationNotSupportedException if schema not supported&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSchema">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the schema associated with the named object.&#xA;     * See {@link #getSchema(Name)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object whose schema is to be retrieved&#xA;     * @return&#x9;the schema associated with the context; never null&#xA;     * @throws&#x9;OperationNotSupportedException if schema not supported&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSchemaClassDefinition">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves a context containing the schema objects of the&#xA;     * named object's class definitions.&#xA;     *&lt;p>&#xA;     * One category of information found in directory schemas is&#xA;     * &lt;em>class definitions&lt;/em>.  An &quot;object class&quot; definition&#xA;     * specifies the object's &lt;em>type&lt;/em> and what attributes (mandatory&#xA;     * and optional) the object must/can have. Note that the term&#xA;     * &quot;object class&quot; being referred to here is in the directory sense&#xA;     * rather than in the Java sense.&#xA;     * For example, if the named object is a directory object of&#xA;     * &quot;Person&quot; class, &lt;tt>getSchemaClassDefinition()&lt;/tt> would return a&#xA;     * &lt;tt>DirContext&lt;/tt> representing the (directory's) object class&#xA;     * definition of &quot;Person&quot;.&#xA;     *&lt;p>&#xA;     * The information that can be retrieved from an object class definition&#xA;     * is directory-dependent.&#xA;     *&lt;p>&#xA;     * Prior to JNDI 1.2, this method&#xA;     * returned a single schema object representing the class definition of&#xA;     * the named object.&#xA;     * Since JNDI 1.2, this method returns a &lt;tt>DirContext&lt;/tt> containing&#xA;     * all of the named object's class definitions.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object whose object class&#xA;     *&#x9;&#x9;definition is to be retrieved&#xA;     * @return&#x9;the &lt;tt>DirContext&lt;/tt> containing the named&#xA;     *&#x9;&#x9;object's class definitions; never null&#xA;     *&#xA;     * @throws&#x9;OperationNotSupportedException if schema not supported&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSchemaClassDefinition">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves a context containing the schema objects of the&#xA;     * named object's class definitions.&#xA;     * See {@link #getSchemaClassDefinition(Name)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object whose object class&#xA;     *&#x9;&#x9;definition is to be retrieved&#xA;     * @return&#x9;the &lt;tt>DirContext&lt;/tt> containing the named&#xA;     *&#x9;&#x9;object's class definitions; never null&#xA;     *&#xA;     * @throws&#x9;OperationNotSupportedException if schema not supported&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="search">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SearchResult.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../NamingEnumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="matchingAttributes">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attributesToReturn">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -------------------- search operations</comments>
        <comments>/**&#xA;     * Searches in a single context for objects that contain a&#xA;     * specified set of attributes, and retrieves selected attributes.&#xA;     * The search is performed using the default&#xA;     * &lt;code>SearchControls&lt;/code> settings.&#xA;     * &lt;p>&#xA;     * For an object to be selected, each attribute in&#xA;     * &lt;code>matchingAttributes&lt;/code> must match some attribute of the&#xA;     * object.  If &lt;code>matchingAttributes&lt;/code> is empty or&#xA;     * null, all objects in the target context are returned.&#xA;     *&lt;p>&#xA;     * An attribute &lt;em>A&lt;/em>&lt;sub>1&lt;/sub> in&#xA;     * &lt;code>matchingAttributes&lt;/code> is considered to match an&#xA;     * attribute &lt;em>A&lt;/em>&lt;sub>2&lt;/sub> of an object if&#xA;     * &lt;em>A&lt;/em>&lt;sub>1&lt;/sub> and &lt;em>A&lt;/em>&lt;sub>2&lt;/sub> have the same&#xA;     * identifier, and each value of &lt;em>A&lt;/em>&lt;sub>1&lt;/sub> is equal&#xA;     * to some value of &lt;em>A&lt;/em>&lt;sub>2&lt;/sub>.  This implies that the&#xA;     * order of values is not significant, and that&#xA;     * &lt;em>A&lt;/em>&lt;sub>2&lt;/sub> may contain &quot;extra&quot; values not found in&#xA;     * &lt;em>A&lt;/em>&lt;sub>1&lt;/sub> without affecting the comparison.  It&#xA;     * also implies that if &lt;em>A&lt;/em>&lt;sub>1&lt;/sub> has no values, then&#xA;     * testing for a match is equivalent to testing for the presence&#xA;     * of an attribute &lt;em>A&lt;/em>&lt;sub>2&lt;/sub> with the same&#xA;     * identifier.&#xA;     *&lt;p>&#xA;     * The precise definition of &quot;equality&quot; used in comparing attribute values&#xA;     * is defined by the underlying directory service.  It might use the&#xA;     * &lt;code>Object.equals&lt;/code> method, for example, or might use a schema&#xA;     * to specify a different equality operation.&#xA;     * For matching based on operations other than equality (such as&#xA;     * substring comparison) use the version of the &lt;code>search&lt;/code>&#xA;     * method that takes a filter argument.&#xA;     * &lt;p>&#xA;     * When changes are made to this &lt;tt>DirContext&lt;/tt>,&#xA;     * the effect on enumerations returned by prior calls to this method&#xA;     * is undefined.&#xA;     *&lt;p>&#xA;     * If the object does not have the attribute&#xA;     * specified, the directory will ignore the nonexistent attribute&#xA;     * and return the requested attributes that the object does have.&#xA;     *&lt;p>&#xA;     * A directory might return more attributes than was requested&#xA;     * (see &lt;strong>Attribute Type Names&lt;/strong> in the class description),&#xA;     * but is not allowed to return arbitrary, unrelated attributes.&#xA;     *&lt;p>&#xA;     * See also &lt;strong>Operational Attributes&lt;/strong> in the class&#xA;     * description.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to search&#xA;     * @param matchingAttributes&#xA;     *&#x9;&#x9;the attributes to search for.  If empty or null,&#xA;     *&#x9;&#x9;all objects in the target context are returned.&#xA;     * @param attributesToReturn&#xA;     *&#x9;&#x9;the attributes to return.  null indicates that&#xA;     *&#x9;&#x9;all attributes are to be returned;&#xA;     *&#x9;&#x9;an empty array indicates that none are to be returned.&#xA;     * @return&#xA;     *&#x9;&#x9;a non-null enumeration of &lt;tt>SearchResult&lt;/tt> objects.&#xA;     *&#x9;&#x9;Each &lt;tt>SearchResult&lt;/tt> contains the attributes&#xA;     *&#x9;&#x9;identified by &lt;code>attributesToReturn&lt;/code>&#xA;     *&#x9;&#x9;and the name of the corresponding object, named relative&#xA;     * &#x9;&#x9;to the context named by &lt;code>name&lt;/code>.&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see SearchControls&#xA;     * @see SearchResult&#xA;     * @see #search(Name, String, Object[], SearchControls)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="search">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SearchResult.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../NamingEnumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="matchingAttributes">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attributesToReturn">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Searches in a single context for objects that contain a&#xA;     * specified set of attributes, and retrieves selected attributes.&#xA;     * See {@link #search(Name, Attributes, String[])} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to search&#xA;     * @param matchingAttributes&#xA;     *&#x9;&#x9;the attributes to search for&#xA;     * @param attributesToReturn&#xA;     *&#x9;&#x9;the attributes to return&#xA;     * @return&#x9;a non-null enumeration of &lt;tt>SearchResult&lt;/tt> objects&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="search">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SearchResult.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../NamingEnumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="matchingAttributes">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Searches in a single context for objects that contain a&#xA;     * specified set of attributes.&#xA;     * This method returns all the attributes of such objects.&#xA;     * It is equivalent to supplying null as&#xA;     * the &lt;tt>atributesToReturn&lt;/tt> parameter to the method&#xA;     * &lt;code>search(Name, Attributes, String[])&lt;/code>.&#xA;     * &lt;br>&#xA;     * See {@link #search(Name, Attributes, String[])} for a full description.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to search&#xA;     * @param matchingAttributes&#xA;     *&#x9;&#x9;the attributes to search for&#xA;     * @return&#x9;an enumeration of &lt;tt>SearchResult&lt;/tt> objects&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #search(Name, Attributes, String[])&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="search">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SearchResult.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../NamingEnumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="matchingAttributes">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Attributes.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Searches in a single context for objects that contain a&#xA;     * specified set of attributes.&#xA;     * See {@link #search(Name, Attributes)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to search&#xA;     * @param matchingAttributes&#xA;     *&#x9;&#x9;the attributes to search for&#xA;     * @return&#x9;an enumeration of &lt;tt>SearchResult&lt;/tt> objects&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="search">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SearchResult.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../NamingEnumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filter">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cons">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SearchControls.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Searches in the named context or object for entries that satisfy the&#xA;     * given search filter.  Performs the search as specified by&#xA;     * the search controls.&#xA;     * &lt;p>&#xA;     * The format and interpretation of &lt;code>filter&lt;/code> follows RFC 2254&#xA;     * with the&#xA;     * following interpretations for &lt;code>attr&lt;/code> and &lt;code>value&lt;/code>&#xA;     * mentioned in the RFC.&#xA;     * &lt;p>&#xA;     * &lt;code>attr&lt;/code> is the attribute's identifier.&#xA;     * &lt;p>&#xA;     * &lt;code>value&lt;/code> is the string representation the attribute's value.&#xA;     * The translation of this string representation into the attribute's value&#xA;     * is directory-specific.&#xA;     * &lt;p>&#xA;     * For the assertion &quot;someCount=127&quot;, for example, &lt;code>attr&lt;/code>&#xA;     * is &quot;someCount&quot; and &lt;code>value&lt;/code> is &quot;127&quot;.&#xA;     * The provider determines, based on the attribute ID (&quot;someCount&quot;)&#xA;     * (and possibly its schema), that the attribute's value is an integer.&#xA;     * It then parses the string &quot;127&quot; appropriately.&#xA;     *&lt;p>&#xA;     * Any non-ASCII characters in the filter string should be&#xA;     * represented by the appropriate Java (Unicode) characters, and&#xA;     * not encoded as UTF-8 octets.  Alternately, the&#xA;     * &quot;backslash-hexcode&quot; notation described in RFC 2254 may be used.&#xA;     *&lt;p>&#xA;     * If the directory does not support a string representation of&#xA;     * some or all of its attributes, the form of &lt;code>search&lt;/code> that&#xA;     * accepts filter arguments in the form of Objects can be used instead.&#xA;     * The service provider for such a directory would then translate&#xA;     * the filter arguments to its service-specific representation&#xA;     * for filter evaluation.&#xA;     * See &lt;code>search(Name, String, Object[], SearchControls)&lt;/code>.&#xA;     * &lt;p>&#xA;     * RFC 2254 defines certain operators for the filter, including substring&#xA;     * matches, equality, approximate match, greater than, less than.  These&#xA;     * operators are mapped to operators with corresponding semantics in the&#xA;     * underlying directory. For example, for the equals operator, suppose&#xA;     * the directory has a matching rule defining &quot;equality&quot; of the&#xA;     * attributes in the filter. This rule would be used for checking&#xA;     * equality of the attributes specified in the filter with the attributes&#xA;     * of objects in the directory. Similarly, if the directory has a&#xA;     * matching rule for ordering, this rule would be used for&#xA;     * making &quot;greater than&quot; and &quot;less than&quot; comparisons.&#xA;     *&lt;p>&#xA;     * Not all of the operators defined in RFC 2254 are applicable to all&#xA;     * attributes.  When an operator is not applicable, the exception&#xA;     * &lt;code>InvalidSearchFilterException&lt;/code> is thrown.&#xA;     * &lt;p>&#xA;     * The result is returned in an enumeration of &lt;tt>SearchResult&lt;/tt>s.&#xA;     * Each &lt;tt>SearchResult&lt;/tt> contains the name of the object&#xA;     * and other information about the object (see SearchResult).&#xA;     * The name is either relative to the target context of the search&#xA;     * (which is named by the &lt;code>name&lt;/code> parameter), or&#xA;     * it is a URL string. If the target context is included in&#xA;     * the enumeration (as is possible when&#xA;     * &lt;code>cons&lt;/code> specifies a search scope of&#xA;     * &lt;code>SearchControls.OBJECT_SCOPE&lt;/code> or&#xA;     * &lt;code>SearchControls.SUBSTREE_SCOPE&lt;/code>), its name is the empty&#xA;     * string. The &lt;tt>SearchResult&lt;/tt> may also contain attributes of the&#xA;     * matching object if the &lt;tt>cons&lt;/tt> argument specified that attributes&#xA;     * be returned.&#xA;     *&lt;p>&#xA;     * If the object does not have a requested attribute, that&#xA;     * nonexistent attribute will be ignored.  Those requested&#xA;     * attributes that the object does have will be returned.&#xA;     *&lt;p>&#xA;     * A directory might return more attributes than were requested&#xA;     * (see &lt;strong>Attribute Type Names&lt;/strong> in the class description)&#xA;     * but is not allowed to return arbitrary, unrelated attributes.&#xA;     *&lt;p>&#xA;     * See also &lt;strong>Operational Attributes&lt;/strong> in the class&#xA;     * description.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context or object to search&#xA;     * @param filter&#xA;     *&#x9;&#x9;the filter expression to use for the search; may not be null&#xA;     * @param cons&#xA;     *&#x9;&#x9;the search controls that control the search.  If null,&#xA;     *&#x9;&#x9;the default search controls are used (equivalent&#xA;     *&#x9;&#x9;to &lt;tt>(new SearchControls())&lt;/tt>).&#xA;     * @return&#x9;an enumeration of &lt;tt>SearchResult&lt;/tt>s of&#xA;     * &#x9;&#x9;the objects that satisfy the filter; never null&#xA;     *&#xA;     * @throws&#x9;InvalidSearchFilterException if the search filter specified is&#xA;     *&#x9;&#x9;not supported or understood by the underlying directory&#xA;     * @throws&#x9;InvalidSearchControlsException if the search controls&#xA;     * &#x9;&#x9;contain invalid settings&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #search(Name, String, Object[], SearchControls)&#xA;     * @see SearchControls&#xA;     * @see SearchResult&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="search">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SearchResult.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../NamingEnumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filter">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cons">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SearchControls.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Searches in the named context or object for entries that satisfy the&#xA;     * given search filter.  Performs the search as specified by&#xA;     * the search controls.&#xA;     * See {@link #search(Name, String, SearchControls)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context or object to search&#xA;     * @param filter&#xA;     *&#x9;&#x9;the filter expression to use for the search; may not be null&#xA;     * @param cons&#xA;     *&#x9;&#x9;the search controls that control the search.  If null,&#xA;     *&#x9;&#x9;the default search controls are used (equivalent&#xA;     *&#x9;&#x9;to &lt;tt>(new SearchControls())&lt;/tt>).&#xA;     *&#xA;     * @return&#x9;an enumeration of &lt;tt>SearchResult&lt;/tt>s for&#xA;     * &#x9;&#x9;the objects that satisfy the filter.&#xA;     * @throws&#x9;InvalidSearchFilterException if the search filter specified is&#xA;     *&#x9;&#x9;not supported or understood by the underlying directory&#xA;     * @throws&#x9;InvalidSearchControlsException if the search controls&#xA;     * &#x9;&#x9;contain invalid settings&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="search">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SearchResult.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../NamingEnumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filterExpr">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filterArgs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cons">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SearchControls.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Searches in the named context or object for entries that satisfy the&#xA;     * given search filter.  Performs the search as specified by&#xA;     * the search controls.&#xA;     *&lt;p>&#xA;     * The interpretation of &lt;code>filterExpr&lt;/code> is based on RFC&#xA;     * 2254.  It may additionally contain variables of the form&#xA;     * &lt;code>{i}&lt;/code> -- where &lt;code>i&lt;/code> is an integer -- that&#xA;     * refer to objects in the &lt;code>filterArgs&lt;/code> array.  The&#xA;     * interpretation of &lt;code>filterExpr&lt;/code> is otherwise&#xA;     * identical to that of the &lt;code>filter&lt;/code> parameter of the&#xA;     * method &lt;code>search(Name, String, SearchControls)&lt;/code>.&#xA;     *&lt;p>&#xA;     * When a variable &lt;code>{i}&lt;/code> appears in a search filter, it&#xA;     * indicates that the filter argument &lt;code>filterArgs[i]&lt;/code>&#xA;     * is to be used in that place.  Such variables may be used&#xA;     * wherever an &lt;em>attr&lt;/em>, &lt;em>value&lt;/em>, or&#xA;     * &lt;em>matchingrule&lt;/em> production appears in the filter grammar&#xA;     * of RFC 2254, section 4.  When a string-valued filter argument&#xA;     * is substituted for a variable, the filter is interpreted as if&#xA;     * the string were given in place of the variable, with any&#xA;     * characters having special significance within filters (such as&#xA;     * &lt;code>'*'&lt;/code>) having been escaped according to the rules of&#xA;     * RFC 2254.&#xA;     *&lt;p>&#xA;     * For directories that do not use a string representation for&#xA;     * some or all of their attributes, the filter argument&#xA;     * corresponding to an attribute value may be of a type other than&#xA;     * String.  Directories that support unstructured binary-valued&#xA;     * attributes, for example, should accept byte arrays as filter&#xA;     * arguments.  The interpretation (if any) of filter arguments of&#xA;     * any other type is determined by the service provider for that&#xA;     * directory, which maps the filter operations onto operations with&#xA;     * corresponding semantics in the underlying directory.&#xA;     *&lt;p>&#xA;     * This method returns an enumeration of the results.&#xA;     * Each element in the enumeration contains the name of the object&#xA;     * and other information about the object (see &lt;code>SearchResult&lt;/code>).&#xA;     * The name is either relative to the target context of the search&#xA;     * (which is named by the &lt;code>name&lt;/code> parameter), or&#xA;     * it is a URL string. If the target context is included in&#xA;     * the enumeration (as is possible when&#xA;     * &lt;code>cons&lt;/code> specifies a search scope of&#xA;     * &lt;code>SearchControls.OBJECT_SCOPE&lt;/code> or&#xA;     * &lt;code>SearchControls.SUBSTREE_SCOPE&lt;/code>),&#xA;     * its name is the empty string.&#xA;     *&lt;p>&#xA;     * The &lt;tt>SearchResult&lt;/tt> may also contain attributes of the matching&#xA;     * object if the &lt;tt>cons&lt;/tt> argument specifies that attributes be&#xA;     * returned.&#xA;     *&lt;p>&#xA;     * If the object does not have a requested attribute, that&#xA;     * nonexistent attribute will be ignored.  Those requested&#xA;     * attributes that the object does have will be returned.&#xA;     *&lt;p>&#xA;     * A directory might return more attributes than were requested&#xA;     * (see &lt;strong>Attribute Type Names&lt;/strong> in the class description)&#xA;     * but is not allowed to return arbitrary, unrelated attributes.&#xA;     *&lt;p>&#xA;     * If a search filter with invalid variable substitutions is provided&#xA;     * to this method, the result is undefined.&#xA;     * When changes are made to this DirContext,&#xA;     * the effect on enumerations returned by prior calls to this method&#xA;     * is undefined.&#xA;     *&lt;p>&#xA;     * See also &lt;strong>Operational Attributes&lt;/strong> in the class&#xA;     * description.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context or object to search&#xA;     * @param filterExpr&#xA;     *&#x9;&#x9;the filter expression to use for the search.&#xA;     *&#x9;&#x9;The expression may contain variables of the&#xA;     *&#x9;&#x9;form &quot;&lt;code>{i}&lt;/code>&quot; where &lt;code>i&lt;/code>&#xA;     *&#x9;&#x9;is a nonnegative integer.  May not be null.&#xA;     * @param filterArgs&#xA;     *&#x9;&#x9;the array of arguments to substitute for the variables&#xA;     *&#x9;&#x9;in &lt;code>filterExpr&lt;/code>.  The value of&#xA;     *&#x9;&#x9;&lt;code>filterArgs[i]&lt;/code> will replace each&#xA;     *&#x9;&#x9;occurrence of &quot;&lt;code>{i}&lt;/code>&quot;.&#xA;     *&#x9;&#x9;If null, equivalent to an empty array.&#xA;     * @param cons&#xA;     *&#x9;&#x9;the search controls that control the search.  If null,&#xA;     *&#x9;&#x9;the default search controls are used (equivalent&#xA;     *&#x9;&#x9;to &lt;tt>(new SearchControls())&lt;/tt>).&#xA;     * @return&#x9;an enumeration of &lt;tt>SearchResult&lt;/tt>s of the objects&#xA;     *&#x9;&#x9;that satisfy the filter; never null&#xA;     *&#xA;     * @throws&#x9;ArrayIndexOutOfBoundsException if &lt;tt>filterExpr&lt;/tt> contains&#xA;     *&#x9;&#x9;&lt;code>{i}&lt;/code> expressions where &lt;code>i&lt;/code> is outside&#xA;     *&#x9;&#x9;the bounds of the array &lt;code>filterArgs&lt;/code>&#xA;     * @throws&#x9;InvalidSearchControlsException if &lt;tt>cons&lt;/tt> contains&#xA;     *&#x9;&#x9;invalid settings&#xA;     * @throws&#x9;InvalidSearchFilterException if &lt;tt>filterExpr&lt;/tt> with&#xA;     *&#x9;&#x9;&lt;tt>filterArgs&lt;/tt> represents an invalid search filter&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #search(Name, Attributes, String[])&#xA;     * @see java.text.MessageFormat&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="search">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SearchResult.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../NamingEnumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filterExpr">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filterArgs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cons">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SearchControls.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Searches in the named context or object for entries that satisfy the&#xA;     * given search filter.  Performs the search as specified by&#xA;     * the search controls.&#xA;     * See {@link #search(Name, String, Object[], SearchControls)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context or object to search&#xA;     * @param filterExpr&#xA;     *&#x9;&#x9;the filter expression to use for the search.&#xA;     *&#x9;&#x9;The expression may contain variables of the&#xA;     *&#x9;&#x9;form &quot;&lt;code>{i}&lt;/code>&quot; where &lt;code>i&lt;/code>&#xA;     *&#x9;&#x9;is a nonnegative integer.  May not be null.&#xA;     * @param filterArgs&#xA;     *&#x9;&#x9;the array of arguments to substitute for the variables&#xA;     *&#x9;&#x9;in &lt;code>filterExpr&lt;/code>.  The value of&#xA;     *&#x9;&#x9;&lt;code>filterArgs[i]&lt;/code> will replace each&#xA;     *&#x9;&#x9;occurrence of &quot;&lt;code>{i}&lt;/code>&quot;.&#xA;     *&#x9;&#x9;If null, equivalent to an empty array.&#xA;     * @param cons&#xA;     *&#x9;&#x9;the search controls that control the search.  If null,&#xA;     *&#x9;&#x9;the default search controls are used (equivalent&#xA;     *&#x9;&#x9;to &lt;tt>(new SearchControls())&lt;/tt>).&#xA;     * @return&#x9;an enumeration of &lt;tt>SearchResult&lt;/tt>s of the objects&#xA;     *&#x9;&#x9;that satisfy the filter; never null&#xA;     *&#xA;     * @throws&#x9;ArrayIndexOutOfBoundsException if &lt;tt>filterExpr&lt;/tt> contains&#xA;     *&#x9;&#x9;&lt;code>{i}&lt;/code> expressions where &lt;code>i&lt;/code> is outside&#xA;     *&#x9;&#x9;the bounds of the array &lt;code>filterArgs&lt;/code>&#xA;     * @throws&#x9;InvalidSearchControlsException if &lt;tt>cons&lt;/tt> contains&#xA;     *&#x9;&#x9;invalid settings&#xA;     * @throws&#x9;InvalidSearchFilterException if &lt;tt>filterExpr&lt;/tt> with&#xA;     *&#x9;&#x9;&lt;tt>filterArgs&lt;/tt> represents an invalid search filter&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The directory service interface, containing&#xA; * methods for examining and updating attributes&#xA; * associated with objects, and for searching the directory.&#xA; * &lt;p>&#xA; * &lt;h4>Names&lt;/h4>&#xA; * Each name passed as an argument to a &lt;tt>DirContext&lt;/tt> method is relative&#xA; * to that context.  The empty name is used to name the context itself.&#xA; * The name parameter may never be null.&#xA; * &lt;p>&#xA; * Most of the methods have overloaded versions with one taking a&#xA; * &lt;code>Name&lt;/code> parameter and one taking a &lt;code>String&lt;/code>.&#xA; * These overloaded versions are equivalent in that if&#xA; * the &lt;code>Name&lt;/code> and &lt;code>String&lt;/code> parameters are just&#xA; * different representations of the same name, then the overloaded&#xA; * versions of the same methods behave the same.&#xA; * In the method descriptions below, only one version is documented.&#xA; * The second version instead has a link to the first:  the same&#xA; * documentation applies to both.&#xA; * &lt;p>&#xA; * See &lt;tt>Context&lt;/tt> for a discussion on the interpretation of the&#xA; * name argument to the &lt;tt>Context&lt;/tt> methods. These same rules&#xA; * apply to the name argument to the &lt;tt>DirContext&lt;/tt> methods.&#xA; * &lt;p>&#xA; * &lt;h4>Attribute Models&lt;/h4>&#xA; * There are two basic models of what attributes should be&#xA; * associated with.  First, attributes may be directly associated with a&#xA; * DirContext object.&#xA; * In this model, an attribute operation on the named object is&#xA; * roughly equivalent&#xA; * to a lookup on the name (which returns the DirContext object),&#xA; * followed by the attribute operation invoked on the DirContext object&#xA; * in which the caller supplies an empty name. The attributes can be viewed&#xA; * as being stored along with the object (note that this does not imply that&#xA; * the implementation must do so).&#xA; * &lt;p>&#xA; * The second model is that attributes are associated with a&#xA; * name (typically an atomic name) in a DirContext.&#xA; * In this model, an attribute operation on the named object is&#xA; * roughly equivalent to a lookup on the name of the parent DirContext of the&#xA; * named object, followed by the attribute operation invoked on the parent&#xA; * in which the caller supplies the terminal atomic name.&#xA; * The attributes can be viewed as being stored in the parent DirContext&#xA; * (again, this does not imply that the implementation must do so).&#xA; * Objects that are not DirContexts can have attributes, as long as&#xA; * their parents are DirContexts.&#xA; * &lt;p>&#xA; * JNDI support both of these models.&#xA; * It is up to the individual service providers to decide where to&#xA; * &quot;store&quot; attributes.&#xA; * JNDI clients are safest when they do not make assumptions about&#xA; * whether an object's attributes are stored as part of the object, or stored&#xA; * within the parent object and associated with the object's name.&#xA; * &lt;p>&#xA; * &lt;h4>Attribute Type Names&lt;/h4>&#xA; * In the &lt;tt>getAttributes()&lt;/tt> and &lt;tt>search()&lt;/tt> methods,&#xA; * you can supply the attributes to return by supplying a list of&#xA; * attribute names (strings).&#xA; * The attributes that you get back might not have the same names as the&#xA; * attribute names you have specified. This is because some directories&#xA; * support features that cause them to return other attributes.  Such&#xA; * features include attribute subclassing, attribute name synonyms, and&#xA; * attribute language codes.&#xA; * &lt;p>&#xA; * In attribute subclassing, attributes are defined in a class hierarchy.&#xA; * In some directories, for example, the &quot;name&quot; attribute might be the&#xA; * superclass of all name-related attributes, including &quot;commonName&quot; and&#xA; * &quot;surName&quot;.  Asking for the &quot;name&quot; attribute might return both the&#xA; * &quot;commonName&quot; and &quot;surName&quot; attributes.&#xA; * &lt;p>&#xA; * With attribute type synonyms, a directory can assign multiple names to&#xA; * the same attribute. For example, &quot;cn&quot; and &quot;commonName&quot; might both&#xA; * refer to the same attribute. Asking for &quot;cn&quot; might return the&#xA; * &quot;commonName&quot; attribute.&#xA; * &lt;p>&#xA; * Some directories support the language codes for attributes.&#xA; * Asking such a directory for the &quot;description&quot; attribute, for example,&#xA; * might return all of the following attributes:&#xA; * &lt;ul>&#xA; * &lt;li>description&#xA; * &lt;li>description;lang-en&#xA; * &lt;li>description;lang-de&#xA; * &lt;li>description;lang-fr&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p>&#xA; *&lt;h4>Operational Attributes&lt;/h4>&#xA; *&lt;p>&#xA; * Some directories have the notion of &quot;operational attributes&quot; which are&#xA; * attributes associated with a directory object for administrative&#xA; * purposes. An example of operational attributes is the access control&#xA; * list for an object.&#xA; * &lt;p>&#xA; * In the &lt;tt>getAttributes()&lt;/tt> and &lt;tt>search()&lt;/tt> methods,&#xA; * you can specify that all attributes associated with the requested objects&#xA; * be returned by supply &lt;tt>null&lt;/tt> as the list of attributes to return.&#xA; * The attributes returned do &lt;em>not&lt;/em> include operational attributes.&#xA; * In order to retrieve operational attributes, you must name them explicitly.&#xA; *&#xA; * &lt;p>&#xA; * &lt;h4>Named Context&lt;/h4>&#xA; * &lt;p>&#xA; * There are certain methods in which the name must resolve to a context&#xA; * (for example, when searching a single level context). The documentation&#xA; * of such methods&#xA; * use the term &lt;em>named context&lt;/em> to describe their name parameter.&#xA; * For these methods, if the named object is not a DirContext,&#xA; * &lt;code>NotContextException&lt;/code> is thrown.&#xA; * Aside from these methods, there is no requirement that the&#xA; * &lt;em>named object&lt;/em> be a DirContext.&#xA; *&lt;p>&#xA; *&lt;h4>Parameters&lt;/h4>&#xA; *&lt;p>&#xA; * An &lt;tt>Attributes&lt;/tt>, &lt;tt>SearchControls&lt;/tt>, or array object&#xA; * passed as a parameter to any method will not be modified by the&#xA; * service provider.  The service provider may keep a reference to it&#xA; * for the duration of the operation, including any enumeration of the&#xA; * method's results and the processing of any referrals generated.&#xA; * The caller should not modify the object during this time.&#xA; * An &lt;tt>Attributes&lt;/tt> object returned by any method is owned by&#xA; * the caller.  The caller may subsequently modify it; the service&#xA; * provider will not.&#xA; *&lt;p>&#xA; *&lt;h4>Exceptions&lt;/h4>&#xA; *&lt;p>&#xA; * All the methods in this interface can throw a NamingException or&#xA; * any of its subclasses. See NamingException and their subclasses&#xA; * for details on each exception.&#xA; *&#xA; * @author Rosanna Lee&#xA; * @author Scott Seligman&#xA; * @author R. Vasudevan&#xA; * @version 1.11 04/05/05&#xA; *&#xA; * @see javax.naming.Context&#xA; * @since 1.3&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../Context.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
