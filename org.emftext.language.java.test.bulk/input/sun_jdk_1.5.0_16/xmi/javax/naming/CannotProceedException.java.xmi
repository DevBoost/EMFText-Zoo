<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="CannotProceedException.java">
  <comments>/*&#xA; * @(#)CannotProceedException.java&#x9;1.11 04/07/16&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>naming</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/util/Hashtable.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="CannotProceedException">
    <members xsi:type="members:Field" name="remainingNewName">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Contains the remaining unresolved part of the second&#xA;     * &quot;name&quot; argument to Context.rename().&#xA;     * This information necessary for&#xA;     * continuing the Context.rename() operation.&#xA;     * &lt;p>&#xA;     * This field is initialized to null.&#xA;     * It should not be manipulated directly:  it should&#xA;     * be accessed and updated using getRemainingName() and setRemainingName().&#xA;     * @serial&#xA;     *&#xA;     * @see #getRemainingNewName&#xA;     * @see #setRemainingNewName&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="environment">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:UnknownTypeArgument"/>
          <typeArguments xsi:type="generics:UnknownTypeArgument"/>
          <target xsi:type="classifiers:Class" href="../../java/util/Hashtable.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Contains the environment&#xA;     * relevant for the Context or DirContext method that cannot proceed.&#xA;     * &lt;p>&#xA;     * This field is initialized to null.&#xA;     * It should not be manipulated directly:  it should be accessed&#xA;     * and updated using getEnvironment() and setEnvironment().&#xA;     * @serial&#xA;     *&#xA;     * @see #getEnvironment&#xA;     * @see #setEnvironment&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="altName">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Contains the name of the resolved object, relative&#xA;     * to the context &lt;code>altNameCtx&lt;/code>.  It is a composite name.&#xA;     * If null, then no name is specified.&#xA;     * See the &lt;code>javax.naming.spi.ObjectFactory.getObjectInstance&lt;/code>&#xA;     * method for details on how this is used.&#xA;     * &lt;p>&#xA;     * This field is initialized to null.&#xA;     * It should not be manipulated directly:  it should&#xA;     * be accessed and updated using getAltName() and setAltName().&#xA;     * @serial&#xA;     *&#xA;     * @see #getAltName&#xA;     * @see #setAltName&#xA;     * @see #altNameCtx&#xA;     * @see javax.naming.spi.ObjectFactory#getObjectInstance&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="altNameCtx">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Context.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Contains the context relative to which&#xA;     * &lt;code>altName&lt;/code> is specified.  If null, then the default initial&#xA;     * context is implied.&#xA;     * See the &lt;code>javax.naming.spi.ObjectFactory.getObjectInstance&lt;/code>&#xA;     * method for details on how this is used.&#xA;     * &lt;p>&#xA;     * This field is initialized to null.&#xA;     * It should not be manipulated directly:  it should&#xA;     * be accessed and updated using getAltNameCtx() and setAltNameCtx().&#xA;     * @serial&#xA;     *&#xA;     * @see #getAltNameCtx&#xA;     * @see #setAltNameCtx&#xA;     * @see #altName&#xA;     * @see javax.naming.spi.ObjectFactory#getObjectInstance&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="CannotProceedException">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="explanation">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new instance of CannotProceedException using an&#xA;     * explanation. All unspecified fields default to null.&#xA;     *&#xA;     * @param&#x9;explanation&#x9;A possibly null string containing additional&#xA;     * &#x9;&#x9;&#x9;&#x9;detail about this exception.&#xA;     *&#x9; If null, this exception has no detail message.&#xA;     * @see java.lang.Throwable#getMessage&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="CannotProceedException">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Constructs a new instance of CannotProceedException.&#xA;      * All fields default to null.&#xA;      */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getEnvironment">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:UnknownTypeArgument"/>
          <typeArguments xsi:type="generics:UnknownTypeArgument"/>
          <target xsi:type="classifiers:Class" href="../../java/util/Hashtable.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the environment that was in effect when this exception&#xA;     * was created.&#xA;     * @return Possibly null environment property set.&#xA;     *&#x9;&#x9;null means no environment was recorded for this exception.&#xA;     * @see #setEnvironment&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setEnvironment">
      <comments>// %%% clone it??</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="environment">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Class" href="../../java/util/Hashtable.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the environment that will be returned when getEnvironment()&#xA;     * is called.&#xA;     * @param environment A possibly null environment property set.&#xA;     * &#x9;&#x9;null means no environment is being recorded for &#xA;     * &#x9;&#x9;this exception.&#xA;     * @see #getEnvironment&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getRemainingNewName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the &quot;remaining new name&quot; field of this exception, which is&#xA;     * used when this exception is thrown during a rename() operation.&#xA;     *&#xA;     * @return The possibly null part of the new name that has not been resolved.&#xA;     * &#x9;&#x9;It is a composite name. It can be null, which means&#xA;     *&#x9;&#x9;the remaining new name field has not been set.&#xA;     *&#xA;     * @see #setRemainingNewName&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setRemainingNewName">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the &quot;remaining new name&quot; field of this exception.&#xA;     * This is the value returned by &lt;code>getRemainingNewName()&lt;/code>.&#xA;     *&lt;p>&#xA;     * &lt;tt>newName&lt;/tt> is a composite name. If the intent is to set&#xA;     * this field using a compound name or string, you must &#xA;     * &quot;stringify&quot; the compound name, and create a composite&#xA;     * name with a single component using the string. You can then&#xA;     * invoke this method using the resulting composite name.&#xA;     *&lt;p>&#xA;     * A copy of &lt;code>newName&lt;/code> is made and stored.&#xA;     * Subsequent changes to &lt;code>name&lt;/code> does not&#xA;     * affect the copy in this NamingException and vice versa.&#xA;     *&#xA;     * @param newName The possibly null name to set the &quot;remaining new name&quot; to.&#xA;     *&#x9;&#x9;If null, it sets the remaining name field to null.&#xA;     *&#xA;     * @see #getRemainingNewName&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="Name.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                </expression>
              </child>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:NullLiteral"/>
          </expression>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAltName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the &lt;code>altName&lt;/code> field of this exception.&#xA;     * This is the name of the resolved object, relative to the context&#xA;     * &lt;code>altNameCtx&lt;/code>. It will be used during a subsequent call to the&#xA;     * &lt;code>javax.naming.spi.ObjectFactory.getObjectInstance&lt;/code> method.&#xA;     *&#xA;     * @return The name of the resolved object, relative to&#xA;     *&#x9;&#x9;&lt;code>altNameCtx&lt;/code>.&#xA;     * &#x9;&#x9;It is a composite name.  If null, then no name is specified.&#xA;     *&#xA;     * @see #setAltName&#xA;     * @see #getAltNameCtx&#xA;     * @see javax.naming.spi.ObjectFactory#getObjectInstance&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setAltName">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="altName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the &lt;code>altName&lt;/code> field of this exception.&#xA;     *&#xA;     * @param altName&#x9;The name of the resolved object, relative to&#xA;     *&#x9;&#x9;&#x9;&lt;code>altNameCtx&lt;/code>.&#xA;     * &#x9;&#x9;&#x9;It is a composite name.&#xA;     *&#x9;&#x9;&#x9;If null, then no name is specified.&#xA;     *&#xA;     * @see #getAltName&#xA;     * @see #setAltNameCtx&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAltNameCtx">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Context.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the &lt;code>altNameCtx&lt;/code> field of this exception.&#xA;     * This is the context relative to which &lt;code>altName&lt;/code> is named.&#xA;     * It will be used during a subsequent call to the&#xA;     * &lt;code>javax.naming.spi.ObjectFactory.getObjectInstance&lt;/code> method.&#xA;     *&#xA;     * @return&#x9;The context relative to which &lt;code>altName&lt;/code> is named.&#xA;     *&#x9;&#x9;If null, then the default initial context is implied.&#xA;     *&#xA;     * @see #setAltNameCtx&#xA;     * @see #getAltName&#xA;     * @see javax.naming.spi.ObjectFactory#getObjectInstance&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setAltNameCtx">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="altNameCtx">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Context.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the &lt;code>altNameCtx&lt;/code> field of this exception.&#xA;     *&#xA;     * @param altNameCtx&#xA;     *&#x9;&#x9;&#x9;The context relative to which &lt;code>altName&lt;/code>&#xA;     *&#x9;&#x9;&#x9;is named.  If null, then the default initial context&#xA;     *&#x9;&#x9;&#x9;is implied.&#xA;     *&#xA;     * @see #getAltNameCtx&#xA;     * @see #setAltName&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="1219724816191576813"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Use serialVersionUID from JNDI 1.1.1 for interoperability&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA;  * This exception is thrown to indicate that the operation reached &#xA;  * a point in the name where the operation cannot proceed any further.&#xA;  * When performing an operation on a composite name, a naming service&#xA;  * provider may reach a part of the name that does not belong to its&#xA;  * namespace.  At that point, it can construct a&#xA;  * CannotProceedException and then invoke methods provided by&#xA;  * javax.naming.spi.NamingManager (such as getContinuationContext())&#xA;  * to locate another provider to continue the operation.  If this is&#xA;  * not possible, this exception is raised to the caller of the&#xA;  * context operation.&#xA;  *&lt;p>&#xA;  * If the program wants to handle this exception in particular, it&#xA;  * should catch CannotProceedException explicitly before attempting to&#xA;  * catch NamingException.&#xA;  *&lt;p>&#xA;  * A CannotProceedException instance is not synchronized against concurrent &#xA;  * multithreaded access. Multiple threads trying to access and modify&#xA;  * CannotProceedException should lock the object.&#xA;  *&#xA;  * @author Rosanna Lee&#xA;  * @author Scott Seligman&#xA;  * @version 1.11 04/07/16&#xA;  * @since 1.3&#xA;  */</comments>
      <comments>/*&#xA;  * The serialized form of a CannotProceedException object consists of&#xA;  * the serialized fields of its NamingException superclass, the remaining new&#xA;  * name (a Name object), the environment (a Hashtable), the altName field&#xA;  * (a Name object), and the serialized form of the altNameCtx field.&#xA;  */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
