<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="Name.java">
  <comments>/*&#xA; * @(#)Name.java&#x9;1.11 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>naming</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="Name">
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="3617482732056931635"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;    * The class fingerprint that is set to indicate&#xA;    * serialization compatibility with a previous&#xA;    * version of the class.&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a new copy of this name.&#xA;     * Subsequent changes to the components of this name will not&#xA;     * affect the new copy, and vice versa.&#xA;     *&#xA;     * @return&#x9;a copy of this name&#xA;     *&#xA;     * @see Object#clone()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares this name with another name for order.&#xA;     * Returns a negative integer, zero, or a positive integer as this&#xA;     * name is less than, equal to, or greater than the given name.&#xA;     *&#xA;     * &lt;p> As with &lt;tt>Object.equals()&lt;/tt>, the notion of ordering for names &#xA;     * depends on the class that implements this interface.&#xA;     * For example, the ordering may be&#xA;     * based on lexicographical ordering of the name components.&#xA;     * Specific attributes of the name, such as how it treats case,&#xA;     * may affect the ordering.  In general, two names of different&#xA;     * classes may not be compared.&#xA;     *&#xA;     * @param   obj the non-null object to compare against.&#xA;     * @return  a negative integer, zero, or a positive integer as this name&#xA;     *&#x9;&#x9;is less than, equal to, or greater than the given name&#xA;     * @throws&#x9;ClassCastException if obj is not a &lt;tt>Name&lt;/tt> of a&#xA;     *&#x9;&#x9;type that may be compared with this name&#xA;     *&#xA;     * @see Comparable#compareTo(Object)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="size">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the number of components in this name.&#xA;     *&#xA;     * @return&#x9;the number of components in this name&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isEmpty">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines whether this name is empty.&#xA;     * An empty name is one with zero components.&#xA;     *&#xA;     * @return&#x9;true if this name is empty, false otherwise&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAll">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the components of this name as an enumeration&#xA;     * of strings.  The effect on the enumeration of updates to&#xA;     * this name is undefined.  If the name has zero components,&#xA;     * an empty (non-null) enumeration is returned.&#xA;     *&#xA;     * @return&#x9;an enumeration of the components of this name, each a string&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves a component of this name.&#xA;     *&#xA;     * @param posn&#xA;     *&#x9;&#x9;the 0-based index of the component to retrieve.&#xA;     *&#x9;&#x9;Must be in the range [0,size()).&#xA;     * @return&#x9;the component at index posn&#xA;     * @throws&#x9;ArrayIndexOutOfBoundsException&#xA;     *&#x9;&#x9;if posn is outside the specified range&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPrefix">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a name whose components consist of a prefix of the&#xA;     * components of this name.  Subsequent changes to&#xA;     * this name will not affect the name that is returned and vice versa.&#xA;     *&#xA;     * @param posn&#xA;     *&#x9;&#x9;the 0-based index of the component at which to stop.&#xA;     *&#x9;&#x9;Must be in the range [0,size()].&#xA;     * @return&#x9;a name consisting of the components at indexes in&#xA;     *&#x9;&#x9;the range [0,posn).&#xA;     * @throws&#x9;ArrayIndexOutOfBoundsException&#xA;     *&#x9;&#x9;if posn is outside the specified range&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSuffix">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a name whose components consist of a suffix of the&#xA;     * components in this name.  Subsequent changes to&#xA;     * this name do not affect the name that is returned and vice versa.&#xA;     *&#xA;     * @param posn&#xA;     *&#x9;&#x9;the 0-based index of the component at which to start.&#xA;     *&#x9;&#x9;Must be in the range [0,size()].&#xA;     * @return&#x9;a name consisting of the components at indexes in&#xA;     *&#x9;&#x9;the range [posn,size()).  If posn is equal to &#xA;     *&#x9;&#x9;size(), an empty name is returned.&#xA;     * @throws&#x9;ArrayIndexOutOfBoundsException&#xA;     *&#x9;&#x9;if posn is outside the specified range&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="startsWith">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines whether this name starts with a specified prefix.&#xA;     * A name &lt;tt>n&lt;/tt> is a prefix if it is equal to&#xA;     * &lt;tt>getPrefix(n.size())&lt;/tt>.&#xA;     *&#xA;     * @param n&#xA;     *&#x9;&#x9;the name to check&#xA;     * @return&#x9;true if &lt;tt>n&lt;/tt> is a prefix of this name, false otherwise&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="endsWith">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines whether this name ends with a specified suffix.&#xA;     * A name &lt;tt>n&lt;/tt> is a suffix if it is equal to&#xA;     * &lt;tt>getSuffix(size()-n.size())&lt;/tt>.&#xA;     *&#xA;     * @param n&#xA;     *&#x9;&#x9;the name to check&#xA;     * @return&#x9;true if &lt;tt>n&lt;/tt> is a suffix of this name, false otherwise&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addAll">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="suffix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds the components of a name -- in order -- to the end of this name.&#xA;     *&#xA;     * @param suffix&#xA;     *&#x9;&#x9;the components to add&#xA;     * @return&#x9;the updated name (not a new one)&#xA;     *&#xA;     * @throws&#x9;InvalidNameException if &lt;tt>suffix&lt;/tt> is not a valid name,&#xA;     *&#x9;&#x9;or if the addition of the components would violate the syntax&#xA;     *&#x9;&#x9;rules of this name&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addAll">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds the components of a name -- in order -- at a specified position&#xA;     * within this name.&#xA;     * Components of this name at or after the index of the first new&#xA;     * component are shifted up (away from 0) to accommodate the new&#xA;     * components.&#xA;     *&#xA;     * @param n&#xA;     *&#x9;&#x9;the components to add&#xA;     * @param posn&#xA;     *&#x9;&#x9;the index in this name at which to add the new&#xA;     *&#x9;&#x9;components.  Must be in the range [0,size()].&#xA;     * @return&#x9;the updated name (not a new one)&#xA;     *&#xA;     * @throws&#x9;ArrayIndexOutOfBoundsException&#xA;     *&#x9;&#x9;if posn is outside the specified range&#xA;     * @throws&#x9;InvalidNameException if &lt;tt>n&lt;/tt> is not a valid name,&#xA;     *&#x9;&#x9;or if the addition of the components would violate the syntax&#xA;     *&#x9;&#x9;rules of this name&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="add">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="comp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds a single component to the end of this name.&#xA;     *&#xA;     * @param comp&#xA;     *&#x9;&#x9;the component to add&#xA;     * @return&#x9;the updated name (not a new one)&#xA;     *&#xA;     * @throws&#x9;InvalidNameException if adding &lt;tt>comp&lt;/tt> would violate&#xA;     *&#x9;&#x9;the syntax rules of this name&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="add">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="comp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds a single component at a specified position within this name.&#xA;     * Components of this name at or after the index of the new component&#xA;     * are shifted up by one (away from index 0) to accommodate the new&#xA;     * component.&#xA;     *&#xA;     * @param comp&#xA;     *&#x9;&#x9;the component to add&#xA;     * @param posn&#xA;     *&#x9;&#x9;the index at which to add the new component.&#xA;     *&#x9;&#x9;Must be in the range [0,size()].&#xA;     * @return&#x9;the updated name (not a new one)&#xA;     *&#xA;     * @throws&#x9;ArrayIndexOutOfBoundsException&#xA;     *&#x9;&#x9;if posn is outside the specified range&#xA;     * @throws&#x9;InvalidNameException if adding &lt;tt>comp&lt;/tt> would violate&#xA;     *&#x9;&#x9;the syntax rules of this name&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="remove">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes a component from this name.&#xA;     * The component of this name at the specified position is removed.&#xA;     * Components with indexes greater than this position&#xA;     * are shifted down (toward index 0) by one.&#xA;     *&#xA;     * @param posn&#xA;     *&#x9;&#x9;the index of the component to remove.&#xA;     *&#x9;&#x9;Must be in the range [0,size()).&#xA;     * @return&#x9;the component removed (a String)&#xA;     *&#xA;     * @throws&#x9;ArrayIndexOutOfBoundsException&#xA;     *&#x9;&#x9;if posn is outside the specified range&#xA;     * @throws&#x9;InvalidNameException if deleting the component&#xA;     *&#x9;&#x9;would violate the syntax rules of the name&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;tt>Name&lt;/tt> interface represents a generic name -- an ordered&#xA; * sequence of components.  It can be a composite name (names that&#xA; * span multiple namespaces), or a compound name (names that are&#xA; * used within individual hierarchical naming systems).&#xA; *&#xA; * &lt;p> There can be different implementations of &lt;tt>Name&lt;/tt>; for example,&#xA; * composite names, URLs, or namespace-specific compound names.&#xA; *&#xA; * &lt;p> The components of a name are numbered.  The indexes of a name&#xA; * with N components range from 0 up to, but not including, N.  This&#xA; * range may be written as [0,N).&#xA; * The most significant component is at index 0.&#xA; * An empty name has no components.&#xA; *&#xA; * &lt;p> None of the methods in this interface accept null as a valid&#xA; * value for a parameter that is a name or a name component.&#xA; * Likewise, methods that return a name or name component never return null.&#xA; *&#xA; * &lt;p> An instance of a &lt;tt>Name&lt;/tt> may not be synchronized against&#xA; * concurrent multithreaded access if that access is not read-only.&#xA; *&#xA; * @author Rosanna Lee&#xA; * @author Scott Seligman&#xA; * @author R. Vasudevan&#xA; * @version 1.11 04/05/05&#xA; * @since 1.3&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../java/lang/Cloneable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
    <extends xsi:type="types:NamespaceClassifierReference">
      <namespaces>java</namespaces>
      <namespaces>io</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../java/io/Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="../../java/lang/Comparable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
