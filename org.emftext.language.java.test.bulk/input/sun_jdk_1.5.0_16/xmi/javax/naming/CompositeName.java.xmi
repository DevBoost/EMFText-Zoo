<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="CompositeName.java">
  <comments>/*&#xA; * @(#)CompositeName.java&#x9;1.14 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>naming</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/util/Properties.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="CompositeName">
    <comments>/*&#xA;    // %%% Test code for serialization.&#xA;    public static void main(String[] args) throws Exception {&#xA;&#x9;CompositeName c = new CompositeName(&quot;aaa/bbb&quot;);&#xA;&#x9;java.io.FileOutputStream f1 = new java.io.FileOutputStream(&quot;/tmp/ser&quot;);&#xA;&#x9;java.io.ObjectOutputStream s1 = new java.io.ObjectOutputStream(f1);&#xA;&#x9;s1.writeObject(c);&#xA;&#x9;s1.close();&#xA;&#x9;java.io.FileInputStream f2 = new java.io.FileInputStream(&quot;/tmp/ser&quot;);&#xA;&#x9;java.io.ObjectInputStream s2 = new java.io.ObjectInputStream(f2);&#xA;&#x9;c = (CompositeName)s2.readObject();&#xA;&#xA;&#x9;System.out.println(&quot;Size: &quot; + c.size());&#xA;&#x9;System.out.println(&quot;Size: &quot; + c.snit);&#xA;    }&#xA;*/</comments>
    <comments>/*&#xA;   %%% Testing code&#xA;    public static void main(String[] args) {&#xA;&#x9;try {&#xA;&#x9;    for (int i = 0; i &lt; args.length; i++) {&#xA;&#x9;&#x9;Name name;&#xA;&#x9;&#x9;Enumeration e;&#xA;&#x9;&#x9;System.out.println(&quot;Given name: &quot; + args[i]);&#xA;&#x9;&#x9;name = new CompositeName(args[i]);&#xA;&#x9;&#x9;e = name.getComponents();&#xA;&#x9;&#x9;while (e.hasMoreElements()) {&#xA;&#x9;&#x9;    System.out.println(&quot;Element: &quot; + e.nextElement());&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;System.out.println(&quot;Constructed name: &quot; + name.toString());&#xA;&#x9;    }&#xA;&#x9;} catch (Exception ne) {&#xA;&#x9;    ne.printStackTrace();&#xA;&#x9;}&#xA;    }&#xA;*/</comments>
    <members xsi:type="members:Field" name="impl">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NameImpl.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Constructor" name="CompositeName">
      <comments>// null means use default syntax</comments>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="NameImpl.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="comps">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;      * Constructs a new composite name instance using the components&#xA;      * specified by 'comps'. This protected method is intended to be&#xA;      * to be used by subclasses of CompositeName when they override&#xA;      * methods such as clone(), getPrefix(), getSuffix().&#xA;      *&#xA;      * @param comps A non-null enumeration containing the components for the new&#xA;      *              composite name. Each element is of class String.&#xA;      *               The enumeration will be consumed to extract its&#xA;      *               elements.&#xA;      */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="CompositeName">
      <comments>// null means use default syntax</comments>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="NameImpl.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Constructs a new composite name instance by parsing the string n&#xA;      * using the composite name syntax (left-to-right, slash separated).&#xA;      * The composite name syntax is described in detail in the class&#xA;      * description.&#xA;      *&#xA;      * @param&#x9;n&#x9;The non-null string to parse.&#xA;      * @exception InvalidNameException If n has invalid composite name syntax.&#xA;      */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="CompositeName">
      <comments>// null means use default syntax</comments>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="NameImpl.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:NullLiteral"/>
          </value>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Constructs a new empty composite name. Such a name returns true&#xA;      * when &lt;code>isEmpty()&lt;/code> is invoked on it.&#xA;      */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Generates the string representation of this composite name.&#xA;      * The string representation consists of enumerating in order&#xA;      * each component of the composite name and separating&#xA;      * each component by a forward slash character. Quoting and&#xA;      * escape characters are applied where necessary according to&#xA;      * the JNDI syntax, which is described in the class description.&#xA;      * An empty component is represented by an empty string.&#xA;      *&#xA;      * The string representation thus generated can be passed to&#xA;      * the CompositeName constructor to create a new equivalent&#xA;      * composite name.&#xA;      *&#xA;      * @return&#x9;A non-null string representation of this composite name.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.33"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Determines whether two composite names are equal.&#xA;      * If obj is null or not a composite name, false is returned.&#xA;      * Two composite names are equal if each component in one is equal&#xA;      * to the corresponding component in the other. This implies&#xA;      * both have the same number of components, and each component's&#xA;      * equals() test against the corresponding component in the other name&#xA;      * returns true.&#xA;      *&#xA;      * @param&#x9;obj&#x9;The possibly null object to compare against.&#xA;      * @return&#x9;true if obj is equal to this composite name, false otherwise.&#xA;      * @see #hashCode&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </children>
            <children xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.34"/>
                <arguments xsi:type="expressions:NestedExpression">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                  <expression xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0"/>
                    </typeReference>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
                  </expression>
                </arguments>
              </next>
            </children>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Computes the hash code of this composite name.&#xA;      * The hash code is the sum of the hash codes of individual components&#xA;      * of this composite name.&#xA;      * &#xA;      * @return An int representing the hash code of this name.&#xA;      * @see #equals&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.49"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares this CompositeName with the specified Object for order.  &#xA;     * Returns a&#xA;     * negative integer, zero, or a positive integer as this Name is less&#xA;     * than, equal to, or greater than the given Object.&#xA;     * &lt;p>&#xA;     * If obj is null or not an instance of CompositeName, ClassCastException&#xA;     * is thrown.&#xA;     * &lt;p>&#xA;     * See equals() for what it means for two composite names to be equal.&#xA;     * If two composite names are equal, 0 is returned.&#xA;     * &lt;p>&#xA;     * Ordering of composite names follows the lexicographical rules for&#xA;     * string comparison, with the extension that this applies to all&#xA;     * the components in the composite name. The effect is as if all the&#xA;     * components were lined up in their specified ordered and the&#xA;     * lexicographical rules applied over the two line-ups.&#xA;     * If this composite name is &quot;lexicographically&quot; lesser than obj,&#xA;     * a negative number is returned.&#xA;     * If this composite name is &quot;lexicographically&quot; greater than obj,&#xA;     * a positive number is returned.&#xA;     * @param obj The non-null object to compare against.&#xA;     *&#xA;     * @return  a negative integer, zero, or a positive integer as this Name&#xA;     *&#x9;&#x9;is less than, equal to, or greater than the given Object.&#xA;     * @exception ClassCastException if obj is not a CompositeName.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/ClassCastException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Not a CompositeName"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.35"/>
            <arguments xsi:type="expressions:NestedExpression">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <expression xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
              </expression>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Generates a copy of this composite name.&#xA;      * Changes to the components of this composite name won't&#xA;      * affect the new copy and vice versa.&#xA;      *&#xA;      * @return A non-null copy of this composite name.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="size">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Retrieves the number of components in this composite name.&#xA;      *&#xA;      * @return&#x9;The nonnegative number of components in this composite name.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.36"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isEmpty">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Determines whether this composite name is empty. A composite name&#xA;      * is empty if it has zero components.&#xA;      *&#xA;      * @return true if this composite name is empty, false otherwise.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.41"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAll">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Retrieves the components of this composite name as an enumeration&#xA;      * of strings.&#xA;      * The effects of updates to this composite name on this enumeration&#xA;      * is undefined.&#xA;      *&#xA;      * @return&#x9;A non-null enumeration of the components of&#xA;      * &#x9;this composite name. Each element of the enumeration is of&#xA;      *&#x9;&#x9;class String.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.37"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Retrieves a component of this composite name.&#xA;      *&#xA;      * @param&#x9;posn&#x9;The 0-based index of the component to retrieve.&#xA;      *&#x9;&#x9;&#x9;Must be in the range [0,size()).&#xA;      * @return The non-null component at index posn.&#xA;      * @exception ArrayIndexOutOfBoundsException if posn is outside the&#xA;      * &#x9;specified range.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.38"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPrefix">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Creates a composite name whose components consist of a prefix of the&#xA;      * components in this composite name. Subsequent changes to&#xA;      * this composite name does not affect the name that is returned.&#xA;      *&#xA;      * @param&#x9;posn&#x9;The 0-based index of the component at which to stop.&#xA;      *&#x9;&#x9;&#x9;Must be in the range [0,size()].&#xA;      * @return&#x9;A composite name consisting of the components at indexes in&#xA;      *&#x9;&#x9;the range [0,posn).&#xA;      * @exception ArrayIndexOutOfBoundsException&#xA;      *&#x9;&#x9;If posn is outside the specified range.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="comps">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.39"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@variable"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSuffix">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Creates a composite name whose components consist of a suffix of the&#xA;      * components in this composite name. Subsequent changes to&#xA;      * this composite name does not affect the name that is returned.&#xA;      *&#xA;      * @param&#x9;posn&#x9;The 0-based index of the component at which to start.&#xA;      *&#x9;&#x9;&#x9;Must be in the range [0,size()].&#xA;      * @return&#x9;A composite name consisting of the components at indexes in&#xA;      *&#x9;&#x9;the range [posn,size()).  If posn is equal to &#xA;      * &#x9;size(), an empty composite name is returned.&#xA;      * @exception ArrayIndexOutOfBoundsException&#xA;      *&#x9;&#x9;If posn is outside the specified range.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="comps">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.40"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="startsWith">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Determines whether a composite name is a prefix of this composite name.&#xA;      * A composite name 'n' is a prefix if it is equal to&#xA;      * getPrefix(n.size())--in other words, this composite name&#xA;      * starts with 'n'. If 'n' is null or not a composite name, false is returned.&#xA;      *&#xA;      * @param&#x9;n&#x9;The possibly null name to check.&#xA;      * @return&#x9;true if n is a CompositeName and&#xA;      * &#x9;is a prefix of this composite name, false otherwise.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:NestedExpression">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.42"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="Name.class.xmi#//@classifiers.0/@members.3"/>
                    </next>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="Name.class.xmi#//@classifiers.0/@members.5"/>
                    </next>
                  </arguments>
                </next>
              </expression>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="endsWith">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Determines whether a composite name is a suffix of this composite name.&#xA;      * A composite name 'n' is a suffix if it it is equal to&#xA;      * getSuffix(size()-n.size())--in other words, this&#xA;      * composite name ends with 'n'.&#xA;      * If n is null or not a composite name, false is returned.&#xA;      *&#xA;      * @param&#x9;n&#x9;The possibly null name to check.&#xA;      * @return&#x9;true if n is a CompositeName and&#xA;      * &#x9;is a suffix of this composite name, false otherwise.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:NestedExpression">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.43"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="Name.class.xmi#//@classifiers.0/@members.3"/>
                    </next>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="Name.class.xmi#//@classifiers.0/@members.5"/>
                    </next>
                  </arguments>
                </next>
              </expression>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="addAll">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="suffix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Adds the components of a composite name -- in order -- to the end of&#xA;      * this composite name.&#xA;      *&#xA;      * @param suffix&#x9;The non-null components to add.&#xA;      * @return The updated CompositeName, not a new one. Cannot be null.&#xA;      * @exception InvalidNameException If suffix is not a composite name.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.44"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="Name.class.xmi#//@classifiers.0/@members.5"/>
                  </next>
                </arguments>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Not a composite name: "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../java/lang/Object.class.xmi#//@classifiers.0/@members.6"/>
                  </next>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="addAll">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Adds the components of a composite name -- in order -- at a specified&#xA;      * position within this composite name.&#xA;      * Components of this composite name at or after the index of the first&#xA;      * new component are shifted up (away from index 0)&#xA;      * to accommodate the new components.&#xA;      *&#xA;      * @param n &#x9;The non-null components to add.&#xA;      * @param posn&#x9;The index in this name at which to add the new&#xA;      *&#x9;&#x9;&#x9;components.  Must be in the range [0,size()].&#xA;      * @return The updated CompositeName, not a new one. Cannot be null.&#xA;      * @exception InvalidNameException If n is not a composite name.&#xA;      * @exception ArrayIndexOutOfBoundsException&#xA;      *&#x9;&#x9;If posn is outside the specified range.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.45"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="Name.class.xmi#//@classifiers.0/@members.5"/>
                  </next>
                </arguments>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Not a composite name: "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../java/lang/Object.class.xmi#//@classifiers.0/@members.6"/>
                  </next>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="add">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="comp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Adds a single component to the end of this composite name.&#xA;      *&#xA;      * @param comp&#x9;The non-null component to add.&#xA;      * @return The updated CompositeName, not a new one. Cannot be null.&#xA;      * @exception InvalidNameException If adding comp at end of the name&#xA;      *&#x9;&#x9;&#x9;&#x9;would violate the name's syntax.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.46"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="add">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="comp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Adds a single component at a specified position within this&#xA;      * composite name.&#xA;      * Components of this composite name at or after the index of the new&#xA;      * component are shifted up by one (away from index 0) to accommodate&#xA;      * the new component.&#xA;      *&#xA;      * @param &#x9;comp&#x9;The non-null component to add.&#xA;      * @param&#x9;posn&#x9;The index at which to add the new component.&#xA;      *&#x9;&#x9;&#x9;Must be in the range [0,size()].&#xA;      * @return The updated CompositeName, not a new one. Cannot be null.&#xA;      * @exception ArrayIndexOutOfBoundsException&#xA;      *&#x9;&#x9;If posn is outside the specified range.&#xA;      * @exception InvalidNameException If adding comp at the specified position&#xA;      *&#x9;&#x9;&#x9;&#x9;would violate the name's syntax.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.47"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="remove">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Deletes a component from this composite name.&#xA;      * The component of this composite name at position 'posn' is removed,&#xA;      * and components at indices greater than 'posn'&#xA;      * are shifted down (towards index 0) by one.&#xA;      *&#xA;      * @param&#x9;posn&#x9;The index of the component to delete.&#xA;      *&#x9;&#x9;&#x9;Must be in the range [0,size()).&#xA;      * @return The component removed (a String).&#xA;      * @exception ArrayIndexOutOfBoundsException&#xA;      *&#x9;&#x9;If posn is outside the specified range (includes case where&#xA;      *&#x9;&#x9;composite name is empty).&#xA;      * @exception InvalidNameException If deleting the component&#xA;      *&#x9;&#x9;&#x9;&#x9;would violate the name's syntax.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.48"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/io/ObjectOutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>java</namespaces>
        <namespaces>io</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Overridden to avoid implementation dependency.&#xA;     * @serialData The number of components (an &lt;tt>int&lt;/tt>) followed by&#xA;     * the individual components (each a &lt;tt>String&lt;/tt>).&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../java/io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.37"/>
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.9"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="comps">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../java/io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.14"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.1/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../java/util/Enumeration.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.1/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../java/util/Enumeration.class.xmi#//@classifiers.0/@members.0"/>
          </next>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/io/ObjectInputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>java</namespaces>
        <namespaces>io</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/ClassNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Overridden to avoid implementation dependency.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="NameImpl.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:NullLiteral"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int">
            <comments>// null means use default syntax</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../java/io/ObjectInputStream.class.xmi#//@classifiers.0/@members.38"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <comments>// number of components</comments>
        <statements xsi:type="statements:WhileLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
                <arguments xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../java/io/ObjectInputStream.class.xmi#//@classifiers.0/@members.16"/>
                    </next>
                  </child>
                </arguments>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="expressions:PrefixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.1/@variable"/>
              <operator xsi:type="operators:MinusMinus"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </condition>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="expressions:NestedExpression">
              <expression xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <namespaces>java</namespaces>
                  <namespaces>io</namespaces>
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../java/io/StreamCorruptedException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="Invalid name"/>
              </expression>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="1667768148915813118"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Use serialVersionUID from JNDI 1.1.1 for interoperability&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This class represents a composite name -- a sequence of &#xA; * component names spanning multiple namespaces.&#xA; * Each component is a string name from the namespace of a&#xA; * naming system. If the component comes from a hierarchical&#xA; * namespace, that component can be further parsed into&#xA; * its atomic parts by using the CompoundName class.&#xA; *&lt;p>&#xA; * The components of a composite name are numbered.  The indexes of a&#xA; * composite name with N components range from 0 up to, but not including, N.&#xA; * This range may be written as [0,N).&#xA; * The most significant component is at index 0.&#xA; * An empty composite name has no components.&#xA; *&lt;p> &#xA; * &lt;h4>JNDI Composite Name Syntax&lt;/h4>&#xA; * JNDI defines a standard string representation for composite names. This&#xA; * representation is the concatenation of the components of a composite name&#xA; * from left to right using the component separator (a forward &#xA; * slash character (/)) to separate each component. &#xA; * The JNDI syntax defines the following meta characters:&#xA; * &lt;ul>&#xA; * &lt;li>escape (backward slash \),&#xA; * &lt;li>quote characters  (single (') and double quotes (&quot;)), and&#xA; * &lt;li>component separator (forward slash character (/)).&#xA; * &lt;/ul>&#xA; * Any occurrence of a leading quote, an escape preceding any meta character,&#xA; * an escape at the end of a component, or a component separator character &#xA; * in an unquoted component must be preceded by an escape character when &#xA; * that component is being composed into a composite name string.&#xA; * Alternatively, to avoid adding escape characters as described,&#xA; * the entire component can be quoted using matching single quotes&#xA; * or matching double quotes. A single quote occurring within a double-quoted&#xA; * component is not considered a meta character (and need not be escaped),&#xA; * and vice versa.&#xA; *&lt;p>&#xA; * When two composite names are compared, the case of the characters&#xA; * is significant.&#xA; *&lt;p> &#xA; * A leading component separator (the composite name string begins with&#xA; * a separator) denotes a leading empty component (a component consisting&#xA; * of an empty string).&#xA; * A trailing component separator (the composite name string ends with&#xA; * a separator) denotes a trailing empty component.&#xA; * Adjacent component separators denote an empty component.&#xA; *&lt;p>&#xA; *&lt;h4>Composite Name Examples&lt;/h4>&#xA; *This table shows examples of some composite names. Each row shows&#xA; *the string form of a composite name and its corresponding structural form&#xA; *(&lt;tt>CompositeName&lt;/tt>).&#xA; *&lt;p>&#xA;&lt;table border=&quot;1&quot; cellpadding=3 width=&quot;70%&quot; summary=&quot;examples showing string form of composite name and its corresponding structural form (CompositeName)&quot;>&#xA;&#xA;&lt;tr>&#xA;&lt;th>String Name&lt;/th>&#xA;&lt;th>CompositeName&lt;/th>&#xA;&lt;/tr>&#xA;&#xA;&lt;tr>&#xA;&lt;td>&#xA;&quot;&quot;&#xA;&lt;/td>&#xA;&lt;td>{} (the empty name == new CompositeName(&quot;&quot;) == new CompositeName())&#xA;&lt;/td>&#xA;&lt;/tr>&#xA;&#xA;&lt;tr>&#xA;&lt;td>&#xA;&quot;x&quot;&#xA;&lt;/td>&#xA;&lt;td>{&quot;x&quot;}&#xA;&lt;/td>&#xA;&lt;/tr>&#xA;&#xA;&lt;tr>&#xA;&lt;td>&#xA;&quot;x/y&quot;&#xA;&lt;/td>&#xA;&lt;td>{&quot;x&quot;, &quot;y&quot;}&lt;/td>&#xA;&lt;/tr>&#xA;&#xA;&lt;tr>&#xA;&lt;td>&quot;x/&quot;&lt;/td>&#xA;&lt;td>{&quot;x&quot;, &quot;&quot;}&lt;/td>&#xA;&lt;/tr>&#xA;&#xA;&lt;tr>&#xA;&lt;td>&quot;/x&quot;&lt;/td>&#xA;&lt;td>{&quot;&quot;, &quot;x&quot;}&lt;/td>&#xA;&lt;/tr>&#xA;&#xA;&lt;tr>&#xA;&lt;td>&quot;/&quot;&lt;/td>&#xA;&lt;td>{&quot;&quot;}&lt;/td>&#xA;&lt;/tr>&#xA;&#xA;&lt;tr>&#xA;&lt;td>&quot;//&quot;&lt;/td>&#xA;&lt;td>{&quot;&quot;, &quot;&quot;}&lt;/td>&#xA;&lt;/tr>&#xA;&#xA;&lt;tr>&lt;td>&quot;/x/&quot;&lt;/td>&#xA;&lt;td>{&quot;&quot;, &quot;x&quot;, &quot;&quot;}&lt;/td>&#xA;&lt;/tr>&#xA;&#xA;&lt;tr>&lt;td>&quot;x//y&quot;&lt;/td>&#xA;&lt;td>{&quot;x&quot;, &quot;&quot;, &quot;y&quot;}&lt;/td>&#xA;&lt;/tr>&#xA;&lt;/table>  &#xA; * &lt;p>&#xA; *&lt;h4>Composition Examples&lt;/h4>&#xA; * Here are some composition examples.  The right column shows composing&#xA; * string composite names while the left column shows composing the&#xA; * corresponding &lt;tt>CompositeName&lt;/tt>s.  Notice that composing the&#xA; * string forms of two composite names simply involves concatenating&#xA; * their string forms together.  &#xA;&#xA;&lt;p> &lt;table border=&quot;1&quot; cellpadding=3 width=&quot;70%&quot; summary=&quot;composition examples showing string names and composite names&quot;>&#xA;&#xA;&lt;tr>&#xA;&lt;th>String Names&lt;/th>&#xA;&lt;th>CompositeNames&lt;/th>&#xA;&lt;/tr>&#xA;&#xA;&lt;tr>&#xA;&lt;td>&#xA;&quot;x/y&quot;&#x9;&#x9;+ &quot;/&quot;&#x9;= x/y/&#xA;&lt;/td>&#xA;&lt;td>&#xA;{&quot;x&quot;, &quot;y&quot;}&#x9;+ {&quot;&quot;}&#x9;= {&quot;x&quot;, &quot;y&quot;, &quot;&quot;}&#xA;&lt;/td>&#xA;&lt;/tr>&#xA;&#xA;&lt;tr>&#xA;&lt;td>&#xA;&quot;&quot;&#x9;&#x9;+ &quot;x&quot;&#x9;= &quot;x&quot;&#xA;&lt;/td>&#xA;&lt;td>&#xA;{}&#x9;&#x9;+ {&quot;x&quot;}&#x9;= {&quot;x&quot;}&#xA;&lt;/td>&#xA;&lt;/tr>&#xA;&#xA;&lt;tr>&#xA;&lt;td>&#xA;&quot;/&quot;&#x9;&#x9;+ &quot;x&quot;&#x9;= &quot;/x&quot;&#xA;&lt;/td>&#xA;&lt;td>&#xA;{&quot;&quot;}&#x9;&#x9;+ {&quot;x&quot;} = {&quot;&quot;, &quot;x&quot;}&#xA;&lt;/td>&#xA;&lt;/tr>&#xA;&#xA;&lt;tr>&#xA;&lt;td>&#xA;&quot;x&quot;   + &quot;&quot;&#x9;+ &quot;&quot;&#x9;= &quot;x&quot;&#xA;&lt;/td>&#xA;&lt;td>&#xA;{&quot;x&quot;} + {}&#x9;+ {}&#x9;= {&quot;x&quot;}&#xA;&lt;/td>&#xA;&lt;/tr>&#xA;&#xA;&lt;/table>&#xA; *&lt;p>&#xA; *&lt;h4>Multithreaded Access&lt;/h4>&#xA; * A &lt;tt>CompositeName&lt;/tt> instance is not synchronized against concurrent&#xA; * multithreaded access. Multiple threads trying to access and modify a&#xA; * &lt;tt>CompositeName&lt;/tt> should lock the object.&#xA; *&#xA; * @author Rosanna Lee&#xA; * @author Scott Seligman&#xA; * @version 1.14 04/05/05&#xA; * @since 1.3&#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
