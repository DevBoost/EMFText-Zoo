<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="EventContext.java">
  <comments>/*&#xA; * @(#)EventContext.java&#x9;1.11 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>naming</namespaces>
  <namespaces>event</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>naming</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>naming</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../Context.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>naming</namespaces>
    <classifier xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="EventContext">
    <members xsi:type="members:Field" name="OBJECT_SCOPE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constant for expressing interest in events concerning the object named &#xA;     * by the target.&#xA;     *&lt;p>&#xA;     * The value of this constant is &lt;tt>0&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="ONELEVEL_SCOPE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constant for expressing interest in events concerning objects &#xA;     * in the context named by the target, &#xA;     * excluding the context named by the target.&#xA;     *&lt;p>&#xA;     * The value of this constant is &lt;tt>1&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="SUBTREE_SCOPE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constant for expressing interest in events concerning objects &#xA;     * in the subtree of the object named by the target, including the object&#xA;     * named by the target.&#xA;     *&lt;p>&#xA;     * The value of this constant is &lt;tt>2&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addNamingListener">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Adds a listener for receiving naming events fired&#xA;     * when the object(s) identified by a target and scope changes.&#xA;     *&#xA;     * The event source of those events is this context. See the&#xA;     * class description for a discussion on event source and target.&#xA;     * See the descriptions of the constants &lt;tt>OBJECT_SCOPE&lt;/tt>,&#xA;     * &lt;tt>ONELEVEL_SCOPE&lt;/tt>, and &lt;tt>SUBTREE_SCOPE&lt;/tt> to see how&#xA;     * &lt;tt>scope&lt;/tt> affects the registration.&#xA;     *&lt;p>&#xA;     * &lt;tt>target&lt;/tt> needs to name a context only when &lt;tt>scope&lt;/tt> is &#xA;     * &lt;tt>ONELEVEL_SCOPE&lt;/tt>.&#xA;     * &lt;tt>target&lt;/tt> may name a non-context if &lt;tt>scope&lt;/tt> is either &#xA;     * &lt;tt>OBJECT_SCOPE&lt;/tt> or &lt;tt>SUBTREE_SCOPE&lt;/tt>.  Using &#xA;     * &lt;tt>SUBTREE_SCOPE&lt;/tt> for a non-context might be useful,&#xA;     * for example, if the caller does not know in advance whether &lt;tt>target&lt;/tt> &#xA;     * is a context and just wants to register interest in the (possibly&#xA;     * degenerate subtree) rooted at &lt;tt>target&lt;/tt>.&#xA;     *&lt;p>&#xA;     * When the listener is notified of an event, the listener may&#xA;     * in invoked in a thread other than the one in which&#xA;     * &lt;tt>addNamingListener()&lt;/tt> is executed.&#xA;     * Care must be taken when multiple threads are accessing the same&#xA;     * &lt;tt>EventContext&lt;/tt> concurrently.&#xA;     * See the&#xA;     * &lt;a href=package-summary.html#THREADING>package description&lt;/a>&#xA;     * for more information on threading issues.&#xA;     *&#xA;     * @param target A nonnull name to be resolved relative to this context.&#xA;     * @param scope One of &lt;tt>OBJECT_SCOPE&lt;/tt>, &lt;tt>ONELEVEL_SCOPE&lt;/tt>, or&#xA;     * &lt;tt>SUBTREE_SCOPE&lt;/tt>.&#xA;     * @param l  The nonnull listener.&#xA;     * @exception NamingException If a problem was encountered while&#xA;     * adding the listener.&#xA;     * @see #removeNamingListener&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="target">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scope">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="NamingListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addNamingListener">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Adds a listener for receiving naming events fired&#xA;     * when the object named by the string target name and scope changes.&#xA;     *&#xA;     * See the overload that accepts a &lt;tt>Name&lt;/tt> for details.&#xA;     *&#xA;     * @param target The nonnull string name of the object resolved relative &#xA;     * to this context.&#xA;     * @param scope One of &lt;tt>OBJECT_SCOPE&lt;/tt>, &lt;tt>ONELEVEL_SCOPE&lt;/tt>, or&#xA;     * &lt;tt>SUBTREE_SCOPE&lt;/tt>.&#xA;     * @param l  The nonnull listener.&#xA;     * @exception NamingException If a problem was encountered while&#xA;     * adding the listener.&#xA;     * @see #removeNamingListener&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="target">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scope">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="NamingListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removeNamingListener">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Removes a listener from receiving naming events fired&#xA;     * by this &lt;tt>EventContext&lt;/tt>.&#xA;     * The listener may have registered more than once with this&#xA;     * &lt;tt>EventContext&lt;/tt>, perhaps with different target/scope arguments.&#xA;     * After this method is invoked, the listener will no longer&#xA;     * receive events with this &lt;tt>EventContext&lt;/tt> instance &#xA;     * as the event source (except for those events already in the process of&#xA;     * being dispatched).&#xA;     * If the listener was not, or is no longer, registered with &#xA;     * this &lt;tt>EventContext&lt;/tt> instance, this method does not do anything.&#xA;     *&#xA;     * @param l  The nonnull listener.&#xA;     * @exception NamingException If a problem was encountered while&#xA;     * removing the listener.&#xA;     * @see #addNamingListener&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="NamingListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="targetMustExist">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Determines whether a listener can register interest in a target&#xA;     * that does not exist.&#xA;     *&#xA;     * @return true if the target must exist; false if the target need not exist.&#xA;     * @exception NamingException If the context's behavior in this regard cannot&#xA;     * be determined.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Contains methods for registering/deregistering listeners to be notified of&#xA; * events fired when objects named in a context changes.&#xA; *&lt;p>&#xA; *&lt;h4>Target&lt;/h4>&#xA; * The name parameter in the &lt;tt>addNamingListener()&lt;/tt> methods is referred&#xA; * to as the &lt;em>target&lt;/em>. The target, along with the scope, identify&#xA; * the object(s) that the listener is interested in.&#xA; * It is possible to register interest in a target that does not exist, but&#xA; * there might be limitations in the extent to which this can be&#xA; * supported by the service provider and underlying protocol/service. &#xA; *&lt;p>&#xA; * If a service only supports registration for existing&#xA; * targets, an attempt to register for a nonexistent target&#xA; * results in a &lt;tt>NameNotFoundException&lt;/tt> being thrown as early as possible,&#xA; * preferably at the time &lt;tt>addNamingListener()&lt;/tt> is called, or if that is&#xA; * not possible, the listener will receive the exception through the &#xA; * &lt;tt>NamingExceptionEvent&lt;/tt>.&#xA; *&lt;p>&#xA; * Also, for service providers that only support registration for existing&#xA; * targets, when the target that a listener has registered for is&#xA; * subsequently removed from the namespace, the listener is notified&#xA; * via a &lt;tt>NamingExceptionEvent&lt;/tt> (containing a &#xA; *&lt;tt>NameNotFoundException&lt;/tt>).&#xA; *&lt;p>&#xA; * An application can use the method &lt;tt>targetMustExist()&lt;/tt> to check&#xA; * whether a &lt;tt>EventContext&lt;/tt> supports registration&#xA; * of nonexistent targets.&#xA; *&lt;p>&#xA; *&lt;h4>Event Source&lt;/h4>&#xA; * The &lt;tt>EventContext&lt;/tt> instance on which you invoke the &#xA; * registration methods is the &lt;em>event source&lt;/em> of the events that are&#xA; * (potentially) generated. &#xA; * The source is &lt;em>not necessarily&lt;/em> the object named by the target.&#xA; * Only when the target is the empty name is the object named by the target &#xA; * the source. &#xA; * In other words, the target,&#xA; * along with the scope parameter, are used to identify&#xA; * the object(s) that the listener is interested in, but the event source&#xA; * is the &lt;tt>EventContext&lt;/tt> instance with which the listener &#xA; * has registered.&#xA; *&lt;p>&#xA; * For example, suppose a listener makes the following registration:&#xA; *&lt;blockquote>&lt;pre>&#xA; *&#x9;NamespaceChangeListener listener = ...;&#xA; *&#x9;src.addNamingListener(&quot;x&quot;, SUBTREE_SCOPE, listener);&#xA; *&lt;/pre>&lt;/blockquote>&#xA; * When an object named &quot;x/y&quot; is subsequently deleted, the corresponding&#xA; * &lt;tt>NamingEvent&lt;/tt> (&lt;tt>evt&lt;/tt>)  must contain:&#xA; *&lt;blockquote>&lt;pre>&#xA; *&#x9;evt.getEventContext() == src&#xA; *&#x9;evt.getOldBinding().getName().equals(&quot;x/y&quot;)&#xA; *&lt;/pre>&lt;/blockquote>&#xA; *&lt;p>&#xA; * Furthermore, listener registration/deregistration is with &#xA; * the &lt;tt>EventContext&lt;/tt>&#xA; * &lt;em>instance&lt;/em>, and not with the corresponding object in the namespace.&#xA; * If the program intends at some point to remove a listener, then it needs to &#xA; * keep a reference to the &lt;tt>EventContext&lt;/tt> instance on &#xA; * which it invoked &lt;tt>addNamingListener()&lt;/tt> (just as&#xA; * it needs to keep a reference to the listener in order to remove it&#xA; * later). It cannot expect to do a &lt;tt>lookup()&lt;/tt> and get another instance of&#xA; * a &lt;tt>EventContext&lt;/tt> on which to perform the deregistration.&#xA; *&lt;h4>Lifetime of Registration&lt;/h4>&#xA; * A registered listener becomes deregistered when:&#xA; *&lt;ul>&#xA; *&lt;li>It is removed using &lt;tt>removeNamingListener()&lt;/tt>.&#xA; *&lt;li>An exception is thrown while collecting information about the events.&#xA; *  That is, when the listener receives a &lt;tt>NamingExceptionEvent&lt;/tt>.&#xA; *&lt;li>&lt;tt>Context.close()&lt;/tt> is invoked on the &lt;tt>EventContext&lt;/tt> &#xA; * instance with which it has registered.&#xA; &lt;/ul>&#xA; * Until that point, a &lt;tt>EventContext&lt;/tt> instance that has outstanding&#xA; * listeners will continue to exist and be maintained by the service provider.&#xA; *&#xA; *&lt;h4>Listener Implementations&lt;/h4>&#xA; * The registration/deregistration methods accept an instance of&#xA; * &lt;tt>NamingListener&lt;/tt>. There are subinterfaces of &lt;tt>NamingListener&lt;/tt>&#xA; * for different of event types of &lt;tt>NamingEvent&lt;/tt>. &#xA; * For example, the &lt;tt>ObjectChangeListener&lt;/tt>&#xA; * interface is for the &lt;tt>NamingEvent.OBJECT_CHANGED&lt;/tt> event type.&#xA; * To register interest in multiple event types, the listener implementation&#xA; * should implement multiple &lt;tt>NamingListener&lt;/tt> subinterfaces and use a&#xA; * single invocation of &lt;tt>addNamingListener()&lt;/tt>.&#xA; * In addition to reducing the number of method calls and possibly the code size&#xA; * of the listeners, this allows some service providers to optimize the&#xA; * registration.&#xA; *&#xA; *&lt;h4>Threading Issues&lt;/h4>&#xA; *&#xA; * Like &lt;tt>Context&lt;/tt> instances in general, instances of&#xA; * &lt;tt>EventContext&lt;/tt> are not guaranteed to be thread-safe.&#xA; * Care must be taken when multiple threads are accessing the same&#xA; * &lt;tt>EventContext&lt;/tt> concurrently.&#xA; * See the&#xA; * &lt;a href=package-summary.html#THREADING>package description&lt;/a>&#xA; * for more information on threading issues.&#xA; * &#xA; * @author Rosanna Lee&#xA; * @author Scott Seligman&#xA; * @version 1.11 03/12/19&#xA; * @since 1.3&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../Context.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
