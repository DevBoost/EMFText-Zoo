<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="CompoundName.java">
  <comments>/*&#xA; * @(#)CompoundName.java&#x9;1.11 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>naming</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/util/Properties.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="CompoundName">
    <comments>/*&#xA;//   For testing&#xA;&#xA;    public static void main(String[] args) {&#xA;&#x9;Properties dotSyntax = new Properties();&#xA;&#x9;dotSyntax.put(&quot;jndi.syntax.direction&quot;, &quot;right_to_left&quot;);&#xA;&#x9;dotSyntax.put(&quot;jndi.syntax.separator&quot;, &quot;.&quot;);&#xA;&#x9;dotSyntax.put(&quot;jndi.syntax.ignorecase&quot;, &quot;true&quot;);&#xA;&#x9;dotSyntax.put(&quot;jndi.syntax.escape&quot;, &quot;\\&quot;);&#xA;//&#x9;dotSyntax.put(&quot;jndi.syntax.beginquote&quot;, &quot;\&quot;&quot;);&#xA;//&#x9;dotSyntax.put(&quot;jndi.syntax.beginquote2&quot;, &quot;'&quot;);&#xA;&#xA;        Name first = null;&#xA;&#x9;try {&#xA;&#x9;    for (int i = 0; i &lt; args.length; i++) {&#xA;&#x9;&#x9;Name name;&#xA;&#x9;&#x9;Enumeration e;&#xA;&#x9;&#x9;System.out.println(&quot;Given name: &quot; + args[i]);&#xA;&#x9;&#x9;name = new CompoundName(args[i], dotSyntax);&#xA;&#x9;&#x9;if (first == null) {&#xA;&#x9;&#x9;    first = name;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;e = name.getComponents();&#xA;&#x9;&#x9;while (e.hasMoreElements()) {&#xA;&#x9;&#x9;    System.out.println(&quot;Element: &quot; + e.nextElement());&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;System.out.println(&quot;Constructed name: &quot; + name.toString());&#xA;&#xA;&#x9;&#x9;System.out.println(&quot;Compare &quot; + first.toString() + &quot; with &quot;&#xA;&#x9;&#x9;    + name.toString() + &quot; = &quot; + first.compareTo(name));&#xA;&#x9;    }&#xA;&#x9;} catch (Exception ne) {&#xA;&#x9;    ne.printStackTrace();&#xA;&#x9;}&#xA;    }&#xA;*/</comments>
    <members xsi:type="members:Field" name="impl">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NameImpl.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;      * Implementation of this compound name.&#xA;      * This field is initialized by the constructors and cannot be null.&#xA;      * It should be treated as a read-only variable by subclasses.&#xA;      */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="mySyntax">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/util/Properties.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;      * Syntax properties for this compound name.&#xA;      * This field is initialized by the constructors and cannot be null.&#xA;      * It should be treated as a read-only variable by subclasses.&#xA;      * Any necessary changes to mySyntax should be made within constructors&#xA;      * and not after the compound name has been instantiated.&#xA;      */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Constructor" name="CompoundName">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="NameImpl.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="comps">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="syntax">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/util/Properties.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;      * Constructs a new compound name instance using the components&#xA;      * specified in comps and syntax. This protected method is intended to be&#xA;      * to be used by subclasses of CompoundName when they override&#xA;      * methods such as clone(), getPrefix(), getSuffix().&#xA;      *&#xA;      * @param comps  A non-null enumeration of the components to add.&#xA;      *   Each element of the enumeration is of class String.&#xA;      *               The enumeration will be consumed to extract its&#xA;      *               elements. &#xA;      * @param syntax&#x9;A non-null properties that specify the syntax of&#xA;      *&#x9;&#x9;&#x9;this compound name. See class description for&#xA;      *&#x9;&#x9;&#x9;contents of properties.&#xA;      */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="CompoundName">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="NameImpl.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="syntax">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/util/Properties.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Constructs a new compound name instance by parsing the string n&#xA;      * using the syntax specified by the syntax properties supplied.&#xA;      *&#xA;      * @param&#x9;n&#x9;The non-null string to parse.&#xA;      * @param syntax&#x9;A non-null list of properties that specify the syntax of&#xA;      *&#x9;&#x9;&#x9;this compound name.  See class description for&#xA;      *&#x9;&#x9;&#x9;contents of properties.&#xA;      * @exception&#x9;InvalidNameException If 'n' violates the syntax specified&#xA;      *&#x9;&#x9;&#x9;by &lt;code>syntax&lt;/code>.&#xA;      */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Generates the string representation of this compound name, using&#xA;      * the syntax rules of the compound name. The syntax rules&#xA;      * are described in the class description.&#xA;      * An empty component is represented by an empty string.&#xA;      *&#xA;      * The string representation thus generated can be passed to&#xA;      * the CompoundName constructor with the same syntax properties&#xA;      * to create a new equivalent compound name.&#xA;      *&#xA;      * @return A non-null string representation of this compound name.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.33"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Determines whether obj is syntactically equal to this compound name.&#xA;      * If obj is null or not a CompoundName, false is returned.&#xA;      * Two compound names are equal if each component in one is &quot;equal&quot;&#xA;      * to the corresponding component in the other. &#xA;      *&lt;p>&#xA;      * Equality is also defined in terms of the syntax of this compound name.&#xA;      * The default implementation of CompoundName uses the syntax properties&#xA;      * jndi.syntax.ignorecase and jndi.syntax.trimblanks when comparing&#xA;      * two components for equality.  If case is ignored, two strings&#xA;      * with the same sequence of characters but with different cases&#xA;      * are considered equal. If blanks are being trimmed, leading and trailing&#xA;      * blanks are ignored for the purpose of the comparison.&#xA;      *&lt;p>&#xA;      * Both compound names must have the same number of components.&#xA;      *&lt;p>&#xA;      * Implementation note: Currently the syntax properties of the two compound&#xA;      * names are not compared for equality. They might be in the future.&#xA;      *&#xA;      * @param&#x9;obj&#x9;The possibly null object to compare against.&#xA;      * @return&#x9;true if obj is equal to this compound name, false otherwise.&#xA;      * @see #compareTo(java.lang.Object obj)&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// %%% check syntax too?</comments>
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </children>
            <children xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.34"/>
                <arguments xsi:type="expressions:NestedExpression">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                  <expression xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0"/>
                    </typeReference>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
                  </expression>
                </arguments>
              </next>
            </children>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Computes the hash code of this compound name.&#xA;      * The hash code is the sum of the hash codes of the &quot;canonicalized&quot; &#xA;      * forms of individual components of this compound name.&#xA;      * Each component is &quot;canonicalized&quot; according to the &#xA;      * compound name's syntax before its hash code is computed.&#xA;      * For a case-insensitive name, for example, the uppercased form of &#xA;      * a name has the same hash code as its lowercased equivalent.&#xA;      * &#xA;      * @return An int representing the hash code of this name.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.49"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Creates a copy of this compound name.&#xA;      * Changes to the components of this compound name won't&#xA;      * affect the new copy and vice versa.&#xA;      * The clone and this compound name share the same syntax.&#xA;      *&#xA;      * @return&#x9;A non-null copy of this compound name.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares this CompoundName with the specified Object for order.  &#xA;     * Returns a&#xA;     * negative integer, zero, or a positive integer as this Name is less&#xA;     * than, equal to, or greater than the given Object. &#xA;     * &lt;p>&#xA;     * If obj is null or not an instance of CompoundName, ClassCastException&#xA;     * is thrown.&#xA;     * &lt;p>&#xA;     * See equals() for what it means for two compound names to be equal.&#xA;     * If two compound names are equal, 0 is returned.&#xA;     *&lt;p>&#xA;     * Ordering of compound names depend on the syntax of the compound name.&#xA;     * By default, they follow lexicographical rules for string comparison&#xA;     * with the extension that this applies to all the components in the&#xA;     * compound name and that comparison of individual components is&#xA;     * affected by the jndi.syntax.ignorecase and jndi.syntax.trimblanks&#xA;     * properties, identical to how they affect equals().&#xA;     * If this compound name is &quot;lexicographically&quot; lesser than obj,&#xA;     * a negative number is returned.&#xA;     * If this compound name is &quot;lexicographically&quot; greater than obj,&#xA;     * a positive number is returned.&#xA;     *&lt;p>&#xA;     * Implementation note: Currently the syntax properties of the two compound&#xA;     * names are not compared when checking order. They might be in the future.&#xA;     * @param&#x9;obj&#x9;The non-null object to compare against.&#xA;     * @return  a negative integer, zero, or a positive integer as this Name&#xA;     *&#x9;&#x9;is less than, equal to, or greater than the given Object.&#xA;     * @exception ClassCastException if obj is not a CompoundName.&#xA;     * @see #equals(java.lang.Object)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/ClassCastException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Not a CompoundName"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.35"/>
            <arguments xsi:type="expressions:NestedExpression">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <expression xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
              </expression>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="size">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Retrieves the number of components in this compound name.&#xA;      *&#xA;      * @return The nonnegative number of components in this compound name.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.36"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isEmpty">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Determines whether this compound name is empty.&#xA;      * A compound name is empty if it has zero components.&#xA;      *&#xA;      * @return true if this compound name is empty, false otherwise.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.41"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAll">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Retrieves the components of this compound name as an enumeration&#xA;      * of strings.&#xA;      * The effects of updates to this compound name on this enumeration&#xA;      * is undefined.&#xA;      *&#xA;      * @return&#x9;A non-null enumeration of the components of this&#xA;      * compound name. Each element of the enumeration is of class String.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.37"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Retrieves a component of this compound name.&#xA;      *&#xA;      * @param&#x9;posn&#x9;The 0-based index of the component to retrieve.&#xA;      *&#x9;&#x9;&#x9;Must be in the range [0,size()).&#xA;      * @return The component at index posn.&#xA;      * @exception ArrayIndexOutOfBoundsException if posn is outside the&#xA;      * &#x9;specified range.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.38"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPrefix">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Creates a compound name whose components consist of a prefix of the&#xA;      * components in this compound name.&#xA;      * The result and this compound name share the same syntax.&#xA;      * Subsequent changes to&#xA;      * this compound name does not affect the name that is returned and&#xA;      * vice versa.&#xA;      *&#xA;      * @param&#x9;posn&#x9;The 0-based index of the component at which to stop.&#xA;      *&#x9;&#x9;&#x9;Must be in the range [0,size()].&#xA;      * @return&#x9;A compound name consisting of the components at indexes in&#xA;      *&#x9;&#x9;the range [0,posn).&#xA;      * @exception ArrayIndexOutOfBoundsException&#xA;      *&#x9;&#x9;If posn is outside the specified range.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="comps">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.39"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSuffix">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Creates a compound name whose components consist of a suffix of the&#xA;      * components in this compound name.&#xA;      * The result and this compound name share the same syntax.&#xA;      * Subsequent changes to&#xA;      * this compound name does not affect the name that is returned.&#xA;      *&#xA;      * @param&#x9;posn&#x9;The 0-based index of the component at which to start.&#xA;      *&#x9;&#x9;&#x9;Must be in the range [0,size()].&#xA;      * @return&#x9;A compound name consisting of the components at indexes in&#xA;      *&#x9;&#x9;the range [posn,size()).  If posn is equal to &#xA;      * &#x9;size(), an empty compound name is returned.&#xA;      * @exception ArrayIndexOutOfBoundsException&#xA;      *&#x9;&#x9;If posn is outside the specified range.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="comps">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.40"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="startsWith">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Determines whether a compound name is a prefix of this compound name.&#xA;      * A compound name 'n' is a prefix if it is equal to &#xA;      * getPrefix(n.size())--in other words, this compound name&#xA;      * starts with 'n'.&#xA;      * If n is null or not a compound name, false is returned.&#xA;      *&lt;p>&#xA;      * Implementation note: Currently the syntax properties of n&#xA;      *  are not used when doing the comparison. They might be in the future.&#xA;      * @param&#x9;n&#x9;The possibly null compound name to check.&#xA;      * @return&#x9;true if n is a CompoundName and&#xA;      * &#x9;&#x9;is a prefix of this compound name, false otherwise.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:NestedExpression">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.42"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="Name.class.xmi#//@classifiers.0/@members.3"/>
                    </next>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="Name.class.xmi#//@classifiers.0/@members.5"/>
                    </next>
                  </arguments>
                </next>
              </expression>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="endsWith">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Determines whether a compound name is a suffix of this compound name.&#xA;      * A compound name 'n' is a suffix if it it is equal to&#xA;      * getSuffix(size()-n.size())--in other words, this&#xA;      * compound name ends with 'n'.&#xA;      * If n is null or not a compound name, false is returned.&#xA;      *&lt;p>&#xA;      * Implementation note: Currently the syntax properties of n&#xA;      *  are not used when doing the comparison. They might be in the future.&#xA;      * @param&#x9;n&#x9;The possibly null compound name to check.&#xA;      * @return&#x9;true if n is a CompoundName and&#xA;      * &#x9;is a suffix of this compound name, false otherwise.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:NestedExpression">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.43"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="Name.class.xmi#//@classifiers.0/@members.3"/>
                    </next>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="Name.class.xmi#//@classifiers.0/@members.5"/>
                    </next>
                  </arguments>
                </next>
              </expression>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="addAll">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="suffix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Adds the components of a compound name -- in order -- to the end of&#xA;      * this compound name.&#xA;      *&lt;p>&#xA;      * Implementation note: Currently the syntax properties of suffix&#xA;      *  is not used or checked. They might be in the future.&#xA;      * @param suffix&#x9;The non-null components to add.&#xA;      * @return The updated CompoundName, not a new one. Cannot be null.&#xA;      * @exception InvalidNameException If suffix is not a compound name,&#xA;      *&#x9;&#x9;   or if the addition of the components violates the syntax&#xA;      *&#x9;&#x9;   of this compound name (e.g. exceeding number of components).&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.44"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="Name.class.xmi#//@classifiers.0/@members.5"/>
                  </next>
                </arguments>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Not a compound name: "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../java/lang/Object.class.xmi#//@classifiers.0/@members.6"/>
                  </next>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="addAll">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Adds the components of a compound name -- in order -- at a specified&#xA;      * position within this compound name.&#xA;      * Components of this compound name at or after the index of the first&#xA;      * new component are shifted up (away from index 0)&#xA;      * to accommodate the new components.&#xA;      *&lt;p>&#xA;      * Implementation note: Currently the syntax properties of suffix&#xA;      *  is not used or checked. They might be in the future.&#xA;      *&#xA;      * @param n &#x9;The non-null components to add.&#xA;      * @param posn&#x9;The index in this name at which to add the new&#xA;      *&#x9;&#x9;&#x9;components.  Must be in the range [0,size()].&#xA;      * @return The updated CompoundName, not a new one. Cannot be null.&#xA;      * @exception ArrayIndexOutOfBoundsException&#xA;      *&#x9;&#x9;If posn is outside the specified range.&#xA;      * @exception InvalidNameException If n is not a compound name,&#xA;      *&#x9;&#x9;   or if the addition of the components violates the syntax&#xA;      *&#x9;&#x9;   of this compound name (e.g. exceeding number of components).&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.45"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="Name.class.xmi#//@classifiers.0/@members.5"/>
                  </next>
                </arguments>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Not a compound name: "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../java/lang/Object.class.xmi#//@classifiers.0/@members.6"/>
                  </next>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="add">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="comp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Adds a single component to the end of this compound name.&#xA;      *&#xA;      * @param comp&#x9;The non-null component to add.&#xA;      * @return The updated CompoundName, not a new one. Cannot be null.&#xA;      * @exception InvalidNameException If adding comp at end of the name&#xA;      *&#x9;&#x9;&#x9;&#x9;would violate the compound name's syntax.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.46"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="add">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="comp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Adds a single component at a specified position within this&#xA;      * compound name.&#xA;      * Components of this compound name at or after the index of the new&#xA;      * component are shifted up by one (away from index 0)&#xA;      * to accommodate the new component.&#xA;      *&#xA;      * @param &#x9;comp&#x9;The non-null component to add.&#xA;      * @param&#x9;posn&#x9;The index at which to add the new component.&#xA;      *&#x9;&#x9;&#x9;Must be in the range [0,size()].&#xA;      * @exception ArrayIndexOutOfBoundsException&#xA;      *&#x9;&#x9;If posn is outside the specified range.&#xA;      * @return The updated CompoundName, not a new one. Cannot be null.&#xA;      * @exception InvalidNameException If adding comp at the specified position&#xA;      *&#x9;&#x9;&#x9;&#x9;would violate the compound name's syntax.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.47"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="remove">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="posn">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;      * Deletes a component from this compound name.&#xA;      * The component of this compound name at position 'posn' is removed,&#xA;      * and components at indices greater than 'posn'&#xA;      * are shifted down (towards index 0) by one.&#xA;      *&#xA;      * @param&#x9;posn&#x9;The index of the component to delete.&#xA;      *&#x9;&#x9;&#x9;Must be in the range [0,size()).&#xA;      * @return The component removed (a String).&#xA;      * @exception ArrayIndexOutOfBoundsException&#xA;      *&#x9;&#x9;If posn is outside the specified range (includes case where&#xA;      *&#x9;&#x9;compound name is empty).&#xA;      * @exception InvalidNameException If deleting the component&#xA;      *&#x9;&#x9;&#x9;&#x9;would violate the compound name's syntax.&#xA;      */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="NameImpl.class.xmi#//@classifiers.0/@members.48"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/io/ObjectOutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>java</namespaces>
        <namespaces>io</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Overridden to avoid implementation dependency.&#xA;     * @serialData The syntax &lt;tt>Properties&lt;/tt>, followed by&#xA;     * the number of components (an &lt;tt>int&lt;/tt>), and the individual&#xA;     * components (each a &lt;tt>String&lt;/tt>).&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../java/io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../java/io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.37"/>
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.9"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="comps">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../java/util/Enumeration.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../java/io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.14"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.2/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../java/util/Enumeration.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.2/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../../java/util/Enumeration.class.xmi#//@classifiers.0/@members.0"/>
          </next>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/io/ObjectInputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>java</namespaces>
        <namespaces>io</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/ClassNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Overridden to avoid implementation dependency.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../java/util/Properties.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../java/io/ObjectInputStream.class.xmi#//@classifiers.0/@members.16"/>
              </next>
            </child>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="NameImpl.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../java/io/ObjectInputStream.class.xmi#//@classifiers.0/@members.38"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <comments>// number of components</comments>
        <statements xsi:type="statements:WhileLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
                <arguments xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../java/io/ObjectInputStream.class.xmi#//@classifiers.0/@members.16"/>
                    </next>
                  </child>
                </arguments>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="expressions:PrefixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.2/@variable"/>
              <operator xsi:type="operators:MinusMinus"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </condition>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="expressions:NestedExpression">
              <expression xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <namespaces>java</namespaces>
                  <namespaces>io</namespaces>
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../java/io/StreamCorruptedException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="Invalid name"/>
              </expression>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InvalidNameException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="3513100557083972036"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Use serialVersionUID from JNDI 1.1.1 for interoperability&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This class represents a compound name -- a name from&#xA; * a hierarchical name space.  &#xA; * Each component in a compound name is an atomic name.&#xA; * &lt;p>&#xA; * The components of a compound name are numbered.  The indexes of a&#xA; * compound name with N components range from 0 up to, but not including, N.&#xA; * This range may be written as [0,N).&#xA; * The most significant component is at index 0.&#xA; * An empty compound name has no components.&#xA; *&lt;p> &#xA; * &lt;h4>Compound Name Syntax&lt;/h4>&#xA; * The syntax of a compound name is specified using a set of properties:&#xA; *&lt;dl>&#xA; *  &lt;dt>jndi.syntax.direction&#xA; *  &lt;dd>Direction for parsing (&quot;right_to_left&quot;, &quot;left_to_right&quot;, &quot;flat&quot;). &#xA; *      If unspecified, defaults to &quot;flat&quot;, which means the namespace is flat&#xA; *      with no hierarchical structure.&#xA; * &#xA; *  &lt;dt>jndi.syntax.separator&#xA; *  &lt;dd>Separator between atomic name components.  &#xA; *      Required unless direction is &quot;flat&quot;.&#xA; *&#xA; *  &lt;dt>jndi.syntax.ignorecase&#xA; *  &lt;dd>If present, &quot;true&quot; means ignore the case when comparing name &#xA; *      components. If its value is not &quot;true&quot;, or if the property is not&#xA; *      present, case is considered when comparing name components.&#xA; *&#xA; *  &lt;dt>jndi.syntax.escape&#xA; *  &lt;dd>If present, specifies the escape string for overriding separator, &#xA; *      escapes and quotes.&#xA; *&#xA; *  &lt;dt>jndi.syntax.beginquote&#xA; *  &lt;dd>If present, specifies the string delimiting start of a quoted string.&#xA; * &#xA; *  &lt;dt>jndi.syntax.endquote&#xA; *  &lt;dd>String delimiting end of quoted string.&#xA; *      If present, specifies the string delimiting the end of a quoted string.&#xA; *&#x9;If not present, use syntax.beginquote as end quote.&#xA; *  &lt;dt>jndi.syntax.beginquote2&#xA; *  &lt;dd>Alternative set of begin/end quotes.&#xA; * &#xA; *  &lt;dt>jndi.syntax.endquote2&#xA; *  &lt;dd>Alternative set of begin/end quotes.&#xA; *&#xA; *  &lt;dt>jndi.syntax.trimblanks&#xA; *  &lt;dd>If present, &quot;true&quot; means trim any leading and trailing whitespaces &#xA; *      in a name component for comparison purposes. If its value is not&#xA; *      &quot;true&quot;, or if the property is not present, blanks are significant.&#xA; *  &lt;dt>jndi.syntax.separator.ava&#xA; *  &lt;dd>If present, specifies the string that separates &#xA; *      attribute-value-assertions when specifying multiple attribute/value&#xA; *      pairs. (e.g. &quot;,&quot;  in age=65,gender=male).&#xA; *  &lt;dt>jndi.syntax.separator.typeval&#xA; *  &lt;dd>If present, specifies the string that separators attribute&#xA; *&#x9;&#x9;from value (e.g. &quot;=&quot; in &quot;age=65&quot;)&#xA; *&lt;/dl>&#xA; * These properties are interpreted according to the following rules:&#xA; *&lt;ol>&#xA; *&lt;li>&#xA; * In a string without quotes or escapes, any instance of the &#xA; * separator delimits two atomic names. Each atomic name is referred&#xA; * to as a &lt;em>component&lt;/em>.&#xA; *&lt;li>&#xA; * A separator, quote or escape is escaped if preceded immediately &#xA; * (on the left) by the escape.&#xA; *&lt;li>&#xA; * If there are two sets of quotes, a specific begin-quote must be matched&#xA; * by its corresponding end-quote.&#xA; *&lt;li>&#xA; * A non-escaped begin-quote which precedes a component must be&#xA; * matched by a non-escaped end-quote at the end of the component.&#xA; * A component thus quoted is referred to as a &#xA; * &lt;em>quoted component&lt;/em>. It is parsed by&#xA; * removing the being- and end- quotes, and by treating the intervening&#xA; * characters as ordinary characters unless one of the rules involving&#xA; * quoted components listed below applies.&#xA; *&lt;li>&#xA; * Quotes embedded in non-quoted components are treated as ordinary strings&#xA; * and need not be matched.&#xA; *&lt;li>&#xA; * A separator that is escaped or appears between non-escaped &#xA; * quotes is treated as an ordinary string and not a separator.&#xA; *&lt;li>&#xA; * An escape string within a quoted component acts as an escape only when&#xA; * followed by the corresponding end-quote string.&#xA; * This can be used to embed an escaped quote within a quoted component.&#xA; *&lt;li>&#xA; * An escaped escape string is not treated as an escape string.&#xA; *&lt;li>&#xA; * An escape string that does not precede a meta string (quotes or separator)&#xA; * and is not at the end of a component is treated as an ordinary string.&#xA; *&lt;li>&#xA; * A leading separator (the compound name string begins with&#xA; * a separator) denotes a leading empty atomic component (consisting&#xA; * of an empty string).&#xA; * A trailing separator (the compound name string ends with&#xA; * a separator) denotes a trailing empty atomic component.&#xA; * Adjacent separators denote an empty atomic component.&#xA; *&lt;/ol>&#xA; * &lt;p>&#xA; * The string form of the compound name follows the syntax described above.&#xA; * When the components of the compound name are turned into their&#xA; * string representation, the reserved syntax rules described above are&#xA; * applied (e.g. embedded separators are escaped or quoted)&#xA; * so that when the same string is parsed, it will yield the same components&#xA; * of the original compound name.&#xA; *&lt;p>&#xA; *&lt;h4>Multithreaded Access&lt;/h4>&#xA; * A &lt;tt>CompoundName&lt;/tt> instance is not synchronized against concurrent&#xA; * multithreaded access. Multiple threads trying to access and modify a&#xA; * &lt;tt>CompoundName&lt;/tt> should lock the object.&#xA; *&#xA; * @author Rosanna Lee&#xA; * @author Scott Seligman&#xA; * @version 1.11 04/05/05&#xA; * @since 1.3&#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
