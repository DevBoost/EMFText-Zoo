<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/types ../../java.ecore#/16" name="Context.java">
  <comments>/*&#xA; * @(#)Context.java&#x9;1.12 04/07/16&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>naming</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/util/Hashtable.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="Context">
    <members xsi:type="members:InterfaceMethod" name="lookup">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the named object.&#xA;     * If &lt;tt>name&lt;/tt> is empty, returns a new instance of this context&#xA;     * (which represents the same naming context as this context, but its&#xA;     * environment may be modified independently and it may be accessed&#xA;     * concurrently).&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object to look up&#xA;     * @return&#x9;the object bound to &lt;tt>name&lt;/tt>&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #lookup(String)&#xA;     * @see #lookupLink(Name)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="lookup">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the named object.&#xA;     * See {@link #lookup(Name)} for details.&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object to look up&#xA;     * @return&#x9;the object bound to &lt;tt>name&lt;/tt>&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="bind">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Binds a name to an object.&#xA;     * All intermediate contexts and the target context (that named by all&#xA;     * but terminal atomic component of the name) must already exist.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name to bind; may not be empty&#xA;     * @param obj&#xA;     *&#x9;&#x9;the object to bind; possibly null&#xA;     * @throws&#x9;NameAlreadyBoundException if name is already bound&#xA;     * @throws&#x9;javax.naming.directory.InvalidAttributesException&#xA;     *&#x9; &#x9;if object did not supply all mandatory attributes&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #bind(String, Object)&#xA;     * @see #rebind(Name, Object)&#xA;     * @see javax.naming.directory.DirContext#bind(Name, Object,&#xA;     *&#x9;&#x9;javax.naming.directory.Attributes)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="bind">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Binds a name to an object.&#xA;     * See {@link #bind(Name, Object)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name to bind; may not be empty&#xA;     * @param obj&#xA;     *&#x9;&#x9;the object to bind; possibly null&#xA;     * @throws&#x9;NameAlreadyBoundException if name is already bound&#xA;     * @throws&#x9;javax.naming.directory.InvalidAttributesException&#xA;     *&#x9; &#x9;if object did not supply all mandatory attributes&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rebind">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Binds a name to an object, overwriting any existing binding.&#xA;     * All intermediate contexts and the target context (that named by all&#xA;     * but terminal atomic component of the name) must already exist.&#xA;     *&#xA;     * &lt;p> If the object is a &lt;tt>DirContext&lt;/tt>, any existing attributes&#xA;     * associated with the name are replaced with those of the object.&#xA;     * Otherwise, any existing attributes associated with the name remain&#xA;     * unchanged.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name to bind; may not be empty&#xA;     * @param obj&#xA;     *&#x9;&#x9;the object to bind; possibly null&#xA;     * @throws&#x9;javax.naming.directory.InvalidAttributesException&#xA;     *&#x9; &#x9;if object did not supply all mandatory attributes&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #rebind(String, Object)&#xA;     * @see #bind(Name, Object)&#xA;     * @see javax.naming.directory.DirContext#rebind(Name, Object,&#xA;     *&#x9;&#x9;javax.naming.directory.Attributes)&#xA;     * @see javax.naming.directory.DirContext&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rebind">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Binds a name to an object, overwriting any existing binding.&#xA;     * See {@link #rebind(Name, Object)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name to bind; may not be empty&#xA;     * @param obj&#xA;     *&#x9;&#x9;the object to bind; possibly null&#xA;     * @throws&#x9;javax.naming.directory.InvalidAttributesException&#xA;     *&#x9; &#x9;if object did not supply all mandatory attributes&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="unbind">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Unbinds the named object.&#xA;     * Removes the terminal atomic name in &lt;code>name&lt;/code>&#xA;     * from the target context--that named by all but the terminal&#xA;     * atomic part of &lt;code>name&lt;/code>.&#xA;     *&#xA;     * &lt;p> This method is idempotent.&#xA;     * It succeeds even if the terminal atomic name&#xA;     * is not bound in the target context, but throws&#xA;     * &lt;tt>NameNotFoundException&lt;/tt>&#xA;     * if any of the intermediate contexts do not exist.&#xA;     *&#xA;     * &lt;p> Any attributes associated with the name are removed.&#xA;     * Intermediate contexts are not changed.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name to unbind; may not be empty&#xA;     * @throws&#x9;NameNotFoundException if an intermediate context does not exist&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     * @see #unbind(String)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="unbind">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Unbinds the named object.&#xA;     * See {@link #unbind(Name)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name to unbind; may not be empty&#xA;     * @throws&#x9;NameNotFoundException if an intermediate context does not exist&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rename">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="oldName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Binds a new name to the object bound to an old name, and unbinds&#xA;     * the old name.  Both names are relative to this context.&#xA;     * Any attributes associated with the old name become associated&#xA;     * with the new name.&#xA;     * Intermediate contexts of the old name are not changed.&#xA;     *&#xA;     * @param oldName&#xA;     *&#x9;&#x9;the name of the existing binding; may not be empty&#xA;     * @param newName&#xA;     *&#x9;&#x9;the name of the new binding; may not be empty&#xA;     * @throws&#x9;NameAlreadyBoundException if &lt;tt>newName&lt;/tt> is already bound&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #rename(String, String)&#xA;     * @see #bind(Name, Object)&#xA;     * @see #rebind(Name, Object)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rename">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="oldName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Binds a new name to the object bound to an old name, and unbinds&#xA;     * the old name.&#xA;     * See {@link #rename(Name, Name)} for details.&#xA;     *&#xA;     * @param oldName&#xA;     *&#x9;&#x9;the name of the existing binding; may not be empty&#xA;     * @param newName&#xA;     *&#x9;&#x9;the name of the new binding; may not be empty&#xA;     * @throws&#x9;NameAlreadyBoundException if &lt;tt>newName&lt;/tt> is already bound&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="list">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="NameClassPair.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="NamingEnumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enumerates the names bound in the named context, along with the&#xA;     * class names of objects bound to them.&#xA;     * The contents of any subcontexts are not included.&#xA;     *&#xA;     * &lt;p> If a binding is added to or removed from this context,&#xA;     * its effect on an enumeration previously returned is undefined.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to list&#xA;     * @return&#x9;an enumeration of the names and class names of the&#xA;     *&#x9;&#x9;bindings in this context.  Each element of the&#xA;     *&#x9;&#x9;enumeration is of type &lt;tt>NameClassPair&lt;/tt>.&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #list(String)&#xA;     * @see #listBindings(Name)&#xA;     * @see NameClassPair&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="list">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="NameClassPair.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="NamingEnumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enumerates the names bound in the named context, along with the&#xA;     * class names of objects bound to them.&#xA;     * See {@link #list(Name)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to list&#xA;     * @return&#x9;an enumeration of the names and class names of the&#xA;     *&#x9;&#x9;bindings in this context.  Each element of the&#xA;     *&#x9;&#x9;enumeration is of type &lt;tt>NameClassPair&lt;/tt>.&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="listBindings">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="Binding.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="NamingEnumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enumerates the names bound in the named context, along with the&#xA;     * objects bound to them.&#xA;     * The contents of any subcontexts are not included.&#xA;     *&#xA;     * &lt;p> If a binding is added to or removed from this context,&#xA;     * its effect on an enumeration previously returned is undefined.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to list&#xA;     * @return&#x9;an enumeration of the bindings in this context.&#xA;     *&#x9;&#x9;Each element of the enumeration is of type&#xA;     *&#x9;&#x9;&lt;tt>Binding&lt;/tt>.&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #listBindings(String)&#xA;     * @see #list(Name)&#xA;     * @see Binding&#xA;      */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="listBindings">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="Binding.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="NamingEnumeration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enumerates the names bound in the named context, along with the&#xA;     * objects bound to them.&#xA;     * See {@link #listBindings(Name)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to list&#xA;     * @return&#x9;an enumeration of the bindings in this context.&#xA;     *&#x9;&#x9;Each element of the enumeration is of type&#xA;     *&#x9;&#x9;&lt;tt>Binding&lt;/tt>.&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="destroySubcontext">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Destroys the named context and removes it from the namespace.&#xA;     * Any attributes associated with the name are also removed.&#xA;     * Intermediate contexts are not destroyed.&#xA;     *&#xA;     * &lt;p> This method is idempotent.&#xA;     * It succeeds even if the terminal atomic name&#xA;     * is not bound in the target context, but throws&#xA;     * &lt;tt>NameNotFoundException&lt;/tt>&#xA;     * if any of the intermediate contexts do not exist.&#xA;     *&#xA;     * &lt;p> In a federated naming system, a context from one naming system&#xA;     * may be bound to a name in another.  One can subsequently&#xA;     * look up and perform operations on the foreign context using a&#xA;     * composite name.  However, an attempt destroy the context using&#xA;     * this composite name will fail with&#xA;     * &lt;tt>NotContextException&lt;/tt>, because the foreign context is not&#xA;     * a &quot;subcontext&quot; of the context in which it is bound.&#xA;     * Instead, use &lt;tt>unbind()&lt;/tt> to remove the&#xA;     * binding of the foreign context.  Destroying the foreign context&#xA;     * requires that the &lt;tt>destroySubcontext()&lt;/tt> be performed&#xA;     * on a context from the foreign context's &quot;native&quot; naming system.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to be destroyed; may not be empty&#xA;     * @throws&#x9;NameNotFoundException if an intermediate context does not exist&#xA;     * @throws&#x9;NotContextException if the name is bound but does not name a&#xA;     *&#x9;&#x9;context, or does not name a context of the appropriate type&#xA;     * @throws&#x9;ContextNotEmptyException if the named context is not empty&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #destroySubcontext(String)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="destroySubcontext">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Destroys the named context and removes it from the namespace.&#xA;     * See {@link #destroySubcontext(Name)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to be destroyed; may not be empty&#xA;     * @throws&#x9;NameNotFoundException if an intermediate context does not exist&#xA;     * @throws&#x9;NotContextException if the name is bound but does not name a&#xA;     *&#x9;&#x9;context, or does not name a context of the appropriate type&#xA;     * @throws&#x9;ContextNotEmptyException if the named context is not empty&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createSubcontext">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates and binds a new context.&#xA;     * Creates a new context with the given name and binds it in&#xA;     * the target context (that named by all but terminal atomic&#xA;     * component of the name).  All intermediate contexts and the&#xA;     * target context must already exist.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to create; may not be empty&#xA;     * @return&#x9;the newly created context&#xA;     *&#xA;     * @throws&#x9;NameAlreadyBoundException if name is already bound&#xA;     * @throws&#x9;javax.naming.directory.InvalidAttributesException&#xA;     *&#x9;&#x9;if creation of the subcontext requires specification of&#xA;     *&#x9;&#x9;mandatory attributes&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #createSubcontext(String)&#xA;     * @see javax.naming.directory.DirContext#createSubcontext&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createSubcontext">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates and binds a new context.&#xA;     * See {@link #createSubcontext(Name)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context to create; may not be empty&#xA;     * @return&#x9;the newly created context&#xA;     *&#xA;     * @throws&#x9;NameAlreadyBoundException if name is already bound&#xA;     * @throws&#x9;javax.naming.directory.InvalidAttributesException&#xA;     *&#x9;&#x9;if creation of the subcontext requires specification of&#xA;     *&#x9;&#x9;mandatory attributes&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="lookupLink">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the named object, following links except&#xA;     * for the terminal atomic component of the name.&#xA;     * If the object bound to &lt;tt>name&lt;/tt> is not a link,&#xA;     * returns the object itself.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object to look up&#xA;     * @return&#x9;the object bound to &lt;tt>name&lt;/tt>, not following the&#xA;     *&#x9;&#x9;terminal link (if any).&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #lookupLink(String)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="lookupLink">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the named object, following links except&#xA;     * for the terminal atomic component of the name.&#xA;     * See {@link #lookupLink(Name)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the object to look up&#xA;     * @return&#x9;the object bound to &lt;tt>name&lt;/tt>, not following the&#xA;     *&#x9;&#x9;terminal link (if any)&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNameParser">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="NameParser.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the parser associated with the named context.&#xA;     * In a federation of namespaces, different naming systems will&#xA;     * parse names differently.  This method allows an application&#xA;     * to get a parser for parsing names into their atomic components&#xA;     * using the naming convention of a particular naming system.&#xA;     * Within any single naming system, &lt;tt>NameParser&lt;/tt> objects&#xA;     * returned by this method must be equal (using the &lt;tt>equals()&lt;/tt>&#xA;     * test).&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context from which to get the parser&#xA;     * @return&#x9;a name parser that can parse compound names into their atomic&#xA;     *&#x9;&#x9;components&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #getNameParser(String)&#xA;     * @see CompoundName&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNameParser">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="NameParser.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the parser associated with the named context.&#xA;     * See {@link #getNameParser(Name)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;the name of the context from which to get the parser&#xA;     * @return&#x9;a name parser that can parse compound names into their atomic&#xA;     *&#x9;&#x9;components&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="composeName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Name.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Composes the name of this context with a name relative to&#xA;     * this context.&#xA;     * Given a name (&lt;code>name&lt;/code>) relative to this context, and&#xA;     * the name (&lt;code>prefix&lt;/code>) of this context relative to one&#xA;     * of its ancestors, this method returns the composition of the&#xA;     * two names using the syntax appropriate for the naming&#xA;     * system(s) involved.  That is, if &lt;code>name&lt;/code> names an&#xA;     * object relative to this context, the result is the name of the&#xA;     * same object, but relative to the ancestor context.  None of the&#xA;     * names may be null.&#xA;     * &lt;p>&#xA;     * For example, if this context is named &quot;wiz.com&quot; relative&#xA;     * to the initial context, then&#xA;     * &lt;pre>&#xA;     *&#x9;composeName(&quot;east&quot;, &quot;wiz.com&quot;)&#x9;&lt;/pre>&#xA;     * might return &lt;code>&quot;east.wiz.com&quot;&lt;/code>.&#xA;     * If instead this context is named &quot;org/research&quot;, then&#xA;     * &lt;pre>&#xA;     *&#x9;composeName(&quot;user/jane&quot;, &quot;org/research&quot;)&#x9;&lt;/pre>&#xA;     * might return &lt;code>&quot;org/research/user/jane&quot;&lt;/code> while&#xA;     * &lt;pre>&#xA;     *&#x9;composeName(&quot;user/jane&quot;, &quot;research&quot;)&#x9;&lt;/pre>&#xA;     * returns &lt;code>&quot;research/user/jane&quot;&lt;/code>.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;a name relative to this context&#xA;     * @param prefix&#xA;     *&#x9;&#x9;the name of this context relative to one of its ancestors&#xA;     * @return&#x9;the composition of &lt;code>prefix&lt;/code> and &lt;code>name&lt;/code>&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #composeName(String, String)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="composeName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Composes the name of this context with a name relative to&#xA;     * this context.&#xA;     * See {@link #composeName(Name, Name)} for details.&#xA;     *&#xA;     * @param name&#xA;     *&#x9;&#x9;a name relative to this context&#xA;     * @param prefix&#xA;     *&#x9;&#x9;the name of this context relative to one of its ancestors&#xA;     * @return&#x9;the composition of &lt;code>prefix&lt;/code> and &lt;code>name&lt;/code>&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addToEnvironment">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="propName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="propVal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds a new environment property to the environment of this&#xA;     * context.  If the property already exists, its value is overwritten.&#xA;     * See class description for more details on environment properties.&#xA;     *&#xA;     * @param propName&#xA;     *&#x9;&#x9;the name of the environment property to add; may not be null&#xA;     * @param propVal&#xA;     *&#x9;&#x9;the value of the property to add; may not be null&#xA;     * @return&#x9;the previous value of the property, or null if the property was&#xA;     *&#x9;&#x9;not in the environment before&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #getEnvironment()&#xA;     * @see #removeFromEnvironment(String)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removeFromEnvironment">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="propName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes an environment property from the environment of this&#xA;     * context.  See class description for more details on environment&#xA;     * properties.&#xA;     *&#xA;     * @param propName&#xA;     *&#x9;&#x9;the name of the environment property to remove; may not be null&#xA;     * @return&#x9;the previous value of the property, or null if the property was&#xA;     *&#x9;&#x9;not in the environment&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #getEnvironment()&#xA;     * @see #addToEnvironment(String, Object)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getEnvironment">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:UnknownTypeArgument"/>
          <typeArguments xsi:type="generics:UnknownTypeArgument"/>
          <target xsi:type="classifiers:Class" href="../../java/util/Hashtable.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the environment in effect for this context.&#xA;     * See class description for more details on environment properties.&#xA;     *&#xA;     * &lt;p> The caller should not make any changes to the object returned:&#xA;     * their effect on the context is undefined.&#xA;     * The environment of this context may be changed using&#xA;     * &lt;tt>addToEnvironment()&lt;/tt> and &lt;tt>removeFromEnvironment()&lt;/tt>.&#xA;     *&#xA;     * @return&#x9;the environment of this context; never null&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="close">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Closes this context.&#xA;     * This method releases this context's resources immediately, instead of&#xA;     * waiting for them to be released automatically by the garbage collector.&#xA;     *&#xA;     * &lt;p> This method is idempotent:  invoking it on a context that has&#xA;     * already been closed has no effect.  Invoking any other method&#xA;     * on a closed context is not allowed, and results in undefined behaviour.&#xA;     *&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNameInNamespace">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NamingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the full name of this context within its own namespace.&#xA;     *&#xA;     * &lt;p> Many naming services have a notion of a &quot;full name&quot; for objects&#xA;     * in their respective namespaces.  For example, an LDAP entry has&#xA;     * a distinguished name, and a DNS record has a fully qualified name.&#xA;     * This method allows the client application to retrieve this name.&#xA;     * The string returned by this method is not a JNDI composite name&#xA;     * and should not be passed directly to context methods.&#xA;     * In naming systems for which the notion of full name does not&#xA;     * make sense, &lt;tt>OperationNotSupportedException&lt;/tt> is thrown.&#xA;     *&#xA;     * @return&#x9;this context's name in its own namespace; never null&#xA;     * @throws&#x9;OperationNotSupportedException if the naming system does&#xA;     *&#x9;&#x9;not have the notion of a full name&#xA;     * @throws&#x9;NamingException if a naming exception is encountered&#xA;     *&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="INITIAL_CONTEXT_FACTORY">
      <initialValue xsi:type="references:StringReference" value="java.naming.factory.initial"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>// public static final:  JLS says recommended style is to omit these modifiers</comments>
          <comments>// because they are the default</comments>
          <comments>/**&#xA;     * Constant that holds the name of the environment property&#xA;     * for specifying the initial context factory to use. The value&#xA;     * of the property should be the fully qualified class name&#xA;     * of the factory class that will create an initial context.&#xA;     * This property may be specified in the environment parameter&#xA;     * passed to the initial context constructor, an applet parameter,&#xA;     * a system property, or an application resource file.&#xA;     * If it is not specified in any of these sources,&#xA;     * &lt;tt>NoInitialContextException&lt;/tt> is thrown when an initial&#xA;     * context is required to complete an operation.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.factory.initial&quot;.&#xA;     *&#xA;     * @see InitialContext&#xA;     * @see javax.naming.directory.InitialDirContext&#xA;     * @see javax.naming.spi.NamingManager#getInitialContext&#xA;     * @see javax.naming.spi.InitialContextFactory&#xA;     * @see NoInitialContextException&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     * @see #APPLET&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="OBJECT_FACTORIES">
      <initialValue xsi:type="references:StringReference" value="java.naming.factory.object"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property&#xA;     * for specifying the list of object factories to use. The value&#xA;     * of the property should be a colon-separated list of the fully&#xA;     * qualified class names of factory classes that will create an object&#xA;     * given information about the object.&#xA;     * This property may be specified in the environment, an applet&#xA;     * parameter, a system property, or one or more resource files.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.factory.object&quot;.&#xA;     *&#xA;     * @see javax.naming.spi.NamingManager#getObjectInstance&#xA;     * @see javax.naming.spi.ObjectFactory&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     * @see #APPLET&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="STATE_FACTORIES">
      <initialValue xsi:type="references:StringReference" value="java.naming.factory.state"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property&#xA;     * for specifying the list of state factories to use. The value&#xA;     * of the property should be a colon-separated list of the fully&#xA;     * qualified class names of state factory classes that will be used&#xA;     * to get an object's state given the object itself.&#xA;     * This property may be specified in the environment, an applet&#xA;     * parameter, a system property, or one or more resource files.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.factory.state&quot;.&#xA;     *&#xA;     * @see javax.naming.spi.NamingManager#getStateToBind&#xA;     * @see javax.naming.spi.StateFactory&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     * @see #APPLET&#xA;     * @since 1.3&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="URL_PKG_PREFIXES">
      <initialValue xsi:type="references:StringReference" value="java.naming.factory.url.pkgs"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property&#xA;     * for specifying the list of package prefixes to use when&#xA;     * loading in URL context factories. The value&#xA;     * of the property should be a colon-separated list of package&#xA;     * prefixes for the class name of the factory class that will create&#xA;     * a URL context factory.&#xA;     * This property may be specified in the environment,&#xA;     * an applet parameter, a system property, or one or more&#xA;     * resource files.&#xA;     * The prefix &lt;tt>com.sun.jndi.url&lt;/tt> is always appended to&#xA;     * the possibly empty list of package prefixes.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.factory.url.pkgs&quot;.&#xA;     *&#xA;     * @see javax.naming.spi.NamingManager#getObjectInstance&#xA;     * @see javax.naming.spi.NamingManager#getURLContext&#xA;     * @see javax.naming.spi.ObjectFactory&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     * @see #APPLET&#xA;      */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="PROVIDER_URL">
      <initialValue xsi:type="references:StringReference" value="java.naming.provider.url"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property&#xA;     * for specifying configuration information for the service provider&#xA;     * to use. The value of the property should contain a URL string&#xA;     * (e.g. &quot;ldap://somehost:389&quot;).&#xA;     * This property may be specified in the environment,&#xA;     * an applet parameter, a system property, or a resource file.&#xA;     * If it is not specified in any of these sources,&#xA;     * the default configuration is determined by the service provider.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.provider.url&quot;.&#xA;     *&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     * @see #APPLET&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="DNS_URL">
      <initialValue xsi:type="references:StringReference" value="java.naming.dns.url"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property&#xA;     * for specifying the DNS host and domain names to use for the&#xA;     * JNDI URL context (for example, &quot;dns://somehost/wiz.com&quot;).&#xA;     * This property may be specified in the environment,&#xA;     * an applet parameter, a system property, or a resource file.&#xA;     * If it is not specified in any of these sources&#xA;     * and the program attempts to use a JNDI URL containing a DNS name,&#xA;     * a &lt;tt>ConfigurationException&lt;/tt> will be thrown.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.dns.url&quot;.&#xA;     *&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="AUTHORITATIVE">
      <initialValue xsi:type="references:StringReference" value="java.naming.authoritative"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property for&#xA;     * specifying the authoritativeness of the service requested.&#xA;     * If the value of the property is the string &quot;true&quot;, it means&#xA;     * that the access is to the most authoritative source (i.e. bypass&#xA;     * any cache or replicas). If the value is anything else,&#xA;     * the source need not be (but may be) authoritative.&#xA;     * If unspecified, the value defaults to &quot;false&quot;.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.authoritative&quot;.&#xA;     *&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="BATCHSIZE">
      <initialValue xsi:type="references:StringReference" value="java.naming.batchsize"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property for&#xA;     * specifying the batch size to use when returning data via the&#xA;     * service's protocol. This is a hint to the provider to return&#xA;     * the results of operations in batches of the specified size, so&#xA;     * the provider can optimize its performance and usage of resources.&#xA;     * The value of the property is the string representation of an&#xA;     * integer.&#xA;     * If unspecified, the batch size is determined by the service&#xA;     * provider.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.batchsize&quot;.&#xA;     *&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="REFERRAL">
      <initialValue xsi:type="references:StringReference" value="java.naming.referral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property for&#xA;     * specifying how referrals encountered by the service provider&#xA;     * are to be processed. The value of the property is one of the&#xA;     * following strings:&#xA;     * &lt;dl>&#xA;     * &lt;dt>&quot;follow&quot;&#xA;     * &lt;dd>follow referrals automatically&#xA;     * &lt;dt>&quot;ignore&quot;&#xA;     * &lt;dd>ignore referrals&#xA;     * &lt;dt>&quot;throw&quot;&#xA;     * &lt;dd>throw &lt;tt>ReferralException&lt;/tt> when a referral is encountered.&#xA;     * &lt;/dl>&#xA;     * If this property is not specified, the default is&#xA;     * determined by the provider.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.referral&quot;.&#xA;     *&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="SECURITY_PROTOCOL">
      <initialValue xsi:type="references:StringReference" value="java.naming.security.protocol"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property for&#xA;     * specifying the security protocol to use.&#xA;     * Its value is a string determined by the service provider&#xA;     * (e.g. &quot;ssl&quot;).&#xA;     * If this property is unspecified,&#xA;     * the behaviour is determined by the service provider.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.security.protocol&quot;.&#xA;     *&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="SECURITY_AUTHENTICATION">
      <initialValue xsi:type="references:StringReference" value="java.naming.security.authentication"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property for&#xA;     * specifying the security level to use.&#xA;     * Its value is one of the following strings:&#xA;     * &quot;none&quot;, &quot;simple&quot;, &quot;strong&quot;.&#xA;     * If this property is unspecified,&#xA;     * the behaviour is determined by the service provider.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.security.authentication&quot;.&#xA;     *&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="SECURITY_PRINCIPAL">
      <initialValue xsi:type="references:StringReference" value="java.naming.security.principal"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property for&#xA;     * specifying the identity of the principal for authenticating&#xA;     * the caller to the service. The format of the principal&#xA;     * depends on the authentication scheme.&#xA;     * If this property is unspecified,&#xA;     * the behaviour is determined by the service provider.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.security.principal&quot;.&#xA;     *&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="SECURITY_CREDENTIALS">
      <initialValue xsi:type="references:StringReference" value="java.naming.security.credentials"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property for&#xA;     * specifying the credentials of the principal for authenticating&#xA;     * the caller to the service. The value of the property depends&#xA;     * on the authentication scheme. For example, it could be a hashed&#xA;     * password, clear-text password, key, certificate, and so on.&#xA;     * If this property is unspecified,&#xA;     * the behaviour is determined by the service provider.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.security.credentials&quot;.&#xA;     *&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="LANGUAGE">
      <initialValue xsi:type="references:StringReference" value="java.naming.language"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property for&#xA;     * specifying the preferred language to use with the service.&#xA;     * The value of the property is a colon-separated list of language&#xA;     * tags as defined in RFC 1766.&#xA;     * If this property is unspecified,&#xA;     * the language preference is determined by the service provider.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.language&quot;.&#xA;     *&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="APPLET">
      <initialValue xsi:type="references:StringReference" value="java.naming.applet"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Constant that holds the name of the environment property for&#xA;     * specifying an applet for the initial context constructor to use&#xA;     * when searching for other properties.&#xA;     * The value of this property is the&#xA;     * &lt;tt>java.applet.Applet&lt;/tt> instance that is being executed.&#xA;     * This property may be specified in the environment parameter&#xA;     * passed to the initial context constructor.&#xA;     * When this property is set, each property that the initial context&#xA;     * constructor looks for in the system properties is first looked for&#xA;     * in the applet's parameter list.&#xA;     * If this property is unspecified, the initial context constructor&#xA;     * will search for properties only in the environment parameter&#xA;     * passed to it, the system properties, and application resource files.&#xA;     *&#xA;     * &lt;p> The value of this constant is &quot;java.naming.applet&quot;.&#xA;     *&#xA;     * @see #addToEnvironment(String, Object)&#xA;     * @see #removeFromEnvironment(String)&#xA;     * @see InitialContext&#xA;     *&#xA;     * @since 1.3&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This interface represents a naming context, which&#xA; * consists of a set of name-to-object bindings.&#xA; * It contains methods for examining and updating these bindings.&#xA; * &lt;p>&#xA; * &lt;h4>Names&lt;/h4>&#xA; * Each name passed as an argument to a &lt;tt>Context&lt;/tt> method is relative&#xA; * to that context.  The empty name is used to name the context itself.&#xA; * A name parameter may never be null.&#xA; * &lt;p>&#xA; * Most of the methods have overloaded versions with one taking a&#xA; * &lt;code>Name&lt;/code> parameter and one taking a &lt;code>String&lt;/code>.&#xA; * These overloaded versions are equivalent in that if&#xA; * the &lt;code>Name&lt;/code> and &lt;code>String&lt;/code> parameters are just&#xA; * different representations of the same name, then the overloaded&#xA; * versions of the same methods behave the same.&#xA; * In the method descriptions below, only one version is fully documented.&#xA; * The second version instead has a link to the first:  the same&#xA; * documentation applies to both.&#xA; * &lt;p>&#xA; * For systems that support federation, &lt;tt>String&lt;/tt> name arguments to&#xA; * &lt;tt>Context&lt;/tt> methods are composite names. Name arguments that are&#xA; * instances of &lt;tt>CompositeName&lt;/tt> are treated as composite names,&#xA; * while &lt;tt>Name&lt;/tt> arguments that are not instances of&#xA; * &lt;tt>CompositeName&lt;/tt> are treated as compound names (which might be&#xA; * instances of &lt;tt>CompoundName&lt;/tt> or other implementations of compound&#xA; * names). This allows the results of &lt;tt>NameParser.parse()&lt;/tt> to be used as&#xA; * arguments to the &lt;tt>Context&lt;/tt> methods.&#xA; * Prior to JNDI 1.2, all name arguments were treated as composite names.&#xA; *&lt;p>&#xA; * Furthermore, for systems that support federation, all names returned&#xA; * in a &lt;tt>NamingEnumeration&lt;/tt>&#xA; * from &lt;tt>list()&lt;/tt> and &lt;tt>listBindings()&lt;/tt> are composite names&#xA; * represented as strings.&#xA; * See &lt;tt>CompositeName&lt;/tt> for the string syntax of names.&#xA; *&lt;p>&#xA; * For systems that do not support federation, the name arguments (in&#xA; * either &lt;tt>Name&lt;/tt> or &lt;tt>String&lt;/tt> forms) and the names returned in&#xA; * &lt;tt>NamingEnumeration&lt;/tt> may be names in their own namespace rather than&#xA; * names in a composite namespace, at the discretion of the service&#xA; * provider.&#xA; *&lt;p>&#xA; *&lt;h4>Exceptions&lt;/h4>&#xA; * All the methods in this interface can throw a &lt;tt>NamingException&lt;/tt> or&#xA; * any of its subclasses. See &lt;tt>NamingException&lt;/tt> and their subclasses&#xA; * for details on each exception.&#xA; *&lt;p>&#xA; *&lt;h4>Concurrent Access&lt;/h4>&#xA; * A Context instance is not guaranteed to be synchronized against&#xA; * concurrent access by multiple threads.  Threads that need to access&#xA; * a single Context instance concurrently should synchronize amongst&#xA; * themselves and provide the necessary locking.  Multiple threads&#xA; * each manipulating a different Context instance need not&#xA; * synchronize.  Note that the {@link #lookup(Name) &lt;tt>lookup&lt;/tt>}&#xA; * method, when passed an empty name, will return a new Context instance&#xA; * representing the same naming context.&#xA; *&lt;p>&#xA; * For purposes of concurrency control,&#xA; * a Context operation that returns a &lt;tt>NamingEnumeration&lt;/tt> is&#xA; * not considered to have completed while the enumeration is still in&#xA; * use, or while any referrals generated by that operation are still&#xA; * being followed.&#xA; *&#xA; *&lt;p>&#xA; *&lt;h4>Parameters&lt;/h4>&#xA; * A &lt;tt>Name&lt;/tt> parameter passed to any method of the&#xA; * &lt;tt>Context&lt;/tt> interface or one of its subinterfaces&#xA; * will not be modified by the service provider.&#xA; * The service provider may keep a reference to it&#xA; * for the duration of the operation, including any enumeration of the&#xA; * method's results and the processing of any referrals generated.&#xA; * The caller should not modify the object during this time.&#xA; * A &lt;tt>Name&lt;/tt> returned by any such method is owned by the caller.&#xA; * The caller may subsequently modify it; the service provider may not.&#xA; *&#xA; *&lt;p>&#xA; *&lt;h4>Environment Properties&lt;/h4>&#xA; *&lt;p>&#xA; * JNDI applications need a way to communicate various preferences&#xA; * and properties that define the environment in which naming and&#xA; * directory services are accessed. For example, a context might&#xA; * require specification of security credentials in order to access&#xA; * the service. Another context might require that server configuration&#xA; * information be supplied. These are referred to as the &lt;em>environment&lt;/em>&#xA; * of a context. The &lt;tt>Context&lt;/tt> interface provides methods for&#xA; * retrieving and updating this environment.&#xA; *&lt;p>&#xA; * The environment is inherited from the parent context as&#xA; * context methods proceed from one context to the next. Changes to&#xA; * the environment of one context do not directly affect those&#xA; * of other contexts.&#xA; *&lt;p>&#xA; * It is implementation-dependent when environment properties are used&#xA; * and/or verified for validity.  For example, some of the&#xA; * security-related properties are used by service providers to &quot;log in&quot;&#xA; * to the directory.  This login process might occur at the time the&#xA; * context is created, or the first time a method is invoked on the&#xA; * context.  When, and whether this occurs at all, is&#xA; * implementation-dependent.  When environment properties are added or&#xA; * removed from the context, verifying the validity of the changes is again&#xA; * implementation-dependent. For example, verification of some properties&#xA; * might occur at the time the change is made, or at the time the next&#xA; * operation is performed on the context, or not at all.&#xA; *&lt;p>&#xA; * Any object with a reference to a context may examine that context's&#xA; * environment.  Sensitive information such as clear-text&#xA; * passwords should not be stored there unless the implementation is&#xA; * known to protect it.&#xA; *&#xA; *&lt;p>&#xA; *&lt;a name=RESOURCEFILES>&lt;/a>&#xA; *&lt;h4>Resource Files&lt;/h4>&#xA; *&lt;p>&#xA; * To simplify the task of setting up the environment&#xA; * required by a JNDI application,&#xA; * application components and service providers may be distributed&#xA; * along with &lt;em>resource files.&lt;/em>&#xA; * A JNDI resource file is a file in the properties file format (see&#xA; * {@link java.util.Properties#load &lt;tt>java.util.Properties&lt;/tt>}),&#xA; * containing a list of key/value pairs.&#xA; * The key is the name of the property (e.g. &quot;java.naming.factory.object&quot;)&#xA; * and the value is a string in the format defined&#xA; * for that property.  Here is an example of a JNDI resource file:&#xA; *&#xA; * &lt;blockquote>&lt;tt>&lt;pre>&#xA; * java.naming.factory.object=com.sun.jndi.ldap.AttrsToCorba:com.wiz.from.Person&#xA; * java.naming.factory.state=com.sun.jndi.ldap.CorbaToAttrs:com.wiz.from.Person&#xA; * java.naming.factory.control=com.sun.jndi.ldap.ResponseControlFactory&#xA; * &lt;/pre>&lt;/tt>&lt;/blockquote>&#xA; *&#xA; * The JNDI class library reads the resource files and makes the property&#xA; * values freely available.  Thus JNDI resource files should be considered&#xA; * to be &quot;world readable&quot;, and sensitive information such as clear-text&#xA; * passwords should not be stored there.&#xA; *&lt;p>&#xA; * There are two kinds of JNDI resource files:&#xA; * &lt;em>provider&lt;/em> and &lt;em>application&lt;/em>.&#xA; *&#xA; * &lt;h5>Provider Resource Files&lt;/h5>&#xA; *&#xA; * Each service provider has an optional resource that lists properties&#xA; * specific to that provider.  The name of this resource is:&#xA; * &lt;blockquote>&#xA; * [&lt;em>prefix&lt;/em>/]&lt;tt>jndiprovider.properties&lt;/tt>&#xA; * &lt;/blockquote>&#xA; * where &lt;em>prefix&lt;/em> is&#xA; * the package name of the provider's context implementation(s),&#xA; * with each period (&quot;.&quot;) converted to a slash (&quot;/&quot;).&#xA; *&#xA; * For example, suppose a service provider defines a context&#xA; * implementation with class name &lt;tt>com.sun.jndi.ldap.LdapCtx&lt;/tt>.&#xA; * The provider resource for this provider is named&#xA; * &lt;tt>com/sun/jndi/ldap/jndiprovider.properties&lt;/tt>.  If the class is&#xA; * not in a package, the resource's name is simply&#xA; * &lt;tt>jndiprovider.properties&lt;/tt>.&#xA; *&#xA; * &lt;p>&#xA; * &lt;a name=LISTPROPS>&lt;/a>&#xA; * Certain methods in the JNDI class library make use of the standard&#xA; * JNDI properties that specify lists of JNDI factories:&#xA; * &lt;ul>&#xA; * &lt;li>java.naming.factory.object&#xA; * &lt;li>java.naming.factory.state&#xA; * &lt;li>java.naming.factory.control&#xA; * &lt;li>java.naming.factory.url.pkgs&#xA; * &lt;/ul>&#xA; * The JNDI library will consult the provider resource file&#xA; * when determining the values of these properties.&#xA; * Properties other than these may be set in the provider&#xA; * resource file at the discretion of the service provider.&#xA; * The service provider's documentation should clearly state which&#xA; * properties are allowed; other properties in the file will be ignored.&#xA; *&#xA; * &lt;h5>Application Resource Files&lt;/h5>&#xA; *&#xA; * When an application is deployed, it will generally have several&#xA; * codebase directories and JARs in its classpath.  Similarly, when an&#xA; * applet is deployed, it will have a codebase and archives specifying&#xA; * where to find the applet's classes.  JNDI locates (using&#xA; * {@link ClassLoader#getResources &lt;tt>ClassLoader.getResources()&lt;/tt>})&#xA; * all &lt;em>application resource files&lt;/em> named &lt;tt>jndi.properties&lt;/tt>&#xA; * in the classpath.&#xA; * In addition, if the file &lt;i>java.home&lt;/i>&lt;tt>/lib/jndi.properties&lt;/tt>&#xA; * exists and is readable,&#xA; * JNDI treats it as an additional application resource file.&#xA; * (&lt;i>java.home&lt;/i> indicates the&#xA; * directory named by the &lt;tt>java.home&lt;/tt> system property.)&#xA; * All of the properties contained in these files are placed&#xA; * into the environment of the initial context.  This environment&#xA; * is then inherited by other contexts.&#xA; *&#xA; * &lt;p>&#xA; * For each property found in more than one application resource file,&#xA; * JNDI uses the first value found or, in a few cases where it makes&#xA; * sense to do so, it concatenates all of the values (details are given&#xA; * below).&#xA; * For example, if the &quot;java.naming.factory.object&quot; property is found in&#xA; * three &lt;tt>jndi.properties&lt;/tt> resource files, the&#xA; * list of object factories is a concatenation of the property&#xA; * values from all three files.&#xA; * Using this scheme, each deployable component is responsible for&#xA; * listing the factories that it exports.  JNDI automatically&#xA; * collects and uses all of these export lists when searching for factory&#xA; * classes.&#xA; *&#xA; * &lt;p>&#xA; * Application resource files are available beginning with the Java 2&#xA; * Platform, except that the file in&#xA; * &lt;i>java.home&lt;/i>&lt;tt>/lib&lt;/tt> may be used on earlier Java platforms as well.&#xA; *&#xA; * &lt;h5>Search Algorithm for Properties&lt;/h5>&#xA; *&#xA; * When JNDI constructs an initial context, the context's environment&#xA; * is initialized with properties defined in the environment parameter&#xA; * passed to the constructor, the system properties, the applet parameters,&#xA; * and the application resource files.  See&#xA; * &lt;a href=InitialContext.html#ENVIRONMENT>&lt;tt>InitialContext&lt;/tt>&lt;/a>&#xA; * for details.&#xA; * This initial environment is then inherited by other context instances.&#xA; *&#xA; * &lt;p>&#xA; * When the JNDI class library needs to determine&#xA; * the value of a property, it does so by merging&#xA; * the values from the following two sources, in order:&#xA; * &lt;ol>&#xA; * &lt;li>The environment of the context being operated on.&#xA; * &lt;li>The provider resource file (&lt;tt>jndiprovider.properties&lt;/tt>)&#xA; * for the context being operated on.&#xA; * &lt;/ol>&#xA; * For each property found in both of these two sources,&#xA; * JNDI determines the property's value as follows.  If the property is&#xA; * one of the standard JNDI properties that specify a list of JNDI&#xA; * factories (listed &lt;a href=#LISTPROPS>above&lt;/a>), the values are&#xA; * concatenated into a single colon-separated list.  For other&#xA; * properties, only the first value found is used.&#xA; *&#xA; * &lt;p>&#xA; * When a service provider needs to determine the value of a property,&#xA; * it will generally take that value directly from the environment.&#xA; * A service provider may define provider-specific properties&#xA; * to be placed in its own provider resource file.  In that&#xA; * case it should merge values as described in the previous paragraph.&#xA; *&#xA; * &lt;p>&#xA; * In this way, each service provider developer can specify a list of&#xA; * factories to use with that service provider. These can be modified by&#xA; * the application resources specified by the deployer of the application&#xA; * or applet, which in turn can be modified by the user.&#xA; *&#xA; * @author Rosanna Lee&#xA; * @author Scott Seligman&#xA; * @author R. Vasudevan&#xA; * @version 1.12 04/07/16&#xA; *&#xA; * @since 1.3&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
