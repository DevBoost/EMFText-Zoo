<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16 http://www.emftext.org/java/variables ../../../java.ecore#/17" name="Duration.java">
  <comments>// $Id: Duration.java,v 1.36.8.1.4.3 2004/06/07 06:33:50 jsuttor Exp $</comments>
  <comments>/*&#xA; * @(#)Duration.java&#x9;1.13 04/07/26&#xA; * &#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>xml</namespaces>
  <namespaces>datatype</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>math</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/math/BigDecimal.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>math</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/util/Calendar.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/util/Date.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/util/GregorianCalendar.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>namespace</namespaces>
    <classifier xsi:type="classifiers:Class" href="../namespace/QName.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Duration">
    <members xsi:type="members:Field" name="DEBUG">
      <initialValue xsi:type="literals:BooleanLiteral" value="true"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;&#x9; * &lt;p>Debugging &lt;code>true&lt;/code> or &lt;code>false&lt;/code>.&lt;/p> &#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getXMLSchemaType">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../namespace/QName.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Return the name of the XML Schema date/time type that this instance &#xA;&#x9; * maps to. Type is computed based on fields that are set,&#xA;&#x9; * i.e. {@link #isSet(DatatypeConstants.Field field)} == &lt;code>true&lt;/code>.&lt;/p>&#xA;&#x9; *&#xA;&#x9; * &lt;table border=&quot;2&quot; rules=&quot;all&quot; cellpadding=&quot;2&quot;>&#xA;&#x9; *   &lt;thead>&#xA;&#x9; *     &lt;tr>&#xA;&#x9; *       &lt;th align=&quot;center&quot; colspan=&quot;7&quot;>&#xA;&#x9; *         Required fields for XML Schema 1.0 Date/Time Datatypes.&lt;br/>&#xA;&#x9; *         &lt;i>(timezone is optional for all date/time datatypes)&lt;/i>&#xA;&#x9; *       &lt;/th>&#xA;&#x9; *     &lt;/tr>&#xA;&#x9; *   &lt;/thead>&#xA;&#x9; *   &lt;tbody>&#xA;&#x9; *     &lt;tr>&#xA;&#x9; *       &lt;td>Datatype&lt;/td>&#xA;&#x9; *       &lt;td>year&lt;/td>&#xA;&#x9; *       &lt;td>month&lt;/td>&#xA;&#x9; *       &lt;td>day&lt;/td>&#xA;&#x9; *       &lt;td>hour&lt;/td>&#xA;&#x9; *       &lt;td>minute&lt;/td>&#xA;&#x9; *       &lt;td>second&lt;/td>&#xA;&#x9; *     &lt;/tr>&#xA;&#x9; *     &lt;tr>&#xA;&#x9; *       &lt;td>{@link DatatypeConstants#DURATION}&lt;/td>&#xA;&#x9; *       &lt;td>X&lt;/td>&#xA;&#x9; *       &lt;td>X&lt;/td>&#xA;&#x9; *       &lt;td>X&lt;/td>&#xA;&#x9; *       &lt;td>X&lt;/td>&#xA;&#x9; *       &lt;td>X&lt;/td>&#xA;&#x9; *       &lt;td>X&lt;/td>&#xA;&#x9; *     &lt;/tr>&#xA;&#x9; *     &lt;tr>&#xA;&#x9; *       &lt;td>{@link DatatypeConstants#DURATION_DAYTIME}&lt;/td>&#xA;&#x9; *       &lt;td>&lt;/td>&#xA;&#x9; *       &lt;td>&lt;/td>&#xA;&#x9; *       &lt;td>X&lt;/td>&#xA;&#x9; *       &lt;td>X&lt;/td>&#xA;&#x9; *       &lt;td>X&lt;/td>&#xA;&#x9; *       &lt;td>X&lt;/td>&#xA;&#x9; *     &lt;/tr>&#xA;&#x9; *     &lt;tr>&#xA;&#x9; *       &lt;td>{@link DatatypeConstants#DURATION_YEARMONTH}&lt;/td>&#xA;&#x9; *       &lt;td>X&lt;/td>&#xA;&#x9; *       &lt;td>X&lt;/td>&#xA;&#x9; *       &lt;td>&lt;/td>&#xA;&#x9; *       &lt;td>&lt;/td>&#xA;&#x9; *       &lt;td>&lt;/td>&#xA;&#x9; *       &lt;td>&lt;/td>&#xA;&#x9; *     &lt;/tr>&#xA;&#x9; *   &lt;/tbody>&#xA;&#x9; * &lt;/table>&#xA;&#x9; * &#xA;&#x9; * @return one of the following constants:&#xA;&#x9; *   {@link DatatypeConstants#DURATION},&#xA;&#x9; *   {@link DatatypeConstants#DURATION_DAYTIME} or&#xA;&#x9; *   {@link DatatypeConstants#DURATION_YEARMONTH}.&#xA;&#x9; *  &#xA;&#x9; * @throws IllegalStateException If the combination of set fields does not match one of the XML Schema date/time datatypes.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="yearSet">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.17"/>
              </next>
              <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="monthSet">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.18"/>
              </next>
              <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="daySet">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.19"/>
              </next>
              <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="hourSet">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.20"/>
              </next>
              <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="minuteSet">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.21"/>
              </next>
              <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="secondSet">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.22"/>
              </next>
              <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// DURATION</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.31"/>
              </next>
              <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.1/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.2/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.3/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.4/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.5/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// DURATION_DAYTIME</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.32"/>
              </next>
              <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.0/@variable"/>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.1/@variable"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.2/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.3/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.4/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.5/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// DURATION_YEARMONTH</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.1/@variable"/>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.2/@variable"/>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.3/@variable"/>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.4/@variable"/>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.5/@variable"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Throw">
        <comments>// nothing matches</comments>
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:StringReference" value="javax.xml.datatype.Duration#getXMLSchemaType():"/>
            <children xsi:type="references:StringReference" value=" this Duration does not match one of the XML Schema date/time datatypes:"/>
            <children xsi:type="references:StringReference" value=" year set = "/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.0/@variable"/>
            <children xsi:type="references:StringReference" value=" month set = "/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.1/@variable"/>
            <children xsi:type="references:StringReference" value=" day set = "/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.2/@variable"/>
            <children xsi:type="references:StringReference" value=" hour set = "/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.3/@variable"/>
            <children xsi:type="references:StringReference" value=" minute set = "/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.4/@variable"/>
            <children xsi:type="references:StringReference" value=" second set = "/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.5/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSign">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Returns the sign of this duration in -1,0, or 1.&#xA;&#x9; * &#xA;&#x9; * @return&#xA;&#x9; *      -1 if this duration is negative, 0 if the duration is zero,&#xA;&#x9; *      and 1 if the duration is positive.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getYears">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Get the years value of this &lt;code>Duration&lt;/code> as an &lt;code>int&lt;/code> or &lt;code>0&lt;/code> if not present.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>&lt;code>getYears()&lt;/code> is a convenience method for&#xA;&#x9; * {@link #getField(DatatypeConstants.Field field) getField(DatatypeConstants.YEARS)}.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>As the return value is an &lt;code>int&lt;/code>, an incorrect value will be returned for &lt;code>Duration&lt;/code>s&#xA;&#x9; * with years that go beyond the range of an &lt;code>int&lt;/code>.&#xA;&#x9; * Use {@link #getField(DatatypeConstants.Field field) getField(DatatypeConstants.YEARS)} to avoid possible loss of precision.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * @return If the years field is present, return its value as an &lt;code>int&lt;/code>, else return &lt;code>0&lt;/code>.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/lang/Number.class.xmi#//@classifiers.0/@members.2"/>
          </next>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMonths">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Obtains the value of the MONTHS field as an integer value,&#xA;&#x9; * or 0 if not present.&#xA;&#x9; * &#xA;&#x9; * This method works just like {@link #getYears()} except&#xA;&#x9; * that this method works on the MONTHS field.&#xA;&#x9; * &#xA;&#x9; * @return Months of this &lt;code>Duration&lt;/code>.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/lang/Number.class.xmi#//@classifiers.0/@members.2"/>
          </next>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.18"/>
            </next>
            <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDays">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Obtains the value of the DAYS field as an integer value,&#xA;&#x9; * or 0 if not present.&#xA;&#x9; * &#xA;&#x9; * This method works just like {@link #getYears()} except&#xA;&#x9; * that this method works on the DAYS field.&#xA;&#x9; * &#xA;&#x9; * @return Days of this &lt;code>Duration&lt;/code>.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/lang/Number.class.xmi#//@classifiers.0/@members.2"/>
          </next>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.19"/>
            </next>
            <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getHours">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Obtains the value of the HOURS field as an integer value,&#xA;&#x9; * or 0 if not present.&#xA;&#x9; * &#xA;&#x9; * This method works just like {@link #getYears()} except&#xA;&#x9; * that this method works on the HOURS field.&#xA;&#x9; * &#xA;&#x9; * @return Hours of this &lt;code>Duration&lt;/code>.&#xA;&#x9; * &#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/lang/Number.class.xmi#//@classifiers.0/@members.2"/>
          </next>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.20"/>
            </next>
            <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMinutes">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Obtains the value of the MINUTES field as an integer value,&#xA;&#x9; * or 0 if not present.&#xA;&#x9; * &#xA;&#x9; * This method works just like {@link #getYears()} except&#xA;&#x9; * that this method works on the MINUTES field.&#xA;&#x9; * &#xA;&#x9; * @return Minutes of this &lt;code>Duration&lt;/code>.&#xA;&#x9; * &#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/lang/Number.class.xmi#//@classifiers.0/@members.2"/>
          </next>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.21"/>
            </next>
            <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSeconds">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Obtains the value of the SECONDS field as an integer value,&#xA;&#x9; * or 0 if not present.&#xA;&#x9; * &#xA;&#x9; * This method works just like {@link #getYears()} except&#xA;&#x9; * that this method works on the SECONDS field.&#xA;&#x9; * &#xA;&#x9; * @return seconds in the integer value. The fraction of seconds&#xA;&#x9; *   will be discarded (for example, if the actual value is 2.5,&#xA;&#x9; *   this method returns 2)&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/lang/Number.class.xmi#//@classifiers.0/@members.2"/>
          </next>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.22"/>
            </next>
            <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getTimeInMillis">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="startInstant">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Returns the length of the duration in milli-seconds.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>If the seconds field carries more digits than milli-second order,&#xA;&#x9; * those will be simply discarded (or in other words, rounded to zero.)  &#xA;&#x9; * For example, for any Calendar value &lt;code>x&lt;code>,&lt;/p>&#xA;&#x9; * &lt;pre>&#xA;&#x9; * &lt;code>new Duration(&quot;PT10.00099S&quot;).getTimeInMills(x) == 10000&lt;/code>.&#xA;&#x9; * &lt;code>new Duration(&quot;-PT10.00099S&quot;).getTimeInMills(x) == -10000&lt;/code>.&#xA;&#x9; * &lt;/pre>&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * Note that this method uses the {@link #addTo(Calendar)} method,&#xA;&#x9; * which may work incorrectly with &lt;code>Duration&lt;/code> objects with&#xA;&#x9; * very large values in its fields. See the {@link #addTo(Calendar)}&#xA;&#x9; * method for details.&#xA;&#x9; * &#xA;&#x9; * @param startInstant&#xA;&#x9; *      The length of a month/year varies. The &lt;code>startInstant&lt;/code> is&#xA;&#x9; *      used to disambiguate this variance. Specifically, this method&#xA;&#x9; *      returns the difference between &lt;code>startInstant&lt;/code> and&#xA;&#x9; *      &lt;code>startInstant+duration&lt;/code>&#xA;&#x9; * &#xA;&#x9; * @return milliseconds between &lt;code>startInstant&lt;/code> and&#xA;&#x9; *   &lt;code>startInstant&lt;/code> plus this &lt;code>Duration&lt;/code>&#xA;&#x9; *&#xA;&#x9; * @throws NullPointerException if &lt;code>startInstant&lt;/code> parameter &#xA;&#x9; * is null.&#xA;&#x9; * &#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cal">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/util/Calendar.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/util/Calendar.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/util/Calendar.class.xmi#//@classifiers.0/@members.141"/>
              </next>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.14">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
          </children>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          </children>
          <additiveOperators xsi:type="operators:Subtraction"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getTimeInMillis">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="startInstant">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/util/Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Returns the length of the duration in milli-seconds.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>If the seconds field carries more digits than milli-second order,&#xA;&#x9; * those will be simply discarded (or in other words, rounded to zero.)&#xA;&#x9; * For example, for any &lt;code>Date&lt;/code> value &lt;code>x&lt;code>,&lt;/p>   &#xA;&#x9; * &lt;pre>&#xA;&#x9; * &lt;code>new Duration(&quot;PT10.00099S&quot;).getTimeInMills(x) == 10000&lt;/code>.&#xA;&#x9; * &lt;code>new Duration(&quot;-PT10.00099S&quot;).getTimeInMills(x) == -10000&lt;/code>.&#xA;&#x9; * &lt;/pre>&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * Note that this method uses the {@link #addTo(Date)} method,&#xA;&#x9; * which may work incorrectly with &lt;code>Duration&lt;/code> objects with&#xA;&#x9; * very large values in its fields. See the {@link #addTo(Date)}&#xA;&#x9; * method for details.&#xA;&#x9; * &#xA;&#x9; * @param startInstant&#xA;&#x9; *      The length of a month/year varies. The &lt;code>startInstant&lt;/code> is&#xA;&#x9; *      used to disambiguate this variance. Specifically, this method&#xA;&#x9; *      returns the difference between &lt;code>startInstant&lt;/code> and&#xA;&#x9; *      &lt;code>startInstant+duration&lt;/code>.&#xA;&#x9; * &#xA;&#x9; * @throws NullPointerException&#xA;&#x9; *      If the startInstant parameter is null.&#xA;&#x9; * &#xA;&#x9; * @return milliseconds between &lt;code>startInstant&lt;/code> and&#xA;&#x9; *   &lt;code>startInstant&lt;/code> plus this &lt;code>Duration&lt;/code>&#xA;&#x9; *&#xA;&#x9; * @see #getTimeInMillis(Calendar)&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cal">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/util/Calendar.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/util/GregorianCalendar.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/util/Calendar.class.xmi#//@classifiers.0/@members.93"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.14">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@variable"/>
          </next>
          <self xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@variable"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../java/util/Date.class.xmi#//@classifiers.0/@members.30"/>
            </next>
          </children>
          <additiveOperators xsi:type="operators:Subtraction"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getField">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Number.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>DatatypeConstants</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DatatypeConstants$Field.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Gets the value of a field. &#xA;&#x9; * &#xA;&#x9; * Fields of a duration object may contain arbitrary large value.&#xA;&#x9; * Therefore this method is designed to return a {@link Number} object.&#xA;&#x9; * &#xA;&#x9; * In case of YEARS, MONTHS, DAYS, HOURS, and MINUTES, the returned&#xA;&#x9; * number will be a non-negative integer. In case of seconds,&#xA;&#x9; * the returned number may be a non-negative decimal value.&#xA;&#x9; * &#xA;&#x9; * @param field&#xA;&#x9; *      one of the six Field constants (YEARS,MONTHS,DAYS,HOURS,&#xA;&#x9; *      MINUTES, or SECONDS.)&#xA;&#x9; * @return&#xA;&#x9; *      If the specified field is present, this method returns&#xA;&#x9; *      a non-null non-negative {@link Number} object that&#xA;&#x9; *      represents its value. If it is not present, return null.&#xA;&#x9; *      For YEARS, MONTHS, DAYS, HOURS, and MINUTES, this method&#xA;&#x9; *      returns a {@link java.math.BigInteger} object. For SECONDS, this&#xA;&#x9; *      method returns a {@link java.math.BigDecimal}. &#xA;&#x9; * &#xA;&#x9; * @throws NullPointerException If the &lt;code>field&lt;/code> is &lt;code>null&lt;/code>.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isSet">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>DatatypeConstants</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DatatypeConstants$Field.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Checks if a field is set.&#xA;&#x9; * &#xA;&#x9; * A field of a duration object may or may not be present.&#xA;&#x9; * This method can be used to test if a field is present.&#xA;&#x9; * &#xA;&#x9; * @param field&#xA;&#x9; *      one of the six Field constants (YEARS,MONTHS,DAYS,HOURS,&#xA;&#x9; *      MINUTES, or SECONDS.)&#xA;&#x9; * @return&#xA;&#x9; *      true if the field is present. false if not.&#xA;&#x9; * &#xA;&#x9; * @throws NullPointerException&#xA;&#x9; *      If the field parameter is null.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="add">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rhs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Computes a new duration whose value is &lt;code>this+rhs&lt;/code>.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>For example,&lt;/p>&#xA;&#x9; * &lt;pre>&#xA;&#x9; * &quot;1 day&quot; + &quot;-3 days&quot; = &quot;-2 days&quot;&#xA;&#x9; * &quot;1 year&quot; + &quot;1 day&quot; = &quot;1 year and 1 day&quot;&#xA;&#x9; * &quot;-(1 hour,50 minutes)&quot; + &quot;-20 minutes&quot; = &quot;-(1 hours,70 minutes)&quot;&#xA;&#x9; * &quot;15 hours&quot; + &quot;-3 days&quot; = &quot;-(2 days,9 hours)&quot;&#xA;&#x9; * &quot;1 year&quot; + &quot;-1 day&quot; = IllegalStateException&#xA;&#x9; * &lt;/pre>&#xA;&#x9; * &#xA;&#x9; * &lt;p>Since there's no way to meaningfully subtract 1 day from 1 month,&#xA;&#x9; * there are cases where the operation fails in&#xA;&#x9; * {@link IllegalStateException}.&lt;/p> &#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * Formally, the computation is defined as follows.&lt;/p>&#xA;&#x9; * &lt;p>&#xA;&#x9; * Firstly, we can assume that two &lt;code>Duration&lt;/code>s to be added&#xA;&#x9; * are both positive without losing generality (i.e.,&#xA;&#x9; * &lt;code>(-X)+Y=Y-X&lt;/code>, &lt;code>X+(-Y)=X-Y&lt;/code>,&#xA;&#x9; * &lt;code>(-X)+(-Y)=-(X+Y)&lt;/code>)&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * Addition of two positive &lt;code>Duration&lt;/code>s are simply defined as  &#xA;&#x9; * field by field addition where missing fields are treated as 0.&#xA;&#x9; * &lt;p>&#xA;&#x9; * A field of the resulting &lt;code>Duration&lt;/code> will be unset if and&#xA;&#x9; * only if respective fields of two input &lt;code>Duration&lt;/code>s are unset. &#xA;&#x9; * &lt;p>&#xA;&#x9; * Note that &lt;code>lhs.add(rhs)&lt;/code> will be always successful if&#xA;&#x9; * &lt;code>lhs.signum()*rhs.signum()!=-1&lt;/code> or both of them are&#xA;&#x9; * normalized.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * @param rhs &lt;code>Duration&lt;/code> to add to this &lt;code>Duration&lt;/code>&#xA;&#x9; * &#xA;&#x9; * @return&#xA;&#x9; *      non-null valid Duration object.&#xA;&#x9; * &#xA;&#x9; * @throws NullPointerException&#xA;&#x9; *      If the rhs parameter is null.&#xA;&#x9; * @throws IllegalStateException&#xA;&#x9; *      If two durations cannot be meaningfully added. For&#xA;&#x9; *      example, adding negative one day to one month causes&#xA;&#x9; *      this exception.&#xA;&#x9; * &#xA;&#x9; * &#xA;&#x9; * @see #subtract(Duration)&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addTo">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="calendar">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Adds this duration to a {@link Calendar} object.&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * Calls {@link java.util.Calendar#add(int,int)} in the&#xA;&#x9; * order of YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, and MILLISECONDS&#xA;&#x9; * if those fields are present. Because the {@link Calendar} class&#xA;&#x9; * uses int to hold values, there are cases where this method&#xA;&#x9; * won't work correctly (for example if values of fields&#xA;&#x9; * exceed the range of int.) &#xA;&#x9; * &lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * Also, since this duration class is a Gregorian duration, this&#xA;&#x9; * method will not work correctly if the given {@link Calendar}&#xA;&#x9; * object is based on some other calendar systems. &#xA;&#x9; * &lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * Any fractional parts of this &lt;code>Duration&lt;/code> object&#xA;&#x9; * beyond milliseconds will be simply ignored. For example, if&#xA;&#x9; * this duration is &quot;P1.23456S&quot;, then 1 is added to SECONDS,&#xA;&#x9; * 234 is added to MILLISECONDS, and the rest will be unused. &#xA;&#x9; * &lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * Note that because {@link Calendar#add(int, int)} is using&#xA;&#x9; * &lt;tt>int&lt;/tt>, &lt;code>Duration&lt;/code> with values beyond the&#xA;&#x9; * range of &lt;tt>int&lt;/tt> in its fields&#xA;&#x9; * will cause overflow/underflow to the given {@link Calendar}.&#xA;&#x9; * {@link XMLGregorianCalendar#add(Duration)} provides the same&#xA;&#x9; * basic operation as this method while avoiding&#xA;&#x9; * the overflow/underflow issues.&#xA;&#x9; * &#xA;&#x9; * @param calendar&#xA;&#x9; *      A calendar object whose value will be modified.&#xA;&#x9; * @throws NullPointerException&#xA;&#x9; *      if the calendar parameter is null.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="addTo">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="date">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/util/Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Adds this duration to a {@link Date} object.&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * The given date is first converted into&#xA;&#x9; * a {@link java.util.GregorianCalendar}, then the duration&#xA;&#x9; * is added exactly like the {@link #addTo(Calendar)} method.&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * The updated time instant is then converted back into a&#xA;&#x9; * {@link Date} object and used to update the given {@link Date} object.&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * This somewhat redundant computation is necessary to unambiguously&#xA;&#x9; * determine the duration of months and years.&#xA;&#x9; * &#xA;&#x9; * @param date&#xA;&#x9; *      A date object whose value will be modified.&#xA;&#x9; * @throws NullPointerException&#xA;&#x9; *      if the date parameter is null.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// check data parameter</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Cannot call "/>
                <children xsi:type="references:SelfReference">
                  <next xsi:type="references:MethodCall">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../../java/lang/Class.class.xmi#//@classifiers.0/@members.44"/>
                    </next>
                    <target xsi:type="members:ClassMethod" href="../../../java/lang/Object.class.xmi#//@classifiers.0/@members.2"/>
                  </next>
                  <self xsi:type="literals:This"/>
                </children>
                <children xsi:type="references:StringReference" value="#addTo(Date date) with date == null."/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cal">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/util/Calendar.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/util/GregorianCalendar.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.1/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/util/Calendar.class.xmi#//@classifiers.0/@members.93"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.14">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.1/@variable"/>
          </next>
          <self xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/util/Date.class.xmi#//@classifiers.0/@members.32"/>
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.1/@variable"/>
            </arguments>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="subtract">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rhs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Computes a new duration whose value is &lt;code>this-rhs&lt;/code>.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>For example:&lt;/p>&#xA;&#x9; * &lt;pre>&#xA;&#x9; * &quot;1 day&quot; - &quot;-3 days&quot; = &quot;4 days&quot;&#xA;&#x9; * &quot;1 year&quot; - &quot;1 day&quot; = IllegalStateException&#xA;&#x9; * &quot;-(1 hour,50 minutes)&quot; - &quot;-20 minutes&quot; = &quot;-(1hours,30 minutes)&quot;&#xA;&#x9; * &quot;15 hours&quot; - &quot;-3 days&quot; = &quot;3 days and 15 hours&quot;&#xA;&#x9; * &quot;1 year&quot; - &quot;-1 day&quot; = &quot;1 year and 1 day&quot;&#xA;&#x9; * &lt;/pre>&#xA;&#x9; * &#xA;&#x9; * &lt;p>Since there's no way to meaningfully subtract 1 day from 1 month,&#xA;&#x9; * there are cases where the operation fails in {@link IllegalStateException}.&lt;/p> &#xA;&#x9; * &#xA;&#x9; * &lt;p>Formally the computation is defined as follows.&#xA;&#x9; * First, we can assume that two &lt;code>Duration&lt;/code>s are both positive&#xA;&#x9; * without losing generality.  (i.e.,&#xA;&#x9; * &lt;code>(-X)-Y=-(X+Y)&lt;/code>, &lt;code>X-(-Y)=X+Y&lt;/code>,&#xA;&#x9; * &lt;code>(-X)-(-Y)=-(X-Y)&lt;/code>)&lt;/p>&#xA;&#x9; *  &#xA;&#x9; * &lt;p>Then two durations are subtracted field by field.&#xA;&#x9; * If the sign of any non-zero field &lt;tt>F&lt;/tt> is different from&#xA;&#x9; * the sign of the most significant field,&#xA;&#x9; * 1 (if &lt;tt>F&lt;/tt> is negative) or -1 (otherwise)&#xA;&#x9; * will be borrowed from the next bigger unit of &lt;tt>F&lt;/tt>.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>This process is repeated until all the non-zero fields have&#xA;&#x9; * the same sign.&lt;/p> &#xA;&#x9; * &#xA;&#x9; * &lt;p>If a borrow occurs in the days field (in other words, if&#xA;&#x9; * the computation needs to borrow 1 or -1 month to compensate&#xA;&#x9; * days), then the computation fails by throwing an&#xA;&#x9; * {@link IllegalStateException}.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * @param rhs &lt;code>Duration&lt;/code> to subtract from this &lt;code>Duration&lt;/code>.&#xA;&#x9; *  &#xA;&#x9; * @return New &lt;code>Duration&lt;/code> created from subtracting &lt;code>rhs&lt;/code> from this &lt;code>Duration&lt;/code>.&#xA;&#x9; * &#xA;&#x9; * @throws IllegalStateException&#xA;&#x9; *      If two durations cannot be meaningfully subtracted. For&#xA;&#x9; *      example, subtracting one day from one month causes&#xA;&#x9; *      this exception.&#xA;&#x9; * &#xA;&#x9; * @throws NullPointerException&#xA;&#x9; *      If the rhs parameter is null.&#xA;&#x9; * &#xA;&#x9; * @see #add(Duration)&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.19"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="multiply">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="factor">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Computes a new duration whose value is &lt;code>factor&lt;/code> times&#xA;&#x9; * longer than the value of this duration.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>This method is provided for the convenience.&#xA;&#x9; * It is functionally equivalent to the following code:&lt;/p>&#xA;&#x9; * &lt;pre>&#xA;&#x9; * multiply(new BigDecimal(String.valueOf(factor)))&#xA;&#x9; * &lt;/pre>&#xA;&#x9; * &#xA;&#x9; * @param factor Factor times longer of new &lt;code>Duration&lt;/code> to create.&#xA;&#x9; * &#xA;&#x9; * @return New &lt;code>Duration&lt;/code> that is &lt;code>factor&lt;/code>times longer than this &lt;code>Duration&lt;/code>.&#xA;&#x9; * &#xA;&#x9; * @see #multiply(BigDecimal)&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/math/BigDecimal.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/lang/String.class.xmi#//@classifiers.0/@members.83"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </arguments>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="multiply">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="factor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/math/BigDecimal.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Computes a new duration whose value is &lt;code>factor&lt;/code> times&#xA;&#x9; * longer than the value of this duration.&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * For example,&#xA;&#x9; * &lt;pre>&#xA;&#x9; * &quot;P1M&quot; (1 month) * &quot;12&quot; = &quot;P12M&quot; (12 months)&#xA;&#x9; * &quot;PT1M&quot; (1 min) * &quot;0.3&quot; = &quot;PT18S&quot; (18 seconds)&#xA;&#x9; * &quot;P1M&quot; (1 month) * &quot;1.5&quot; = IllegalStateException&#xA;&#x9; * &lt;/pre>&#xA;&#x9; *  &#xA;&#x9; * &lt;p>&#xA;&#x9; * Since the &lt;code>Duration&lt;/code> class is immutable, this method&#xA;&#x9; * doesn't change the value of this object. It simply computes&#xA;&#x9; * a new Duration object and returns it.&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * The operation will be performed field by field with the precision&#xA;&#x9; * of {@link BigDecimal}. Since all the fields except seconds are&#xA;&#x9; * restricted to hold integers,&#xA;&#x9; * any fraction produced by the computation will be&#xA;&#x9; * carried down toward the next lower unit. For example,&#xA;&#x9; * if you multiply &quot;P1D&quot; (1 day) with &quot;0.5&quot;, then it will be 0.5 day,&#xA;&#x9; * which will be carried down to &quot;PT12H&quot; (12 hours).&#xA;&#x9; * When fractions of month cannot be meaningfully carried down&#xA;&#x9; * to days, or year to months, this will cause an&#xA;&#x9; * {@link IllegalStateException} to be thrown. &#xA;&#x9; * For example if you multiple one month by 0.5.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * To avoid {@link IllegalStateException}, use&#xA;&#x9; * the {@link #normalizeWith(Calendar)} method to remove the years&#xA;&#x9; * and months fields.&#xA;&#x9; * &#xA;&#x9; * @param factor to multiply by&#xA;&#x9; * &#xA;&#x9; * @return&#xA;&#x9; *      returns a non-null valid &lt;code>Duration&lt;/code> object&#xA;&#x9; *&#xA;&#x9; * @throws IllegalStateException if operation produces fraction in &#xA;&#x9; * the months field.&#xA;&#x9; *&#xA;&#x9; * @throws NullPointerException if the &lt;code>factor&lt;/code> parameter is &#xA;&#x9; * &lt;code>null&lt;/code>.&#xA;&#x9; *&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="negate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Returns a new &lt;code>Duration&lt;/code> object whose&#xA;&#x9; * value is &lt;code>-this&lt;/code>.&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * Since the &lt;code>Duration&lt;/code> class is immutable, this method&#xA;&#x9; * doesn't change the value of this object. It simply computes&#xA;&#x9; * a new Duration object and returns it.&#xA;&#x9; * &#xA;&#x9; * @return&#xA;&#x9; *      always return a non-null valid &lt;code>Duration&lt;/code> object.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="normalizeWith">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="startTimeInstant">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Converts the years and months fields into the days field&#xA;&#x9; * by using a specific time instant as the reference point.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>For example, duration of one month normalizes to 31 days&#xA;&#x9; * given the start time instance &quot;July 8th 2003, 17:40:32&quot;.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>Formally, the computation is done as follows:&lt;/p>&#xA;&#x9; * &lt;ol>&#xA;&#x9; *  &lt;li>the given Calendar object is cloned&lt;/li>&#xA;&#x9; *  &lt;li>the years, months and days fields will be added to the {@link Calendar} object&#xA;&#x9; *      by using the {@link Calendar#add(int,int)} method&lt;/li> &#xA;&#x9; *  &lt;li>the difference between the two Calendars in computed in milliseconds and converted to days,&#xA;&#x9; *     if a remainder occurs due to Daylight Savings Time, it is discarded&lt;/li>&#xA;&#x9; *  &lt;li>the computed days, along with the hours, minutes and seconds&#xA;&#x9; *      fields of this duration object is used to construct a new&#xA;&#x9; *      Duration object.&lt;/li>&#xA;&#x9; * &lt;/ol>&#xA;&#x9; * &#xA;&#x9; * &lt;p>Note that since the Calendar class uses &lt;code>int&lt;/code> to&#xA;&#x9; * hold the value of year and month, this method may produce&#xA;&#x9; * an unexpected result if this duration object holds&#xA;&#x9; * a very large value in the years or months fields.&lt;/p>&#xA;&#x9; *&#xA;&#x9; * @param startTimeInstant &lt;code>Calendar&lt;/code> reference point.&#xA;&#x9; *  &#xA;&#x9; * @return &lt;code>Duration&lt;/code> of years and months of this &lt;code>Duration&lt;/code> as days.&#xA;&#x9; * &#xA;&#x9; * @throws NullPointerException If the startTimeInstant parameter is null.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="compare">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="duration">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Partial order relation comparison with this &lt;code>Duration&lt;/code> instance.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>Comparison result must be in accordance with&#xA;&#x9; * &lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#duration-order&quot;>W3C XML Schema 1.0 Part 2, Section 3.2.7.6.2,&#xA;&#x9; * &lt;i>Order relation on duration&lt;/i>&lt;/a>.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>Return:&lt;/p>&#xA;&#x9; * &lt;ul>&#xA;&#x9; *   &lt;li>{@link DatatypeConstants#LESSER} if this &lt;code>Duration&lt;/code> is shorter than &lt;code>duration&lt;/code> parameter&lt;/li>&#xA;&#x9; *   &lt;li>{@link DatatypeConstants#EQUAL} if this &lt;code>Duration&lt;/code> is equal to &lt;code>duration&lt;/code> parameter&lt;/li>&#xA;&#x9; *   &lt;li>{@link DatatypeConstants#GREATER} if this &lt;code>Duration&lt;/code> is longer than &lt;code>duration&lt;/code> parameter&lt;/li>&#xA;&#x9; *   &lt;li>{@link DatatypeConstants#INDETERMINATE} if a conclusive partial order relation cannot be determined&lt;/li>&#xA;&#x9; * &lt;/ul>&#xA;&#x9; *&#xA;&#x9; * @param duration to compare&#xA;&#x9; * &#xA;&#x9; * @return the relationship between &lt;code>this&lt;/code> &lt;code>Duration&lt;/code>and &lt;code>duration&lt;/code> parameter as&#xA;&#x9; *   {@link DatatypeConstants#LESSER}, {@link DatatypeConstants#EQUAL}, {@link DatatypeConstants#GREATER}&#xA;&#x9; *   or {@link DatatypeConstants#INDETERMINATE}.&#xA;&#x9; * &#xA;&#x9; * @throws UnsupportedOperationException If the underlying implementation&#xA;&#x9; *   cannot reasonably process the request, e.g. W3C XML Schema allows for&#xA;&#x9; *   arbitrarily large/small/precise values, the request may be beyond the&#xA;&#x9; *   implementations capability.&#xA;&#x9; * @throws NullPointerException if &lt;code>duration&lt;/code> is &lt;code>null&lt;/code>. &#xA;&#x9; *&#xA;&#x9; * @see #isShorterThan(Duration)&#xA;&#x9; * @see #isLongerThan(Duration)&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="isLongerThan">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="duration">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Checks if this duration object is strictly longer than&#xA;&#x9; * another &lt;code>Duration&lt;/code> object.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>Duration X is &quot;longer&quot; than Y if and only if X>Y &#xA;&#x9; * as defined in the section 3.2.6.2 of the XML Schema 1.0&#xA;&#x9; * specification.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>For example, &quot;P1D&quot; (one day) > &quot;PT12H&quot; (12 hours) and&#xA;&#x9; * &quot;P2Y&quot; (two years) > &quot;P23M&quot; (23 months).&lt;/p> &#xA;&#x9; * &#xA;&#x9; * @param duration &lt;code>Duration&lt;/code> to test this &lt;code>Duration&lt;/code> against.&#xA;&#x9; * &#xA;&#x9; * @throws UnsupportedOperationException If the underlying implementation&#xA;&#x9; *   cannot reasonably process the request, e.g. W3C XML Schema allows for&#xA;&#x9; *   arbitrarily large/small/precise values, the request may be beyond the&#xA;&#x9; *   implementations capability.&#xA;&#x9; * @throws NullPointerException If &lt;code>duration&lt;/code> is null.&#xA;&#x9; * &#xA;&#x9; * @return&#xA;&#x9; *      true if the duration represented by this object&#xA;&#x9; *      is longer than the given duration. false otherwise.&#xA;&#x9; * &#xA;&#x9; * @see #isShorterThan(Duration)&#xA;&#x9; * @see #compare(Duration duration)&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.21">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
          </children>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.14"/>
            </next>
            <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isShorterThan">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="duration">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Checks if this duration object is strictly shorter than&#xA;&#x9; * another &lt;code>Duration&lt;/code> object.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * @param duration &lt;code>Duration&lt;/code> to test this &lt;code>Duration&lt;/code> against.&#xA;&#x9; * &#xA;&#x9; * @return &lt;code>true&lt;/code> if &lt;code>duration&lt;/code> parameter is shorter than this &lt;code>Duration&lt;/code>,&#xA;&#x9; *   else &lt;code>false&lt;/code>. &#xA;&#x9; * &#xA;&#x9; * @throws UnsupportedOperationException If the underlying implementation&#xA;&#x9; *   cannot reasonably process the request, e.g. W3C XML Schema allows for&#xA;&#x9; *   arbitrarily large/small/precise values, the request may be beyond the&#xA;&#x9; *   implementations capability.&#xA;&#x9; * @throws NullPointerException if &lt;code>duration&lt;/code> is null.&#xA;&#x9; *&#xA;&#x9; * @see #isLongerThan(Duration duration)&#xA;&#x9; * @see #compare(Duration duration)&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.21">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
          </children>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.12"/>
            </next>
            <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="duration">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Checks if this duration object has the same duration&#xA;&#x9; * as another &lt;code>Duration&lt;/code> object.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>For example, &quot;P1D&quot; (1 day) is equal to &quot;PT24H&quot; (24 hours).&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>Duration X is equal to Y if and only if time instant&#xA;&#x9; * t+X and t+Y are the same for all the test time instants&#xA;&#x9; * specified in the section 3.2.6.2 of the XML Schema 1.0 &#xA;&#x9; * specification.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>Note that there are cases where two &lt;code>Duration&lt;/code>s are&#xA;&#x9; * &quot;incomparable&quot; to each other, like one month and 30 days.&#xA;&#x9; * For example,&lt;/p>&#xA;&#x9; * &lt;pre>&#xA;&#x9; * !new Duration(&quot;P1M&quot;).isShorterThan(new Duration(&quot;P30D&quot;))&#xA;&#x9; * !new Duration(&quot;P1M&quot;).isLongerThan(new Duration(&quot;P30D&quot;))&#xA;&#x9; * !new Duration(&quot;P1M&quot;).equals(new Duration(&quot;P30D&quot;))&#xA;&#x9; * &lt;/pre>&#xA;&#x9; * &#xA;&#x9; * @param duration&#xA;&#x9; *      A non-null valid &lt;code>Duration&lt;/code> object.&#xA;&#x9; * &#xA;&#x9; * @return&#xA;&#x9; *      &lt;code>true&lt;/code> if this duration is the same length as&#xA;&#x9; *         &lt;code>duration&lt;/code>.&#xA;&#x9; *      &lt;code>false&lt;/code> if &lt;code>duration&lt;/code> is not a&#xA;&#x9; *         &lt;code>Duration&lt;/code> object&#xA;&#x9; *         or its length is different from this duration.&#xA;&#x9; * &#xA;&#x9; * @throws UnsupportedOperationException If the underlying implementation&#xA;&#x9; *   cannot reasonably process the request, e.g. W3C XML Schema allows for&#xA;&#x9; *   arbitrarily large/small/precise values, the request may be beyond the&#xA;&#x9; *   implementations capability.&#xA;&#x9; * @throws NullPointerException if parameter is null.&#xA;&#x9; *&#xA;&#x9; * @see #compare(Duration duration)&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.21">
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            </arguments>
          </children>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.13"/>
            </next>
            <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Returns a hash code consistent with the definition of the equals method.&#xA;&#x9; * &#xA;&#x9; * @see Object#hashCode() &#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Returns a &lt;code>String&lt;/code> representation of this &lt;code>Duration&lt;/code> &lt;code>Object&lt;/code>.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>The result is formatted according to the XML Schema 1.0 spec and can be always parsed back later into the&#xA;&#x9; * equivalent &lt;code>Duration&lt;/code> &lt;code>Object&lt;/code> by {@link DatatypeFactory#newDuration(String  lexicalRepresentation)}.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>Formally, the following holds for any &lt;code>Duration&lt;/code>&#xA;&#x9; * &lt;code>Object&lt;/code> x:&lt;/p> &#xA;&#x9; * &lt;pre>&#xA;&#x9; * new Duration(x.toString()).equals(x)&#xA;&#x9; * &lt;/pre>&#xA;&#x9; * &#xA;&#x9; * @return A non-&lt;code>null&lt;/code> valid &lt;code>String&lt;/code> representation of this &lt;code>Duration&lt;/code>.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="buf">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                <arguments xsi:type="literals:CharacterLiteral" value="45"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
            <arguments xsi:type="literals:CharacterLiteral" value="80"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="years">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.17"/>
                </next>
                <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
              </arguments>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.3/@variable"/>
                  <children xsi:type="references:StringReference" value="Y"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.3/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="months">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.18"/>
                </next>
                <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
              </arguments>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.5/@variable"/>
                  <children xsi:type="references:StringReference" value="M"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.5/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="days">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.19"/>
                </next>
                <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
              </arguments>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.7/@variable"/>
                  <children xsi:type="references:StringReference" value="D"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.7/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="hours">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.20"/>
                </next>
                <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
              </arguments>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="minutes">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.21"/>
                </next>
                <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
              </arguments>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="seconds">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/math/BigDecimal.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../java/math/BigDecimal.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DatatypeConstants.class.xmi#//@classifiers.0/@members.22"/>
                </next>
                <target xsi:type="classifiers:Class" href="DatatypeConstants.class.xmi#//@classifiers.0"/>
              </arguments>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                <arguments xsi:type="literals:CharacterLiteral" value="84"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.9/@variable"/>
                      <children xsi:type="references:StringReference" value="H"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.9/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.10/@variable"/>
                      <children xsi:type="references:StringReference" value="M"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.10/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.27">
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.11/@variable"/>
                      </children>
                      <children xsi:type="references:StringReference" value="S"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.11/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.9/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.10/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.11/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bd">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/math/BigDecimal.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * &lt;p>Turns {@link BigDecimal} to a string representation.&lt;/p>&#xA;     * &#xA;     * &lt;p>Due to a behavior change in the {@link BigDecimal#toString()}&#xA;     * method in JDK 5, this had to be implemented here.&lt;/p>&#xA;     * &#xA;     * @param bd &lt;code>BigDecimal&lt;/code> to format as a &lt;code>String&lt;/code>&#xA;     * &#xA;     * @return  &lt;code>String&lt;/code> representation of &lt;code>BigDecimal&lt;/code> &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="intString">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/math/BigInteger.class.xmi#//@classifiers.0/@members.113"/>
              </next>
              <target xsi:type="members:ClassMethod" href="../../../java/math/BigDecimal.class.xmi#//@classifiers.0/@members.78"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="scale">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../java/math/BigDecimal.class.xmi#//@classifiers.0/@members.76"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.1/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="buf">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>/* Insert decimal point */</comments>
              <target xsi:type="classifiers:Class" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="insertionPoint">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/lang/String.class.xmi#//@classifiers.0/@members.22"/>
              </next>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.1/@variable"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <comments>/* Point goes right before intVal */</comments>
            <returnValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="0."/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.3/@variable">
                  <comments>/* Point goes inside intVal */</comments>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.3/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.45"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@variable"/>
                  <arguments xsi:type="literals:CharacterLiteral" value="46"/>
                </next>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.3/@variable">
                  <comments>/* We must insert zeros between point and intVal */</comments>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../../java/lang/String.class.xmi#//@classifiers.0/@members.22"/>
                      </next>
                    </children>
                    <additiveOperators xsi:type="operators:Subtraction"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.3/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="references:StringReference" value="0."/>
                </next>
              </expression>
            </statements>
            <statements xsi:type="statements:ForLoop">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.3/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                      <arguments xsi:type="literals:CharacterLiteral" value="48"/>
                    </next>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.5/@elseStatement/@elseStatement/@statements.2/@init"/>
                <children xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Subtraction"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@variable"/>
                </children>
                <relationOperators xsi:type="operators:LessThan"/>
              </condition>
              <init xsi:type="variables:LocalVariable" name="i">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </init>
              <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.5/@elseStatement/@elseStatement/@statements.2/@init"/>
                <operator xsi:type="operators:PlusPlus"/>
              </updates>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.3/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable"/>
                </next>
              </expression>
            </statements>
          </elseStatement>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.3/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCalendarTimeInMillis">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * &lt;p>Calls the {@link Calendar#getTimeInMillis} method.&#xA;     * Prior to JDK1.4, this method was protected and therefore&#xA;     * cannot be invoked directly.&lt;/p>&#xA;     * &#xA;     * &lt;p>TODO: In future, this should be replaced by &lt;code>cal.getTimeInMillis()&lt;/code>.&lt;/p>&#xA;     * &#xA;     * @param cal &lt;code>Calendar&lt;/code> to get time in milliseconds.&#xA;     * &#xA;     * @return Milliseconds of &lt;code>cal&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../java/util/Date.class.xmi#//@classifiers.0/@members.30"/>
            </next>
            <target xsi:type="members:ClassMethod" href="../../../java/util/Calendar.class.xmi#//@classifiers.0/@members.92"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;p>Immutable representation of a time span as defined in&#xA; * the W3C XML Schema 1.0 specification.&lt;/p>&#xA; * &#xA; * &lt;p>A Duration object represents a period of Gregorian time,&#xA; * which consists of six fields (years, months, days, hours,&#xA; * minutes, and seconds) plus a sign (+/-) field.&lt;/p>&#xA; * &#xA; * &lt;p>The first five fields have non-negative (>=0) integers or null&#xA; * (which represents that the field is not set),&#xA; * and the seconds field has a non-negative decimal or null.&#xA; * A negative sign indicates a negative duration.&lt;/p> &#xA; * &#xA; * &lt;p>This class provides a number of methods that make it easy&#xA; * to use for the duration datatype of XML Schema 1.0 with&#xA; * the errata.&lt;/p>&#xA; * &#xA; * &lt;h2>Order relationship&lt;/h2>&#xA; * &lt;p>Duration objects only have partial order, where two values A and B&#xA; * maybe either:&lt;/p>&#xA; * &lt;ol>&#xA; *  &lt;li>A&amp;lt;B (A is shorter than B)&#xA; *  &lt;li>A&amp;gt;B (A is longer than B)&#xA; *  &lt;li>A==B   (A and B are of the same duration)&#xA; *  &lt;li>A&amp;lt;>B (Comparison between A and B is indeterminate)&#xA; * &lt;/ol>&#xA;&#xA; *  * &lt;p>For example, 30 days cannot be meaningfully compared to one month.&#xA; * The {@link #compare(Duration duration)} method implements this&#xA; * relationship.&lt;/p>&#xA; * &#xA; * &lt;p>See the {@link #isLongerThan(Duration)} method for details about&#xA; * the order relationship among &lt;code>Duration&lt;/code> objects.&lt;/p>&#xA; * &#xA; * &lt;h2>Operations over Duration&lt;/h2>&#xA; * &lt;p>This class provides a set of basic arithmetic operations, such&#xA; * as addition, subtraction and multiplication.&#xA; * Because durations don't have total order, an operation could&#xA; * fail for some combinations of operations. For example, you cannot&#xA; * subtract 15 days from 1 month. See the javadoc of those methods&#xA; * for detailed conditions where this could happen.&lt;/p>&#xA; * &#xA; * &lt;p>Also, division of a duration by a number is not provided because&#xA; * the &lt;code>Duration&lt;/code> class can only deal with finite precision&#xA; * decimal numbers. For example, one cannot represent 1 sec divided by 3.&lt;/p> &#xA; * &#xA; * &lt;p>However, you could substitute a division by 3 with multiplying&#xA; * by numbers such as 0.3 or 0.333.&lt;/p>&#xA; * &#xA; * &lt;h2>Range of allowed values&lt;/h2>&#xA; * &lt;p>&#xA; * Because some operations of &lt;code>Duration&lt;/code> rely on {@link Calendar}&#xA; * even though {@link Duration} can hold very large or very small values,&#xA; * some of the methods may not work correctly on such &lt;code>Duration&lt;/code>s.&#xA; * The impacted methods document their dependency on {@link Calendar}.&#xA; * &#xA; *  &#xA; * @author &lt;a href=&quot;mailto:Joseph.Fialli@Sun.COM&quot;>Joseph Fialli&lt;/a>&#xA; * @author &lt;a href=&quot;mailto:Kohsuke.Kawaguchi@Sun.com&quot;>Kohsuke Kawaguchi&lt;/a>&#xA; * @author &lt;a href=&quot;mailto:Jeff.Suttor@Sun.com&quot;>Jeff Suttor&lt;/a>&#xA; * @version $Revision: 1.36.8.1.4.3 $, $Date: 2004/06/07 06:33:50 $    &#xA; * @see XMLGregorianCalendar#add(Duration)&#xA; * @since 1.5&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
