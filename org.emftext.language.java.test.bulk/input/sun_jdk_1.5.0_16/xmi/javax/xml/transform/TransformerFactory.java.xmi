<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="TransformerFactory.java">
  <comments>// $Id: TransformerFactory.java,v 1.14.14.1 2004/05/05 20:04:52 jsuttor Exp $</comments>
  <comments>/*&#xA; * @(#)TransformerFactory.java&#x9;1.36 04/07/26&#xA; * &#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>xml</namespaces>
  <namespaces>transform</namespaces>
  <classifiers xsi:type="classifiers:Class" name="TransformerFactory">
    <members xsi:type="members:Constructor" name="TransformerFactory">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Default constructor is protected on purpose.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="newInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TransformerFactoryConfigurationError.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;p>Get current state of canonicalization.&lt;/p>&#xA;     * &#xA;     * @return current state canonicalization control&#xA;     */</comments>
        <comments>/*&#xA;    public boolean getCanonicalization() {&#xA;        return canonicalState;&#xA;    }&#xA;    */</comments>
        <comments>/**&#xA;     * &lt;p>Set canonicalization control to &lt;code>true&lt;/code> or&#xA;     * &lt;/code>false&lt;/code>.&lt;/p>&#xA;     * &#xA;     * @param state of canonicalization&#xA;     */</comments>
        <comments>/*&#xA;    public void setCanonicalization(boolean state) {&#xA;        canonicalState = state;&#xA;    }&#xA;    */</comments>
        <comments>/**&#xA;     * Obtain a new instance of a &lt;code>TransformerFactory&lt;/code>.&#xA;     * This static method creates a new factory instance&#xA;     * This method uses the following ordered lookup procedure to determine&#xA;     * the &lt;code>TransformerFactory&lt;/code> implementation class to&#xA;     * load:&#xA;     * &lt;ul>&#xA;     * &lt;li>&#xA;     * Use the &lt;code>javax.xml.transform.TransformerFactory&lt;/code> system&#xA;     * property.&#xA;     * &lt;/li>&#xA;     * &lt;li>&#xA;     * Use the properties file &quot;lib/jaxp.properties&quot; in the JRE directory.&#xA;     * This configuration file is in standard &lt;code>java.util.Properties&#xA;     * &lt;/code> format and contains the fully qualified name of the&#xA;     * implementation class with the key being the system property defined&#xA;     * above.&#xA;     * &#xA;     * The jaxp.properties file is read only once by the JAXP implementation&#xA;     * and it's values are then cached for future use.  If the file does not exist&#xA;     * when the first attempt is made to read from it, no further attempts are&#xA;     * made to check for its existence.  It is not possible to change the value&#xA;     * of any property in jaxp.properties after it has been read for the first time.&#xA;     * &lt;/li>&#xA;     * &lt;li>&#xA;     * Use the Services API (as detailed in the JAR specification), if&#xA;     * available, to determine the classname. The Services API will look&#xA;     * for a classname in the file&#xA;     * &lt;code>META-INF/services/javax.xml.transform.TransformerFactory&lt;/code>&#xA;     * in jars available to the runtime.&#xA;     * &lt;/li>&#xA;     * &lt;li>&#xA;     * Platform default &lt;code>TransformerFactory&lt;/code> instance.&#xA;     * &lt;/li>&#xA;     * &lt;/ul>&#xA;     *&#xA;     * Once an application has obtained a reference to a &lt;code>&#xA;     * TransformerFactory&lt;/code> it can use the factory to configure&#xA;     * and obtain parser instances.&#xA;     *&#xA;     * @return new TransformerFactory instance, never null.&#xA;     *&#xA;     * @throws TransformerFactoryConfigurationError Thrown if the implementation&#xA;     *    is not available or cannot be instantiated.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="FactoryFinder.class.xmi#//@classifiers.0/@members.7"/>
                <arguments xsi:type="references:StringReference" value="javax.xml.transform.TransformerFactory">
                  <comments>/* The default property name according to the JAXP spec */</comments>
                </arguments>
                <arguments xsi:type="references:StringReference" value="com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl">
                  <comments>/* The fallback implementation class name, XSLTC */</comments>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="FactoryFinder.class.xmi#//@classifiers.0"/>
            </child>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="TransformerFactoryConfigurationError.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.0/@catcheBlocks.0/@parameter">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="FactoryFinder$ConfigurationError.class.xmi#//@classifiers.0/@members.2"/>
                </next>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.0/@catcheBlocks.0/@parameter">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/Throwable.class.xmi#//@classifiers.0/@members.9"/>
                </next>
              </arguments>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <namespaces>FactoryFinder</namespaces>
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="FactoryFinder$ConfigurationError.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="newTransformer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Transformer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Source.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TransformerConfigurationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;p>Process the &lt;code>Source&lt;/code> into a &lt;code>Transformer&lt;/code>&#xA;     * &lt;code>Object&lt;/code>.  The &lt;code>Source&lt;/code> is an XSLT document that&#xA;     * conforms to &lt;a href=&quot;http://www.w3.org/TR/xslt&quot;>&#xA;     * XSL Transformations (XSLT) Version 1.0&lt;/a>.  Care must&#xA;     * be taken not to use this &lt;code>Transformer&lt;/code> in multiple&#xA;     * &lt;code>Thread&lt;/code>s running concurrently.&#xA;     * Different &lt;code>TransformerFactories&lt;/code> can be used concurrently by&#xA;     * different &lt;code>Thread&lt;/code>s.&lt;/p>&#xA;     *&#xA;     * @param source &lt;code>Source &lt;/code> of XSLT document used to create&#xA;     *   &lt;code>Transformer&lt;/code>.&#xA;     *   Examples of XML &lt;code>Source&lt;/code>s include&#xA;     *   {@link javax.xml.transform.dom.DOMSource DOMSource},&#xA;     *   {@link javax.xml.transform.sax.SAXSource SAXSource}, and&#xA;     *   {@link javax.xml.transform.stream.StreamSource StreamSource}.&#xA;     *&#xA;     * @return A &lt;code>Transformer&lt;/code> object that may be used to perform&#xA;     *   a transformation in a single &lt;code>Thread&lt;/code>, never&#xA;     *   &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @throws TransformerConfigurationException Thrown if there are errors when&#xA;     *    parsing the &lt;code>Source&lt;/code> or it is not possible to create a&#xA;     *   &lt;code>Transformer&lt;/code> instance.&#xA;     * &#xA;     * @see &lt;a href=&quot;http://www.w3.org/TR/xslt&quot;>&#xA;     *   XSL Transformations (XSLT) Version 1.0&lt;/a>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="newTransformer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Transformer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TransformerConfigurationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;p>Create a new &lt;code>Transformer&lt;code> that performs a copy&#xA;     * of the &lt;code>Source&lt;/code> to the &lt;code>Result&lt;/code>.&#xA;     * i.e. the &quot;&lt;em>identity transform&lt;/em>&quot;.&lt;/p>&#xA;     *&#xA;     * @return A Transformer object that may be used to perform a transformation&#xA;     * in a single thread, never null.&#xA;     *&#xA;     * @exception TransformerConfigurationException Thrown if it is not&#xA;     *   possible to create a &lt;code>Transformer&lt;/code> instance.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="newTemplates">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Templates.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Source.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TransformerConfigurationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Process the Source into a Templates object, which is a&#xA;     * a compiled representation of the source. This Templates object&#xA;     * may then be used concurrently across multiple threads.  Creating&#xA;     * a Templates object allows the TransformerFactory to do detailed&#xA;     * performance optimization of transformation instructions, without&#xA;     * penalizing runtime transformation.&#xA;     *&#xA;     * @param source An object that holds a URL, input stream, etc.&#xA;     *&#xA;     * @return A Templates object capable of being used for transformation&#xA;     * purposes, never null.&#xA;     *&#xA;     * @exception TransformerConfigurationException May throw this during the&#xA;     * parse when it is constructing the Templates object and fails.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAssociatedStylesheet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Source.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Source.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="media">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="title">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="charset">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TransformerConfigurationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;p>Get the stylesheet specification(s) associated with the&#xA;     * XML &lt;code>Source&lt;/code> document via the&#xA;     * &lt;a href=&quot;http://www.w3.org/TR/xml-stylesheet/&quot;>&#xA;     * xml-stylesheet processing instruction&lt;/a> that match the given criteria.&#xA;     * Note that it is possible to return several stylesheets, in which case&#xA;     * they are applied as if they were a list of imports or cascades in a&#xA;     * single stylesheet.&lt;/p>&#xA;     *&#xA;     * @param source The XML source document.&#xA;     * @param media The media attribute to be matched.  May be null, in which&#xA;     *      case the prefered templates will be used (i.e. alternate = no).&#xA;     * @param title The value of the title attribute to match.  May be null.&#xA;     * @param charset The value of the charset attribute to match.  May be null.&#xA;     *&#xA;     * @return A &lt;code>Source&lt;/code> &lt;code>Object&lt;/code> suitable for passing&#xA;     *   to the &lt;code>TransformerFactory&lt;/code>.&#xA;     * &#xA;     * @throws TransformerConfigurationException An &lt;code>Exception&lt;/code>&#xA;     *   is thrown if an error occurings during parsing of the&#xA;     *   &lt;code>source&lt;/code>.&#xA;     * &#xA;     * @see &lt;a href=&quot;http://www.w3.org/TR/xml-stylesheet/&quot;>&#xA;     *   Associating Style Sheets with XML documents Version 1.0&lt;/a>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setURIResolver">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="resolver">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="URIResolver.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set an object that is used by default during the transformation&#xA;     * to resolve URIs used in document(), xsl:import, or xsl:include.&#xA;     *&#xA;     * @param resolver An object that implements the URIResolver interface,&#xA;     * or null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getURIResolver">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="URIResolver.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Get the object that is used by default during the transformation&#xA;     * to resolve URIs used in document(), xsl:import, or xsl:include.&#xA;     *&#xA;     * @return The URIResolver that was set with setURIResolver.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setFeature">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TransformerConfigurationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>//======= CONFIGURATION METHODS =======</comments>
        <comments>/**&#xA;&#x9; * &lt;p>Set a feature for this &lt;code>TransformerFactory&lt;/code> and &lt;code>Transformer&lt;/code>s&#xA;&#x9; * or &lt;code>Template&lt;/code>s created by this factory.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>&#xA;&#x9; * Feature names are fully qualified {@link java.net.URI}s.&#xA;&#x9; * Implementations may define their own features.&#xA;&#x9; * An {@link TransformerConfigurationException} is thrown if this &lt;code>TransformerFactory&lt;/code> or the&#xA;&#x9; * &lt;code>Transformer&lt;/code>s or &lt;code>Template&lt;/code>s it creates cannot support the feature.&#xA;&#x9; * It is possible for an &lt;code>TransformerFactory&lt;/code> to expose a feature value but be unable to change its state.&#xA;&#x9; * &lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>All implementations are required to support the {@link javax.xml.XMLConstants#FEATURE_SECURE_PROCESSING} feature.&#xA;&#x9; * When the feature is:&lt;/p>&#xA;&#x9; * &lt;ul>&#xA;&#x9; *   &lt;li>&#xA;&#x9; *     &lt;code>true&lt;/code>: the implementation will limit XML processing to conform to implementation limits&#xA;&#x9; *     and behave in a secure fashion as defined by the implementation.&#xA;&#x9; *     Examples include resolving user defined style sheets and functions.&#xA;&#x9; *     If XML processing is limited for security reasons, it will be reported via a call to the registered&#xA;&#x9; *     {@link ErrorListener#fatalError(TransformerException exception)}.&#xA;&#x9; *     See {@link  #setErrorListener(ErrorListener listener)}.&#xA;&#x9; *   &lt;/li>&#xA;&#x9; *   &lt;li>&#xA;&#x9; *     &lt;code>false&lt;/code>: the implementation will processing XML according to the XML specifications without&#xA;&#x9; *     regard to possible implementation limits.&#xA;&#x9; *   &lt;/li>&#xA;&#x9; * &lt;/ul>&#xA;&#x9; * &#xA;&#x9; * @param name Feature name.&#xA;&#x9; * @param value Is feature state &lt;code>true&lt;/code> or &lt;code>false&lt;/code>.&#xA;&#x9; *  &#xA;&#x9; * @throws TransformerConfigurationException if this &lt;code>TransformerFactory&lt;/code>&#xA;&#x9; *   or the &lt;code>Transformer&lt;/code>s or &lt;code>Template&lt;/code>s it creates cannot support this feature.&#xA;     * @throws NullPointerException If the &lt;code>name&lt;/code> parameter is null.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFeature">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Look up the value of a feature.&#xA;     *&#xA;&#x9; * &lt;p>&#xA;&#x9; * Feature names are fully qualified {@link java.net.URI}s.&#xA;&#x9; * Implementations may define their own features.&#xA;&#x9; * &lt;code>false&lt;/code> is returned if this &lt;code>TransformerFactory&lt;/code> or the&#xA;&#x9; * &lt;code>Transformer&lt;/code>s or &lt;code>Template&lt;/code>s it creates cannot support the feature.&#xA;&#x9; * It is possible for an &lt;code>TransformerFactory&lt;/code> to expose a feature value but be unable to change its state.&#xA;&#x9; * &lt;/p>&#xA;&#x9; * &#xA;&#x9; * @param name Feature name.&#xA;&#x9; * &#xA;     * @return The current state of the feature, &lt;code>true&lt;/code> or &lt;code>false&lt;/code>.&#xA;     * &#xA;     * @throws NullPointerException If the &lt;code>name&lt;/code> parameter is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setAttribute">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allows the user to set specific attributes on the underlying&#xA;     * implementation.  An attribute in this context is defined to&#xA;     * be an option that the implementation provides.&#xA;     * An &lt;code>IllegalArgumentException&lt;/code> is thrown if the underlying&#xA;     * implementation doesn't recognize the attribute.&#xA;     *&#xA;     * @param name The name of the attribute.&#xA;     * @param value The value of the attribute.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAttribute">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allows the user to retrieve specific attributes on the underlying&#xA;     * implementation.&#xA;     * An &lt;code>IllegalArgumentException&lt;/code> is thrown if the underlying&#xA;     * implementation doesn't recognize the attribute.&#xA;     * &#xA;     * @param name The name of the attribute.&#xA;     * @return value The value of the attribute.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setErrorListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="ErrorListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set the error event listener for the TransformerFactory, which&#xA;     * is used for the processing of transformation instructions,&#xA;     * and not for the transformation itself.&#xA;     * An &lt;code>IllegalArgumentException&lt;/code> is thrown if the&#xA;     * &lt;code>ErrorListener&lt;/code> listener is &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @param listener The new error listener.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getErrorListener">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="ErrorListener.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Get the error event handler for the TransformerFactory.&#xA;     *&#xA;     * @return The current error handler, which should never be null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;p>A TransformerFactory instance can be used to create&#xA; * {@link javax.xml.transform.Transformer} and&#xA; * {@link javax.xml.transform.Templates} objects.&lt;/p>&#xA; *&#xA; * &lt;p>The system property that determines which Factory implementation&#xA; * to create is named &lt;code>&quot;javax.xml.transform.TransformerFactory&quot;&lt;/code>.&#xA; * This property names a concrete subclass of the&#xA; * &lt;code>TransformerFactory&lt;/code> abstract class. If the property is not&#xA; * defined, a platform default is be used.&lt;/p>&#xA; * &#xA; * @author &lt;a href=&quot;mailto:Jeff.Suttor@Sun.com&quot;>Jeff Suttor&lt;/a>&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
