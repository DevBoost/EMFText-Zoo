<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="Transformer.java">
  <comments>// $Id: Transformer.java,v 1.9.14.1.2.4 2004/06/28 18:45:41 ndw Exp $</comments>
  <comments>/*&#xA; * @(#)Transformer.java&#x9;1.25 04/07/26&#xA; * &#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>xml</namespaces>
  <namespaces>transform</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/util/Properties.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Transformer">
    <members xsi:type="members:Constructor" name="Transformer">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Default constructor is protected on purpose.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="reset">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Reset this &lt;code>Transformer&lt;/code> to its original configuration.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>&lt;code>Transformer&lt;/code> is reset to the same state as when it was created with&#xA;&#x9; * {@link TransformerFactory#newTransformer()},&#xA;&#x9; * {@link TransformerFactory#newTransformer(Source source)} or&#xA;&#x9; * {@link Templates#newTransformer()}.&#xA;&#x9; * &lt;code>reset()&lt;/code> is designed to allow the reuse of existing &lt;code>Transformer&lt;/code>s&#xA;&#x9; * thus saving resources associated with the creation of new &lt;code>Transformer&lt;/code>s.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>The reset &lt;code>Transformer&lt;/code> is not guaranteed to have the same {@link URIResolver}&#xA;&#x9; * or {@link ErrorListener} &lt;code>Object&lt;/code>s, e.g. {@link Object#equals(Object obj)}.&#xA;&#x9; * It is guaranteed to have a functionally equal &lt;code>URIResolver&lt;/code>&#xA;&#x9; * and &lt;code>ErrorListener&lt;/code>.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * @since 1.5&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Throw">
        <comments>// implementors should override this method</comments>
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:StringReference" value="This Transformer, &quot;"/>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/Class.class.xmi#//@classifiers.0/@members.44"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../../../java/lang/Object.class.xmi#//@classifiers.0/@members.2"/>
              </next>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="references:StringReference" value="&quot;, does not support the reset functionality."/>
            <children xsi:type="references:StringReference" value="  Specification &quot;"/>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../java/lang/Package.class.xmi#//@classifiers.0/@members.14"/>
                  </next>
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/Class.class.xmi#//@classifiers.0/@members.51"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../../../java/lang/Object.class.xmi#//@classifiers.0/@members.2"/>
              </next>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="references:StringReference" value="&quot;"/>
            <children xsi:type="references:StringReference" value=" version &quot;"/>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../java/lang/Package.class.xmi#//@classifiers.0/@members.15"/>
                  </next>
                  <target xsi:type="members:ClassMethod" href="../../../java/lang/Class.class.xmi#//@classifiers.0/@members.51"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../../../java/lang/Object.class.xmi#//@classifiers.0/@members.2"/>
              </next>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="references:StringReference" value="&quot;"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="transform">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="xmlSource">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Source.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="outputTarget">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Result.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TransformerException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;p>Transform the XML &lt;code>Source&lt;/code> to a &lt;code>Result&lt;/code>.&#xA;     * Specific transformation behavior is determined by the settings of the&#xA;     * &lt;code>TransformerFactory&lt;/code> in effect when the&#xA;     * &lt;code>Transformer&lt;/code> was instantiated and any modifications made to&#xA;     * the &lt;code>Transformer&lt;/code> instance.&lt;/p>&#xA;     *&#xA;     * &lt;p>An empty &lt;code>Source&lt;/code> is represented as an empty document&#xA;     * as constructed by {@link javax.xml.parsers.DocumentBuilder#newDocument()}.&#xA;     * The result of transforming an empty &lt;code>Source&lt;/code> depends on&#xA;     * the transformation behavior; it is not always an empty&#xA;     * &lt;code>Result&lt;/code>.&lt;/p>&#xA;     *&#xA;     * @param xmlSource The XML input to transform.&#xA;     * @param outputTarget The &lt;code>Result&lt;/code> of transforming the&#xA;     *   &lt;code>xmlSource&lt;/code>.&#xA;     *&#xA;     * @throws TransformerException If an unrecoverable error occurs&#xA;     *   during the course of the transformation.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setParameter">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Add a parameter for the transformation.&#xA;     *&#xA;     * &lt;p>Pass a qualified name as a two-part string, the namespace URI&#xA;     * enclosed in curly braces ({}), followed by the local name. If the&#xA;     * name has a null URL, the String only contain the local name. An&#xA;     * application can safely check for a non-null URI by testing to see if the&#xA;     * first character of the name is a '{' character.&lt;/p>&#xA;     * &lt;p>For example, if a URI and local name were obtained from an element&#xA;     * defined with &amp;lt;xyz:foo&#xA;     * xmlns:xyz=&quot;http://xyz.foo.com/yada/baz.html&quot;/&amp;gt;,&#xA;     * then the qualified name would be &quot;{http://xyz.foo.com/yada/baz.html}foo&quot;.&#xA;     * Note that no prefix is used.&lt;/p>&#xA;     *&#xA;     * @param name The name of the parameter, which may begin with a&#xA;     * namespace URI in curly braces ({}).&#xA;     * @param value The value object.  This can be any valid Java object. It is&#xA;     * up to the processor to provide the proper object coersion or to simply&#xA;     * pass the object on for use in an extension.&#xA;     *&#xA;     * @throws NullPointerException If value is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getParameter">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Get a parameter that was explicitly set with setParameter.&#xA;     *&#xA;     * &lt;p>This method does not return a default parameter value, which&#xA;     * cannot be determined until the node context is evaluated during&#xA;     * the transformation process.&#xA;     *&#xA;     * @param name of &lt;code>Object&lt;/code> to get&#xA;     * @return A parameter that has been set with setParameter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="clearParameters">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;p>Set a list of parameters.&lt;/p>&#xA;     * &#xA;     * &lt;p>Note that the list of parameters is specified as a&#xA;     * &lt;code>Properties&lt;/code> &lt;code>Object&lt;/code> which limits the parameter&#xA;     * values to &lt;code>String&lt;/code>s.  Multiple calls to&#xA;     * {@link #setParameter(String name, Object value)} should be used when the&#xA;     * desired values are non-&lt;code>String&lt;/code> &lt;code>Object&lt;/code>s.&#xA;     * The parameter names should conform as specified in&#xA;     * {@link #setParameter(String name, Object value)}.&#xA;     * An &lt;code>IllegalArgumentException&lt;/code> is thrown if any names do not&#xA;     * conform.&lt;/p>&#xA;     * &#xA;     * &lt;p>New parameters in the list are added to any existing parameters.&#xA;     * If the name of a new parameter is equal to the name of an existing&#xA;     * parameter as determined by {@link java.lang.Object#equals(Object obj)},&#xA;     *  the existing parameter is set to the new value.&lt;/p>&#xA;     * &#xA;     * @param params Parameters to set.&#xA;     * &#xA;     * @throws IllegalArgumentException If any parameter names do not conform&#xA;     *   to the naming rules.&#xA;     */</comments>
        <comments>/**&#xA;     * Clear all parameters set with setParameter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setURIResolver">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="resolver">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="URIResolver.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set an object that will be used to resolve URIs used in&#xA;     * document().&#xA;     *&#xA;     * &lt;p>If the resolver argument is null, the URIResolver value will&#xA;     * be cleared and the transformer will no longer have a resolver.&lt;/p>&#xA;     *&#xA;     * @param resolver An object that implements the URIResolver interface,&#xA;     * or null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getURIResolver">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="URIResolver.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Get an object that will be used to resolve URIs used in&#xA;     * document().&#xA;     *&#xA;     * @return An object that implements the URIResolver interface,&#xA;     * or null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setOutputProperties">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="oformat">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/util/Properties.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set the output properties for the transformation.  These&#xA;     * properties will override properties set in the Templates&#xA;     * with xsl:output.&#xA;     *&#xA;     * &lt;p>If argument to this function is null, any properties&#xA;     * previously set are removed, and the value will revert to the value&#xA;     * defined in the templates object.&lt;/p>&#xA;     *&#xA;     * &lt;p>Pass a qualified property key name as a two-part string, the namespace&#xA;     * URI enclosed in curly braces ({}), followed by the local name. If the&#xA;     * name has a null URL, the String only contain the local name. An&#xA;     * application can safely check for a non-null URI by testing to see if the&#xA;     * first character of the name is a '{' character.&lt;/p>&#xA;     * &lt;p>For example, if a URI and local name were obtained from an element&#xA;     * defined with &amp;lt;xyz:foo&#xA;     * xmlns:xyz=&quot;http://xyz.foo.com/yada/baz.html&quot;/&amp;gt;,&#xA;     * then the qualified name would be &quot;{http://xyz.foo.com/yada/baz.html}foo&quot;.&#xA;     * Note that no prefix is used.&lt;/p>&#xA;     * An &lt;code>IllegalArgumentException&lt;/code> is thrown  if any of the&#xA;     * argument keys are not recognized and are not namespace qualified.&#xA;     *&#xA;     * @param oformat A set of output properties that will be&#xA;     * used to override any of the same properties in affect&#xA;     * for the transformation.&#xA;     *&#xA;     * @see javax.xml.transform.OutputKeys&#xA;     * @see java.util.Properties&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getOutputProperties">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/util/Properties.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;p>Get a copy of the output properties for the transformation.&lt;/p>&#xA;     *&#xA;     * &lt;p>The properties returned should contain properties set by the user,&#xA;     * and properties set by the stylesheet, and these properties&#xA;     * are &quot;defaulted&quot; by default properties specified by&#xA;     * &lt;a href=&quot;http://www.w3.org/TR/xslt#output&quot;>section 16 of the&#xA;     * XSL Transformations (XSLT) W3C Recommendation&lt;/a>.  The properties that&#xA;     * were specifically set by the user or the stylesheet should be in the base&#xA;     * Properties list, while the XSLT default properties that were not&#xA;     * specifically set should be the default Properties list.  Thus,&#xA;     * getOutputProperties().getProperty(String key) will obtain any&#xA;     * property in that was set by {@link #setOutputProperty},&#xA;     * {@link #setOutputProperties}, in the stylesheet, &lt;em>or&lt;/em> the default&#xA;     * properties, while&#xA;     * getOutputProperties().get(String key) will only retrieve properties&#xA;     * that were explicitly set by {@link #setOutputProperty},&#xA;     * {@link #setOutputProperties}, or in the stylesheet.&lt;/p>&#xA;     *&#xA;     * &lt;p>Note that mutation of the Properties object returned will not&#xA;     * effect the properties that the transformer contains.&lt;/p>&#xA;     *&#xA;     * &lt;p>If any of the argument keys are not recognized and are not&#xA;     * namespace qualified, the property will be ignored and not returned.&#xA;     * In other words the behaviour is not orthogonal with&#xA;     * {@link #setOutputProperties setOutputProperties}.&lt;/p>&#xA;     *&#xA;     * @return A copy of the set of output properties in effect for&#xA;     *   the next transformation.&#xA;     *&#xA;     * @see javax.xml.transform.OutputKeys&#xA;     * @see java.util.Properties&#xA;     * @see &lt;a href=&quot;http://www.w3.org/TR/xslt#output&quot;>&#xA;     *   XSL Transformations (XSLT) Version 1.0&lt;/a>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setOutputProperty">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set an output property that will be in effect for the&#xA;     * transformation.&#xA;     *&#xA;     * &lt;p>Pass a qualified property name as a two-part string, the namespace URI&#xA;     * enclosed in curly braces ({}), followed by the local name. If the&#xA;     * name has a null URL, the String only contain the local name. An&#xA;     * application can safely check for a non-null URI by testing to see if the&#xA;     * first character of the name is a '{' character.&lt;/p>&#xA;     * &lt;p>For example, if a URI and local name were obtained from an element&#xA;     * defined with &amp;lt;xyz:foo&#xA;     * xmlns:xyz=&quot;http://xyz.foo.com/yada/baz.html&quot;/&amp;gt;,&#xA;     * then the qualified name would be &quot;{http://xyz.foo.com/yada/baz.html}foo&quot;.&#xA;     * Note that no prefix is used.&lt;/p>&#xA;     *&#xA;     * &lt;p>The Properties object that was passed to {@link #setOutputProperties}&#xA;     * won't be effected by calling this method.&lt;/p>&#xA;     *&#xA;     * @param name A non-null String that specifies an output&#xA;     * property name, which may be namespace qualified.&#xA;     * @param value The non-null string value of the output property.&#xA;     *&#xA;     * @throws IllegalArgumentException If the property is not supported, and is&#xA;     * not qualified with a namespace.&#xA;     *&#xA;     * @see javax.xml.transform.OutputKeys&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getOutputProperty">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Get an output property that is in effect for the&#xA;     * transformer.  The property specified may be a property&#xA;     * that was set with setOutputProperty, or it may be a&#xA;     * property specified in the stylesheet.&#xA;     *&#xA;     * @param name A non-null String that specifies an output&#xA;     * property name, which may be namespace qualified.&#xA;     *&#xA;     * @return The string value of the output property, or null&#xA;     * if no property was found.&#xA;     *&#xA;     * @throws IllegalArgumentException If the property is not supported.&#xA;     *&#xA;     * @see javax.xml.transform.OutputKeys&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setErrorListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="ErrorListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set the error event listener in effect for the transformation.&#xA;     *&#xA;     * @param listener The new error listener.&#xA;     * @throws IllegalArgumentException if listener is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getErrorListener">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="ErrorListener.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Get the error event handler in effect for the transformation.&#xA;     * Implementations must provide a default error listener.&#xA;     *&#xA;     * @return The current error handler, which should never be null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * An instance of this abstract class can transform a&#xA; * source tree into a result tree.&#xA; *&#xA; * &lt;p>An instance of this class can be obtained with the&#xA; * {@link TransformerFactory#newTransformer TransformerFactory.newTransformer}&#xA; * method. This instance may then be used to process XML from a&#xA; * variety of sources and write the transformation output to a&#xA; * variety of sinks.&lt;/p>&#xA; *&#xA; * &lt;p>An object of this class may not be used in multiple threads&#xA; * running concurrently.  Different Transformers may be used&#xA; * concurrently by different threads.&lt;/p>&#xA; *&#xA; * &lt;p>A &lt;code>Transformer&lt;/code> may be used multiple times.  Parameters and&#xA; * output properties are preserved across transformations.&lt;/p>&#xA; * &#xA; * @author &lt;a href=&quot;Jeff.Suttor@Sun.com&quot;>Jeff Suttor&lt;/a>&#xA; * @version $Revision: 1.9.14.1.2.4 $, $Date: 2004/06/28 18:45:41 $&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
