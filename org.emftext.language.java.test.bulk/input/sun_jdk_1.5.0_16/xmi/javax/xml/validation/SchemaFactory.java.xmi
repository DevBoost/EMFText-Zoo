<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="SchemaFactory.java">
  <comments>// $Id: SchemaFactory.java,v 1.20.10.1.2.3 2004/09/16 09:24:47 nb131165 Exp $</comments>
  <comments>/*&#xA; * @(#)SchemaFactory.java&#x9;1.13 05/01/04&#xA; * &#xA; * Copyright 2005 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>xml</namespaces>
  <namespaces>validation</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/io/File.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>net</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/net/URL.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>transform</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../transform/Source.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>transform</namespaces>
    <namespaces>stream</namespaces>
    <classifier xsi:type="classifiers:Class" href="../transform/stream/StreamSource.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>w3c</namespaces>
    <namespaces>dom</namespaces>
    <namespaces>ls</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../org/w3c/dom/ls/LSResourceResolver.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>sax</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../org/xml/sax/ErrorHandler.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>sax</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>sax</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotRecognizedException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>sax</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotSupportedException.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="SchemaFactory">
    <members xsi:type="members:Field" name="ss">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SecuritySupport.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SecuritySupport.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Constructor" name="SchemaFactory">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * &lt;p>Constructor for derived classes.&lt;/p>&#xA;     * &#xA;     * &lt;p>The constructor does nothing.&lt;/p>&#xA;     * &#xA;     * &lt;p>Derived classes must create {@link SchemaFactory} objects that have&#xA;     * &lt;code>null&lt;/code> {@link ErrorHandler} and&#xA;     * &lt;code>null&lt;/code> {@link LSResourceResolver}.&lt;/p>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="newInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schemaLanguage">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;p>Lookup an implementation of the &lt;code>SchemaFactory&lt;/code> that supports the specified&#xA;     * schema language and return it.&lt;/p>&#xA;     * &#xA;     * &lt;p>To find a &lt;code>SchemaFactory&lt;/code> object for a given schema language,&#xA;     * this method looks the following places in the following order&#xA;     * where &quot;the class loader&quot; refers to the context class loader:&lt;/p>&#xA;     * &lt;ol>&#xA;     *  &lt;li>&#xA;     *     If the system property&#xA;     *     &lt;code>&quot;javax.xml.validation.SchemaFactory:&lt;i>schemaLanguage&lt;/i>&quot;&lt;/code>&#xA;     *     is present (where &lt;i>schemaLanguage&lt;/i> is the parameter&#xA;     *     to this method), then its value is read&#xA;     *     as a class name. The method will try to&#xA;     *     create a new instance of this class by using the class loader,&#xA;     *     and returns it if it is successfully created.&#xA;     *   &lt;/li>&#xA;     *   &lt;li>&#xA;     *     &lt;code>$java.home/lib/jaxp.properties&lt;/code> is read and&#xA;     *     the value associated with the key being the system property above&#xA;     *     is looked for. If present, the value is processed just like above.&#xA;     *   &lt;/li>&#xA;     *   &lt;li>&#xA;     *     &lt;p>The class loader is asked for service provider provider-configuration files matching&#xA;     *     &lt;code>javax.xml.validation.SchemaFactory&lt;/code> in the resource directory META-INF/services.&#xA;     *     See the JAR File Specification for file format and parsing rules.&#xA;     *     Each potential service provider is required to implement the method:&lt;/p>&#xA;     *     &lt;pre>&#xA;     *        {@link #isSchemaLanguageSupported(String schemaLanguage)}&#xA;     *     &lt;/pre> &#xA;     *     The first service provider found in class loader order that supports the specified schema language is returned.&#xA;     *   &lt;/li>&#xA;     *   &lt;li>&#xA;     *     Platform default &lt;code>SchemaFactory&lt;/code> is located&#xA;     *     in a implementation specific way. There must be a platform default&#xA;     *     &lt;code>SchemaFactory&lt;/code> for W3C XML Schema.&#xA;     *   &lt;/li>&#xA;     * &lt;/ol>&#xA;     * &#xA;     * &lt;p>If everything fails, {@link IllegalArgumentException} will be thrown.&lt;/p>&#xA;     * &#xA;     * &lt;p>&lt;strong>Tip for Trouble-shooting:&lt;/strong>&lt;/p>&#xA;     * &lt;p>See {@link java.util.Properties#load(java.io.InputStream)} for&#xA;     * exactly how a property file is parsed. In particular, colons ':'&#xA;     * need to be escaped in a property file, so make sure schema language&#xA;     * URIs are properly escaped in it. For example:&lt;/p>&#xA;     * &lt;pre>&#xA;     * http\://www.w3.org/2001/XMLSchema=org.acme.foo.XSSchemaFactory&#xA;     * &lt;/pre>&#xA;     * &#xA;     * @param schemaLanguage&#xA;     *      Specifies the schema language which the returned&#xA;     *      SchemaFactory will understand. See&#xA;     *      &lt;a href=&quot;#schemaLanguage&quot;>the list of available&#xA;     *      schema languages&lt;/a> for the possible values.&#xA;     * &#xA;     * @return New instance of a &lt;code>SchemaFactory&lt;/code>&#xA;     * &#xA;     * @throws IllegalArgumentException&#xA;     *      If no implementation of the schema language is available.&#xA;     * &#xA;     * @throws NullPointerException&#xA;     *      If the &lt;tt>schemLanguage&lt;/tt> parameter is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cl">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/lang/ClassLoader.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.0/@variable"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SecuritySupport.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.0/@variable">
                <comments>//cl = ClassLoader.getSystemClassLoader();</comments>
                <comments>//use the current class loader</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0">
                <next xsi:type="references:ReflectiveClassReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../java/lang/Class.class.xmi#//@classifiers.0/@members.46"/>
                  </next>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="f">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SchemaFactoryFinder.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SchemaFactoryFinder.class.xmi#//@classifiers.0/@members.10"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
            </next>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.0/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.3/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.3/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isSchemaLanguageSupported">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schemaLanguage">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Is specified schema supported by this &lt;code>SchemaFactory&lt;/code>?&lt;/p>&#xA;&#x9; * &#xA;&#x9; * @param schemaLanguage Specifies the schema language which the returned &lt;code>SchemaFactory&lt;/code> will understand.&#xA;     *    &lt;code>schemaLanguage&lt;/code> must specify a &lt;a href=&quot;#schemaLanguage&quot;>valid&lt;/a> schema language.&#xA;&#x9; * &#xA;&#x9; * @return &lt;code>true&lt;/code> if &lt;code>SchemaFactory&lt;/code> supports &lt;code>schemaLanguage&lt;/code>, else &lt;code>false&lt;/code>.&#xA;&#x9; * &#xA;&#x9; * @throws NullPointerException If &lt;code>schemaLanguage&lt;/code> is &lt;code>null&lt;/code>.&#xA;&#x9; * @throws IllegalArgumentException If &lt;code>schemaLanguage.length() == 0&lt;/code>&#xA;&#x9; *   or &lt;code>schemaLanguage&lt;/code> does not specify a &lt;a href=&quot;#schemaLanguage&quot;>valid&lt;/a> schema language.  &#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getFeature">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotRecognizedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotSupportedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Look up the value of a feature flag.&#xA;     *&#xA;     * &lt;p>The feature name is any fully-qualified URI.  It is&#xA;     * possible for a {@link SchemaFactory} to recognize a feature name but&#xA;     * temporarily be unable to return its value.&#xA;     *&#xA;     * &lt;p>Implementors are free (and encouraged) to invent their own features,&#xA;     * using names built on their own URIs.&lt;/p>&#xA;     *&#xA;     * @param name The feature name, which is a non-null fully-qualified URI.&#xA;     * @return The current value of the feature (true or false).&#xA;     * @exception org.xml.sax.SAXNotRecognizedException If the feature&#xA;     *            value can't be assigned or retrieved.&#xA;     * @exception org.xml.sax.SAXNotSupportedException When the&#xA;     *            {@link SchemaFactory} recognizes the feature name but &#xA;     *            cannot determine its value at this time.&#xA;     * @exception NullPointerException&#xA;     *              if the name parameter is null.&#xA;     * @see #setFeature(String, boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="the name parameter is null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotRecognizedException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setFeature">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotRecognizedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotSupportedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set the value of a feature flag.&#xA;     *&#xA;     * &lt;p>&#xA;     * Feature can be used to control the way a {@link SchemaFactory}&#xA;     * parses schemas, although {@link SchemaFactory}s are not required&#xA;     * to recognize any specific feature names.&lt;/p>&#xA;     *&#xA;     * &lt;p>The feature name is any fully-qualified URI.  It is&#xA;     * possible for a {@link SchemaFactory} to expose a feature value but&#xA;     * to be unable to change the current value.&lt;/p>&#xA;     *&#xA;&#x9; * &lt;p>All implementations are required to support the {@link javax.xml.XMLConstants#FEATURE_SECURE_PROCESSING} feature.&#xA;&#x9; * When the feature is:&lt;/p>&#xA;&#x9; * &lt;ul>&#xA;&#x9; *   &lt;li>&#xA;&#x9; *     &lt;code>true&lt;/code>: the implementation will limit XML processing to conform to implementation limits.&#xA;&#x9; *     Examples include enity expansion limits and XML Schema constructs that would consume large amounts of resources.&#xA;&#x9; *     If XML processing is limited for security reasons, it will be reported via a call to the registered&#xA;&#x9; *     {@link ErrorHandler#fatalError(SAXParseException exception)}.&#xA;&#x9; *     See {@link  #setErrorHandler(ErrorHandler errorHandler)}.&#xA;&#x9; *   &lt;/li>&#xA;&#x9; *   &lt;li>&#xA;&#x9; *     &lt;code>false&lt;/code>: the implementation will processing XML according to the XML specifications without&#xA;&#x9; *     regard to possible implementation limits.&#xA;&#x9; *   &lt;/li>&#xA;&#x9; * &lt;/ul>&#xA;&#x9; * &#xA;     * @param name The feature name, which is a non-null fully-qualified URI.&#xA;     * @param value The requested value of the feature (true or false).&#xA;     * &#xA;     * @exception org.xml.sax.SAXNotRecognizedException If the feature&#xA;     *            value can't be assigned or retrieved.&#xA;     * @exception org.xml.sax.SAXNotSupportedException When the&#xA;     *            {@link SchemaFactory} recognizes the feature name but &#xA;     *            cannot set the requested value.&#xA;     * @exception NullPointerException&#xA;     *              if the name parameter is null.&#xA;     * &#xA;     * @see #getFeature(String)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="the name parameter is null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotRecognizedException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setProperty">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="object">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotRecognizedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotSupportedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set the value of a property.&#xA;     *&#xA;     * &lt;p>The property name is any fully-qualified URI.  It is&#xA;     * possible for a {@link SchemaFactory} to recognize a property name but&#xA;     * to be unable to change the current value.&lt;/p>&#xA;     *&#xA;     * &lt;p>{@link SchemaFactory}s are not required to recognize setting&#xA;     * any specific property names.&lt;/p>&#xA;     *&#xA;     * @param name The property name, which is a non-null fully-qualified URI.&#xA;     * @param object The requested value for the property.&#xA;     * @exception org.xml.sax.SAXNotRecognizedException If the property&#xA;     *            value can't be assigned or retrieved.&#xA;     * @exception org.xml.sax.SAXNotSupportedException When the&#xA;     *            {@link SchemaFactory} recognizes the property name but &#xA;     *            cannot set the requested value.&#xA;     * @exception NullPointerException&#xA;     *              if the name parameter is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="the name parameter is null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotRecognizedException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getProperty">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotRecognizedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotSupportedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Look up the value of a property.&#xA;     *&#xA;     * &lt;p>The property name is any fully-qualified URI.  It is&#xA;     * possible for a {@link SchemaFactory} to recognize a property name but&#xA;     * temporarily be unable to return its value.&lt;/p>&#xA;     *&#xA;     * &lt;p>{@link SchemaFactory}s are not required to recognize any specific&#xA;     * property names.&lt;/p>&#xA;     *&#xA;     * &lt;p>Implementors are free (and encouraged) to invent their own properties,&#xA;     * using names built on their own URIs.&lt;/p>&#xA;     *&#xA;     * @param name The property name, which is a non-null fully-qualified URI.&#xA;     * @return The current value of the property.&#xA;     * @exception org.xml.sax.SAXNotRecognizedException If the property&#xA;     *            value can't be assigned or retrieved.&#xA;     * @exception org.xml.sax.SAXNotSupportedException When the&#xA;     *            XMLReader recognizes the property name but &#xA;     *            cannot determine its value at this time.&#xA;     * @exception NullPointerException&#xA;     *              if the name parameter is null.&#xA;     * @see #setProperty(String, Object)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="the name parameter is null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXNotRecognizedException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setErrorHandler">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="errorHandler">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../org/xml/sax/ErrorHandler.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the {@link ErrorHandler} to receive errors encountered&#xA;     * during the &lt;code>newSchema&lt;/code> method invocation.&#xA;     * &#xA;     * &lt;p>&#xA;     * Error handler can be used to customize the error handling process&#xA;     * during schema parsing. When an {@link ErrorHandler} is set,&#xA;     * errors found during the parsing of schemas will be first sent&#xA;     * to the {@link ErrorHandler}.&#xA;     * &#xA;     * &lt;p>&#xA;     * The error handler can abort the parsing of a schema immediately&#xA;     * by throwing {@link SAXException} from the handler. Or for example&#xA;     * it can print an error to the screen and try to continue the&#xA;     * processing by returning normally from the {@link ErrorHandler} &#xA;     * &#xA;     * &lt;p>&#xA;     * If any {@link Throwable} (or instances of its derived classes)&#xA;     * is thrown from an {@link ErrorHandler},&#xA;     * the caller of the &lt;code>newSchema&lt;/code> method will be thrown&#xA;     * the same {@link Throwable} object.&#xA;     * &#xA;     * &lt;p>&#xA;     * {@link SchemaFactory} is not allowed to&#xA;     * throw {@link SAXException} without first reporting it to&#xA;     * {@link ErrorHandler}.&#xA;     * &#xA;     * &lt;p>&#xA;     * Applications can call this method even during a {@link Schema}&#xA;     * is being parsed. &#xA;     * &#xA;     * &lt;p>&#xA;     * When the {@link ErrorHandler} is null, the implementation will&#xA;     * behave as if the following {@link ErrorHandler} is set:&#xA;     * &lt;pre>&#xA;     * class DraconianErrorHandler implements {@link ErrorHandler} {&#xA;     *     public void fatalError( {@link org.xml.sax.SAXParseException} e ) throws {@link SAXException} {&#xA;     *         throw e;&#xA;     *     }&#xA;     *     public void error( {@link org.xml.sax.SAXParseException} e ) throws {@link SAXException} {&#xA;     *         throw e;&#xA;     *     }&#xA;     *     public void warning( {@link org.xml.sax.SAXParseException} e ) throws {@link SAXException} {&#xA;     *         // noop&#xA;     *     }&#xA;     * }&#xA;     * &lt;/pre>&#xA;     * &#xA;     * &lt;p>&#xA;     * When a new {@link SchemaFactory} object is created, initially&#xA;     * this field is set to null. This field will &lt;em>NOT&lt;/em> be&#xA;     * inherited to {@link Schema}s, {@link Validator}s, or &#xA;     * {@link ValidatorHandler}s that are created from this {@link SchemaFactory}.&#xA;     * &#xA;     * &#xA;     * @param   errorHandler&#xA;     *      A new error handler to be set. This parameter can be null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getErrorHandler">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../org/xml/sax/ErrorHandler.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the current {@link ErrorHandler} set to this {@link SchemaFactory}.&#xA;     * &#xA;     * @return&#xA;     *      This method returns the object that was last set through&#xA;     *      the {@link #setErrorHandler(ErrorHandler)} method, or null&#xA;     *      if that method has never been called since this {@link SchemaFactory}&#xA;     *      has created.&#xA;     * &#xA;     * @see #setErrorHandler(ErrorHandler)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setResourceResolver">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="resourceResolver">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../org/w3c/dom/ls/LSResourceResolver.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the {@link LSResourceResolver} to customize&#xA;     * resource resolution when parsing schemas.&#xA;     * &#xA;     * &lt;p>&#xA;     * {@link SchemaFactory} uses a {@link LSResourceResolver}&#xA;     * when it needs to locate external resources while parsing schemas,&#xA;     * although exactly what constitutes &quot;locating external resources&quot; is&#xA;     * up to each schema language. For example, for W3C XML Schema,&#xA;     * this includes files &lt;tt>&amp;lt;include>&lt;/tt>d or &lt;tt>&amp;lt;import>&lt;/tt>ed,&#xA;     * and DTD referenced from schema files, etc.&#xA;     * &#xA;     * &lt;p>&#xA;     * Applications can call this method even during a {@link Schema}&#xA;     * is being parsed. &#xA;     * &#xA;     * &lt;p>&#xA;     * When the {@link LSResourceResolver} is null, the implementation will&#xA;     * behave as if the following {@link LSResourceResolver} is set:&#xA;     * &lt;pre>&#xA;     * class DumbDOMResourceResolver implements {@link LSResourceResolver} {&#xA;     *     public {@link org.w3c.dom.ls.LSInput} resolveResource(&#xA;     *         String publicId, String systemId, String baseURI) {&#xA;     *         &#xA;     *         return null; // always return null&#xA;     *     }&#xA;     * }&#xA;     * &lt;/pre>&#xA;     * &#xA;     * &lt;p>&#xA;     * If a {@link LSResourceResolver} throws a {@link RuntimeException}&#xA;     *  (or instances of its derived classes),&#xA;     * then the {@link SchemaFactory} will abort the parsing and  &#xA;     * the caller of the &lt;code>newSchema&lt;/code> method will receive&#xA;     * the same {@link RuntimeException}. &#xA;     * &#xA;     * &lt;p>&#xA;     * When a new {@link SchemaFactory} object is created, initially&#xA;     * this field is set to null.  This field will &lt;em>NOT&lt;/em> be&#xA;     * inherited to {@link Schema}s, {@link Validator}s, or &#xA;     * {@link ValidatorHandler}s that are created from this {@link SchemaFactory}.&#xA;     * &#xA;     * @param   resourceResolver&#xA;     *      A new resource resolver to be set. This parameter can be null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getResourceResolver">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../org/w3c/dom/ls/LSResourceResolver.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the current {@link LSResourceResolver} set to this {@link SchemaFactory}.&#xA;     * &#xA;     * @return&#xA;     *      This method returns the object that was last set through&#xA;     *      the {@link #setResourceResolver(LSResourceResolver)} method, or null&#xA;     *      if that method has never been called since this {@link SchemaFactory}&#xA;     *      has created.&#xA;     * &#xA;     * @see #setErrorHandler(ErrorHandler)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="newSchema">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Schema.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schema">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../transform/Source.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;p>Parses the specified source as a schema and returns it as a schema.&lt;/p>&#xA;     * &#xA;     * &lt;p>This is a convenience method for {@link #newSchema(Source[] schemas)}.&lt;/p>&#xA;     * &#xA;     * @param schema Source that represents a schema.&#xA;     * &#xA;     * @return New &lt;code>Schema&lt;/code> from parsing &lt;code>schema&lt;/code>.&#xA;     * &#xA;     * @throws SAXException If a SAX error occurs during parsing.&#xA;     * @throws NullPointerException if &lt;tt>schema&lt;/tt> is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Interface" href="../transform/Source.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
            </arrayInitializer>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newSchema">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Schema.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schema">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/File.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;p>Parses the specified &lt;code>File&lt;/code> as a schema and returns it as a &lt;code>Schema&lt;/code>.&lt;/p>&#xA;     * &#xA;     * &lt;p>This is a convenience method for {@link #newSchema(Source schema)}.&lt;/p>&#xA;     * &#xA;     * @param schema File that represents a schema.&#xA;     * &#xA;     * @return New &lt;code>Schema&lt;/code> from parsing &lt;code>schema&lt;/code>.&#xA;     * &#xA;     * @throws SAXException If a SAX error occurs during parsing.&#xA;     * @throws NullPointerException if &lt;tt>schema&lt;/tt> is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../transform/stream/StreamSource.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newSchema">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Schema.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schema">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/net/URL.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;p>Parses the specified &lt;code>URL&lt;/code> as a schema and returns it as a &lt;code>Schema&lt;/code>.&lt;/p>&#xA;     * &#xA;     * &lt;p>This is a convenience method for {@link #newSchema(Source schema)}.&lt;/p>&#xA;     * &#xA;     * @param schema &lt;code>URL&lt;/code> that represents a schema.&#xA;     * &#xA;     * @return New &lt;code>Schema&lt;/code> from parsing &lt;code>schema&lt;/code>.&#xA;     * &#xA;     * @throws SAXException If a SAX error occurs during parsing.&#xA;     * @throws NullPointerException if &lt;tt>schema&lt;/tt> is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../transform/stream/StreamSource.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/net/URL.class.xmi#//@classifiers.0/@members.41"/>
              </next>
            </arguments>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="newSchema">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Schema.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schemas">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../transform/Source.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Parses the specified source(s) as a schema and returns it as a schema.&#xA;     * &#xA;     * &lt;p>&#xA;     * The callee will read all the {@link Source}s and combine them into a&#xA;     * single schema. The exact semantics of the combination depends on the schema&#xA;     * language that this {@link SchemaFactory} object is created for.&#xA;     * &#xA;     * &lt;p>&#xA;     * When an {@link ErrorHandler} is set, the callee will report all the errors&#xA;     * found in sources to the handler. If the handler throws an exception, it will&#xA;     * abort the schema compilation and the same exception will be thrown from&#xA;     * this method. Also, after an error is reported to a handler, the callee is allowed&#xA;     * to abort the further processing by throwing it. If an error handler is not set,&#xA;     * the callee will throw the first error it finds in the sources.   &#xA;     * &#xA;     * &lt;h2>W3C XML Schema 1.0&lt;/h2>&#xA;     * &lt;p>&#xA;     * The resulting schema contains components from the specified sources.&#xA;     * The same result would be achieved if all these sources were&#xA;     * imported, using appropriate values for schemaLocation and namespace,&#xA;     * into a single schema document with a different targetNamespace&#xA;     * and no components of its own, if the import elements were given&#xA;     * in the same order as the sources.  Section 4.2.3 of the XML Schema&#xA;     * recommendation describes the options processors have in this&#xA;     * regard.  While a processor should be consistent in its treatment of&#xA;     * JAXP schema sources and XML Schema imports, the behaviour between&#xA;     * JAXP-compliant parsers may vary; in particular, parsers may choose&#xA;     * to ignore all but the first &amp;lt;import> for a given namespace,&#xA;     * regardless of information provided in schemaLocation.&#xA;     * &#xA;     * &lt;p>&#xA;     * If the parsed set of schemas includes error(s) as&#xA;     * specified in the section 5.1 of the XML Schema spec, then&#xA;     * the error must be reported to the {@link ErrorHandler}.&#xA;     * &#xA;     * &lt;h2>RELAX NG&lt;/h2>&#xA;     * &#xA;     * &lt;p>For RELAX NG, this method must throw {@link UnsupportedOperationException}&#xA;     * if &lt;tt>schemas.length!=1&lt;/tt>. &#xA;     *  &#xA;     * &#xA;     * @param schemas&#xA;     *      inputs to be parsed. {@link SchemaFactory} is required&#xA;     *      to recognize {@link javax.xml.transform.sax.SAXSource},&#xA;     *      {@link StreamSource}, and {@link javax.xml.transform.dom.DOMSource}.&#xA;     * &#xA;     * @return&#xA;     *      Always return a non-null valid {@link Schema} object.&#xA;     *      Note that when an error has been reported, there is no&#xA;     *      guarantee that the returned {@link Schema} object is&#xA;     *      meaningful.&#xA;     * &#xA;     * @throws SAXException&#xA;     *      If an error is found during processing the specified inputs.&#xA;     *      When an {@link ErrorHandler} is set, errors are reported to&#xA;     *      there first. See {@link #setErrorHandler(ErrorHandler)}.&#xA;     * @throws NullPointerException&#xA;     *      If the &lt;code>schemas&lt;/code> parameter itself is null or&#xA;     *      any item in the array is null.&#xA;     * @throws IllegalArgumentException&#xA;     *      If any item in the array is not recognized by this method. &#xA;     * @throws UnsupportedOperationException&#xA;     *      If the schema language doesn't support this operation.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="newSchema">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Schema.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a special {@link Schema} object.&#xA;     * &#xA;     * &lt;p>&#xA;     * The exact semantics of the returned {@link Schema} object depends&#xA;     * on the schema language that this {@link SchemaFactory} is created&#xA;     * for.&#xA;     * &#xA;     * &lt;p>&#xA;     * Also, implementations are allowed to use implementation-specific&#xA;     * property/feature to alter the semantics of this method.&#xA;     * &#xA;     * &#xA;     * &lt;h2>W3C XML Schema 1.0&lt;/h2>&#xA;     * &lt;p>&#xA;     * For XML Schema, this method creates a {@link Schema} object that&#xA;     * performs validation by using location hints specified in documents.&#xA;     * &#xA;     * &lt;p>&#xA;     * The returned {@link Schema} object assumes that if documents&#xA;     * refer to the same URL in the schema location hints,&#xA;     * they will always resolve to the same schema document. This&#xA;     * asusmption allows implementations to reuse parsed results of&#xA;     * schema documents so that multiple validations against the same&#xA;     * schema will run faster.&#xA;     * &#xA;     * &lt;p>&#xA;     * Note that the use of schema location hints introduces a&#xA;     * vulnerability to denial-of-service attacks. &#xA;     *  &#xA;     * &#xA;     * &lt;h2>RELAX NG&lt;/h2>&#xA;     * &lt;p>&#xA;     * RELAX NG does not support this operation. &#xA;     * &#xA;     * @return&#xA;     *      Always return non-null valid {@link Schema} object.&#xA;     * &#xA;     * @throws UnsupportedOperationException&#xA;     *      If this operation is not supported by the callee.&#xA;     * @throws SAXException&#xA;     *      If this operation is supported but failed for some reason.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Factory that creates {@link Schema} objects&amp;#x2E; Entry-point to&#xA; * the validation API.&#xA; *&#xA; * &lt;p>&#xA; * {@link SchemaFactory} is a schema compiler. It reads external&#xA; * representations of schemas and prepares them for validation.&#xA; * &#xA; * &lt;p>&#xA; * The {@link SchemaFactory} class is not thread-safe. In other words,&#xA; * it is the application's responsibility to ensure that at most&#xA; * one thread is using a {@link SchemaFactory} object at any&#xA; * given moment. Implementations are encouraged to mark methods&#xA; * as &lt;tt>synchronized&lt;/tt> to protect themselves from broken clients.&#xA; * &#xA; * &lt;p>&#xA; * {@link SchemaFactory} is not re-entrant. While one of the&#xA; * &lt;code>newSchema&lt;/code> methods is being invoked, applications&#xA; * may not attempt to recursively invoke the &lt;code>newSchema&lt;/code> method,&#xA; * even from the same thread.&#xA; * &#xA; * &lt;h2>&lt;a name=&quot;schemaLanguage&quot;>&lt;/a>Schema Language&lt;/h2>&#xA; * &lt;p>&#xA; * This spec uses a namespace URI to designate a schema language.&#xA; * The following table shows the values defined by this specification.&#xA; * &lt;p>&#xA; * To be compliant with the spec, the implementation &#xA; * is only required to support W3C XML Schema 1.0. However,&#xA; * if it chooses to support other schema languages listed here,&#xA; * it must conform to the relevant behaviors described in this spec.&#xA; * &#xA; * &lt;p>&#xA; * Schema languages not listed here are expected to&#xA; * introduce their own URIs to represent themselves.  &#xA; * The {@link SchemaFactory} class is capable of locating other&#xA; * implementations for other schema languages at run-time.&#xA; * &#xA; * &lt;p>&#xA; * Note that because the XML DTD is strongly tied to the parsing process&#xA; * and has a significant effect on the parsing process, it is impossible&#xA; * to define the DTD validation as a process independent from parsing. &#xA; * For this reason, this specification does not define the semantics for&#xA; * the XML DTD. This doesn't prohibit implentors from implementing it&#xA; * in a way they see fit, but &lt;em>users are warned that any DTD&#xA; * validation implemented on this interface necessarily deviate from&#xA; * the XML DTD semantics as defined in the XML 1.0&lt;/em>.&#xA; * &#xA; * &lt;table border=&quot;1&quot; cellpadding=&quot;2&quot;>&#xA; *   &lt;thead>&#xA; *     &lt;tr>&#xA; *       &lt;th>value&lt;/th>&#xA; *       &lt;th>language&lt;/th>&#xA; *     &lt;/tr>&#xA; *   &lt;/thead>&#xA; *   &lt;tbody>&#xA; *     &lt;tr>&#xA; *       &lt;td>{@link javax.xml.XMLConstants#W3C_XML_SCHEMA_NS_URI} (&quot;&lt;code>http://www.w3.org/2001/XMLSchema&lt;/code>&quot;)&lt;/td>&#xA; *       &lt;td>&lt;a href=&quot;http://www.w3.org/TR/xmlschema-1&quot;>W3C XML Schema 1.0&lt;/a>&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td>{@link javax.xml.XMLConstants#RELAXNG_NS_URI} (&quot;&lt;code>http://relaxng.org/ns/structure/1.0&lt;/code>&quot;)&lt;/td>&#xA; *       &lt;td>&lt;a href=&quot;http://www.relaxng.org/&quot;>RELAX NG 1.0&lt;/a>&lt;/td>&#xA; *     &lt;/tr>&#xA; *   &lt;/tbody>&#xA; * &lt;/table>&#xA; * &#xA; * @author  &lt;a href=&quot;mailto:Kohsuke.Kawaguchi@Sun.com&quot;>Kohsuke Kawaguchi&lt;/a>&#xA; * @version $Revision: 1.20.10.1.2.3 $, $Date: 2004/09/16 09:24:47 $&#xA; * @since 1.5&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
