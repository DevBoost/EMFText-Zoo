<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="IIOParam.java">
  <comments>/*&#xA; * @(#)IIOParam.java&#x9;1.29 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>imageio</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/awt/Point.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="IIOParam">
    <members xsi:type="members:Field" name="sourceRegion">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The source region, on &lt;code>null&lt;/code> if none is set.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="sourceXSubsampling">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The decimation subsampling to be applied in the horizontal&#xA;     * direction.  By default, the value is &lt;code>1&lt;/code>.&#xA;     * The value must not be negative or 0.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="sourceYSubsampling">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The decimation subsampling to be applied in the vertical&#xA;     * direction.  By default, the value is &lt;code>1&lt;/code>.&#xA;     * The value must not be negative or 0.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="subsamplingXOffset">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * A horizontal offset to be applied to the subsampling grid before&#xA;     * subsampling.  The first pixel to be used will be offset this&#xA;     * amount from the origin of the region, or of the image if no&#xA;     * region is specified.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="subsamplingYOffset">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * A vertical offset to be applied to the subsampling grid before&#xA;     * subsampling.  The first pixel to be used will be offset this&#xA;     * amount from the origin of the region, or of the image if no&#xA;     * region is specified.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="sourceBands">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:Int"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * An array of &lt;code>int&lt;/code>s indicating which source bands&#xA;     * will be used, or &lt;code>null&lt;/code>.  If &lt;code>null&lt;/code>, the&#xA;     * set of source bands to be used is as described in the comment&#xA;     * for the &lt;code>setSourceBands&lt;/code> method.  No value should&#xA;     * be allowed to be negative.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="destinationType">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ImageTypeSpecifier.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * An &lt;code>ImageTypeSpecifier&lt;/code> to be used to generate a&#xA;     * destination image when reading, or to set the output color type&#xA;     * when writing.  If non has been setm the value will be&#xA;     * &lt;code>null&lt;/code>.  By default, the value is &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="destinationOffset">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/awt/Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/awt/Point.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The offset in the destination where the upper-left decoded&#xA;     * pixel should be placed.  By default, the value is (0, 0).&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="defaultController">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="IIOParamController.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The default &lt;code>IIOParamController&lt;/code> that will be&#xA;     * used to provide settings for this &lt;code>IIOParam&lt;/code>&#xA;     * object when the &lt;code>activateController&lt;/code> method&#xA;     * is called.  This default should be set by subclasses&#xA;     * that choose to provide their own default controller, &#xA;     * usually a GUI, for setting parameters.&#xA;     *&#xA;     * @see IIOParamController&#xA;     * @see #getDefaultController&#xA;     * @see #activateController&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="controller">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="IIOParamController.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The &lt;code>IIOParamController&lt;/code> that will be&#xA;     * used to provide settings for this &lt;code>IIOParam&lt;/code>&#xA;     * object when the &lt;code>activateController&lt;/code> method&#xA;     * is called.  This value overrides any default controller, &#xA;     * even when null.&#xA;     *&#xA;     * @see IIOParamController&#xA;     * @see #setController(IIOParamController)&#xA;     * @see #hasController()&#xA;     * @see #activateController()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="IIOParam">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Protected constructor may be called only by subclasses.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="setSourceRegion">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sourceRegion">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the source region of interest.  The region of interest is&#xA;     * described as a rectangle, with the upper-left corner of the&#xA;     * source image as pixel (0, 0) and increasing values down and to&#xA;     * the right.  The actual number of pixels used will depend on&#xA;     * the subsampling factors set by &lt;code>setSourceSubsampling&lt;/code>.&#xA;     * If subsampling has been set such that this number is zero,&#xA;     * an &lt;code>IllegalStateException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> The source region of interest specified by this method will&#xA;     * be clipped as needed to fit within the source bounds, as well&#xA;     * as the destination offsets, width, and height at the time of&#xA;     * actual I/O.&#xA;     *&#xA;     * &lt;p> A value of &lt;code>null&lt;/code> for &lt;code>sourceRegion&lt;/code>&#xA;     * will remove any region specification, causing the entire image&#xA;     * to be used.&#xA;     *&#xA;     * @param sourceRegion a &lt;code>Rectangle&lt;/code> specifying the&#xA;     * source region of interest, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @exception IllegalArgumentException if&#xA;     * &lt;code>sourceRegion&lt;/code> is non-&lt;code>null&lt;/code> and either&#xA;     * &lt;code>sourceRegion.x&lt;/code> or &lt;code>sourceRegion.y&lt;/code> is&#xA;     * negative.&#xA;     * @exception IllegalArgumentException if&#xA;     * &lt;code>sourceRegion&lt;/code> is non-&lt;code>null&lt;/code> and either&#xA;     * &lt;code>sourceRegion.width&lt;/code> or&#xA;     * &lt;code>sourceRegion.height&lt;/code> is negative or 0.&#xA;     * @exception IllegalStateException if subsampling is such that&#xA;     * this region will have a subsampled width or height of zero.&#xA;     *&#xA;     * @see #getSourceRegion&#xA;     * @see #setSourceSubsampling&#xA;     * @see ImageReadParam#setDestinationOffset&#xA;     * @see ImageReadParam#getDestinationOffset&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:NullLiteral"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="sourceRegion.x &lt; 0!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="sourceRegion.y &lt; 0!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="sourceRegion.width &lt;= 0!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="sourceRegion.height &lt;= 0!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.3"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Throw an IllegalStateException if region falls between subsamples</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="sourceRegion.width &lt;= subsamplingXOffset!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="sourceRegion.height &lt;= subsamplingYOffset!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.3"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../java/awt/geom/RectangularShape.class.xmi#//@classifiers.0/@members.25"/>
              </next>
            </child>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSourceRegion">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the source region to be used.  The returned value is&#xA;     * that set by the most recent call to&#xA;     * &lt;code>setSourceRegion&lt;/code>, and will be &lt;code>null&lt;/code> if&#xA;     * there is no region set.&#xA;     * &#xA;     * @return the source region of interest as a&#xA;     * &lt;code>Rectangle&lt;/code>, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @see #setSourceRegion&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:NullLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../java/awt/geom/RectangularShape.class.xmi#//@classifiers.0/@members.25"/>
            </next>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setSourceSubsampling">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sourceXSubsampling">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sourceYSubsampling">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="subsamplingXOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="subsamplingYOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Specifies a decimation subsampling to apply on I/O.  The&#xA;     * &lt;code>sourceXSubsampling&lt;/code> and&#xA;     * &lt;code>sourceYSubsampling&lt;/code> parameters specify the&#xA;     * subsampling period (&lt;i>i.e.&lt;/i>, the number of rows and columns&#xA;     * to advance after every source pixel).  Specifically, a period of&#xA;     * 1 will use every row or column; a period of 2 will use every&#xA;     * other row or column.  The &lt;code>subsamplingXOffset&lt;/code> and&#xA;     * &lt;code>subsamplingYOffset&lt;/code> parameters specify an offset&#xA;     * from the region (or image) origin for the first subsampled pixel.&#xA;     * Adjusting the origin of the subsample grid is useful for avoiding&#xA;     * seams when subsampling a very large source image into destination&#xA;     * regions that will be assembled into a complete subsampled image.&#xA;     * Most users will want to simply leave these parameters at 0.&#xA;     *&#xA;     * &lt;p> The number of pixels and scanlines to be used are calculated&#xA;     * as follows.&#xA;     * &lt;p>&#xA;     * The number of subsampled pixels in a scanline is given by&#xA;     * &lt;p>&#xA;     * &lt;code>truncate[(width - subsamplingXOffset + sourceXSubsampling - 1)&#xA;     * / sourceXSubsampling]&lt;/code>.&#xA;     * &lt;p>&#xA;     * If the region is such that this width is zero, an &#xA;     * &lt;code>IllegalStateException&lt;/code> is thrown.&#xA;     * &lt;p> &#xA;     * The number of scanlines to be used can be computed similarly.&#xA;     *&#xA;     * &lt;p>The ability to set the subsampling grid to start somewhere&#xA;     * other than the source region origin is useful if the &#xA;     * region is being used to create subsampled tiles of a large image, &#xA;     * where the tile width and height are not multiples of the &#xA;     * subsampling periods.  If the subsampling grid does not remain&#xA;     * consistent from tile to tile, there will be artifacts at the tile&#xA;     * boundaries.  By adjusting the subsampling grid offset for each&#xA;     * tile to compensate, these artifacts can be avoided.  The tradeoff&#xA;     * is that in order to avoid these artifacts, the tiles are not all&#xA;     * the same size.  The grid offset to use in this case is given by:&#xA;     * &lt;br>&#xA;     * grid offset = [period - (region offset modulo period)] modulo period)&#xA;     *&#xA;     * &lt;p> If either &lt;code>sourceXSubsampling&lt;/code> or&#xA;     * &lt;code>sourceYSubsampling&lt;/code> is 0 or negative, an&#xA;     * &lt;code>IllegalArgumentException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> If either &lt;code>subsamplingXOffset&lt;/code> or&#xA;     * &lt;code>subsamplingYOffset&lt;/code> is negative or greater than or&#xA;     * equal to the corresponding period, an &#xA;     * &lt;code>IllegalArgumentException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> There is no &lt;code>unsetSourceSubsampling&lt;/code> method;&#xA;     * simply call &lt;code>setSourceSubsampling(1, 1, 0, 0)&lt;/code> to&#xA;     * restore default values.&#xA;     *&#xA;     * @param sourceXSubsampling the number of columns to advance&#xA;     * between pixels.&#xA;     * @param sourceYSubsampling the number of rows to advance between&#xA;     * pixels.&#xA;     * @param subsamplingXOffset the horizontal offset of the first subsample&#xA;     * within the region, or within the image if no region is set.&#xA;     * @param subsamplingYOffset the horizontal offset of the first subsample&#xA;     * within the region, or within the image if no region is set.&#xA;     * @exception IllegalArgumentException if either period is&#xA;     * negative or 0, or if either grid offset is negative or greater than&#xA;     * the corresponding period.&#xA;     * @exception IllegalStateException if the source region is such that&#xA;     * the subsampled output would contain no pixels.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="sourceXSubsampling &lt;= 0!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="sourceYSubsampling &lt;= 0!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="subsamplingXOffset out of range!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="subsamplingYOffset out of range!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.3"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.3"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Throw an IllegalStateException if region falls between subsamples</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:StringReference" value="region contains no pixels!"/>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.2"/>
                  </next>
                </children>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.3"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.3"/>
                  </next>
                </children>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.3"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSourceXSubsampling">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the number of source columns to advance for each pixel.&#xA;     *&#xA;     * &lt;p>If &lt;code>setSourceSubsampling&lt;/code> has not been called, 1&#xA;     * is returned (which is the correct value).&#xA;     *&#xA;     * @return the source subsampling X period.&#xA;     *&#xA;     * @see #setSourceSubsampling&#xA;     * @see #getSourceYSubsampling&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSourceYSubsampling">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the number of rows to advance for each pixel.&#xA;     *&#xA;     * &lt;p>If &lt;code>setSourceSubsampling&lt;/code> has not been called, 1&#xA;     * is returned (which is the correct value).&#xA;     *&#xA;     * @return the source subsampling Y period.&#xA;     *&#xA;     * @see #setSourceSubsampling&#xA;     * @see #getSourceXSubsampling&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSubsamplingXOffset">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the horizontal offset of the subsampling grid.&#xA;     *&#xA;     * &lt;p>If &lt;code>setSourceSubsampling&lt;/code> has not been called, 0&#xA;     * is returned (which is the correct value).&#xA;     *&#xA;     * @return the source subsampling grid X offset.&#xA;     *&#xA;     * @see #setSourceSubsampling&#xA;     * @see #getSubsamplingYOffset&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSubsamplingYOffset">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the vertical offset of the subsampling grid.&#xA;     *&#xA;     * &lt;p>If &lt;code>setSourceSubsampling&lt;/code> has not been called, 0&#xA;     * is returned (which is the correct value).&#xA;     *&#xA;     * @return the source subsampling grid Y offset.&#xA;     *&#xA;     * @see #setSourceSubsampling&#xA;     * @see #getSubsamplingXOffset&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setSourceBands">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sourceBands">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the indices of the source bands to be used.  Duplicate&#xA;     * indices are not allowed.&#xA;     *&#xA;     * &lt;p> A &lt;code>null&lt;/code> value indicates that all source bands&#xA;     * will be used.&#xA;     * &#xA;     * &lt;p> At the time of reading, an&#xA;     * &lt;code>IllegalArgumentException&lt;/code> will be thrown by the&#xA;     * reader or writer if a value larger than the largest available&#xA;     * source band index has been specified or if the number of source&#xA;     * bands and destination bands to be used differ.  The&#xA;     * &lt;code>ImageReader.checkReadParamBandSettings&lt;/code> method may&#xA;     * be used to automate this test.&#xA;     *&#xA;     * &lt;p> Semantically, a copy is made of the array; changes to the&#xA;     * array contents subsequent to this call have no effect on&#xA;     * this &lt;code>IIOParam&lt;/code>.&#xA;     *&#xA;     * @param sourceBands an array of integer band indices to be&#xA;     * used.&#xA;     *&#xA;     * @exception IllegalArgumentException if &lt;code>sourceBands&lt;/code>&#xA;     * contains a negative or duplicate value.&#xA;     *&#xA;     * @see #getSourceBands&#xA;     * @see ImageReadParam#setDestinationBands&#xA;     * @see ImageReader#checkReadParamBandSettings&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:NullLiteral"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="numBands">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
                <next xsi:type="references:IdentifierReference"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="band">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@elseStatement/@statements.1/@init"/>
                    </arraySelectors>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Throw">
                    <throwable xsi:type="instantiations:NewConstructorCall">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <arguments xsi:type="references:StringReference" value="Band value &lt; 0!"/>
                    </throwable>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@elseStatement/@statements.1/@statement/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ForLoop">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:Throw">
                        <throwable xsi:type="instantiations:NewConstructorCall">
                          <typeReference xsi:type="types:NamespaceClassifierReference">
                            <classifierReferences>
                              <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                            </classifierReferences>
                          </typeReference>
                          <arguments xsi:type="references:StringReference" value="Duplicate band value!"/>
                        </throwable>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@elseStatement/@statements.1/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@elseStatement/@statements.1/@statement/@statements.2/@init"/>
                        </arraySelectors>
                      </children>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@elseStatement/@statements.1/@statement/@statements.2/@init"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@elseStatement/@statements.0/@variable"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
                <init xsi:type="variables:LocalVariable" name="j">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@elseStatement/@statements.1/@init"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </initialValue>
                </init>
                <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@elseStatement/@statements.1/@statement/@statements.2/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </updates>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@elseStatement/@statements.1/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@elseStatement/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@elseStatement/@statements.1/@init"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Int"/>
                <arrayDimensionsBefore/>
                <child xsi:type="expressions:NestedExpression">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../java/lang/Object.class.xmi#//@classifiers.0/@members.5"/>
                    </next>
                  </expression>
                </child>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSourceBands">
      <typeReference xsi:type="types:Int"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the set of of source bands to be used. The returned&#xA;     * value is that set by the most recent call to&#xA;     * &lt;code>setSourceBands&lt;/code>, or &lt;code>null&lt;/code> if there have&#xA;     * been no calls to &lt;code>setSourceBands&lt;/code>.&#xA;     *&#xA;     * &lt;p> Semantically, the array returned is a copy; changes to&#xA;     * array contents subsequent to this call have no effect on this&#xA;     * &lt;code>IIOParam&lt;/code>.&#xA;     *&#xA;     * @return the set of source bands to be used, or&#xA;     * &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @see #setSourceBands&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:NullLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Int"/>
          <arrayDimensionsBefore/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../java/lang/Object.class.xmi#//@classifiers.0/@members.5"/>
              </next>
            </expression>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setDestinationType">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="destinationType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageTypeSpecifier.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the desired image type for the destination image, using an&#xA;     * &lt;code>ImageTypeSpecifier&lt;/code>.&#xA;     *&#xA;     * &lt;p> When reading, if the layout of the destination has been set&#xA;     * using this method, each call to an &lt;code>ImageReader&lt;/code>&#xA;     * &lt;code>read&lt;/code> method will return a new&#xA;     * &lt;code>BufferedImage&lt;/code> using the format specified by the&#xA;     * supplied type specifier.  As a side effect, any destination&#xA;     * &lt;code>BufferedImage&lt;/code> set by&#xA;     * &lt;code>ImageReadParam.setDestination(BufferedImage)&lt;/code> will&#xA;     * no longer be set as the destination.  In other words, this&#xA;     * method may be thought of as calling&#xA;     * &lt;code>setDestination((BufferedImage)null)&lt;/code>.&#xA;     *&#xA;     * &lt;p> When writing, the destination type maybe used to determine&#xA;     * the color type of the image.  The &lt;code>SampleModel&lt;/code>&#xA;     * information will be ignored, and may be &lt;code>null&lt;/code>.  For&#xA;     * example, a 4-banded image could represent either CMYK or RGBA&#xA;     * data.  If a destination type is set, its&#xA;     * &lt;code>ColorModel&lt;/code> will override any&#xA;     * &lt;code>ColorModel&lt;/code> on the image itself.  This is crucial&#xA;     * when &lt;code>setSourceBands&lt;/code> is used since the image's&#xA;     * &lt;code>ColorModel&lt;/code> will refer to the entire image rather&#xA;     * than to the subset of bands being written.&#xA;     *&#xA;     * @param destinationType the &lt;code>ImageTypeSpecifier&lt;/code> to&#xA;     * be used to determine the destination layout and color type.&#xA;     *&#xA;     * @see #getDestinationType&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDestinationType">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ImageTypeSpecifier.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the type of image to be returned by the read, if one&#xA;     * was set by a call to&#xA;     * &lt;code>setDestination(ImageTypeSpecifier)&lt;/code>, as an&#xA;     * &lt;code>ImageTypeSpecifier&lt;/code>.  If none was set,&#xA;     * &lt;code>null&lt;/code> is returned.&#xA;     *&#xA;     * @return an &lt;code>ImageTypeSpecifier&lt;/code> describing the&#xA;     * destination type, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @see #setDestinationType&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setDestinationOffset">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="destinationOffset">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/awt/Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Specifies the offset in the destination image at which future&#xA;     * decoded pixels are to be placed, when reading, or where a&#xA;     * region will be written, when writing.&#xA;     *&#xA;     * &lt;p> When reading, the region to be written within the&#xA;     * destination &lt;code>BufferedImage&lt;/code> will start at this&#xA;     * offset and have a width and height determined by the source&#xA;     * region of interest, the subsampling parameters, and the&#xA;     * destination bounds.&#xA;     *&#xA;     * &lt;p> Normal writes are not affected by this method, only writes&#xA;     * performed using &lt;code>ImageWriter.replacePixels&lt;/code>.  For&#xA;     * such writes, the offset specified is within the output stream&#xA;     * image whose pixels are being modified.&#xA;     *&#xA;     * &lt;p> There is no &lt;code>unsetDestinationOffset&lt;/code> method;&#xA;     * simply call &lt;code>setDestinationOffset(new Point(0, 0))&lt;/code> to&#xA;     * restore default values.&#xA;     *&#xA;     * @param destinationOffset the offset in the destination, as a&#xA;     * &lt;code>Point&lt;/code>.&#xA;     *&#xA;     * @exception IllegalArgumentException if&#xA;     * &lt;code>destinationOffset&lt;/code> is &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @see #getDestinationOffset&#xA;     * @see ImageWriter#replacePixels&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="destinationOffset == null!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../java/awt/Point.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../java/awt/geom/Point2D.class.xmi#//@classifiers.0/@members.11"/>
              </next>
            </child>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDestinationOffset">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/awt/Point.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the offset in the destination image at which pixels are&#xA;     * to be placed.&#xA;     *&#xA;     * &lt;p> If &lt;code>setDestinationOffsets&lt;/code> has not been called,&#xA;     * a &lt;code>Point&lt;/code> with zero X and Y values is returned&#xA;     * (which is the correct value).&#xA;     *&#xA;     * @return the destination offset as a &lt;code>Point&lt;/code>.&#xA;     *&#xA;     * @see #setDestinationOffset&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../java/awt/Point.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../java/awt/geom/Point2D.class.xmi#//@classifiers.0/@members.11"/>
            </next>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setController">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="controller">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="IIOParamController.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the &lt;code>IIOParamController&lt;/code> to be used&#xA;     * to provide settings for this &lt;code>IIOParam&lt;/code>&#xA;     * object when the &lt;code>activateController&lt;/code> method&#xA;     * is called, overriding any default controller.  If the&#xA;     * argument is &lt;code>null&lt;/code>, no controller will be&#xA;     * used, including any default.  To restore the default, use&#xA;     * &lt;code>setController(getDefaultController())&lt;/code>.&#xA;     *&#xA;     * @param controller An appropriate &#xA;     * &lt;code>IIOParamController&lt;/code>, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @see IIOParamController&#xA;     * @see #getController&#xA;     * @see #getDefaultController&#xA;     * @see #hasController&#xA;     * @see #activateController()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getController">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="IIOParamController.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns whatever &lt;code>IIOParamController&lt;/code> is currently&#xA;     * installed.  This could be the default if there is one, &#xA;     * &lt;code>null&lt;/code>, or the argument of the most recent call&#xA;     * to &lt;code>setController&lt;/code>.&#xA;     *&#xA;     * @return the currently installed&#xA;     * &lt;code>IIOParamController&lt;/code>, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @see IIOParamController&#xA;     * @see #setController&#xA;     * @see #getDefaultController&#xA;     * @see #hasController&#xA;     * @see #activateController()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDefaultController">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="IIOParamController.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the default &lt;code>IIOParamController&lt;/code>, if there&#xA;     * is one, regardless of the currently installed controller.  If&#xA;     * there is no default controller, returns &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @return the default &lt;code>IIOParamController&lt;/code>, or&#xA;     * &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @see IIOParamController&#xA;     * @see #setController(IIOParamController)&#xA;     * @see #getController&#xA;     * @see #hasController&#xA;     * @see #activateController()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hasController">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if there is a controller installed&#xA;     * for this &lt;code>IIOParam&lt;/code> object.  This will return&#xA;     * &lt;code>true&lt;/code> if &lt;code>getController&lt;/code> would not&#xA;     * return &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if a controller is installed.&#xA;     *&#xA;     * @see IIOParamController&#xA;     * @see #setController(IIOParamController)&#xA;     * @see #getController&#xA;     * @see #getDefaultController&#xA;     * @see #activateController()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
            <children xsi:type="literals:NullLiteral"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="activateController">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Activates the installed &lt;code>IIOParamController&lt;/code> for&#xA;     * this &lt;code>IIOParam&lt;/code> object and returns the resulting&#xA;     * value.  When this method returns &lt;code>true&lt;/code>, all values&#xA;     * for this &lt;code>IIOParam&lt;/code> object will be ready for the&#xA;     * next read or write operation.  If &lt;code>false&lt;/code> is&#xA;     * returned, no settings in this object will have been disturbed&#xA;     * (&lt;i>i.e.&lt;/i>, the user canceled the operation).&#xA;     *&#xA;     * &lt;p> Ordinarily, the controller will be a GUI providing a user&#xA;     * interface for a subclass of &lt;code>IIOParam&lt;/code> for a&#xA;     * particular plug-in.  Controllers need not be GUIs, however.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if the controller completed normally.&#xA;     *&#xA;     * @exception IllegalStateException if there is no controller&#xA;     * currently installed.&#xA;     *&#xA;     * @see IIOParamController&#xA;     * @see #setController(IIOParamController)&#xA;     * @see #getController&#xA;     * @see #getDefaultController&#xA;     * @see #hasController&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="hasController() == false!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.27"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="IIOParamController.class.xmi#//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A superclass of all classes describing how streams should be &#xA; * decoded or encoded.  This class contains all the variables and&#xA; * methods that are shared by &lt;code>ImageReadParam&lt;/code> and&#xA; * &lt;code>ImageWriteParam&lt;/code>.&#xA; * &#xA; * &lt;p> This class provides mechanisms to specify a source region and a&#xA; * destination region.  When reading, the source is the stream and &#xA; * the in-memory image is the destination.  When writing, these are&#xA; * reversed.  In the case of writing, destination regions may be used&#xA; * only with a writer that supports pixel replacement.&#xA; * &lt;p>&#xA; * Decimation subsampling may be specified for both readers&#xA; * and writers, using a movable subsampling grid.&#xA; * &lt;p>&#xA; * Subsets of the source and destination bands may be selected.&#xA; *&#xA; * @version 0.5&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
