<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="ImageOutputStream.java">
  <comments>/*&#xA; * @(#)ImageOutputStream.java&#x9;1.24 04/05/13&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>imageio</namespaces>
  <namespaces>stream</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../java/io/DataOutput.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/io/UTFDataFormatException.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="ImageOutputStream">
    <members xsi:type="members:InterfaceMethod" name="write">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a single byte to the stream at the current position.&#xA;     * The 24 high-order bits of &lt;code>b&lt;/code> are ignored.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.  Implementers can use the &#xA;     * {@link ImageOutputStreamImpl#flushBits &lt;code>flushBits&lt;/code>}&#xA;     * method of {@link ImageOutputStreamImpl &#xA;     * &lt;code>ImageOutputStreamImpl&lt;/code>} to guarantee this.&#xA;     *&#xA;     * @param b an &lt;code>int&lt;/code> whose lower 8 bits are to be&#xA;     * written.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="write">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a sequence of bytes to the stream at the current&#xA;     * position.  If &lt;code>b.length&lt;/code> is 0, nothing is written.&#xA;     * The byte &lt;code>b[0]&lt;/code> is written first, then the byte&#xA;     * &lt;code>b[1]&lt;/code>, and so on.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param b an array of &lt;code>byte&lt;/code>s to be written.&#xA;     *&#xA;     * @exception NullPointerException if &lt;code>b&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="write">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a sequence of bytes to the stream at the current&#xA;     * position.  If &lt;code>len&lt;/code> is 0, nothing is written.&#xA;     * The byte &lt;code>b[off]&lt;/code> is written first, then the byte&#xA;     * &lt;code>b[off + 1]&lt;/code>, and so on.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.  Implementers can use the &#xA;     * {@link ImageOutputStreamImpl#flushBits &lt;code>flushBits&lt;/code>}&#xA;     * method of {@link ImageOutputStreamImpl &#xA;     * &lt;code>ImageOutputStreamImpl&lt;/code>} to guarantee this.&#xA;     *&#xA;     * @param b an array of &lt;code>byte&lt;/code>s to be written.&#xA;     * @param off the start offset in the data.&#xA;     * @param len the number of &lt;code>byte&lt;/code>s to write.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>b.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>b&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeBoolean">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a &lt;code>boolean&lt;/code> value to the stream.  If&#xA;     * &lt;code>v&lt;/code> is true, the value &lt;code>(byte)1&lt;/code> is&#xA;     * written; if &lt;code>v&lt;/code> is false, the value&#xA;     * &lt;code>(byte)0&lt;/code> is written.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param v the &lt;code>boolean&lt;/code> to be written.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeByte">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes the 8 low-order bits of &lt;code>v&lt;/code> to the&#xA;     * stream. The 24 high-order bits of &lt;code>v&lt;/code> are ignored.&#xA;     * (This means that &lt;code>writeByte&lt;/code> does exactly the same&#xA;     * thing as &lt;code>write&lt;/code> for an integer argument.)&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param v an &lt;code>int&lt;/code> containing the byte value to be&#xA;     * written.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeShort">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes the 16 low-order bits of &lt;code>v&lt;/code> to the&#xA;     * stream. The 16 high-order bits of &lt;code>v&lt;/code> are ignored.&#xA;     * If the stream uses network byte order, the bytes written, in&#xA;     * order, will be:&#xA;     *&#xA;     * &lt;pre>&#xA;     * (byte)((v &amp;gt;&amp;gt; 8) &amp;amp; 0xff)&#xA;     * (byte)(v &amp;amp; 0xff)&#xA;     * &lt;/pre>&#xA;     *&#xA;     * Otherwise, the bytes written will be:&#xA;     *&#xA;     * &lt;pre>&#xA;     * (byte)(v &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 8) &amp;amp; 0xff)&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param v an &lt;code>int&lt;/code> containing the short value to be&#xA;     * written.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeChar">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * This method is a synonym for &#xA;     * {@link #writeShort &lt;code>writeShort&lt;/code>}.&#xA;     *&#xA;     * @param v an &lt;code>int&lt;/code> containing the char (unsigned&#xA;     * short) value to be written.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     *&#xA;     * @see #writeShort(int)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeInt">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes the 32 bits of &lt;code>v&lt;/code> to the stream.  If the&#xA;     * stream uses network byte order, the bytes written, in order,&#xA;     * will be:&#xA;     *&#xA;     * &lt;pre>&#xA;     * (byte)((v &amp;gt;&amp;gt; 24) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 16) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 8) &amp;amp; 0xff)&#xA;     * (byte)(v &amp;amp; 0xff)&#xA;     * &lt;/pre>&#xA;     *&#xA;     * Otheriwse, the bytes written will be:&#xA;     *&#xA;     * &lt;pre>&#xA;     * (byte)(v &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 8) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 16) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 24) &amp;amp; 0xff)&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param v an &lt;code>int&lt;/code> containing the value to be&#xA;     * written.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeLong">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes the 64 bits of &lt;code>v&lt;/code> to the stream.  If the&#xA;     * stream uses network byte order, the bytes written, in order,&#xA;     * will be:&#xA;     *&#xA;     * &lt;pre>&#xA;     * (byte)((v &amp;gt;&amp;gt; 56) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 48) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 40) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 32) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 24) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 16) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 8) &amp;amp; 0xff)&#xA;     * (byte)(v &amp;amp; 0xff)&#xA;     * &lt;/pre>&#xA;     *&#xA;     * Otherwise, the bytes written will be:&#xA;     *&#xA;     * &lt;pre>&#xA;     * (byte)(v &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 8) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 16) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 24) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 32) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 40) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 48) &amp;amp; 0xff)&#xA;     * (byte)((v &amp;gt;&amp;gt; 56) &amp;amp; 0xff)&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param v a &lt;code>long&lt;/code> containing the value to be&#xA;     * written.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeFloat">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a &lt;code>float&lt;/code> value, which is comprised of four&#xA;     * bytes, to the output stream. It does this as if it first&#xA;     * converts this &lt;code>float&lt;/code> value to an &lt;code>int&lt;/code>&#xA;     * in exactly the manner of the &lt;code>Float.floatToIntBits&lt;/code>&#xA;     * method and then writes the int value in exactly the manner of&#xA;     * the &lt;code>writeInt&lt;/code> method.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param v a &lt;code>float&lt;/code> containing the value to be&#xA;     * written.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeDouble">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a &lt;code>double&lt;/code> value, which is comprised of four&#xA;     * bytes, to the output stream. It does this as if it first&#xA;     * converts this &lt;code>double&lt;/code> value to an &lt;code>long&lt;/code>&#xA;     * in exactly the manner of the&#xA;     * &lt;code>Double.doubleToLongBits&lt;/code> method and then writes the&#xA;     * long value in exactly the manner of the &lt;code>writeLong&lt;/code>&#xA;     * method.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param v a &lt;code>double&lt;/code> containing the value to be&#xA;     * written.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeBytes">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a string to the output stream. For every character in&#xA;     * the string &lt;code>s&lt;/code>, taken in order, one byte is written&#xA;     * to the output stream. If &lt;code>s&lt;/code> is &lt;code>null&lt;/code>, a&#xA;     * &lt;code>NullPointerException&lt;/code> is thrown.&#xA;     *&#xA;     * &lt;p> If &lt;code>s.length&lt;/code> is zero, then no bytes are&#xA;     * written. Otherwise, the character &lt;code>s[0]&lt;/code> is written&#xA;     * first, then &lt;code>s[1]&lt;/code>, and so on; the last character&#xA;     * written is &lt;code>s[s.length-1]&lt;/code>. For each character, one&#xA;     * byte is written, the low-order byte, in exactly the manner of&#xA;     * the &lt;code>writeByte&lt;/code> method. The high-order eight bits of&#xA;     * each character in the string are ignored.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param s a &lt;code>String&lt;/code> containing the value to be&#xA;     * written.&#xA;     *&#xA;     * @exception NullPointerException if &lt;code>s&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeChars">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a string to the output stream. For every character in&#xA;     * the string &lt;code>s&lt;/code>, taken in order, two bytes are&#xA;     * written to the output stream, ordered according to the current&#xA;     * byte order setting.  If network byte order is being used, the&#xA;     * high-order byte is written first; the order is reversed&#xA;     * otherwise.  If &lt;code>s&lt;/code> is &lt;code>null&lt;/code>, a&#xA;     * &lt;code>NullPointerException&lt;/code> is thrown.&#xA;     *&#xA;     * &lt;p> If &lt;code>s.length&lt;/code> is zero, then no bytes are&#xA;     * written. Otherwise, the character &lt;code>s[0]&lt;/code> is written&#xA;     * first, then &lt;code>s[1]&lt;/code>, and so on; the last character&#xA;     * written is &lt;code>s[s.length-1]&lt;/code>.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param s a &lt;code>String&lt;/code> containing the value to be&#xA;     * written.&#xA;     *&#xA;     * @exception NullPointerException if &lt;code>s&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeUTF">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes two bytes of length information to the output stream in&#xA;     * network byte order, followed by the&#xA;     * &lt;a href=&quot;../../../java/io/DataInput.html#modified-utf-8&quot;>modified&#xA;     * UTF-8&lt;/a>&#xA;     * representation of every character in the string &lt;code>s&lt;/code>.&#xA;     * If &lt;code>s&lt;/code> is &lt;code>null&lt;/code>, a&#xA;     * &lt;code>NullPointerException&lt;/code> is thrown.  Each character in&#xA;     * the string &lt;code>s&lt;/code> is converted to a group of one, two,&#xA;     * or three bytes, depending on the value of the character.&#xA;     *&#xA;     * &lt;p> If a character &lt;code>c&lt;/code> is in the range&#xA;     * &lt;code>&amp;#92;u0001&lt;/code> through &lt;code>&amp;#92;u007f&lt;/code>, it is&#xA;     * represented by one byte:&#xA;     *&#xA;     * &lt;p>&lt;pre>&#xA;     * (byte)c&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;p> If a character &lt;code>c&lt;/code> is &lt;code>&amp;#92;u0000&lt;/code> or&#xA;     * is in the range &lt;code>&amp;#92;u0080&lt;/code> through&#xA;     * &lt;code>&amp;#92;u07ff&lt;/code>, then it is represented by two bytes,&#xA;     * to be written in the order shown:&#xA;     *&#xA;     * &lt;p> &lt;pre>&lt;code>&#xA;     * (byte)(0xc0 | (0x1f &amp;amp; (c &amp;gt;&amp;gt; 6)))&#xA;     * (byte)(0x80 | (0x3f &amp;amp; c))&#xA;     * &lt;/code>&lt;/pre>&#xA;     *&#xA;     * &lt;p> If a character &lt;code>c&lt;/code> is in the range&#xA;     * &lt;code>&amp;#92;u0800&lt;/code> through &lt;code>uffff&lt;/code>, then it is&#xA;     * represented by three bytes, to be written in the order shown:&#xA;     *&#xA;     * &lt;p> &lt;pre>&lt;code>&#xA;     * (byte)(0xe0 | (0x0f &amp;amp; (c &amp;gt;&amp;gt; 12)))&#xA;     * (byte)(0x80 | (0x3f &amp;amp; (c &amp;gt;&amp;gt; 6)))&#xA;     * (byte)(0x80 | (0x3f &amp;amp; c))&#xA;     * &lt;/code>&lt;/pre>&#xA;     *&#xA;     * &lt;p> First, the total number of bytes needed to represent all&#xA;     * the characters of &lt;code>s&lt;/code> is calculated. If this number&#xA;     * is larger than &lt;code>65535&lt;/code>, then a&#xA;     * &lt;code>UTFDataFormatException&lt;/code> is thrown. Otherwise, this&#xA;     * length is written to the output stream in exactly the manner of&#xA;     * the &lt;code>writeShort&lt;/code> method; after this, the one-, two-,&#xA;     * or three-byte representation of each character in the string&#xA;     * &lt;code>s&lt;/code> is written.&#xA;     *&#xA;     * &lt;p> The current byte order setting is ignored.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * &lt;p>&lt;strong>Note:&lt;/strong> This method should not be used in&#xA;     * the  implementation of image formats that use standard UTF-8,&#xA;     * because  the modified UTF-8 used here is incompatible with&#xA;     * standard UTF-8.&#xA;     *&#xA;     * @param s a &lt;code>String&lt;/code> containing the value to be&#xA;     * written.&#xA;     *&#xA;     * @exception NullPointerException if &lt;code>s&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception UTFDataFormatException if the modified UTF-8&#xA;     * representation of &lt;code>s&lt;/code> requires more than 65536 bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeShorts">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a sequence of shorts to the stream at the current&#xA;     * position.  If &lt;code>len&lt;/code> is 0, nothing is written.&#xA;     * The short &lt;code>s[off]&lt;/code> is written first, then the short&#xA;     * &lt;code>s[off + 1]&lt;/code>, and so on.  The byte order of the&#xA;     * stream is used to determine the order in which the individual&#xA;     * bytes are written.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param s an array of &lt;code>short&lt;/code>s to be written.&#xA;     * @param off the start offset in the data.&#xA;     * @param len the number of &lt;code>short&lt;/code>s to write.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>s.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>s&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:Short"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeChars">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a sequence of chars to the stream at the current&#xA;     * position.  If &lt;code>len&lt;/code> is 0, nothing is written.&#xA;     * The char &lt;code>c[off]&lt;/code> is written first, then the char&#xA;     * &lt;code>c[off + 1]&lt;/code>, and so on.  The byte order of the&#xA;     * stream is used to determine the order in which the individual&#xA;     * bytes are written.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param c an array of &lt;code>char&lt;/code>s to be written.&#xA;     * @param off the start offset in the data.&#xA;     * @param len the number of &lt;code>char&lt;/code>s to write.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>c.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>c&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeInts">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a sequence of ints to the stream at the current&#xA;     * position.  If &lt;code>len&lt;/code> is 0, nothing is written.&#xA;     * The int &lt;code>i[off]&lt;/code> is written first, then the int&#xA;     * &lt;code>i[off + 1]&lt;/code>, and so on.  The byte order of the&#xA;     * stream is used to determine the order in which the individual&#xA;     * bytes are written.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param i an array of &lt;code>int&lt;/code>s to be written.&#xA;     * @param off the start offset in the data.&#xA;     * @param len the number of &lt;code>int&lt;/code>s to write.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>i.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>i&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeLongs">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a sequence of longs to the stream at the current&#xA;     * position.  If &lt;code>len&lt;/code> is 0, nothing is written.&#xA;     * The long &lt;code>l[off]&lt;/code> is written first, then the long&#xA;     * &lt;code>l[off + 1]&lt;/code>, and so on.  The byte order of the&#xA;     * stream is used to determine the order in which the individual&#xA;     * bytes are written.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param l an array of &lt;code>long&lt;/code>s to be written.&#xA;     * @param off the start offset in the data.&#xA;     * @param len the number of &lt;code>long&lt;/code>s to write.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>l.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>l&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:Long"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeFloats">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a sequence of floats to the stream at the current&#xA;     * position.  If &lt;code>len&lt;/code> is 0, nothing is written.&#xA;     * The float &lt;code>f[off]&lt;/code> is written first, then the float&#xA;     * &lt;code>f[off + 1]&lt;/code>, and so on.  The byte order of the&#xA;     * stream is used to determine the order in which the individual&#xA;     * bytes are written.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param f an array of &lt;code>float&lt;/code>s to be written.&#xA;     * @param off the start offset in the data.&#xA;     * @param len the number of &lt;code>float&lt;/code>s to write.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>f.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>f&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeDoubles">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a sequence of doubles to the stream at the current&#xA;     * position.  If &lt;code>len&lt;/code> is 0, nothing is written.&#xA;     * The double &lt;code>d[off]&lt;/code> is written first, then the double&#xA;     * &lt;code>d[off + 1]&lt;/code>, and so on.  The byte order of the&#xA;     * stream is used to determine the order in which the individual&#xA;     * bytes are written.&#xA;     *&#xA;     * &lt;p> If the bit offset within the stream is non-zero, the&#xA;     * remainder of the current byte is padded with 0s&#xA;     * and written out first.  The bit offset will be 0 after the&#xA;     * write.&#xA;     *&#xA;     * @param d an array of &lt;code>doubles&lt;/code>s to be written.&#xA;     * @param off the start offset in the data.&#xA;     * @param len the number of &lt;code>double&lt;/code>s to write.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>d.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>d&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeBit">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a single bit, given by the least significant bit of the&#xA;     * argument, to the stream at the current bit offset within the&#xA;     * current byte position.  The upper 31 bits of the argument are&#xA;     * ignored.  The given bit replaces the previous bit at that&#xA;     * position.  The bit offset is advanced by one and reduced modulo&#xA;     * 8.&#xA;     *&#xA;     * &lt;p> If any bits of a particular byte have never been set&#xA;     * at the time the byte is flushed to the destination, those&#xA;     * bits will be set to 0 automatically.&#xA;     *&#xA;     * @param bit an &lt;code>int&lt;/code> whose least significant bit&#xA;     * is to be written to the stream.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bit">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeBits">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Writes a sequence of bits, given by the &lt;code>numBits&lt;/code>&#xA;     * least significant bits of the &lt;code>bits&lt;/code> argument in&#xA;     * left-to-right order, to the stream at the current bit offset&#xA;     * within the current byte position.  The upper &lt;code>64 -&#xA;     * numBits&lt;/code> bits of the argument are ignored.  The bit&#xA;     * offset is advanced by &lt;code>numBits&lt;/code> and reduced modulo&#xA;     * 8.  Note that a bit offset of 0 always indicates the&#xA;     * most-significant bit of the byte, and bytes of bits are written&#xA;     * out in sequence as they are encountered.  Thus bit writes are&#xA;     * always effectively in network byte order.  The actual stream&#xA;     * byte order setting is ignored.&#xA;     *&#xA;     * &lt;p> Bit data may be accumulated in memory indefinitely, until&#xA;     * &lt;code>flushBefore&lt;/code> is called.  At that time, all bit data&#xA;     * prior to the flushed position will be written.&#xA;     *&#xA;     * &lt;p> If any bits of a particular byte have never been set&#xA;     * at the time the byte is flushed to the destination, those&#xA;     * bits will be set to 0 automatically.&#xA;     *&#xA;     * @param bits a &lt;code>long&lt;/code> containing the bits to be&#xA;     * written, starting with the bit in position &lt;code>numBits -&#xA;     * 1&lt;/code> down to the least significant bit.&#xA;     * &#xA;     * @param numBits an &lt;code>int&lt;/code> between 0 and 64, inclusive.&#xA;     *&#xA;     * @exception IllegalArgumentException if &lt;code>numBits&lt;/code> is&#xA;     * not between 0 and 64, inclusive.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bits">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="numBits">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="flushBefore">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Flushes all data prior to the given position to the underlying&#xA;     * destination, such as an &lt;code>OutputStream&lt;/code> or&#xA;     * &lt;code>File&lt;/code>.  Attempting to seek to the flushed portion&#xA;     * of the stream will result in an&#xA;     * &lt;code>IndexOutOfBoundsException&lt;/code>.&#xA;     *&#xA;     * @param pos a &lt;code>long&lt;/code> containing the length of the&#xA;     * file prefix that may be flushed to the destination.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>pos&lt;/code> lies&#xA;     * in the flushed portion of the stream or past the current stream&#xA;     * position.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A seekable output stream interface for use by&#xA; * &lt;code>ImageWriter&lt;/code>s.  Various output destinations, such as&#xA; * &lt;code>OutputStream&lt;/code>s and &lt;code>File&lt;/code>s, as well as&#xA; * future fast I/O destinations may be &quot;wrapped&quot; by a suitable&#xA; * implementation of this interface for use by the Image I/O API.&#xA; *&#xA; * &lt;p> Unlike a standard &lt;code>OutputStream&lt;/code>, ImageOutputStream&#xA; * extends its counterpart, &lt;code>ImageInputStream&lt;/code>.  Thus it is&#xA; * possible to read from the stream as it is being written.  The same&#xA; * seek and flush positions apply to both reading and writing, although&#xA; * the semantics for dealing with a non-zero bit offset before a byte-aligned&#xA; * write are necessarily different from the semantics for dealing with&#xA; * a non-zero bit offset before a byte-aligned read.  When reading bytes, &#xA; * any bit offset is set to 0 before the read; when writing bytes, a&#xA; * non-zero bit offset causes the remaining bits in the byte to be written&#xA; * as 0s.  The byte-aligned write then starts at the next byte position.&#xA; *&#xA; * @see ImageInputStream&#xA; *&#xA; * @version 0.5&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="ImageInputStream.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../../java/io/DataOutput.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
