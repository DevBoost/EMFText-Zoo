<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="ImageInputStream.java">
  <comments>/*&#xA; * @(#)ImageInputStream.java&#x9;1.47 04/05/13&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>imageio</namespaces>
  <namespaces>stream</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../java/io/DataInput.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/io/EOFException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/io/UTFDataFormatException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/nio/ByteOrder.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="ImageInputStream">
    <members xsi:type="members:InterfaceMethod" name="setByteOrder">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the desired byte order for future reads of data values&#xA;     * from this stream.  For example, the sequence of bytes '0x01&#xA;     * 0x02 0x03 0x04' if read as a 4-byte integer would have the&#xA;     * value '0x01020304' using network byte order and the value&#xA;     * '0x04030201' under the reverse byte order.&#xA;     *&#xA;     * &lt;p> The enumeration class &lt;code>java.nio.ByteOrder&lt;/code> is&#xA;     * used to specify the byte order.  A value of&#xA;     * &lt;code>ByteOrder.BIG_ENDIAN&lt;/code> specifies so-called&#xA;     * big-endian or network byte order, in which the high-order byte&#xA;     * comes first.  Motorola and Sparc processors store data in this&#xA;     * format, while Intel processors store data in the reverse&#xA;     * &lt;code>ByteOrder.LITTLE_ENDIAN&lt;/code> order.&#xA;     *&#xA;     * &lt;p> The byte order has no effect on the results returned from&#xA;     * the &lt;code>readBits&lt;/code> method (or the value written by&#xA;     * &lt;code>ImageOutputStream.writeBits&lt;/code>).&#xA;     *&#xA;     * @param byteOrder one of &lt;code>ByteOrder.BIG_ENDIAN&lt;/code> or&#xA;     * &lt;code>java.nio.ByteOrder.LITTLE_ENDIAN&lt;/code>, indicating whether&#xA;     * network byte order or its reverse will be used for future&#xA;     * reads.&#xA;     *&#xA;     * @see java.nio.ByteOrder&#xA;     * @see #getByteOrder&#xA;     * @see #readBits(int)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="byteOrder">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/nio/ByteOrder.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getByteOrder">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns the byte order with which data values will be read from&#xA;     * this stream as an instance of the&#xA;     * &lt;code>java.nio.ByteOrder&lt;/code> enumeration.&#xA;     *&#xA;     * @return one of &lt;code>ByteOrder.BIG_ENDIAN&lt;/code> or&#xA;     * &lt;code>ByteOrder.LITTLE_ENDIAN&lt;/code>, indicating which byte&#xA;     * order is being used.&#xA;     *&#xA;     * @see java.nio.ByteOrder&#xA;     * @see #setByteOrder&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/nio/ByteOrder.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="read">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Reads a single byte from the stream and returns it as an&#xA;     * integer between 0 and 255.  If the end of the stream is&#xA;     * reached, -1 is returned.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @return a byte value from the stream, as an int, or -1 to&#xA;     * indicate EOF.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="read">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Reads up to &lt;code>b.length&lt;/code> bytes from the stream, and&#xA;     * stores them into &lt;code>b&lt;/code> starting at index 0.  The&#xA;     * number of bytes read is returned.  If no bytes can be read&#xA;     * because the end of the stream has been reached, -1 is returned.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @param b an array of bytes to be written to.&#xA;     *&#xA;     * @return the number of bytes actually read, or &lt;code>-1&lt;/code>&#xA;     * to indicate EOF.&#xA;     *&#xA;     * @exception NullPointerException if &lt;code>b&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="read">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Reads up to &lt;code>len&lt;/code> bytes from the stream, and stores&#xA;     * them into &lt;code>b&lt;/code> starting at index &lt;code>off&lt;/code>.&#xA;     * The number of bytes read is returned.  If no bytes can be read&#xA;     * because the end of the stream has been reached, &lt;code>-1&lt;/code>&#xA;     * is returned.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @param b an array of bytes to be written to.&#xA;     * @param off the starting position within &lt;code>b&lt;/code> to write to.&#xA;     * @param len the maximum number of &lt;code>byte&lt;/code>s to read.&#xA;     *&#xA;     * @return the number of bytes actually read, or &lt;code>-1&lt;/code>&#xA;     * to indicate EOF.&#xA;     *&#xA;     * @exception NullPointerException if &lt;code>b&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>b.length&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readBytes">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Reads up to &lt;code>len&lt;/code> bytes from the stream, and&#xA;     * modifies the supplied &lt;code>IIOByteBuffer&lt;/code> to indicate&#xA;     * the byte array, offset, and length where the data may be found.&#xA;     * The caller should not attempt to modify the data found in the&#xA;     * &lt;code>IIOByteBuffer&lt;/code>.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @param buf an IIOByteBuffer object to be modified.&#xA;     * @param len the maximum number of &lt;code>byte&lt;/code>s to read.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>len&lt;/code> is&#xA;     * negative.&#xA;     * @exception NullPointerException if &lt;code>buf&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="IIOByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readBoolean">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Reads a byte from the stream and returns a &lt;code>boolean&lt;/code>&#xA;     * value of &lt;code>true&lt;/code> if it is nonzero, &lt;code>false&lt;/code>&#xA;     * if it is zero.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @return a boolean value from the stream.&#xA;     *&#xA;     * @exception EOFException if the end of the stream is reached.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readByte">
      <typeReference xsi:type="types:Byte">
        <comments>/**&#xA;     * Reads a byte from the stream and returns it as a&#xA;     * &lt;code>byte&lt;/code> value.  Byte values between &lt;code>0x00&lt;/code>&#xA;     * and &lt;code>0x7f&lt;/code> represent integer values between&#xA;     * &lt;code>0&lt;/code> and &lt;code>127&lt;/code>.  Values between&#xA;     * &lt;code>0x80&lt;/code> and &lt;code>0xff&lt;/code> represent negative&#xA;     * values from &lt;code>-128&lt;/code> to &lt;code>/1&lt;/code>.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @return a signed byte value from the stream.&#xA;     *&#xA;     * @exception EOFException if the end of the stream is reached.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readUnsignedByte">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Reads a byte from the stream, and (conceptually) converts it to&#xA;     * an int, masks it with &lt;code>0xff&lt;/code> in order to strip off&#xA;     * any sign-extension bits, and returns it as a &lt;code>byte&lt;/code>&#xA;     * value.&#xA;     *&#xA;     * &lt;p> Thus, byte values between &lt;code>0x00&lt;/code> and&#xA;     * &lt;code>0x7f&lt;/code> are simply returned as integer values between&#xA;     * &lt;code>0&lt;/code> and &lt;code>127&lt;/code>.  Values between&#xA;     * &lt;code>0x80&lt;/code> and &lt;code>0xff&lt;/code>, which normally&#xA;     * represent negative &lt;code>byte&lt;/code>values, will be mapped into&#xA;     * positive integers between &lt;code>128&lt;/code> and&#xA;     * &lt;code>255&lt;/code>.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @return an unsigned byte value from the stream.&#xA;     *&#xA;     * @exception EOFException if the end of the stream is reached.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readShort">
      <typeReference xsi:type="types:Short">
        <comments>/**&#xA;     * Reads two bytes from the stream, and (conceptually)&#xA;     * concatenates them according to the current byte order, and&#xA;     * returns the result as a &lt;code>short&lt;/code> value.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @return a signed short value from the stream.&#xA;     *&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     *&#xA;     * @see #getByteOrder&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readUnsignedShort">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Reads two bytes from the stream, and (conceptually)&#xA;     * concatenates them according to the current byte order, converts&#xA;     * the resulting value to an &lt;code>int&lt;/code>, masks it with&#xA;     * &lt;code>0xffff&lt;/code> in order to strip off any sign-extension&#xA;     * buts, and returns the result as an unsigned &lt;code>int&lt;/code>&#xA;     * value.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @return an unsigned short value from the stream, as an int.&#xA;     *&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     *&#xA;     * @see #getByteOrder&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readChar">
      <typeReference xsi:type="types:Char">
        <comments>/**&#xA;     * Equivalent to &lt;code>readUnsignedShort&lt;/code>, except that the&#xA;     * result is returned using the &lt;code>char&lt;/code> datatype.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @return an unsigned char value from the stream.&#xA;     *&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     *&#xA;     * @see #readUnsignedShort&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readInt">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Reads 4 bytes from the stream, and (conceptually) concatenates&#xA;     * them according to the current byte order and returns the result&#xA;     * as an &lt;code>int&lt;/code>.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is ignored and treated as&#xA;     * though it were zero.&#xA;     *&#xA;     * @return a signed int value from the stream.&#xA;     *&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     *&#xA;     * @see #getByteOrder&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readUnsignedInt">
      <typeReference xsi:type="types:Long">
        <comments>/**&#xA;     * Reads 4 bytes from the stream, and (conceptually) concatenates&#xA;     * them according to the current byte order, converts the result&#xA;     * to a long, masks it with &lt;code>0xffffffffL&lt;/code> in order to&#xA;     * strip off any sign-extension bits, and returns the result as an&#xA;     * unsigned &lt;code>long&lt;/code> value.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @return an unsigned int value from the stream, as a long.&#xA;     *&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     *&#xA;     * @see #getByteOrder&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readLong">
      <typeReference xsi:type="types:Long">
        <comments>/**&#xA;     * Reads 8 bytes from the stream, and (conceptually) concatenates&#xA;     * them according to the current byte order and returns the result&#xA;     * as a &lt;code>long&lt;/code>.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @return a signed long value from the stream.&#xA;     *&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     *&#xA;     * @see #getByteOrder&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readFloat">
      <typeReference xsi:type="types:Float">
        <comments>/**&#xA;     * Reads 4 bytes from the stream, and (conceptually) concatenates&#xA;     * them according to the current byte order and returns the result&#xA;     * as a &lt;code>float&lt;/code>.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @return a float value from the stream.&#xA;     *&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     *&#xA;     * @see #getByteOrder&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readDouble">
      <typeReference xsi:type="types:Double">
        <comments>/**&#xA;     * Reads 8 bytes from the stream, and (conceptually) concatenates&#xA;     * them according to the current byte order and returns the result&#xA;     * as a &lt;code>double&lt;/code>.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @return a double value from the stream.&#xA;     *&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     *&#xA;     * @see #getByteOrder&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readLine">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Reads the next line of text from the input stream.  It reads&#xA;     * successive bytes, converting each byte separately into a&#xA;     * character, until it encounters a line terminator or end of&#xA;     * file; the characters read are then returned as a&#xA;     * &lt;code>String&lt;/code>. Note that because this method processes&#xA;     * bytes, it does not support input of the full Unicode character&#xA;     * set.&#xA;     *&#xA;     * &lt;p> If end of file is encountered before even one byte can be&#xA;     * read, then &lt;code>null&lt;/code> is returned. Otherwise, each byte&#xA;     * that is read is converted to type &lt;code>char&lt;/code> by&#xA;     * zero-extension. If the character &lt;code>'\n'&lt;/code> is&#xA;     * encountered, it is discarded and reading ceases. If the&#xA;     * character &lt;code>'\r'&lt;/code> is encountered, it is discarded&#xA;     * and, if the following byte converts &amp;#32;to the character&#xA;     * &lt;code>'\n'&lt;/code>, then that is discarded also; reading then&#xA;     * ceases. If end of file is encountered before either of the&#xA;     * characters &lt;code>'\n'&lt;/code> and &lt;code>'\r'&lt;/code> is&#xA;     * encountered, reading ceases. Once reading has ceased, a&#xA;     * &lt;code>String&lt;/code> is returned that contains all the&#xA;     * characters read and not discarded, taken in order.  Note that&#xA;     * every character in this string will have a value less than&#xA;     * &lt;code>&amp;#92;u0100&lt;/code>, that is, &lt;code>(char)256&lt;/code>.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @return a String containing a line of text from the stream.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readUTF">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Reads in a string that has been encoded using a&#xA;     * &lt;a href=&quot;../../../java/io/DataInput.html#modified-utf-8&quot;>modified&#xA;     * UTF-8&lt;/a>&#xA;     * format.  The general contract of &lt;code>readUTF&lt;/code> is that&#xA;     * it reads a representation of a Unicode character string encoded&#xA;     * in modified UTF-8 format; this string of characters is&#xA;     * then returned as a &lt;code>String&lt;/code>.&#xA;     *&#xA;     * &lt;p> First, two bytes are read and used to construct an unsigned&#xA;     * 16-bit integer in the manner of the&#xA;     * &lt;code>readUnsignedShort&lt;/code> method, using network byte order&#xA;     * (regardless of the current byte order setting). This integer&#xA;     * value is called the &lt;i>UTF length&lt;/i> and specifies the number&#xA;     * of additional bytes to be read. These bytes are then converted&#xA;     * to characters by considering them in groups. The length of each&#xA;     * group is computed from the value of the first byte of the&#xA;     * group. The byte following a group, if any, is the first byte of&#xA;     * the next group.&#xA;     *&#xA;     * &lt;p> If the first byte of a group matches the bit pattern&#xA;     * &lt;code>0xxxxxxx&lt;/code> (where &lt;code>x&lt;/code> means &quot;may be&#xA;     * &lt;code>0&lt;/code> or &lt;code>1&lt;/code>&quot;), then the group consists of&#xA;     * just that byte. The byte is zero-extended to form a character.&#xA;     *&#xA;     * &lt;p> If the first byte of a group matches the bit pattern&#xA;     * &lt;code>110xxxxx&lt;/code>, then the group consists of that byte&#xA;     * &lt;code>a&lt;/code> and a second byte &lt;code>b&lt;/code>. If there is no&#xA;     * byte &lt;code>b&lt;/code> (because byte &lt;code>a&lt;/code> was the last&#xA;     * of the bytes to be read), or if byte &lt;code>b&lt;/code> does not&#xA;     * match the bit pattern &lt;code>10xxxxxx&lt;/code>, then a&#xA;     * &lt;code>UTFDataFormatException&lt;/code> is thrown. Otherwise, the&#xA;     * group is converted to the character:&#xA;     *&#xA;     * &lt;p> &lt;pre>&lt;code>&#xA;     * (char)(((a&amp;amp; 0x1F) &amp;lt;&amp;lt; 6) | (b &amp;amp; 0x3F))&#xA;     * &lt;/code>&lt;/pre>&#xA;     *&#xA;     * If the first byte of a group matches the bit pattern&#xA;     * &lt;code>1110xxxx&lt;/code>, then the group consists of that byte&#xA;     * &lt;code>a&lt;/code> and two more bytes &lt;code>b&lt;/code> and&#xA;     * &lt;code>c&lt;/code>.  If there is no byte &lt;code>c&lt;/code> (because&#xA;     * byte &lt;code>a&lt;/code> was one of the last two of the bytes to be&#xA;     * read), or either byte &lt;code>b&lt;/code> or byte &lt;code>c&lt;/code>&#xA;     * does not match the bit pattern &lt;code>10xxxxxx&lt;/code>, then a&#xA;     * &lt;code>UTFDataFormatException&lt;/code> is thrown. Otherwise, the&#xA;     * group is converted to the character:&#xA;     *&#xA;     * &lt;p> &lt;pre>&lt;code>&#xA;     * (char)(((a &amp;amp; 0x0F) &amp;lt;&amp;lt; 12) | ((b &amp;amp; 0x3F) &amp;lt;&amp;lt; 6) | (c &amp;amp; 0x3F))&#xA;     * &lt;/code>&lt;/pre>&#xA;     *&#xA;     * If the first byte of a group matches the pattern&#xA;     * &lt;code>1111xxxx&lt;/code> or the pattern &lt;code>10xxxxxx&lt;/code>,&#xA;     * then a &lt;code>UTFDataFormatException&lt;/code> is thrown.&#xA;     *&#xA;     * &lt;p> If end of file is encountered at any time during this&#xA;     * entire process, then an &lt;code>EOFException&lt;/code> is thrown.&#xA;     *&#xA;     * &lt;p> After every group has been converted to a character by this&#xA;     * process, the characters are gathered, in the same order in&#xA;     * which their corresponding groups were read from the input&#xA;     * stream, to form a &lt;code>String&lt;/code>, which is returned.&#xA;     *&#xA;     * &lt;p> The current byte order setting is ignored.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * &lt;p>&lt;strong>Note:&lt;/strong> This method should not be used in&#xA;     * the  implementation of image formats that use standard UTF-8,&#xA;     * because  the modified UTF-8 used here is incompatible with&#xA;     * standard UTF-8.&#xA;     *&#xA;     * @return a String read from the stream.&#xA;     *&#xA;     * @exception  EOFException  if this stream reaches the end&#xA;     * before reading all the bytes.&#xA;     * @exception  UTFDataFormatException if the bytes do not represent a&#xA;     * valid modified UTF-8 encoding of a string.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readFully">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Reads &lt;code>len&lt;/code> bytes from the stream, and stores them&#xA;     * into &lt;code>b&lt;/code> starting at index &lt;code>off&lt;/code>.&#xA;     * If the end of the stream is reached, an &lt;code>EOFException&lt;/code>&#xA;     * will be thrown.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @param b an array of bytes to be written to.&#xA;     * @param off the starting position within &lt;code>b&lt;/code> to write to.&#xA;     * @param len the maximum number of &lt;code>byte&lt;/code>s to read.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>b.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>b&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readFully">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Reads &lt;code>b.length&lt;/code> bytes from the stream, and stores them&#xA;     * into &lt;code>b&lt;/code> starting at index &lt;code>0&lt;/code>.&#xA;     * If the end of the stream is reached, an &lt;code>EOFException&lt;/code>&#xA;     * will be thrown.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @param b an array of &lt;code>byte&lt;/code>s.&#xA;     *&#xA;     * @exception NullPointerException if &lt;code>b&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readFully">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Reads &lt;code>len&lt;/code> shorts (signed 16-bit integers) from the&#xA;     * stream according to the current byte order, and&#xA;     * stores them into &lt;code>s&lt;/code> starting at index&#xA;     * &lt;code>off&lt;/code>.  If the end of the stream is reached, an&#xA;     * &lt;code>EOFException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @param s an array of shorts to be written to.&#xA;     * @param off the starting position withinb to write to.&#xA;     * @param len the maximum number of &lt;code>short&lt;/code>s to read.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>s.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>s&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:Short"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readFully">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Reads &lt;code>len&lt;/code> chars (unsigned 16-bit integers) from the&#xA;     * stream according to the current byte order, and&#xA;     * stores them into &lt;code>c&lt;/code> starting at index&#xA;     * &lt;code>off&lt;/code>.  If the end of the stream is reached, an&#xA;     * &lt;code>EOFException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @param c an array of chars to be written to.&#xA;     * @param off the starting position withinb to write to.&#xA;     * @param len the maximum number of &lt;code>char&lt;/code>s to read.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>c.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>c&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readFully">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Reads &lt;code>len&lt;/code> ints (signed 32-bit integers) from the&#xA;     * stream according to the current byte order, and&#xA;     * stores them into &lt;code>i&lt;/code> starting at index&#xA;     * &lt;code>off&lt;/code>.  If the end of the stream is reached, an&#xA;     * &lt;code>EOFException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @param i an array of ints to be written to.&#xA;     * @param off the starting position withinb to write to.&#xA;     * @param len the maximum number of &lt;code>int&lt;/code>s to read.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>i.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>i&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readFully">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Reads &lt;code>len&lt;/code> longs (signed 64-bit integers) from the&#xA;     * stream according to the current byte order, and&#xA;     * stores them into &lt;code>l&lt;/code> starting at index&#xA;     * &lt;code>off&lt;/code>.  If the end of the stream is reached, an&#xA;     * &lt;code>EOFException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @param l an array of longs to be written to.&#xA;     * @param off the starting position withinb to write to.&#xA;     * @param len the maximum number of &lt;code>long&lt;/code>s to read.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>l.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>l&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:Long"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readFully">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Reads &lt;code>len&lt;/code> floats (32-bit IEEE single-precision&#xA;     * floats) from the stream according to the current byte order,&#xA;     * and stores them into &lt;code>f&lt;/code> starting at&#xA;     * index &lt;code>off&lt;/code>.  If the end of the stream is reached,&#xA;     * an &lt;code>EOFException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @param f an array of floats to be written to.&#xA;     * @param off the starting position withinb to write to.&#xA;     * @param len the maximum number of &lt;code>float&lt;/code>s to read.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>f.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>f&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readFully">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Reads &lt;code>len&lt;/code> doubles (64-bit IEEE double-precision&#xA;     * floats) from the stream according to the current byte order,&#xA;     * and stores them into &lt;code>d&lt;/code> starting at&#xA;     * index &lt;code>off&lt;/code>.  If the end of the stream is reached,&#xA;     * an &lt;code>EOFException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> The bit offset within the stream is reset to zero before&#xA;     * the read occurs.&#xA;     *&#xA;     * @param d an array of doubles to be written to.&#xA;     * @param off the starting position withinb to write to.&#xA;     * @param len the maximum number of &lt;code>double&lt;/code>s to read.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>off&lt;/code> is&#xA;     * negative, &lt;code>len&lt;/code> is negative, or &lt;code>off +&#xA;     * len&lt;/code> is greater than &lt;code>d.length&lt;/code>.&#xA;     * @exception NullPointerException if &lt;code>d&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bytes.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getStreamPosition">
      <typeReference xsi:type="types:Long">
        <comments>/**&#xA;     * Returns the current byte position of the stream.  The next read&#xA;     * will take place starting at this offset.&#xA;     *&#xA;     * @return a long containing the position of the stream.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBitOffset">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Returns the current bit offset, as an integer between 0 and 7,&#xA;     * inclusive.  The bit offset is updated implicitly by calls to&#xA;     * the &lt;code>readBits&lt;/code> method.  A value of 0 indicates the&#xA;     * most-significant bit, and a value of 7 indicates the least&#xA;     * significant bit, of the byte being read.&#xA;     *&#xA;     * &lt;p> The bit offset is set to 0 when a stream is first&#xA;     * opened, and is reset to 0 by calls to &lt;code>seek&lt;/code>,&#xA;     * &lt;code>skipBytes&lt;/code>, or any &lt;code>read&lt;/code> or &#xA;     * &lt;code>readFully&lt;/code> method.&#xA;     *&#xA;     * @return an &lt;code>int&lt;/code> containing the bit offset between&#xA;     * 0 and 7, inclusive.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     *&#xA;     * @see #setBitOffset&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setBitOffset">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the bit offset to an integer between 0 and 7, inclusive.&#xA;     * The byte offset within the stream, as returned by&#xA;     * &lt;code>getStreamPosition&lt;/code>, is left unchanged.&#xA;     * A value of 0 indicates the&#xA;     * most-significant bit, and a value of 7 indicates the least&#xA;     * significant bit, of the byte being read.&#xA;     *&#xA;     * @param bitOffset the desired offset, as an &lt;code>int&lt;/code>&#xA;     * between 0 and 7, inclusive.&#xA;     *&#xA;     * @exception IllegalArgumentException if &lt;code>bitOffset&lt;/code>&#xA;     * is not between 0 and 7, inclusive.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     *&#xA;     * @see #getBitOffset&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bitOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readBit">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Reads a single bit from the stream and returns it as an&#xA;     * &lt;code>int&lt;/code> with the value &lt;code>0&lt;/code> or&#xA;     * &lt;code>1&lt;/code>.  The bit offset is advanced by one and reduced&#xA;     * modulo 8.&#xA;     *&#xA;     * @return an &lt;code>int&lt;/code> containing the value &lt;code>0&lt;/code>&#xA;     * or &lt;code>1&lt;/code>.&#xA;     *&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bits.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readBits">
      <typeReference xsi:type="types:Long">
        <comments>/**&#xA;     * Reads a bitstring from the stream and returns it as a&#xA;     * &lt;code>long&lt;/code>, with the first bit read becoming the most&#xA;     * significant bit of the output.  The read starts within the byte&#xA;     * indicated by &lt;code>getStreamPosition&lt;/code>, at the bit given&#xA;     * by &lt;code>getBitOffset&lt;/code>.  The bit offset is advanced by&#xA;     * &lt;code>numBits&lt;/code> and reduced modulo 8.&#xA;     *&#xA;     * &lt;p> The byte order of the stream has no effect on this&#xA;     * method.  The return value of this method is constructed as&#xA;     * though the bits were read one at a time, and shifted into&#xA;     * the right side of the return value, as shown by the following&#xA;     * pseudo-code:&#xA;     *&#xA;     * &lt;pre>&#xA;     * long accum = 0L;&#xA;     * for (int i = 0; i &lt; numBits; i++) {&#xA;     *   accum &lt;&lt;= 1; // Shift left one bit to make room&#xA;     *   accum |= readBit();&#xA;     * }&#xA;     * &lt;/pre>&#xA;     *&#xA;     * Note that the result of &lt;code>readBits(32)&lt;/code> may thus not&#xA;     * be equal to that of &lt;code>readInt()&lt;/code> if a reverse network&#xA;     * byte order is being used (i.e., &lt;code>getByteOrder() ==&#xA;     * false&lt;/code>).&#xA;     *&#xA;     * &lt;p> If the end of the stream is encountered before all the bits&#xA;     * have been read, an &lt;code>EOFException&lt;/code> is thrown.&#xA;     *&#xA;     * @param numBits the number of bits to read, as an &lt;code>int&lt;/code>&#xA;     * between 0 and 64, inclusive.&#xA;     * @return the bitstring, as a &lt;code>long&lt;/code> with the last bit&#xA;     * read stored in the least significant bit.&#xA;     *&#xA;     * @exception IllegalArgumentException if &lt;code>numBits&lt;/code>&#xA;     * is not between 0 and 64, inclusive.&#xA;     * @exception EOFException if the stream reaches the end before&#xA;     * reading all the bits.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="numBits">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="length">
      <typeReference xsi:type="types:Long">
        <comments>/**&#xA;     * Returns the total length of the stream, if known.  Otherwise,&#xA;     * &lt;code>-1&lt;/code> is returned.&#xA;     *&#xA;     * @return a &lt;code>long&lt;/code> containing the length of the&#xA;     * stream, if known, or else &lt;code>-1&lt;/code>.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="skipBytes">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Moves the stream position forward by a given number of bytes.  It&#xA;     * is possible that this method will only be able to skip forward&#xA;     * by a smaller number of bytes than requested, for example if the&#xA;     * end of the stream is reached.  In all cases, the actual number&#xA;     * of bytes skipped is returned.  The bit offset is set to zero&#xA;     * prior to advancing the position.&#xA;     *&#xA;     * @param n an &lt;code>int&lt;/code> containing the number of bytes to&#xA;     * be skipped.&#xA;     *&#xA;     * @return an &lt;code>int&lt;/code> representing the number of bytes skipped.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="skipBytes">
      <typeReference xsi:type="types:Long">
        <comments>/**&#xA;     * Moves the stream position forward by a given number of bytes.&#xA;     * This method is identical to &lt;code>skipBytes(int)&lt;/code> except&#xA;     * that it allows for a larger skip distance.&#xA;     *&#xA;     * @param n a &lt;code>long&lt;/code> containing the number of bytes to&#xA;     * be skipped.&#xA;     *&#xA;     * @return a &lt;code>long&lt;/code> representing the number of bytes&#xA;     * skipped.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="seek">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the current stream position to the desired location.  The&#xA;     * next read will occur at this location.  The bit offset is set&#xA;     * to 0.&#xA;     *&#xA;     * &lt;p> An &lt;code>IndexOutOfBoundsException&lt;/code> will be thrown if&#xA;     * &lt;code>pos&lt;/code> is smaller than the flushed position (as&#xA;     * returned by &lt;code>getflushedPosition&lt;/code>).&#xA;     *&#xA;     * &lt;p> It is legal to seek past the end of the file; an&#xA;     * &lt;code>EOFException&lt;/code> will be thrown only if a read is&#xA;     * performed.&#xA;     *&#xA;     * @param pos a &lt;code>long&lt;/code> containing the desired file&#xA;     * pointer position.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>pos&lt;/code> is smaller&#xA;     * than the flushed position.&#xA;     * @exception IOException if any other I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="mark">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Marks a position in the stream to be returned to by a&#xA;     * subsequent call to &lt;code>reset&lt;/code>.  Unlike a standard&#xA;     * &lt;code>InputStream&lt;/code>, all &lt;code>ImageInputStream&lt;/code>s&#xA;     * support marking.  Additionally, calls to &lt;code>mark&lt;/code> and&#xA;     * &lt;code>reset&lt;/code> may be nested arbitrarily.&#xA;     *&#xA;     * &lt;p> Unlike the &lt;code>mark&lt;/code> methods declared by the&#xA;     * &lt;code>Reader&lt;/code> &lt;code>InputStream&lt;/code> interfaces, no&#xA;     * &lt;code>readLimit&lt;/code> parameter is used.  An arbitrary amount&#xA;     * of data may be read following the call to &lt;code>mark&lt;/code>.&#xA;     *&#xA;     * &lt;p> The bit position used by the &lt;code>readBits&lt;/code> method&#xA;     * is saved and restored by each pair of calls to&#xA;     * &lt;code>mark&lt;/code> and &lt;code>reset&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="reset">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Returns the file pointer to its previous position, including&#xA;     * the bit offset, at the time of the most recent unmatched call&#xA;     * to &lt;code>mark&lt;/code>.&#xA;     *&#xA;     * &lt;p> Calls to &lt;code>reset&lt;/code> without a corresponding call&#xA;     * to &lt;code>mark&lt;/code> have no effect.&#xA;     *&#xA;     * &lt;p> An &lt;code>IOException&lt;/code> will be thrown if the previous&#xA;     * marked position lies in the discarded portion of the stream.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="flushBefore">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Discards the initial portion of the stream prior to the&#xA;     * indicated postion.  Attempting to seek to an offset within the&#xA;     * flushed portion of the stream will result in an&#xA;     * &lt;code>IndexOutOfBoundsException&lt;/code>.&#xA;     *&#xA;     * &lt;p> Calling &lt;code>flushBefore&lt;/code> may allow classes&#xA;     * implementing this interface to free up resources such as memory&#xA;     * or disk space that are being used to store data from the&#xA;     * stream.&#xA;     *&#xA;     * @param pos a &lt;code>long&lt;/code> containing the length of the&#xA;     * file prefix that may be flushed.&#xA;     *&#xA;     * @exception IndexOutOfBoundsException if &lt;code>pos&lt;/code> lies&#xA;     * in the flushed portion of the stream or past the current stream&#xA;     * position.&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="flush">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Discards the initial position of the stream prior to the current&#xA;     * stream position.  Equivalent to&#xA;     * &lt;code>flushBefore(getStreamPosition())&lt;/code>.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFlushedPosition">
      <typeReference xsi:type="types:Long">
        <comments>/**&#xA;     * Returns the earliest position in the stream to which seeking&#xA;     * may be performed.  The returned value will be the maximum of&#xA;     * all values passed into previous calls to&#xA;     * &lt;code>flushBefore&lt;/code>.&#xA;     *&#xA;     * @return the earliest legal position for seeking, as a&#xA;     * &lt;code>long&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isCached">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if this &lt;code>ImageInputStream&lt;/code>&#xA;     * caches data itself in order to allow seeking backwards.&#xA;     * Applications may consult this in order to decide how frequently,&#xA;     * or whether, to flush in order to conserve cache resources.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if this &lt;code>ImageInputStream&lt;/code>&#xA;     * caches data.&#xA;     *&#xA;     * @see #isCachedMemory&#xA;     * @see #isCachedFile&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isCachedMemory">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if this &lt;code>ImageInputStream&lt;/code>&#xA;     * caches data itself in order to allow seeking backwards, and&#xA;     * the cache is kept in main memory.  Applications may consult&#xA;     * this in order to decide how frequently, or whether, to flush&#xA;     * in order to conserve cache resources.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if this &lt;code>ImageInputStream&lt;/code>&#xA;     * caches data in main memory.&#xA;     *&#xA;     * @see #isCached&#xA;     * @see #isCachedFile&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isCachedFile">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if this &lt;code>ImageInputStream&lt;/code>&#xA;     * caches data itself in order to allow seeking backwards, and&#xA;     * the cache is kept in a temporary file.  Applications may consult&#xA;     * this in order to decide how frequently, or whether, to flush&#xA;     * in order to conserve cache resources.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if this &lt;code>ImageInputStream&lt;/code>&#xA;     * caches data in a temporary file.&#xA;     *&#xA;     * @see #isCached&#xA;     * @see #isCachedMemory&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="close">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Closes the stream.  Attempts to access a stream that has been&#xA;     * closed may result in &lt;code>IOException&lt;/code>s or incorrect&#xA;     * behavior.  Calling this method may allow classes implementing&#xA;     * this interface to release resources associated with the stream&#xA;     * such as memory, disk space, or file descriptors.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A seekable input stream interface for use by&#xA; * &lt;code>ImageReader&lt;/code>s.  Various input sources, such as&#xA; * &lt;code>InputStream&lt;/code>s and &lt;code>File&lt;/code>s,&#xA; * as well as future fast I/O sources may be &quot;wrapped&quot; by a suitable&#xA; * implementation of this interface for use by the Image I/O API.&#xA; *&#xA; * @see ImageInputStreamImpl&#xA; * @see FileImageInputStream&#xA; * @see FileCacheImageInputStream&#xA; * @see MemoryCacheImageInputStream&#xA; *&#xA; * @version 0.5&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../../java/io/DataInput.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
