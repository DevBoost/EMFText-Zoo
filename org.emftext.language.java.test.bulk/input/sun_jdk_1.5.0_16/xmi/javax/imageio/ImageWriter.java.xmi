<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="ImageWriter.java">
  <comments>/*&#xA; * @(#)ImageWriter.java&#x9;1.94 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>imageio</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/awt/Dimension.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/awt/image/BufferedImage.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../java/awt/image/RenderedImage.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/awt/image/Raster.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/util/ArrayList.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../java/util/List.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/util/Locale.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/util/MissingResourceException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/util/ResourceBundle.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>imageio</namespaces>
    <namespaces>event</namespaces>
    <classifier xsi:type="classifiers:Interface" href="event/IIOWriteWarningListener.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>imageio</namespaces>
    <namespaces>event</namespaces>
    <classifier xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>imageio</namespaces>
    <namespaces>metadata</namespaces>
    <classifier xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>imageio</namespaces>
    <namespaces>stream</namespaces>
    <classifier xsi:type="classifiers:Interface" href="stream/ImageOutputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>imageio</namespaces>
    <namespaces>spi</namespaces>
    <classifier xsi:type="classifiers:Class" href="spi/ImageWriterSpi.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="ImageWriter">
    <members xsi:type="members:Field" name="originatingProvider">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="spi/ImageWriterSpi.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The &lt;code>ImageWriterSpi&lt;/code> that instantiated this object,&#xA;     * or &lt;code>null&lt;/code> if its identity is not known or none&#xA;     * exists.  By default it is initialized to &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="output">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The &lt;code>ImageOutputStream&lt;/code> or other &lt;code>Object&lt;/code>&#xA;     * set by &lt;code>setOutput&lt;/code> and retrieved by&#xA;     * &lt;code>getOutput&lt;/code>.  By default it is initialized to&#xA;     * &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="availableLocales">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/util/Locale.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * An array of &lt;code>Locale&lt;/code>s that may be used to localize&#xA;     * warning messages and compression setting values, or&#xA;     * &lt;code>null&lt;/code> if localization is not supported.  By default&#xA;     * it is initialized to &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="locale">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/util/Locale.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The current &lt;code>Locale&lt;/code> to be used for localization, or&#xA;     * &lt;code>null&lt;/code> if none has been set.  By default it is&#xA;     * initialized to &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="warningListeners">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Interface" href="event/IIOWriteWarningListener.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../java/util/List.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * A &lt;code>List&lt;/code> of currently registered&#xA;     * &lt;code>IIOWriteWarningListener&lt;/code>s, initialized by default to&#xA;     * &lt;code>null&lt;/code>, which is synonymous with an empty&#xA;     * &lt;code>List&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="warningLocales">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../java/util/Locale.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../java/util/List.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * A &lt;code>List&lt;/code> of &lt;code>Locale&lt;/code>s, one for each&#xA;     * element of &lt;code>warningListeners&lt;/code>, initialized by default&#xA;     * &lt;code>null&lt;/code>, which is synonymous with an empty&#xA;     * &lt;code>List&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="progressListeners">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../java/util/List.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * A &lt;code>List&lt;/code> of currently registered&#xA;     * &lt;code>IIOWriteProgressListener&lt;/code>s, initialized by default&#xA;     * &lt;code>null&lt;/code>, which is synonymous with an empty&#xA;     * &lt;code>List&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="abortFlag">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * If &lt;code>true&lt;/code>, the current write operation should be&#xA;     * aborted.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="ImageWriter">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="originatingProvider">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="spi/ImageWriterSpi.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Constructs an &lt;code>ImageWriter&lt;/code> and sets its&#xA;     * &lt;code>originatingProvider&lt;/code> instance variable to the&#xA;     * supplied value.&#xA;     *&#xA;     * &lt;p> Subclasses that make use of extensions should provide a&#xA;     * constructor with signature &lt;code>(ImageWriterSpi,&#xA;     * Object)&lt;/code> in order to retrieve the extension object.  If&#xA;     * the extension object is unsuitable, an&#xA;     * &lt;code>IllegalArgumentException&lt;/code> should be thrown.&#xA;     *&#xA;     * @param originatingProvider the &lt;code>ImageWriterSpi&lt;/code> that&#xA;     * is constructing this object, or &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getOriginatingProvider">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="spi/ImageWriterSpi.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>ImageWriterSpi&lt;/code> object that created&#xA;     * this &lt;code>ImageWriter&lt;/code>, or &lt;code>null&lt;/code> if this&#xA;     * object was not created through the &lt;code>IIORegistry&lt;/code>.&#xA;     *&#xA;     * &lt;p> The default implementation returns the value of the&#xA;     * &lt;code>originatingProvider&lt;/code> instance variable.&#xA;     *&#xA;     * @return an &lt;code>ImageWriterSpi&lt;/code>, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @see ImageWriterSpi&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setOutput">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="output">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the destination to the given&#xA;     * &lt;code>ImageOutputStream&lt;/code> or other &lt;code>Object&lt;/code>.&#xA;     * The destination is assumed to be ready to accept data, and will&#xA;     * not be closed at the end of each write. This allows distributed&#xA;     * imaging applications to transmit a series of images over a&#xA;     * single network connection.  If &lt;code>output&lt;/code> is&#xA;     * &lt;code>null&lt;/code>, any currently set output will be removed.&#xA;     *&#xA;     * &lt;p> If &lt;code>output&lt;/code> is an&#xA;     * &lt;code>ImageOutputStream&lt;/code>, calls to the&#xA;     * &lt;code>write&lt;/code>, &lt;code>writeToSequence&lt;/code>, and&#xA;     * &lt;code>prepareWriteEmpty&lt;/code>/&lt;code>endWriteEmpty&lt;/code>&#xA;     * methods will preserve the existing contents of the stream.&#xA;     * Other write methods, such as &lt;code>writeInsert&lt;/code>,&#xA;     * &lt;code>replaceStreamMetadata&lt;/code>,&#xA;     * &lt;code>replaceImageMetadata&lt;/code>, &lt;code>replacePixels&lt;/code>,&#xA;     * &lt;code>prepareInsertEmpty&lt;/code>/&lt;code>endInsertEmpty&lt;/code>,&#xA;     * and &lt;code>endWriteSequence&lt;/code>, require the full contents&#xA;     * of the stream to be readable and writable, and may alter any&#xA;     * portion of the stream.&#xA;     *&#xA;     * &lt;p> Use of a general &lt;code>Object&lt;/code> other than an&#xA;     * &lt;code>ImageOutputStream&lt;/code> is intended for writers that&#xA;     * interact directly with an output device or imaging protocol.&#xA;     * The set of legal classes is advertised by the writer's service&#xA;     * provider's &lt;code>getOutputTypes&lt;/code> method; most writers&#xA;     * will return a single-element array containing only&#xA;     * &lt;code>ImageOutputStream.class&lt;/code> to indicate that they&#xA;     * accept only an &lt;code>ImageOutputStream&lt;/code>.&#xA;     *&#xA;     * &lt;p> The default implementation sets the &lt;code>output&lt;/code>&#xA;     * instance variable to the value of &lt;code>output&lt;/code> after&#xA;     * checking &lt;code>output&lt;/code> against the set of classes&#xA;     * advertised by the originating provider, if there is one.&#xA;     *&#xA;     * @param output the &lt;code>ImageOutputStream&lt;/code> or other&#xA;     * &lt;code>Object&lt;/code> to use for future writing.&#xA;     *&#xA;     * @exception IllegalArgumentException if &lt;code>output&lt;/code> is&#xA;     * not an instance of one of the classes returned by the&#xA;     * originating service provider's &lt;code>getOutputTypes&lt;/code>&#xA;     * method.&#xA;     *&#xA;     * @see #getOutput&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="provider">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="spi/ImageWriterSpi.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.9"/>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="classes">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../java/lang/Class.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arrayDimensionsBefore/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.0/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="spi/ImageWriterSpi.class.xmi#//@classifiers.0/@members.7"/>
                    </next>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="found">
                  <typeReference xsi:type="types:Boolean"/>
                  <initialValue xsi:type="literals:BooleanLiteral"/>
                </variable>
              </statements>
              <statements xsi:type="statements:ForLoop">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@statement/@statements.1/@variable"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="literals:BooleanLiteral" value="true"/>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:Break"/>
                    </statement>
                    <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../java/lang/Class.class.xmi#//@classifiers.0/@members.37"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
                      </next>
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@statement/@statements.2/@init"/>
                      </arraySelectors>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@statement/@statements.2/@init"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable">
                    <next xsi:type="references:IdentifierReference"/>
                  </children>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
                <init xsi:type="variables:LocalVariable" name="i">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </init>
                <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@statement/@statements.2/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </updates>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Throw">
                    <throwable xsi:type="instantiations:NewConstructorCall">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <arguments xsi:type="references:StringReference" value="Illegal output type!"/>
                    </throwable>
                  </statements>
                </statement>
                <condition xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Negate"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@statement/@statements.1/@variable"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getOutput">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>ImageOutputStream&lt;/code> or other&#xA;     * &lt;code>Object&lt;/code> set by the most recent call to the&#xA;     * &lt;code>setOutput&lt;/code> method.  If no destination has been&#xA;     * set, &lt;code>null&lt;/code> is returned.&#xA;     *&#xA;     * &lt;p> The default implementation returns the value of the&#xA;     * &lt;code>output&lt;/code> instance variable.&#xA;     *&#xA;     * @return the &lt;code>Object&lt;/code> that was specified using&#xA;     * &lt;code>setOutput&lt;/code>, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @see #setOutput&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAvailableLocales">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/util/Locale.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Localization</comments>
        <comments>/**&#xA;     * Returns an array of &lt;code>Locale&lt;/code>s that may be used to&#xA;     * localize warning listeners and compression settings.  A return&#xA;     * value of &lt;code>null&lt;/code> indicates that localization is not&#xA;     * supported.&#xA;     *&#xA;     * &lt;p> The default implementation returns a clone of the&#xA;     * &lt;code>availableLocales&lt;/code> instance variable if it is&#xA;     * non-&lt;code>null&lt;/code>, or else returns &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @return an array of &lt;code>Locale&lt;/code>s that may be used as&#xA;     * arguments to &lt;code>setLocale&lt;/code>, or &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </child>
          <expressionIf xsi:type="literals:NullLiteral"/>
          <expressionElse xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../java/util/Locale.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../java/util/Locale.class.xmi#//@classifiers.0/@members.54"/>
              </next>
            </child>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setLocale">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="locale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the current &lt;code>Locale&lt;/code> of this&#xA;     * &lt;code>ImageWriter&lt;/code> to the given value.  A value of&#xA;     * &lt;code>null&lt;/code> removes any previous setting, and indicates&#xA;     * that the writer should localize as it sees fit.&#xA;     *&#xA;     * &lt;p> The default implementation checks &lt;code>locale&lt;/code>&#xA;     * against the values returned by&#xA;     * &lt;code>getAvailableLocales&lt;/code>, and sets the&#xA;     * &lt;code>locale&lt;/code> instance variable if it is found.  If&#xA;     * &lt;code>locale&lt;/code> is &lt;code>null&lt;/code>, the instance variable&#xA;     * is set to &lt;code>null&lt;/code> without any checking.&#xA;     *&#xA;     * @param locale the desired &lt;code>Locale&lt;/code>, or&#xA;     * &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @exception IllegalArgumentException if &lt;code>locale&lt;/code> is&#xA;     * non-&lt;code>null&lt;/code> but is not one of the values returned by&#xA;     * &lt;code>getAvailableLocales&lt;/code>.&#xA;     *&#xA;     * @see #getLocale&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="locales">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/util/Locale.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arrayDimensionsBefore/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="found">
              <typeReference xsi:type="types:Boolean"/>
              <initialValue xsi:type="literals:BooleanLiteral"/>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ForLoop">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statement/@statements.1/@variable"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="literals:BooleanLiteral" value="true"/>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:Break"/>
                    </statement>
                    <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../java/util/Locale.class.xmi#//@classifiers.0/@members.56"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statement/@statements.0/@variable">
                          <arraySelectors>
                            <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statement/@statements.2/@statement/@statements.0/@init"/>
                          </arraySelectors>
                        </arguments>
                      </next>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statement/@statements.2/@statement/@statements.0/@init"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statement/@statements.0/@variable">
                    <next xsi:type="references:IdentifierReference"/>
                  </children>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
                <init xsi:type="variables:LocalVariable" name="i">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </init>
                <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statement/@statements.2/@statement/@statements.0/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </updates>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:StringReference" value="Invalid locale!"/>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statement/@statements.1/@variable"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLocale">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/util/Locale.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the currently set &lt;code>Locale&lt;/code>, or&#xA;     * &lt;code>null&lt;/code> if none has been set.&#xA;     *&#xA;     * &lt;p> The default implementation returns the value of the&#xA;     * &lt;code>locale&lt;/code> instance variable.&#xA;     *&#xA;     * @return the current &lt;code>Locale&lt;/code>, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @see #setLocale&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDefaultWriteParam">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Write params</comments>
        <comments>/**&#xA;     * Returns a new &lt;code>ImageWriteParam&lt;/code> object of the&#xA;     * appropriate type for this file format containing default&#xA;     * values, that is, those values that would be used &#xA;     * if no &lt;code>ImageWriteParam&lt;/code> object were specified.  This&#xA;     * is useful as a starting point for tweaking just a few parameters&#xA;     * and otherwise leaving the default settings alone.&#xA;     *&#xA;     * &lt;p> The default implementation constructs and returns a new&#xA;     * &lt;code>ImageWriteParam&lt;/code> object that does not allow tiling,&#xA;     * progressive encoding, or compression, and that will be&#xA;     * localized for the current &lt;code>Locale&lt;/code> (&lt;i>i.e.&lt;/i>,&#xA;     * what you would get by calling &lt;code>new&#xA;     * ImageWriteParam(getLocale())&lt;/code>.&#xA;     *&#xA;     * &lt;p> Individual plug-ins may return an instance of&#xA;     * &lt;code>ImageWriteParam&lt;/code> with additional optional features&#xA;     * enabled, or they may return an instance of a plug-in specific&#xA;     * subclass of &lt;code>ImageWriteParam&lt;/code>.&#xA;     *&#xA;     * @return a new &lt;code>ImageWriteParam&lt;/code> object containing&#xA;     * default values.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDefaultStreamMetadata">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="param">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Metadata</comments>
        <comments>/**&#xA;     * Returns an &lt;code>IIOMetadata&lt;/code> object containing default&#xA;     * values for encoding a stream of images.  The contents of the&#xA;     * object may be manipulated using either the XML tree structure&#xA;     * returned by the &lt;code>IIOMetadata.getAsTree&lt;/code> method, an&#xA;     * &lt;code>IIOMetadataController&lt;/code> object, or via plug-in&#xA;     * specific interfaces, and the resulting data supplied to one of&#xA;     * the &lt;code>write&lt;/code> methods that take a stream metadata&#xA;     * parameter.&#xA;     * &#xA;     * &lt;p> An optional &lt;code>ImageWriteParam&lt;/code> may be supplied&#xA;     * for cases where it may affect the structure of the stream&#xA;     * metadata.&#xA;     *&#xA;     * &lt;p> If the supplied &lt;code>ImageWriteParam&lt;/code> contains&#xA;     * optional setting values not supported by this writer (&lt;i>e.g.&lt;/i>&#xA;     * progressive encoding or any format-specific settings), they&#xA;     * will be ignored.&#xA;     * &#xA;     * &lt;p> Writers that do not make use of stream metadata&#xA;     * (&lt;i>e.g.&lt;/i>, writers for single-image formats) should return&#xA;     * &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @param param an &lt;code>ImageWriteParam&lt;/code> that will be used to&#xA;     * encode the image, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @return an &lt;code>IIOMetadata&lt;/code> object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDefaultImageMetadata">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageTypeSpecifier.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="param">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an &lt;code>IIOMetadata&lt;/code> object containing default&#xA;     * values for encoding an image of the given type.  The contents&#xA;     * of the object may be manipulated using either the XML tree&#xA;     * structure returned by the &lt;code>IIOMetadata.getAsTree&lt;/code>&#xA;     * method, an &lt;code>IIOMetadataController&lt;/code> object, or via&#xA;     * plug-in specific interfaces, and the resulting data supplied to&#xA;     * one of the &lt;code>write&lt;/code> methods that take a stream&#xA;     * metadata parameter.&#xA;     *&#xA;     * &lt;p> An optional &lt;code>ImageWriteParam&lt;/code> may be supplied&#xA;     * for cases where it may affect the structure of the image&#xA;     * metadata.&#xA;     *&#xA;     * &lt;p> If the supplied &lt;code>ImageWriteParam&lt;/code> contains&#xA;     * optional setting values not supported by this writer (&lt;i>e.g.&lt;/i>&#xA;     * progressive encoding or any format-specific settings), they&#xA;     * will be ignored.&#xA;     *&#xA;     * @param imageType an &lt;code>ImageTypeSpecifier&lt;/code> indicating the&#xA;     * format of the image to be written later.&#xA;     * @param param an &lt;code>ImageWriteParam&lt;/code> that will be used to&#xA;     * encode the image, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @return an &lt;code>IIOMetadata&lt;/code> object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="convertStreamMetadata">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inData">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="param">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// comment inherited</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="convertImageMetadata">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inData">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageTypeSpecifier.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="param">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// comment inherited</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getNumThumbnailsSupported">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageTypeSpecifier.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="param">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="streamMetadata">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageMetadata">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Thumbnails</comments>
        <comments>/**&#xA;     * Returns the number of thumbnails suported by the format being&#xA;     * written, given the image type and any additional write&#xA;     * parameters and metadata objects that will be used during&#xA;     * encoding.  A return value of &lt;code>-1&lt;/code> indicates that&#xA;     * insufficient information is available.&#xA;     *&#xA;     * &lt;p> An &lt;code>ImageWriteParam&lt;/code> may optionally be supplied&#xA;     * for cases where it may affect thumbnail handling.&#xA;     *&#xA;     * &lt;p> If the supplied &lt;code>ImageWriteParam&lt;/code> contains&#xA;     * optional setting values not supported by this writer (&lt;i>e.g.&lt;/i>&#xA;     * progressive encoding or any format-specific settings), they&#xA;     * will be ignored.&#xA;     *&#xA;     * &lt;p> The default implementation returns 0.&#xA;     *&#xA;     * @param imageType an &lt;code>ImageTypeSpecifier&lt;/code> indicating&#xA;     * the type of image to be written, or &lt;code>null&lt;/code>.&#xA;     * @param param the &lt;code>ImageWriteParam&lt;/code> that will be used for&#xA;     * writing, or &lt;code>null&lt;/code>.&#xA;     * @param streamMetadata an &lt;code>IIOMetadata&lt;/code> object that will&#xA;     * be used for writing, or &lt;code>null&lt;/code>.&#xA;     * @param imageMetadata an &lt;code>IIOMetadata&lt;/code> object that will&#xA;     * be used for writing, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @return the number of thumbnails that may be written given the&#xA;     * supplied parameters, or &lt;code>-1&lt;/code> if insufficient&#xA;     * information is available.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPreferredThumbnailSizes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/awt/Dimension.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageTypeSpecifier.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="param">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="streamMetadata">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageMetadata">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an array of &lt;code>Dimension&lt;/code>s indicating the&#xA;     * legal size ranges for thumbnail images as they will be encoded&#xA;     * in the output file or stream.  This information is merely&#xA;     * advisory; the writer will resize any supplied thumbnails as&#xA;     * necessary.&#xA;     *&#xA;     * &lt;p> The information is returned as a set of pairs; the first&#xA;     * element of a pair contains an (inclusive) minimum width and&#xA;     * height, and the second element contains an (inclusive) maximum&#xA;     * width and height.  Together, each pair defines a valid range of&#xA;     * sizes.  To specify a fixed size, the same width and height will&#xA;     * appear for both elements.  A return value of &lt;code>null&lt;/code>&#xA;     * indicates that the size is arbitrary or unknown.&#xA;     *&#xA;     * &lt;p> An &lt;code>ImageWriteParam&lt;/code> may optionally be supplied&#xA;     * for cases where it may affect thumbnail handling.&#xA;     *&#xA;     * &lt;p> If the supplied &lt;code>ImageWriteParam&lt;/code> contains&#xA;     * optional setting values not supported by this writer (&lt;i>e.g.&lt;/i>&#xA;     * progressive encoding or any format-specific settings), they&#xA;     * will be ignored.&#xA;     *&#xA;     * &lt;p> The default implementation returns &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @param imageType an &lt;code>ImageTypeSpecifier&lt;/code> indicating the&#xA;     * type of image to be written, or &lt;code>null&lt;/code>.&#xA;     * @param param the &lt;code>ImageWriteParam&lt;/code> that will be used for&#xA;     * writing, or &lt;code>null&lt;/code>.&#xA;     * @param streamMetadata an &lt;code>IIOMetadata&lt;/code> object that will&#xA;     * be used for writing, or &lt;code>null&lt;/code>.&#xA;     * @param imageMetadata an &lt;code>IIOMetadata&lt;/code> object that will&#xA;     * be used for writing, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @return an array of &lt;code>Dimension&lt;/code>s with an even length&#xA;     * of at least two, or &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canWriteRasters">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if the methods that take an&#xA;     * &lt;code>IIOImage&lt;/code> parameter are capable of dealing with a&#xA;     * &lt;code>Raster&lt;/code> (as opposed to &lt;code>RenderedImage&lt;/code>)&#xA;     * source image.  If this method returns &lt;code>false&lt;/code>, then&#xA;     * those methods will throw an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code> if supplied with an&#xA;     * &lt;code>IIOImage&lt;/code> containing a &lt;code>Raster&lt;/code>.&#xA;     *&#xA;     * &lt;p> The default implementation returns &lt;code>false&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if &lt;code>Raster&lt;/code> sources are&#xA;     * supported.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="streamMetadata">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="image">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="IIOImage.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="param">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends a complete image stream containing a single image and&#xA;     * associated stream and image metadata and thumbnails to the&#xA;     * output.  Any necessary header information is included.  If the&#xA;     * output is an &lt;code>ImageOutputStream&lt;/code>, its existing&#xA;     * contents prior to the current seek position are not affected,&#xA;     * and need not be readable or writable.&#xA;     *&#xA;     * &lt;p> The output must have been set beforehand using the&#xA;     * &lt;code>setOutput&lt;/code> method.&#xA;     *&#xA;     * &lt;p> Stream metadata may optionally be supplied; if it is&#xA;     * &lt;code>null&lt;/code>, default stream metadata will be used.&#xA;     *&#xA;     * &lt;p> If &lt;code>canWriteRasters&lt;/code> returns &lt;code>true&lt;/code>,&#xA;     * the &lt;code>IIOImage&lt;/code> may contain a &lt;code>Raster&lt;/code>&#xA;     * source.  Otherwise, it must contain a&#xA;     * &lt;code>RenderedImage&lt;/code> source.&#xA;     *&#xA;     * &lt;p> The supplied thumbnails will be resized if needed, and any&#xA;     * thumbnails in excess of the supported number will be ignored.&#xA;     * If the format requires additional thumbnails that are not&#xA;     * provided, the writer should generate them internally.&#xA;     *&#xA;     * &lt;p>  An &lt;code>ImageWriteParam&lt;/code> may&#xA;     * optionally be supplied to control the writing process.  If&#xA;     * &lt;code>param&lt;/code> is &lt;code>null&lt;/code>, a default write param&#xA;     * will be used.&#xA;     *&#xA;     * &lt;p> If the supplied &lt;code>ImageWriteParam&lt;/code> contains&#xA;     * optional setting values not supported by this writer (&lt;i>e.g.&lt;/i>&#xA;     * progressive encoding or any format-specific settings), they&#xA;     * will be ignored.&#xA;     *&#xA;     * @param streamMetadata an &lt;code>IIOMetadata&lt;/code> object representing&#xA;     * stream metadata, or &lt;code>null&lt;/code> to use default values.&#xA;     * @param image an &lt;code>IIOImage&lt;/code> object containing an&#xA;     * image, thumbnails, and metadata to be written.&#xA;     * @param param an &lt;code>ImageWriteParam&lt;/code>, or&#xA;     * &lt;code>null&lt;/code> to use a default&#xA;     * &lt;code>ImageWriteParam&lt;/code>.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception UnsupportedOperationException if &lt;code>image&lt;/code>&#xA;     * contains a &lt;code>Raster&lt;/code> and &lt;code>canWriteRasters&lt;/code>&#xA;     * returns &lt;code>false&lt;/code>.&#xA;     * @exception IllegalArgumentException if &lt;code>image&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IOException if an error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="image">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="IIOImage.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends a complete image stream containing a single image with&#xA;     * default metadata and thumbnails to the output.  This method is&#xA;     * a shorthand for &lt;code>write(null, image, null)&lt;/code>.&#xA;     *&#xA;     * @param image an &lt;code>IIOImage&lt;/code> object containing an&#xA;     * image, thumbnails, and metadata to be written.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception IllegalArgumentException if &lt;code>image&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception UnsupportedOperationException if &lt;code>image&lt;/code>&#xA;     * contains a &lt;code>Raster&lt;/code> and &lt;code>canWriteRasters&lt;/code>&#xA;     * returns &lt;code>false&lt;/code>.&#xA;     * @exception IOException if an error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="literals:NullLiteral"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
          <arguments xsi:type="literals:NullLiteral"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="image">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../java/awt/image/RenderedImage.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends a complete image stream consisting of a single image&#xA;     * with default metadata and thumbnails to the output.  This&#xA;     * method is a shorthand for &lt;code>write(null, new IIOImage(image,&#xA;     * null, null), null)&lt;/code>.&#xA;     *&#xA;     * @param image a &lt;code>RenderedImage&lt;/code> to be written.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception IllegalArgumentException if &lt;code>image&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IOException if an error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="literals:NullLiteral"/>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IIOImage.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="literals:NullLiteral"/>
          </arguments>
          <arguments xsi:type="literals:NullLiteral"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="unsupported">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Check that the output has been set, then throw an</comments>
        <comments>// UnsupportedOperationException.</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="getOutput() == null!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../java/lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="Unsupported write variant!"/>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canWriteSequence">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Sequence writes</comments>
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if the writer is able to append an&#xA;     * image to an image stream that already contains header&#xA;     * information and possibly prior images.&#xA;     *&#xA;     * &lt;p> If &lt;code>canWriteSequence&lt;/code> returns &lt;code>false&lt;/code>,&#xA;     * &lt;code>writeToSequence&lt;/code> and &lt;code>endWriteSequence&lt;/code>&#xA;     * will throw an &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * &lt;p> The default implementation returns &lt;code>false&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if images may be appended sequentially.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="prepareWriteSequence">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="streamMetadata">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Prepares a stream to accept a series of subsequent &#xA;     * &lt;code>writeToSequence&lt;/code> calls, using the provided stream&#xA;     * metadata object.  The metadata will be written to the stream if&#xA;     * it should precede the image data.  If the argument is &lt;code>null&lt;/code>,&#xA;     * default stream metadata is used.&#xA;     *&#xA;     * &lt;p> If the output is an &lt;code>ImageOutputStream&lt;/code>, the existing&#xA;     * contents of the output prior to the current seek position are&#xA;     * flushed, and need not be readable or writable.  If the format&#xA;     * requires that &lt;code>endWriteSequence&lt;/code> be able to rewind to&#xA;     * patch up the header information, such as for a sequence of images&#xA;     * in a single TIFF file, then the metadata written by this method&#xA;     * must remain in a writable portion of the stream.  Other formats&#xA;     * may flush the stream after this method and after each image.&#xA;     *&#xA;     * &lt;p> If &lt;code>canWriteSequence&lt;/code> returns &lt;code>false&lt;/code>,&#xA;     * this method will throw an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * &lt;p> The output must have been set beforehand using either&#xA;     * the &lt;code>setOutput&lt;/code> method.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param streamMetadata A stream metadata object, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canWriteSequence&lt;/code> returns &lt;code>false&lt;/code>.&#xA;     * @exception IOException if an error occurs writing the stream&#xA;     * metadata.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeToSequence">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="image">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="IIOImage.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="param">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends a single image and possibly associated metadata and&#xA;     * thumbnails, to the output.  If the output is an&#xA;     * &lt;code>ImageOutputStream&lt;/code>, the existing contents of the&#xA;     * output prior to the current seek position may be flushed, and&#xA;     * need not be readable or writable, unless the plug-in needs to &#xA;     * be able to patch up the header information when &#xA;     * &lt;code>endWriteSequence&lt;/code> is called (&lt;italic>e.g.&lt;/italic> TIFF).&#xA;     *&#xA;     * &lt;p> If &lt;code>canWriteSequence&lt;/code> returns &lt;code>false&lt;/code>,&#xA;     * this method will throw an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * &lt;p> The output must have been set beforehand using &#xA;     * the &lt;code>setOutput&lt;/code> method.&#xA;     *&#xA;     * &lt;p> &lt;code>prepareWriteSequence&lt;/code> must have been called&#xA;     * beforehand, or an &lt;code>IllegalStateException&lt;/code> is thrown.&#xA;     *&#xA;     * &lt;p> If &lt;code>canWriteRasters&lt;/code> returns &lt;code>true&lt;/code>,&#xA;     * the &lt;code>IIOImage&lt;/code> may contain a &lt;code>Raster&lt;/code>&#xA;     * source.  Otherwise, it must contain a&#xA;     * &lt;code>RenderedImage&lt;/code> source.&#xA;     *&#xA;     * &lt;p> The supplied thumbnails will be resized if needed, and any&#xA;     * thumbnails in excess of the supported number will be ignored.&#xA;     * If the format requires additional thumbnails that are not&#xA;     * provided, the writer will generate them internally.&#xA;     *&#xA;     * &lt;p> An &lt;code>ImageWriteParam&lt;/code> may optionally be supplied&#xA;     * to control the writing process.  If &lt;code>param&lt;/code> is&#xA;     * &lt;code>null&lt;/code>, a default write param will be used.&#xA;     *&#xA;     * &lt;p> If the supplied &lt;code>ImageWriteParam&lt;/code> contains&#xA;     * optional setting values not supported by this writer (&lt;i>e.g.&lt;/i>&#xA;     * progressive encoding or any format-specific settings), they&#xA;     * will be ignored.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     * &#xA;     * @param image an &lt;code>IIOImage&lt;/code> object containing an&#xA;     * image, thumbnails, and metadata to be written.&#xA;     * @param param an &lt;code>ImageWriteParam&lt;/code>, or&#xA;     * &lt;code>null&lt;/code> to use a default&#xA;     * &lt;code>ImageWriteParam&lt;/code>.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set, or &lt;code>prepareWriteSequence&lt;/code> has not been called.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canWriteSequence&lt;/code> returns &lt;code>false&lt;/code>.&#xA;     * @exception IllegalArgumentException if &lt;code>image&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception UnsupportedOperationException if &lt;code>image&lt;/code>&#xA;     * contains a &lt;code>Raster&lt;/code> and &lt;code>canWriteRasters&lt;/code>&#xA;     * returns &lt;code>false&lt;/code>.&#xA;     * @exception IOException if an error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="endWriteSequence">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Completes the writing of a sequence of images begun with&#xA;     * &lt;code>prepareWriteSequence&lt;/code>.  Any stream metadata that&#xA;     * should come at the end of the sequence of images is written out,&#xA;     * and any header information at the beginning of the sequence is&#xA;     * patched up if necessary.  If the output is an&#xA;     * &lt;code>ImageOutputStream&lt;/code>, data through the stream metadata&#xA;     * at the end of the sequence are flushed and need not be readable&#xA;     * or writable.&#xA;     *&#xA;     * &lt;p> If &lt;code>canWriteSequence&lt;/code> returns &lt;code>false&lt;/code>,&#xA;     * this method will throw an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     * &#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set, or &lt;code>prepareWriteSequence&lt;/code> has not been called.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canWriteSequence&lt;/code> returns &lt;code>false&lt;/code>.&#xA;     * @exception IOException if an error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canReplaceStreamMetadata">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Metadata replacement</comments>
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if it is possible to replace the&#xA;     * stream metadata already present in the output.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise returns &lt;code>false&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if replacement of stream metadata is&#xA;     * allowed.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception IOException if an I/O error occurs during the query.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="getOutput() == null!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="replaceStreamMetadata">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="streamMetadata">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Replaces the stream metadata in the output with new&#xA;     * information.  If the output is an&#xA;     * &lt;code>ImageOutputStream&lt;/code>, the prior contents of the&#xA;     * stream are examined and possibly edited to make room for the&#xA;     * new data.  All of the prior contents of the output must be&#xA;     * available for reading and writing.&#xA;     *&#xA;     * &lt;p> If &lt;code>canReplaceStreamMetadata&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>, an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param streamMetadata an &lt;code>IIOMetadata&lt;/code> object representing&#xA;     * stream metadata, or &lt;code>null&lt;/code> to use default values.&#xA;     * &#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception UnsupportedOperationException if the&#xA;     * &lt;code>canReplaceStreamMetadata&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>.  modes do not include&#xA;     * @exception IOException if an error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canReplaceImageMetadata">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if it is possible to replace the&#xA;     * image metadata associated with an existing image with index&#xA;     * &lt;code>imageIndex&lt;/code>.  If this method returns&#xA;     * &lt;code>false&lt;/code>, a call to&#xA;     * &lt;code>replaceImageMetadata(imageIndex)&lt;/code> will throw an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * &lt;p> A writer that does not support any image metadata&#xA;     * replacement may return &lt;code>false&lt;/code> without performing&#xA;     * bounds checking on the index.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise returns &lt;code>false&lt;/code>&#xA;     * without checking the value of &lt;code>imageIndex&lt;/code>.&#xA;     * &#xA;     * @param imageIndex the index of the image whose metadata is to&#xA;     * be replaced.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if the image metadata of the given&#xA;     * image can be replaced.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception IndexOutOfBoundsException if the writer supports&#xA;     * image metadata replacement in general, but&#xA;     * &lt;code>imageIndex&lt;/code> is less than 0 or greater than the&#xA;     * largest available index.&#xA;     * @exception IOException if an I/O error occurs during the query.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="getOutput() == null!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="replaceImageMetadata">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageMetadata">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Replaces the image metadata associated with an existing image.&#xA;     *&#xA;     * &lt;p> If &lt;code>canReplaceImageMetadata(imageIndex)&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>, an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code> will be thrown.&#xA;     * &#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param imageIndex the index of the image whose metadata is to&#xA;     * be replaced.&#xA;     * @param imageMetadata an &lt;code>IIOMetadata&lt;/code> object&#xA;     * representing image metadata, or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not been&#xA;     * set.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canReplaceImageMetadata&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>.&#xA;     * @exception IndexOutOfBoundsException if &lt;code>imageIndex&lt;/code>&#xA;     * is less than 0 or greater than the largest available index.&#xA;     * @exception IOException if an error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canInsertImage">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Image insertion</comments>
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if the writer supports the insertion&#xA;     * of a new image at the given index.  Existing images with&#xA;     * indices greater than or equal to the insertion index will have&#xA;     * their indices increased by 1.  A value for&#xA;     * &lt;code>imageIndex&lt;/code> of &lt;code>-1&lt;/code> may be used to&#xA;     * signify an index one larger than the current largest index.&#xA;     *&#xA;     * &lt;p> A writer that does not support any image insertion may&#xA;     * return &lt;code>false&lt;/code> without performing bounds checking on&#xA;     * the index.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise returns &lt;code>false&lt;/code>&#xA;     * withour checking the value of &lt;code>imageIndex&lt;/code>.&#xA;     *&#xA;     * @param imageIndex the index at which the image is to be&#xA;     * inserted.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if an image may be inserted at the&#xA;     * given index.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception IndexOutOfBoundsException if the writer supports&#xA;     * image insertion in general, but &lt;code>imageIndex&lt;/code> is less&#xA;     * than -1 or greater than the largest available index.&#xA;     * @exception IOException if an I/O error occurs during the query.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="getOutput() == null!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeInsert">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="image">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="IIOImage.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="param">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts a new image into an existing image stream.  Existing&#xA;     * images with an index greater than &lt;code>imageIndex&lt;/code> are&#xA;     * preserved, and their indices are each increased by 1.  A value&#xA;     * for &lt;code>imageIndex&lt;/code> of -1 may be used to signify an&#xA;     * index one larger than the previous largest index; that is, it&#xA;     * will cause the image to be logically appended to the end of the&#xA;     * sequence.  If the output is an &lt;code>ImageOutputStream&lt;/code>,&#xA;     * the entirety of the stream must be both readable and writeable.&#xA;     *&#xA;     * &lt;p> If &lt;code>canInsertImage(imageIndex)&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>, an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> An &lt;code>ImageWriteParam&lt;/code> may optionally be supplied&#xA;     * to control the writing process.  If &lt;code>param&lt;/code> is&#xA;     * &lt;code>null&lt;/code>, a default write param will be used.&#xA;     *&#xA;     * &lt;p> If the supplied &lt;code>ImageWriteParam&lt;/code> contains&#xA;     * optional setting values not supported by this writer (&lt;i>e.g.&lt;/i>&#xA;     * progressive encoding or any format-specific settings), they&#xA;     * will be ignored.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param imageIndex the index at which to write the image.&#xA;     * @param image an &lt;code>IIOImage&lt;/code> object containing an&#xA;     * image, thumbnails, and metadata to be written.&#xA;     * @param param an &lt;code>ImageWriteParam&lt;/code>, or&#xA;     * &lt;code>null&lt;/code> to use a default&#xA;     * &lt;code>ImageWriteParam&lt;/code>.&#xA;     * &#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canInsertImage(imageIndex)&lt;/code> returns &lt;code>false&lt;/code>.&#xA;     * @exception IllegalArgumentException if &lt;code>image&lt;/code> is&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception IndexOutOfBoundsException if &lt;code>imageIndex&lt;/code>&#xA;     * is less than -1 or greater than the largest available index.&#xA;     * @exception UnsupportedOperationException if &lt;code>image&lt;/code>&#xA;     * contains a &lt;code>Raster&lt;/code> and &lt;code>canWriteRasters&lt;/code>&#xA;     * returns &lt;code>false&lt;/code>.&#xA;     * @exception IOException if an error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canRemoveImage">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Image removal</comments>
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if the writer supports the removal&#xA;     * of an existing image at the given index.  Existing images with&#xA;     * indices greater than the insertion index will have&#xA;     * their indices decreased by 1.&#xA;     *&#xA;     * &lt;p> A writer that does not support any image removal may&#xA;     * return &lt;code>false&lt;/code> without performing bounds checking on&#xA;     * the index.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise returns &lt;code>false&lt;/code>&#xA;     * without checking the value of &lt;code>imageIndex&lt;/code>.&#xA;     *&#xA;     * @param imageIndex the index of the image to be removed.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if it is possible to remove the given&#xA;     * image.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception IndexOutOfBoundsException if the writer supports&#xA;     * image removal in general, but &lt;code>imageIndex&lt;/code> is less&#xA;     * than 0 or greater than the largest available index.&#xA;     * @exception IOException if an I/O error occurs during the&#xA;     * query.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="getOutput() == null!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeImage">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes an image from the stream.&#xA;     *&#xA;     * &lt;p> If &lt;code>canRemoveImage(imageIndex)&lt;/code> returns false,&#xA;     * an &lt;code>UnsupportedOperationException&lt;/code>will be thrown.&#xA;     *&#xA;     * &lt;p> The removal may or may not cause a reduction in the actual&#xA;     * file size.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param imageIndex the index of the image to be removed.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canRemoveImage(imageIndex)&lt;/code> returns &lt;code>false&lt;/code>.&#xA;     * @exception IndexOutOfBoundsException if &lt;code>imageIndex&lt;/code>&#xA;     * is less than 0 or greater than the largest available index.&#xA;     * @exception IOException if an I/O error occurs during the&#xA;     * removal.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canWriteEmpty">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Empty images</comments>
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if the writer supports the writing of&#xA;     * a complete image stream consisting of a single image with&#xA;     * undefined pixel values and associated metadata and thumbnails&#xA;     * to the output.  The pixel values may be defined by future&#xA;     * calls to the &lt;code>replacePixels&lt;/code> methods.  If the output&#xA;     * is an &lt;code>ImageOutputStream&lt;/code>, its existing contents&#xA;     * prior to the current seek position are not affected, and need&#xA;     * not be readable or writable.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise returns &lt;code>false&lt;/code>.&#xA;     * &#xA;     * @return &lt;code>true&lt;/code> if the writing of complete image&#xA;     * stream with contents to be defined later is supported.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not been&#xA;     * set.&#xA;     * @exception IOException if an I/O error occurs during the&#xA;     * query.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="getOutput() == null!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="prepareWriteEmpty">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="streamMetadata">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageTypeSpecifier.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageMetadata">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="thumbnails">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/awt/image/BufferedImage.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../../java/util/List.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="param">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Begins the writing of a complete image stream, consisting of a&#xA;     * single image with undefined pixel values and associated&#xA;     * metadata and thumbnails, to the output.  The pixel values will&#xA;     * be defined by future calls to the &lt;code>replacePixels&lt;/code>&#xA;     * methods.  If the output is an &lt;code>ImageOutputStream&lt;/code>,&#xA;     * its existing contents prior to the current seek position are&#xA;     * not affected, and need not be readable or writable.&#xA;     *&#xA;     * &lt;p> The writing is not complete until a call to&#xA;     * &lt;code>endWriteEmpty&lt;/code> occurs.  Calls to&#xA;     * &lt;code>prepareReplacePixels&lt;/code>, &lt;code>replacePixels&lt;/code>,&#xA;     * and &lt;code>endReplacePixels&lt;/code> may occur between calls to&#xA;     * &lt;code>prepareWriteEmpty&lt;/code> and &lt;code>endWriteEmpty&lt;/code>.&#xA;     * However, calls to &lt;code>prepareWriteEmpty&lt;/code> cannot be&#xA;     * nested, and calls to &lt;code>prepareWriteEmpty&lt;/code> and&#xA;     * &lt;code>prepareInsertEmpty&lt;/code> may not be interspersed.&#xA;     *&#xA;     * &lt;p> If &lt;code>canWriteEmpty&lt;/code> returns &lt;code>false&lt;/code>,&#xA;     * an &lt;code>UnsupportedOperationException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> An &lt;code>ImageWriteParam&lt;/code> may optionally be supplied&#xA;     * to control the writing process.  If &lt;code>param&lt;/code> is&#xA;     * &lt;code>null&lt;/code>, a default write param will be used.&#xA;     *&#xA;     * &lt;p> If the supplied &lt;code>ImageWriteParam&lt;/code> contains&#xA;     * optional setting values not supported by this writer (&lt;i>e.g.&lt;/i>&#xA;     * progressive encoding or any format-specific settings), they&#xA;     * will be ignored.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param streamMetadata an &lt;code>IIOMetadata&lt;/code> object representing&#xA;     * stream metadata, or &lt;code>null&lt;/code> to use default values.&#xA;     * @param imageType an &lt;code>ImageTypeSpecifier&lt;/code> describing&#xA;     * the layout of the image.&#xA;     * @param width the width of the image.&#xA;     * @param height the height of the image.&#xA;     * @param imageMetadata an &lt;code>IIOMetadata&lt;/code> object&#xA;     * representing image metadata, or &lt;code>null&lt;/code>.&#xA;     * @param thumbnails a &lt;code>List&lt;/code> of&#xA;     * &lt;code>BufferedImage&lt;/code> thumbnails for this image, or&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @param param an &lt;code>ImageWriteParam&lt;/code>, or&#xA;     * &lt;code>null&lt;/code> to use a default&#xA;     * &lt;code>ImageWriteParam&lt;/code>.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canWriteEmpty&lt;/code> returns &lt;code>false&lt;/code>.&#xA;     * @exception IllegalStateException if a previous call to&#xA;     * &lt;code>prepareWriteEmpty&lt;/code> has been made without a&#xA;     * corresponding call to &lt;code>endWriteEmpty&lt;/code>.&#xA;     * @exception IllegalStateException if a previous call to&#xA;     * &lt;code>prepareInsertEmpty&lt;/code> has been made without a&#xA;     * corresponding call to &lt;code>endInsertEmpty&lt;/code>.&#xA;     * @exception IllegalArgumentException if &lt;code>imageType&lt;/code>&#xA;     * is &lt;code>null&lt;/code> or &lt;code>thumbnails&lt;/code> contains&#xA;     * &lt;code>null&lt;/code> references or objects other than&#xA;     * &lt;code>BufferedImage&lt;/code>s.&#xA;     * @exception IllegalArgumentException if width or height are less&#xA;     * than 1.&#xA;     * @exception IOException if an I/O error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="endWriteEmpty">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Completes the writing of a new image that was begun with a&#xA;     * prior call to &lt;code>prepareWriteEmpty&lt;/code>.&#xA;     *&#xA;     * &lt;p> If &lt;code>canWriteEmpty()&lt;/code> returns &lt;code>false&lt;/code>,&#xA;     * an &lt;code>UnsupportedOperationException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canWriteEmpty(imageIndex)&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>.&#xA;     * @exception IllegalStateException if a previous call to&#xA;     * &lt;code>prepareWriteEmpty&lt;/code> without a corresponding call to&#xA;     * &lt;code>endWriteEmpty&lt;/code> has not been made.&#xA;     * @exception IllegalStateException if a previous call to&#xA;     * &lt;code>prepareInsertEmpty&lt;/code> without a corresponding call to&#xA;     * &lt;code>endInsertEmpty&lt;/code> has been made.&#xA;     * @exception IllegalStateException if a call to&#xA;     * &lt;code>prepareReiplacePixels&lt;/code> has been made without a&#xA;     * matching call to &lt;code>endReplacePixels&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="getOutput() == null!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="No call to prepareWriteEmpty!"/>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canInsertEmpty">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if the writer supports the insertion&#xA;     * of a new, empty image at the given index.  The pixel values of&#xA;     * the image are undefined, and may be specified in pieces using&#xA;     * the &lt;code>replacePixels&lt;/code> methods.  Existing images with&#xA;     * indices greater than or equal to the insertion index will have&#xA;     * their indices increased by 1.  A value for&#xA;     * &lt;code>imageIndex&lt;/code> of &lt;code>-1&lt;/code> may be used to&#xA;     * signify an index one larger than the current largest index.&#xA;     *&#xA;     * &lt;p> A writer that does not support insertion of empty images&#xA;     * may return &lt;code>false&lt;/code> without performing bounds&#xA;     * checking on the index.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise returns &lt;code>false&lt;/code>&#xA;     * without checking the value of &lt;code>imageIndex&lt;/code>.&#xA;     * &#xA;     * @param imageIndex the index at which the image is to be&#xA;     * inserted.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if an empty image may be inserted at&#xA;     * the given index.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not been&#xA;     * set.&#xA;     * @exception IndexOutOfBoundsException if the writer supports&#xA;     * empty image insertion in general, but &lt;code>imageIndex&lt;/code>&#xA;     * is less than -1 or greater than the largest available index.&#xA;     * @exception IOException if an I/O error occurs during the&#xA;     * query.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="getOutput() == null!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="prepareInsertEmpty">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageTypeSpecifier.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageMetadata">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="metadata/IIOMetadata.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="thumbnails">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/awt/image/BufferedImage.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../../java/util/List.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="param">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Begins the insertion of a new image with undefined pixel values&#xA;     * into an existing image stream.  Existing images with an index&#xA;     * greater than &lt;code>imageIndex&lt;/code> are preserved, and their&#xA;     * indices are each increased by 1.  A value for&#xA;     * &lt;code>imageIndex&lt;/code> of -1 may be used to signify an index&#xA;     * one larger than the previous largest index; that is, it will&#xA;     * cause the image to be logically appended to the end of the&#xA;     * sequence.  If the output is an &lt;code>ImageOutputStream&lt;/code>,&#xA;     * the entirety of the stream must be both readable and writeable.&#xA;     *&#xA;     * &lt;p> The image contents may be&#xA;     * supplied later using the &lt;code>replacePixels&lt;/code> method.&#xA;     * The insertion is not complete until a call to&#xA;     * &lt;code>endInsertEmpty&lt;/code> occurs.  Calls to&#xA;     * &lt;code>prepareReplacePixels&lt;/code>, &lt;code>replacePixels&lt;/code>,&#xA;     * and &lt;code>endReplacePixels&lt;/code> may occur between calls to&#xA;     * &lt;code>prepareInsertEmpty&lt;/code> and&#xA;     * &lt;code>endInsertEmpty&lt;/code>.  However, calls to&#xA;     * &lt;code>prepareInsertEmpty&lt;/code> cannot be nested, and calls to&#xA;     * &lt;code>prepareWriteEmpty&lt;/code> and&#xA;     * &lt;code>prepareInsertEmpty&lt;/code> may not be interspersed.&#xA;     *&#xA;     * &lt;p> If &lt;code>canInsertEmpty(imageIndex)&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>, an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> An &lt;code>ImageWriteParam&lt;/code> may optionally be supplied&#xA;     * to control the writing process.  If &lt;code>param&lt;/code> is&#xA;     * &lt;code>null&lt;/code>, a default write param will be used.&#xA;     *&#xA;     * &lt;p> If the supplied &lt;code>ImageWriteParam&lt;/code> contains&#xA;     * optional setting values not supported by this writer (&lt;i>e.g.&lt;/i>&#xA;     * progressive encoding or any format-specific settings), they&#xA;     * will be ignored.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param imageIndex the index at which to write the image.&#xA;     * @param imageType an &lt;code>ImageTypeSpecifier&lt;/code> describing&#xA;     * the layout of the image.&#xA;     * @param width the width of the image.&#xA;     * @param height the height of the image.&#xA;     * @param imageMetadata an &lt;code>IIOMetadata&lt;/code> object&#xA;     * representing image metadata, or &lt;code>null&lt;/code>.&#xA;     * @param thumbnails a &lt;code>List&lt;/code> of&#xA;     * &lt;code>BufferedImage&lt;/code> thumbnails for this image, or&#xA;     * &lt;code>null&lt;/code>.&#xA;     * @param param an &lt;code>ImageWriteParam&lt;/code>, or&#xA;     * &lt;code>null&lt;/code> to use a default&#xA;     * &lt;code>ImageWriteParam&lt;/code>.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canInsertEmpty(imageIndex)&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>.&#xA;     * @exception IndexOutOfBoundsException if &lt;code>imageIndex&lt;/code>&#xA;     * is less than -1 or greater than the largest available index.&#xA;     * @exception IllegalStateException if a previous call to&#xA;     * &lt;code>prepareInsertEmpty&lt;/code> has been made without a&#xA;     * corresponding call to &lt;code>endInsertEmpty&lt;/code>.&#xA;     * @exception IllegalStateException if a previous call to&#xA;     * &lt;code>prepareWriteEmpty&lt;/code> has been made without a&#xA;     * corresponding call to &lt;code>endWriteEmpty&lt;/code>.&#xA;     * @exception IllegalArgumentException if &lt;code>imageType&lt;/code>&#xA;     * is &lt;code>null&lt;/code> or &lt;code>thumbnails&lt;/code> contains&#xA;     * &lt;code>null&lt;/code> references or objects other than&#xA;     * &lt;code>BufferedImage&lt;/code>s.&#xA;     * @exception IllegalArgumentException if width or height are less&#xA;     * than 1.&#xA;     * @exception IOException if an I/O error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="endInsertEmpty">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Completes the insertion of a new image that was begun with a&#xA;     * prior call to &lt;code>prepareInsertEmpty&lt;/code>.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canInsertEmpty(imageIndex)&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>.&#xA;     * @exception IllegalStateException if a previous call to&#xA;     * &lt;code>prepareInsertEmpty&lt;/code> without a corresponding call to&#xA;     * &lt;code>endInsertEmpty&lt;/code> has not been made.&#xA;     * @exception IllegalStateException if a previous call to&#xA;     * &lt;code>prepareWriteEmpty&lt;/code> without a corresponding call to&#xA;     * &lt;code>endWriteEmpty&lt;/code> has been made.&#xA;     * @exception IllegalStateException if a call to&#xA;     * &lt;code>prepareReplacePixels&lt;/code> has been made without a&#xA;     * matching call to &lt;code>endReplacePixels&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canReplacePixels">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Pixel replacement</comments>
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if the writer allows pixels of the&#xA;     * given image to be replaced using the &lt;code>replacePixels&lt;/code>&#xA;     * methods.&#xA;     *&#xA;     * &lt;p> A writer that does not support any pixel replacement may&#xA;     * return &lt;code>false&lt;/code> without performing bounds checking on&#xA;     * the index.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise returns &lt;code>false&lt;/code>&#xA;     * without checking the value of &lt;code>imageIndex&lt;/code>.&#xA;     *&#xA;     * @param imageIndex the index of the image whose pixels are to be&#xA;     * replaced.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if the pixels of the given&#xA;     * image can be replaced.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not been&#xA;     * set.&#xA;     * @exception IndexOutOfBoundsException if the writer supports&#xA;     * pixel replacement in general, but &lt;code>imageIndex&lt;/code> is&#xA;     * less than 0 or greater than the largest available index.&#xA;     * @exception IOException if an I/O error occurs during the query.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="getOutput() == null!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="prepareReplacePixels">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="region">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Prepares the writer to handle a series of calls to the&#xA;     * &lt;code>replacePixels&lt;/code> methods.  The affected pixel area&#xA;     * will be clipped against the supplied&#xA;     *&#xA;     * &lt;p> If &lt;code>canReplacePixels&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>, and&#xA;     * &lt;code>UnsupportedOperationException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param imageIndex the index of the image whose pixels are to be&#xA;     * replaced.&#xA;     * @param region a &lt;code>Rectangle&lt;/code> that will be used to clip&#xA;     * future pixel regions.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canReplacePixels(imageIndex)&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>.&#xA;     * @exception IndexOutOfBoundsException if &lt;code>imageIndex&lt;/code>&#xA;     * is less than 0 or greater than the largest available index.&#xA;     * @exception IllegalStateException if there is a previous call to&#xA;     * &lt;code>prepareReplacePixels&lt;/code> without a matching call to&#xA;     * &lt;code>endReplacePixels&lt;/code> (&lt;i>i.e.&lt;/i>, nesting is not&#xA;     * allowed).&#xA;     * @exception IllegalArgumentException if &lt;code>region&lt;/code> is&#xA;     * &lt;code>null&lt;/code> or has a width or height less than 1.&#xA;     * @exception IOException if an I/O error occurs during the&#xA;     * preparation.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="replacePixels">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="image">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../java/awt/image/RenderedImage.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="param">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Replaces a portion of an image already present in the output&#xA;     * with a portion of the given image.  The image data must match,&#xA;     * or be convertible to, the image layout of the existing image.&#xA;     *&#xA;     * &lt;p> The destination region is specified in the&#xA;     * &lt;code>param&lt;/code> argument, and will be clipped to the image&#xA;     * boundaries and the region supplied to&#xA;     * &lt;code>prepareReplacePixels&lt;/code>.  At least one pixel of the&#xA;     * source must not be clipped, or an exception is thrown.&#xA;     *&#xA;     * &lt;p> An &lt;code>ImageWriteParam&lt;/code> may optionally be supplied&#xA;     * to control the writing process.  If &lt;code>param&lt;/code> is&#xA;     * &lt;code>null&lt;/code>, a default write param will be used.&#xA;     *&#xA;     * &lt;p> If the supplied &lt;code>ImageWriteParam&lt;/code> contains&#xA;     * optional setting values not supported by this writer (&lt;i>e.g.&lt;/i>&#xA;     * progressive encoding or any format-specific settings), they&#xA;     * will be ignored.&#xA;     *&#xA;     * &lt;p> This method may only be called after a call to&#xA;     * &lt;code>prepareReplacePixels&lt;/code>, or else an&#xA;     * &lt;code>IllegalStateException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param image a &lt;code>RenderedImage&lt;/code> containing source&#xA;     * pixels.&#xA;     * @param param an &lt;code>ImageWriteParam&lt;/code>, or&#xA;     * &lt;code>null&lt;/code> to use a default&#xA;     * &lt;code>ImageWriteParam&lt;/code>.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canReplacePixels(imageIndex)&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>.&#xA;     * @exception IllegalStateException if there is no previous call to&#xA;     * &lt;code>prepareReplacePixels&lt;/code> without a matching call to&#xA;     * &lt;code>endReplacePixels&lt;/code>.&#xA;     * @exception IllegalArgumentException if any of the following are true:&#xA;     * &lt;li> &lt;code>image&lt;/code> is &lt;code>null&lt;/code>.&#xA;     * &lt;li> &lt;code>param&lt;/code> is &lt;code>null&lt;/code>.&#xA;     * &lt;li> the intersected region does not contain at least one pixel.&#xA;     * &lt;li> the layout of &lt;code>image&lt;/code> does not match, or this&#xA;     * writer cannot convert it to, the existing image layout.&#xA;     * &lt;/ul>&#xA;     * @exception IOException if an I/O error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="replacePixels">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="raster">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/awt/image/Raster.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="param">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageWriteParam.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Replaces a portion of an image already present in the output&#xA;     * with a portion of the given &lt;code>Raster&lt;/code>.  The image&#xA;     * data must match, or be convertible to, the image layout of the&#xA;     * existing image.&#xA;     *&#xA;     * &lt;p> An &lt;code>ImageWriteParam&lt;/code> may optionally be supplied&#xA;     * to control the writing process.  If &lt;code>param&lt;/code> is&#xA;     * &lt;code>null&lt;/code>, a default write param will be used.&#xA;     *&#xA;     * &lt;p> The destination region is specified in the&#xA;     * &lt;code>param&lt;/code> argument, and will be clipped to the image&#xA;     * boundaries and the region supplied to&#xA;     * &lt;code>prepareReplacePixels&lt;/code>.  At least one pixel of the&#xA;     * source must not be clipped, or an exception is thrown.&#xA;     *&#xA;     * &lt;p> If the supplied &lt;code>ImageWriteParam&lt;/code> contains&#xA;     * optional setting values not supported by this writer (&lt;i>e.g.&lt;/i>&#xA;     * progressive encoding or any format-specific settings), they&#xA;     * will be ignored.&#xA;     *&#xA;     * &lt;p> This method may only be called after a call to&#xA;     * &lt;code>prepareReplacePixels&lt;/code>, or else an&#xA;     * &lt;code>IllegalStateException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param raster a &lt;code>Raster&lt;/code> containing source&#xA;     * pixels.&#xA;     * @param param an &lt;code>ImageWriteParam&lt;/code>, or&#xA;     * &lt;code>null&lt;/code> to use a default&#xA;     * &lt;code>ImageWriteParam&lt;/code>.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canReplacePixels(imageIndex)&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>.&#xA;     * @exception IllegalStateException if there is no previous call to&#xA;     * &lt;code>prepareReplacePixels&lt;/code> without a matching call to&#xA;     * &lt;code>endReplacePixels&lt;/code>.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canWriteRasters&lt;/code> returns &lt;code>false&lt;/code>.&#xA;     * @exception IllegalArgumentException if any of the following are true:&#xA;     * &lt;li> &lt;code>raster&lt;/code> is &lt;code>null&lt;/code>.&#xA;     * &lt;li> &lt;code>param&lt;/code> is &lt;code>null&lt;/code>.&#xA;     * &lt;li> the intersected region does not contain at least one pixel.&#xA;     * &lt;li> the layout of &lt;code>raster&lt;/code> does not match, or this&#xA;     * writer cannot convert it to, the existing image layout.&#xA;     * &lt;/ul>&#xA;     * @exception IOException if an I/O error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="endReplacePixels">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Terminates a sequence of calls to &lt;code>replacePixels&lt;/code>.&#xA;     *&#xA;     * &lt;p> If &lt;code>canReplacePixels&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>, and&#xA;     * &lt;code>UnsupportedOperationException&lt;/code> will be thrown.&#xA;     *&#xA;     * &lt;p> The default implementation throws an&#xA;     * &lt;code>IllegalStateException&lt;/code> if the output is&#xA;     * &lt;code>null&lt;/code>, and otherwise throws an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @exception IllegalStateException if the output has not&#xA;     * been set.&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>canReplacePixels(imageIndex)&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>.&#xA;     * @exception IllegalStateException if there is no previous call&#xA;     * to &lt;code>prepareReplacePixels&lt;/code> without a matching call to&#xA;     * &lt;code>endReplacePixels&lt;/code>.&#xA;     * @exception IOException if an I/O error occurs during writing.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="abort">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Abort</comments>
        <comments>/**&#xA;     * Requests that any current write operation be aborted.  The&#xA;     * contents of the output following the abort will be undefined.&#xA;     *&#xA;     * &lt;p> Writers should call &lt;code>clearAbortRequest&lt;/code> at the&#xA;     * beginning of each write operation, and poll the value of&#xA;     * &lt;code>abortRequested&lt;/code> regularly during the write.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="abortRequested">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if a request to abort the current&#xA;     * write operation has been made since the writer was instantiated or&#xA;     * &lt;code>clearAbortRequest&lt;/code> was called.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if the current write operation should&#xA;     * be aborted.&#xA;     *&#xA;     * @see #abort&#xA;     * @see #clearAbortRequest&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clearAbortRequest">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Clears any previous abort request.  After this method has been&#xA;     * called, &lt;code>abortRequested&lt;/code> will return&#xA;     * &lt;code>false&lt;/code>.&#xA;     *&#xA;     * @see #abort&#xA;     * @see #abortRequested&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="addIIOWriteWarningListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="event/IIOWriteWarningListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Listeners</comments>
        <comments>/**&#xA;     * Adds an &lt;code>IIOWriteWarningListener&lt;/code> to the list of&#xA;     * registered warning listeners.  If &lt;code>listener&lt;/code> is&#xA;     * &lt;code>null&lt;/code>, no exception will be thrown and no action&#xA;     * will be taken.  Messages sent to the given listener will be&#xA;     * localized, if possible, to match the current&#xA;     * &lt;code>Locale&lt;/code>.  If no &lt;code>Locale&lt;/code> has been set,&#xA;     * warning messages may be localized as the writer sees fit.&#xA;     *&#xA;     * @param listener an &lt;code>IIOWriteWarningListener&lt;/code> to be&#xA;     * registered.&#xA;     *&#xA;     * @see #removeIIOWriteWarningListener&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="ImageReader.class.xmi#//@classifiers.0/@members.61"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="ImageReader.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="ImageReader.class.xmi#//@classifiers.0/@members.61"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.14"/>
            </next>
            <target xsi:type="classifiers:Class" href="ImageReader.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeIIOWriteWarningListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="event/IIOWriteWarningListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes an &lt;code>IIOWriteWarningListener&lt;/code> from the list&#xA;     * of registered warning listeners.  If the listener was not&#xA;     * previously registered, or if &lt;code>listener&lt;/code> is&#xA;     * &lt;code>null&lt;/code>, no exception will be thrown and no action&#xA;     * will be taken.&#xA;     *&#xA;     * @param listener an &lt;code>IIOWriteWarningListener&lt;/code> to be&#xA;     * deregistered.&#xA;     *&#xA;     * @see #addIIOWriteWarningListener&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="index">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.20"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.1/@variable"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.1/@variable"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:NullLiteral"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:NullLiteral"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.1/@variable"/>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </children>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeAllIIOWriteWarningListeners">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes all currently registered&#xA;     * &lt;code>IIOWriteWarningListener&lt;/code> objects.&#xA;     *&#xA;     * &lt;p> The default implementation sets the&#xA;     * &lt;code>warningListeners&lt;/code> and &lt;code>warningLocales&lt;/code>&#xA;     * instance variables to &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:NullLiteral"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:NullLiteral"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="addIIOWriteProgressListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds an &lt;code>IIOWriteProgressListener&lt;/code> to the list of&#xA;     * registered progress listeners.  If &lt;code>listener&lt;/code> is&#xA;     * &lt;code>null&lt;/code>, no exception will be thrown and no action&#xA;     * will be taken.&#xA;     *&#xA;     * @param listener an &lt;code>IIOWriteProgressListener&lt;/code> to be&#xA;     * registered.&#xA;     *&#xA;     * @see #removeIIOWriteProgressListener&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="ImageReader.class.xmi#//@classifiers.0/@members.61"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="ImageReader.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeIIOWriteProgressListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes an &lt;code>IIOWriteProgressListener&lt;/code> from the list&#xA;     * of registered progress listeners.  If the listener was not&#xA;     * previously registered, or if &lt;code>listener&lt;/code> is&#xA;     * &lt;code>null&lt;/code>, no exception will be thrown and no action&#xA;     * will be taken.&#xA;     *&#xA;     * @param listener an &lt;code>IIOWriteProgressListener&lt;/code> to be&#xA;     * deregistered.&#xA;     *&#xA;     * @see #addIIOWriteProgressListener&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="ImageReader.class.xmi#//@classifiers.0/@members.62"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="ImageReader.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeAllIIOWriteProgressListeners">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes all currently registered&#xA;     * &lt;code>IIOWriteProgressListener&lt;/code> objects.&#xA;     *&#xA;     * &lt;p> The default implementation sets the&#xA;     * &lt;code>progressListeners&lt;/code> instance variable to&#xA;     * &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:NullLiteral"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="processImageStarted">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Broadcasts the start of an image write to all registered&#xA;     * &lt;code>IIOWriteProgressListener&lt;/code>s by calling their&#xA;     * &lt;code>imageStarted&lt;/code> method.  Subclasses may use this&#xA;     * method as a convenience.&#xA;     *&#xA;     * @param imageIndex the index of the image about to be written.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="numListeners">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="listener">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.16"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.2/@init"/>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.2/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0/@members.0"/>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.0"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.2/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="processImageProgress">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="percentageDone">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Broadcasts the current percentage of image completion to all&#xA;     * registered &lt;code>IIOWriteProgressListener&lt;/code>s by calling&#xA;     * their &lt;code>imageProgress&lt;/code> method.  Subclasses may use&#xA;     * this method as a convenience.&#xA;     *&#xA;     * @param percentageDone the current percentage of completion,&#xA;     * as a &lt;code>float&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="numListeners">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="listener">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.16"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.2/@init"/>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.2/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0/@members.1"/>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.0"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.2/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="processImageComplete">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Broadcasts the completion of an image write to all registered&#xA;     * &lt;code>IIOWriteProgressListener&lt;/code>s by calling their&#xA;     * &lt;code>imageComplete&lt;/code> method.  Subclasses may use this&#xA;     * method as a convenience.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="numListeners">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="listener">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.16"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.2/@init"/>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.2/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0/@members.2"/>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.2/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="processThumbnailStarted">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="thumbnailIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Broadcasts the start of a thumbnail write to all registered&#xA;     * &lt;code>IIOWriteProgressListener&lt;/code>s by calling their&#xA;     * &lt;code>thumbnailStarted&lt;/code> method.  Subclasses may use this&#xA;     * method as a convenience.&#xA;     *&#xA;     * @param imageIndex the index of the image associated with the&#xA;     * thumbnail.&#xA;     * @param thumbnailIndex the index of the thumbnail.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="numListeners">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="listener">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.16"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@statements.2/@init"/>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@statements.2/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0/@members.3"/>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@parameters.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@statements.2/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="processThumbnailProgress">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="percentageDone">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Broadcasts the current percentage of thumbnail completion to&#xA;     * all registered &lt;code>IIOWriteProgressListener&lt;/code>s by calling&#xA;     * their &lt;code>thumbnailProgress&lt;/code> method.  Subclasses may&#xA;     * use this method as a convenience.&#xA;     *&#xA;     * @param percentageDone the current percentage of completion,&#xA;     * as a &lt;code>float&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="numListeners">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="listener">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.16"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.2/@init"/>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.2/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0/@members.4"/>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.2/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="processThumbnailComplete">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Broadcasts the completion of a thumbnail write to all registered&#xA;     * &lt;code>IIOWriteProgressListener&lt;/code>s by calling their&#xA;     * &lt;code>thumbnailComplete&lt;/code> method.  Subclasses may use this&#xA;     * method as a convenience.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="numListeners">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="listener">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.16"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.2/@init"/>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.2/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0/@members.5"/>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.2/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="processWriteAborted">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Broadcasts that the write has been aborted to all registered&#xA;     * &lt;code>IIOWriteProgressListener&lt;/code>s by calling their&#xA;     * &lt;code>writeAborted&lt;/code> method.  Subclasses may use this&#xA;     * method as a convenience.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="numListeners">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="listener">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.16"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@statements.2/@init"/>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@statements.2/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="event/IIOWriteProgressListener.class.xmi#//@classifiers.0/@members.6"/>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@statements.2/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="processWarningOccurred">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="warning">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Broadcasts a warning message to all registered&#xA;     * &lt;code>IIOWriteWarningListener&lt;/code>s by calling their&#xA;     * &lt;code>warningOccurred&lt;/code> method.  Subclasses may use this&#xA;     * method as a convenience.&#xA;     *&#xA;     * @param imageIndex the index of the image on which the warning&#xA;     * occurred.&#xA;     * @param warning the warning message.&#xA;     *&#xA;     * @exception IllegalArgumentException if &lt;code>warning&lt;/code>&#xA;     * is &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="warning == null!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="numListeners">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="listener">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="event/IIOWriteWarningListener.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="event/IIOWriteWarningListener.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.16"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.3/@init"/>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.3/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="event/IIOWriteWarningListener.class.xmi#//@classifiers.0/@members.0"/>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="processWarningOccurred">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="imageIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="baseName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="keyword">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Broadcasts a localized warning message to all registered&#xA;     * &lt;code>IIOWriteWarningListener&lt;/code>s by calling their&#xA;     * &lt;code>warningOccurred&lt;/code> method with a string taken&#xA;     * from a &lt;code>ResourceBundle&lt;/code>.  Subclasses may use this&#xA;     * method as a convenience.&#xA;     *&#xA;     * @param imageIndex the index of the image on which the warning&#xA;     * occurred.&#xA;     * @param baseName the base name of a set of&#xA;     * &lt;code>ResourceBundle&lt;/code>s containing localized warning&#xA;     * messages.&#xA;     * @param keyword the keyword used to index the warning message&#xA;     * within the set of &lt;code>ResourceBundle&lt;/code>s.&#xA;     *&#xA;     * @exception IllegalArgumentException if &lt;code>baseName&lt;/code>&#xA;     * is &lt;code>null&lt;/code>.&#xA;     * @exception IllegalArgumentException if &lt;code>keyword&lt;/code>&#xA;     * is &lt;code>null&lt;/code>.&#xA;     * @exception IllegalArgumentException if no appropriate&#xA;     * &lt;code>ResourceBundle&lt;/code> may be located.&#xA;     * @exception IllegalArgumentException if the named resource is&#xA;     * not found in the located &lt;code>ResourceBundle&lt;/code>.&#xA;     * @exception IllegalArgumentException if the object retrieved&#xA;     * from the &lt;code>ResourceBundle&lt;/code> is not a&#xA;     * &lt;code>String&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="baseName == null!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="keyword == null!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@parameters.2"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="numListeners">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="listener">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="event/IIOWriteWarningListener.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="event/IIOWriteWarningListener.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.16"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@init"/>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="locale">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/util/Locale.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../java/util/Locale.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../java/util/List.class.xmi#//@classifiers.0/@members.16"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@init"/>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@statement/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../java/util/Locale.class.xmi#//@classifiers.0/@members.35"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../../java/util/Locale.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@statement/@statements.1/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="loader">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <comments>/**&#xA;             * If an applet supplies an implementation of ImageWriter and&#xA;&#x9;     * resource bundles, then the resource bundle will need to be&#xA;&#x9;     * accessed via the applet class loader. So first try the context&#xA;&#x9;     * class loader to locate the resource bundle.&#xA;&#x9;     * If that throws MissingResourceException, then try the&#xA;&#x9;     * system class loader.&#xA;&#x9;     */</comments>
                  <target xsi:type="classifiers:Class" href="../../java/lang/ClassLoader.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../java/lang/ClassLoader.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../java/security/AccessController.class.xmi#//@classifiers.0/@members.1"/>
                        <arguments xsi:type="instantiations:NewConstructorCall">
                          <typeReference xsi:type="types:NamespaceClassifierReference">
                            <namespaces>java</namespaces>
                            <namespaces>security</namespaces>
                            <classifierReferences>
                              <target xsi:type="classifiers:Interface" href="../../java/security/PrivilegedAction.class.xmi#//@classifiers.0"/>
                            </classifierReferences>
                          </typeReference>
                          <anonymousClass>
                            <members xsi:type="members:ClassMethod" name="run">
                              <typeReference xsi:type="types:NamespaceClassifierReference">
                                <classifierReferences>
                                  <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
                                </classifierReferences>
                              </typeReference>
                              <annotationsAndModifiers xsi:type="modifiers:Public"/>
                              <statements xsi:type="statements:Return">
                                <returnValue xsi:type="references:IdentifierReference">
                                  <next xsi:type="references:MethodCall">
                                    <next xsi:type="references:MethodCall">
                                      <target xsi:type="members:ClassMethod" href="../../java/lang/Thread.class.xmi#//@classifiers.0/@members.76"/>
                                    </next>
                                    <target xsi:type="members:ClassMethod" href="../../java/lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
                                  </next>
                                  <target xsi:type="classifiers:Class" href="../../java/lang/Thread.class.xmi#//@classifiers.0"/>
                                </returnValue>
                              </statements>
                            </members>
                          </anonymousClass>
                        </arguments>
                      </next>
                      <target xsi:type="classifiers:Class" href="../../java/security/AccessController.class.xmi#//@classifiers.0"/>
                    </next>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="bundle">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/util/ResourceBundle.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="literals:NullLiteral"/>
            </variable>
          </statements>
          <statements xsi:type="statements:TryBlock">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@statement/@statements.4/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../java/util/ResourceBundle.class.xmi#//@classifiers.0/@members.21"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@parameters.1"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@statement/@statements.1/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@statement/@statements.3/@variable"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../../java/util/ResourceBundle.class.xmi#//@classifiers.0"/>
                </value>
              </expression>
            </statements>
            <catcheBlocks>
              <statements xsi:type="statements:TryBlock">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@statement/@statements.4/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../java/util/ResourceBundle.class.xmi#//@classifiers.0/@members.20"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@parameters.1"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@statement/@statements.1/@variable"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="../../java/util/ResourceBundle.class.xmi#//@classifiers.0"/>
                    </value>
                  </expression>
                </statements>
                <catcheBlocks>
                  <statements xsi:type="statements:Throw">
                    <throwable xsi:type="instantiations:NewConstructorCall">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <arguments xsi:type="references:StringReference" value="Bundle not found!"/>
                    </throwable>
                  </statements>
                  <parameter name="mre1">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../java/util/MissingResourceException.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                  </parameter>
                </catcheBlocks>
              </statements>
              <parameter name="mre">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../java/util/MissingResourceException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </parameter>
            </catcheBlocks>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="warning">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="literals:NullLiteral"/>
            </variable>
          </statements>
          <statements xsi:type="statements:TryBlock">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@statement/@statements.6/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@statement/@statements.4/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../java/util/ResourceBundle.class.xmi#//@classifiers.0/@members.11"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@parameters.2"/>
                  </next>
                </value>
              </expression>
            </statements>
            <catcheBlocks>
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:StringReference" value="Resource is not a String!"/>
                </throwable>
              </statements>
              <parameter name="cce">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../java/lang/ClassCastException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </parameter>
            </catcheBlocks>
            <catcheBlocks>
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:StringReference" value="Resource is missing!"/>
                </throwable>
              </statements>
              <parameter name="mre">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../java/util/MissingResourceException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </parameter>
            </catcheBlocks>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="event/IIOWriteWarningListener.class.xmi#//@classifiers.0/@members.0"/>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@statement/@statements.6/@variable"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.3/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.4/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="reset">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// State management</comments>
        <comments>/**&#xA;     * Restores the &lt;code>ImageWriter&lt;/code> to its initial state.&#xA;     *&#xA;     * &lt;p> The default implementation calls&#xA;     * &lt;code>setOutput(null)&lt;/code>, &lt;code>setLocale(null)&lt;/code>,&#xA;     * &lt;code>removeAllIIOWriteWarningListeners()&lt;/code>,&#xA;     * &lt;code>removeAllIIOWriteProgressListeners()&lt;/code>, and&#xA;     * &lt;code>clearAbortRequest&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.10">
          <arguments xsi:type="literals:NullLiteral"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="literals:NullLiteral"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.55"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.58"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.52"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="dispose">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allows any resources held by this object to be released.  The&#xA;     * result of calling any other method (other than&#xA;     * &lt;code>finalize&lt;/code>) subsequent to a call to this method&#xA;     * is undefined.&#xA;     *&#xA;     * &lt;p>It is important for applications to call this method when they&#xA;     * know they will no longer be using this &lt;code>ImageWriter&lt;/code>.&#xA;     * Otherwise, the writer may continue to hold on to resources&#xA;     * indefinitely.&#xA;     *&#xA;     * &lt;p>The default implementation of this method in the superclass does&#xA;     * nothing.  Subclass implementations should ensure that all resources,&#xA;     * especially native resources, are released.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * An abstract superclass for encoding and writing images.  This class&#xA; * must be subclassed by classes that write out images in the context&#xA; * of the Java Image I/O framework.&#xA; *&#xA; * &lt;p> &lt;code>ImageWriter&lt;/code> objects are normally instantiated by&#xA; * the service provider class for the specific format.  Service&#xA; * provider classes are registered with the &lt;code>IIORegistry&lt;/code>,&#xA; * which uses them for format recognition and presentation of&#xA; * available format readers and writers.&#xA; *&#xA; * &lt;p> &#xA; *&#xA; * @see ImageReader&#xA; * @see ImageWriteParam&#xA; * @see javax.imageio.spi.IIORegistry&#xA; * @see javax.imageio.spi.ImageWriterSpi&#xA; *&#xA; * @version 0.5&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="ImageTranscoder.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
