<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="ImageReadParam.java">
  <comments>/*&#xA; * @(#)ImageReadParam.java&#x9;1.58 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>imageio</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/awt/Dimension.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/awt/image/BufferedImage.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="ImageReadParam">
    <members xsi:type="members:Field" name="canSetSourceRenderSize">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * &lt;code>true&lt;/code> if this &lt;code>ImageReadParam&lt;/code> allows&#xA;     * the source rendering dimensions to be set.  By default, the&#xA;     * value is &lt;code>false&lt;/code>.  Subclasses must set this value&#xA;     * manually.&#xA;     *&#xA;     * &lt;p> &lt;code>ImageReader&lt;/code>s that do not support setting of&#xA;     * the source render size should set this value to&#xA;     * &lt;code>false&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="sourceRenderSize">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/awt/Dimension.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The desired rendering width and height of the source, if&#xA;     * &lt;code>canSetSourceRenderSize&lt;/code> is &lt;code>true&lt;/code>, or&#xA;     * &lt;code>null&lt;/code>.&#xA;     *&#xA;     * &lt;p> &lt;code>ImageReader&lt;/code>s that do not support setting of&#xA;     * the source render size may ignore this value.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="destination">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/awt/image/BufferedImage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The current destination &lt;code>BufferedImage&lt;/code>, or&#xA;     * &lt;code>null&lt;/code> if none has been set.  By default, the value&#xA;     * is &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="destinationBands">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:Int"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The set of destination bands to be used, as an array of&#xA;     * &lt;code>int&lt;/code>s.  By default, the value is &lt;code>null&lt;/code>,&#xA;     * indicating all destination bands should be written in order.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="minProgressivePass">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The minimum index of a progressive pass to read from the&#xA;     * source.  By default, the value is set to 0, which indicates&#xA;     * that passes starting with the first available pass should be&#xA;     * decoded.&#xA;     *&#xA;     * &lt;p> Subclasses should ensure that this value is&#xA;     * non-negative.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="numProgressivePasses">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="../../java/lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
        </next>
        <target xsi:type="classifiers:Class" href="../../java/lang/Integer.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The maximum number of progressive passes to read from the&#xA;     * source.  By default, the value is set to&#xA;     * &lt;code>Integer.MAX_VALUE&lt;/code>, which indicates that passes up&#xA;     * to and including the last available pass should be decoded.&#xA;     *&#xA;     * &lt;p> Subclasses should ensure that this value is positive.&#xA;     * Additionally, if the value is not&#xA;     * &lt;code>Integer.MAX_VALUE&lt;/code>, then &lt;code>minProgressivePass +&#xA;     * numProgressivePasses - 1&lt;/code> should not exceed&#xA;     * &lt;code>Integer.MAX_VALUE&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="ImageReadParam">
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs an &lt;code>ImageReadParam&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="setDestinationType">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="destinationType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageTypeSpecifier.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Comment inherited</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="IIOParam.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          </next>
          <self xsi:type="literals:Super"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.8">
          <arguments xsi:type="literals:NullLiteral"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setDestination">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="destination">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/awt/image/BufferedImage.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Supplies a &lt;code>BufferedImage&lt;/code> to be used as the&#xA;     * destination for decoded pixel data.  The currently set image&#xA;     * will be written to by the &lt;code>read&lt;/code>,&#xA;     * &lt;code>readAll&lt;/code>, and &lt;code>readRaster&lt;/code> methods, and&#xA;     * a reference to it will be returned by those methods.&#xA;     *&#xA;     * &lt;p> Pixel data from the aforementioned methods will be written&#xA;     * starting at the offset specified by&#xA;     * &lt;code>getDestinationOffset&lt;/code>.&#xA;     *&#xA;     * &lt;p> If &lt;code>destination&lt;/code> is &lt;code>null&lt;/code>, a&#xA;     * newly-created &lt;code>BufferedImage&lt;/code> will be returned by&#xA;     * those methods.&#xA;     *&#xA;     * &lt;p> At the time of reading, the image is checked to verify that&#xA;     * its &lt;code>ColorModel&lt;/code> and &lt;code>SampleModel&lt;/code>&#xA;     * correspond to one of the &lt;code>ImageTypeSpecifier&lt;/code>s&#xA;     * returned from the &lt;code>ImageReader&lt;/code>'s&#xA;     * &lt;code>getImageTypes&lt;/code> method.  If it does not, the reader&#xA;     * will throw an &lt;code>IIOException&lt;/code>.&#xA;     *&#xA;     * @param destination the BufferedImage to be written to, or&#xA;     * &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @see #getDestination&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDestination">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/awt/image/BufferedImage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>BufferedImage&lt;/code> currently set by the&#xA;     * &lt;code>setDestination&lt;/code> method, or &lt;code>null&lt;/code>&#xA;     * if none is set.&#xA;     *&#xA;     * @return the BufferedImage to be written to.&#xA;     *&#xA;     * @see #setDestination&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setDestinationBands">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="destinationBands">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the indices of the destination bands where data&#xA;     * will be placed.  Duplicate indices are not allowed.&#xA;     *&#xA;     * &lt;p> A &lt;code>null&lt;/code> value indicates that all destination&#xA;     * bands will be used.&#xA;     *&#xA;     * &lt;p> Choosing a destination band subset will not affect the&#xA;     * number of bands in the output image of a read if no destination&#xA;     * image is specified; the created destination image will still&#xA;     * have the same number of bands as if this method had never been&#xA;     * called.  If a different number of bands in the destination&#xA;     * image is desired, an image must be supplied using the&#xA;     * &lt;code>ImageReadParam.setDestination&lt;/code> method.&#xA;     *&#xA;     * &lt;p> At the time of reading or writing, an&#xA;     * &lt;code>IllegalArgumentException&lt;/code> will be thrown by the&#xA;     * reader or writer if a value larger than the largest destination&#xA;     * band index has been specified, or if the number of source bands&#xA;     * and destination bands to be used differ.  The&#xA;     * &lt;code>ImageReader.checkReadParamBandSettings&lt;/code> method may&#xA;     * be used to automate this test.&#xA;     *&#xA;     * @param destinationBands an array of integer band indices to be&#xA;     * used.&#xA;     *&#xA;     * @exception IllegalArgumentException if &lt;code>destinationBands&lt;/code>&#xA;     * contains a negative or duplicate value.&#xA;     *&#xA;     * @see #getDestinationBands&#xA;     * @see #getSourceBands&#xA;     * @see ImageReader#checkReadParamBandSettings&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:NullLiteral"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="numBands">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
                <next xsi:type="references:IdentifierReference"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="band">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.1/@init"/>
                    </arraySelectors>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Throw">
                    <throwable xsi:type="instantiations:NewConstructorCall">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <arguments xsi:type="references:StringReference" value="Band value &lt; 0!"/>
                    </throwable>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.1/@statement/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ForLoop">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:Throw">
                        <throwable xsi:type="instantiations:NewConstructorCall">
                          <typeReference xsi:type="types:NamespaceClassifierReference">
                            <classifierReferences>
                              <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                            </classifierReferences>
                          </typeReference>
                          <arguments xsi:type="references:StringReference" value="Duplicate band value!"/>
                        </throwable>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.1/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.1/@statement/@statements.2/@init"/>
                        </arraySelectors>
                      </children>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.1/@statement/@statements.2/@init"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.0/@variable"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
                <init xsi:type="variables:LocalVariable" name="j">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.1/@init"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </initialValue>
                </init>
                <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.1/@statement/@statements.2/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </updates>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.1/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.1/@init"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Int"/>
                <arrayDimensionsBefore/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../java/lang/Object.class.xmi#//@classifiers.0/@members.5"/>
                  </next>
                </child>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDestinationBands">
      <typeReference xsi:type="types:Int"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the set of band indices where data will be placed.&#xA;     * If no value has been set, &lt;code>null&lt;/code> is returned to&#xA;     * indicate that all destination bands will be used.&#xA;     *&#xA;     * @return the indices of the destination bands to be used,&#xA;     * or &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @see #setDestinationBands&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:NullLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <arrayDimensionsBefore/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../java/lang/Object.class.xmi#//@classifiers.0/@members.5"/>
                  </next>
                </expression>
              </child>
            </returnValue>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canSetSourceRenderSize">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if this reader allows the source&#xA;     * image to be rendered at an arbitrary size as part of the&#xA;     * decoding process, by means of the&#xA;     * &lt;code>setSourceRenderSize&lt;/code> method.  If this method&#xA;     * returns &lt;code>false&lt;/code>, calls to&#xA;     * &lt;code>setSourceRenderSize&lt;/code> will throw an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if setting source rendering size is&#xA;     * supported.&#xA;     *&#xA;     * @see #setSourceRenderSize&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setSourceRenderSize">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="size">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/awt/Dimension.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * If the image is able to be rendered at an arbitrary size, sets&#xA;     * the source width and height to the supplied values.  Note that&#xA;     * the values returned from the &lt;code>getWidth&lt;/code> and&#xA;     * &lt;code>getHeight&lt;/code> methods on &lt;code>ImageReader&lt;/code> are&#xA;     * not affected by this method; they will continue to return the&#xA;     * default size for the image.  Similarly, if the image is also&#xA;     * tiled the tile width and height are given in terms of the default&#xA;     * size.&#xA;     *&#xA;     * &lt;p> Typically, the width and height should be chosen such that&#xA;     * the ratio of width to height closely approximates the aspect&#xA;     * ratio of the image, as returned from&#xA;     * &lt;code>ImageReader.getAspectRatio&lt;/code>.&#xA;     *&#xA;     * &lt;p> If this plug-in does not allow the rendering size to be&#xA;     * set, an &lt;code>UnsupportedOperationException&lt;/code> will be&#xA;     * thrown.&#xA;     *&#xA;     * &lt;p> To remove the render size setting, pass in a value of&#xA;     * &lt;code>null&lt;/code> for &lt;code>size&lt;/code>.&#xA;     *&#xA;     * @param size a &lt;code>Dimension&lt;/code> indicating the desired&#xA;     * width and height.&#xA;     *&#xA;     * @exception IllegalArgumentException if either the width or the&#xA;     * height is negative or 0.&#xA;     * @exception UnsupportedOperationException if image resizing&#xA;     * is not supported by this plug-in.&#xA;     *&#xA;     * @see #getSourceRenderSize&#xA;     * @see ImageReader#getWidth&#xA;     * @see ImageReader#getHeight&#xA;     * @see ImageReader#getAspectRatio&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Can't set source render size!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:NullLiteral"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:StringReference" value="width or height &lt;= 0!"/>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../../java/awt/Dimension.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../../java/awt/Dimension.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../java/awt/Dimension.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../java/awt/geom/Dimension2D.class.xmi#//@classifiers.0/@members.5"/>
                  </next>
                </child>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSourceRenderSize">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../java/awt/Dimension.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the width and height of the source image as it&#xA;     * will be rendered during decoding, if they have been set via the&#xA;     * &lt;code>setSourceRenderSize&lt;/code> method.  A&#xA;     * &lt;code>null&lt;/code>value indicates that no setting has been made.&#xA;     *&#xA;     * @return the rendered width and height of the source image&#xA;     * as a &lt;code>Dimension&lt;/code>.&#xA;     *&#xA;     * @see #setSourceRenderSize&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </child>
          <expressionIf xsi:type="literals:NullLiteral"/>
          <expressionElse xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../java/awt/Dimension.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../java/awt/geom/Dimension2D.class.xmi#//@classifiers.0/@members.5"/>
              </next>
            </child>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setSourceProgressivePasses">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="minPass">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="numPasses">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the range of progressive passes that will be decoded.&#xA;     * Passes outside of this range will be ignored.&#xA;     *&#xA;     * &lt;p> A progressive pass is a re-encoding of the entire image,&#xA;     * generally at progressively higher effective resolutions, but&#xA;     * requiring greater transmission bandwidth.  The most common use&#xA;     * of progressive encoding is found in the JPEG format, where&#xA;     * successive passes include more detailed representations of the&#xA;     * high-frequency image content.&#xA;     *&#xA;     * &lt;p> The actual number of passes to be decoded is determined&#xA;     * during decoding, based on the number of actual passes available&#xA;     * in the stream.  Thus if &lt;code>minPass + numPasses - 1&lt;/code> is&#xA;     * larger than the index of the last available passes, decoding&#xA;     * will end with that pass.&#xA;     *&#xA;     * &lt;p> A value of &lt;code>numPasses&lt;/code> of&#xA;     * &lt;code>Integer.MAX_VALUE&lt;/code> indicates that all passes from&#xA;     * &lt;code>minPass&lt;/code> forward should be read.  Otherwise, the&#xA;     * index of the last pass (&lt;i>i.e.&lt;/i>, &lt;code>minPass + numPasses&#xA;     * - 1&lt;/code>) must not exceed &lt;code>Integer.MAX_VALUE&lt;/code>.&#xA;     *&#xA;     * &lt;p> There is no &lt;code>unsetSourceProgressivePasses&lt;/code>&#xA;     * method; the same effect may be obtained by calling&#xA;     * &lt;code>setSourceProgressivePasses(0, Integer.MAX_VALUE)&lt;/code>.&#xA;     *&#xA;     * @param minPass the index of the first pass to be decoded.&#xA;     * @param numPasses the maximum number of passes to be decoded.&#xA;     *&#xA;     * @exception IllegalArgumentException if &lt;code>minPass&lt;/code> is&#xA;     * negative, &lt;code>numPasses&lt;/code> is negative or 0, or&#xA;     * &lt;code>numPasses&lt;/code> is smaller than&#xA;     * &lt;code>Integer.MAX_VALUE&lt;/code> but &lt;code>minPass +&#xA;     * numPasses - 1&lt;/code> is greater than&#xA;     * &lt;code>INTEGER.MAX_VALUE&lt;/code>.&#xA;     *&#xA;     * @see #getSourceMinProgressivePass&#xA;     * @see #getSourceMaxProgressivePass&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="minPass &lt; 0!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="numPasses &lt;= 0!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="minPass + numPasses - 1 > INTEGER.MAX_VALUE!"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../../java/lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../java/lang/Integer.class.xmi#//@classifiers.0"/>
              </children>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AndExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </expression>
                  </children>
                  <children xsi:type="literals:HexIntegerLiteral" hexValue="2147483648"/>
                </expression>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSourceMinProgressivePass">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index of the first progressive pass that will be&#xA;     * decoded. If no value has been set, 0 will be returned (which is&#xA;     * the correct value).&#xA;     *&#xA;     * @return the index of the first pass that will be decoded.&#xA;     *&#xA;     * @see #setSourceProgressivePasses&#xA;     * @see #getSourceNumProgressivePasses&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSourceMaxProgressivePass">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * If &lt;code>getSourceNumProgressivePasses&lt;/code> is equal to&#xA;     * &lt;code>Integer.MAX_VALUE&lt;/code>, returns&#xA;     * &lt;code>Integer.MAX_VALUE&lt;/code>.  Otherwise, returns&#xA;     * &lt;code>getSourceMinProgressivePass() +&#xA;     * getSourceNumProgressivePasses() - 1&lt;/code>.&#xA;     *&#xA;     * @return the index of the last pass to be read, or&#xA;     * &lt;code>Integer.MAX_VALUE&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../../java/lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../java/lang/Integer.class.xmi#//@classifiers.0"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../../java/lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../java/lang/Integer.class.xmi#//@classifiers.0"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </returnValue>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSourceNumProgressivePasses">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the number of the progressive passes that will be&#xA;     * decoded. If no value has been set,&#xA;     * &lt;code>Integer.MAX_VALUE&lt;/code> will be returned (which is the&#xA;     * correct value).&#xA;     *&#xA;     * @return the number of the passes that will be decoded.&#xA;     *&#xA;     * @see #setSourceProgressivePasses&#xA;     * @see #getSourceMinProgressivePass&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A class describing how a stream is to be decoded.  Instances of&#xA; * this class or its subclasses are used to supply prescriptive&#xA; * &quot;how-to&quot; information to instances of &lt;code>ImageReader&lt;/code>.&#xA; *&#xA; * &lt;p> An image encoded as part of a file or stream may be thought of&#xA; * extending out in multiple dimensions: the spatial dimensions of&#xA; * width and height, a number of bands, and a number of progressive&#xA; * decoding passes.  This class allows a contiguous (hyper)rectangular&#xA; * subarea of the image in all of these dimensions to be selected for&#xA; * decoding.  Additionally, the spatial dimensions may be subsampled&#xA; * discontinuously.  Finally, color and format conversions may be&#xA; * specified by controlling the &lt;code>ColorModel&lt;/code> and&#xA; * &lt;code>SampleModel&lt;/code> of the destination image, either by&#xA; * providing a &lt;code>BufferedImage&lt;/code> or by using an&#xA; * &lt;code>ImageTypeSpecifier&lt;/code>.&#xA; *&#xA; * &lt;p> An &lt;code>ImageReadParam&lt;/code> object is used to specify how an&#xA; * image, or a set of images, will be converted on input from&#xA; * a stream in the context of the Java Image I/O framework.  A plug-in for a&#xA; * specific image format will return instances of&#xA; * &lt;code>ImageReadParam&lt;/code> from the&#xA; * &lt;code>getDefaultReadParam&lt;/code> method of its&#xA; * &lt;code>ImageReader&lt;/code> implementation.&#xA; *&#xA; * &lt;p> The state maintained by an instance of&#xA; * &lt;code>ImageReadParam&lt;/code> is independent of any particular image&#xA; * being decoded.  When actual decoding takes place, the values set in&#xA; * the read param are combined with the actual properties of the image&#xA; * being decoded from the stream and the destination&#xA; * &lt;code>BufferedImage&lt;/code> that will receive the decoded pixel&#xA; * data.  For example, the source region set using&#xA; * &lt;code>setSourceRegion&lt;/code> will first be intersected with the&#xA; * actual valid source area.  The result will be translated by the&#xA; * value returned by &lt;code>getDestinationOffset&lt;/code>, and the&#xA; * resulting rectangle intersected with the actual valid destination&#xA; * area to yield the destination area that will be written.&#xA; *&#xA; * &lt;p> The parameters specified by an &lt;code>ImageReadParam&lt;/code> are&#xA; * applied to an image as follows.  First, if a rendering size has&#xA; * been set by &lt;code>setSourceRenderSize&lt;/code>, the entire decoded&#xA; * image is rendered at the size given by&#xA; * &lt;code>getSourceRenderSize&lt;/code>.  Otherwise, the image has its&#xA; * natural size given by &lt;code>ImageReader.getWidth&lt;/code> and&#xA; * &lt;code>ImageReader.getHeight&lt;/code>.&#xA; *&#xA; * &lt;p> Next, the image is clipped against the source region&#xA; * specified by &lt;code>getSourceXOffset&lt;/code>, &lt;code>getSourceYOffset&lt;/code>,&#xA; * &lt;code>getSourceWidth&lt;/code>, and &lt;code>getSourceHeight&lt;/code>.&#xA; *&#xA; * &lt;p> The resulting region is then subsampled according to the&#xA; * factors given in {@link IIOParam#setSourceSubsampling &#xA; * &lt;code>IIOParam.setSourceSubsampling&lt;/code>}.  The first pixel,&#xA; * the number of pixels per row, and the number of rows all depend&#xA; * on the subsampling settings.&#xA; * Call the minimum X and Y coordinates of the resulting rectangle&#xA; * (&lt;code>minX&lt;/code>, &lt;code>minY&lt;/code>), its width &lt;code>w&lt;/code>&#xA; * and its height &lt;code>h&lt;/code>.&#xA; *&#xA; * &lt;p> This rectangle is offset by&#xA; * (&lt;code>getDestinationOffset().x&lt;/code>,&#xA; * &lt;code>getDestinationOffset().y&lt;/code>) and clipped against the&#xA; * destination bounds.  If no destination image has been set, the&#xA; * destination is defined to have a width of&#xA; * &lt;code>getDestinationOffset().x&lt;/code> + &lt;code>w&lt;/code>, and a&#xA; * height of &lt;code>getDestinationOffset().y&lt;/code> + &lt;code>h&lt;/code> so&#xA; * that all pixels of the source region may be written to the&#xA; * destination.&#xA; *&#xA; * &lt;p> Pixels that land, after subsampling, within the destination&#xA; * image, and that are written in one of the progressive passes&#xA; * specified by &lt;code>getSourceMinProgressivePass&lt;/code> and&#xA; * &lt;code>getSourceNumProgressivePasses&lt;/code> are passed along to the&#xA; * next step.&#xA; *&#xA; * &lt;p> Finally, the source samples of each pixel are mapped into&#xA; * destination bands according to the algorithm described in the&#xA; * comment for &lt;code>setDestinationBands&lt;/code>.&#xA; *&#xA; * &lt;p> Plug-in writers may extend the functionality of&#xA; * &lt;code>ImageReadParam&lt;/code> by providing a subclass that implements&#xA; * additional, plug-in specific interfaces.  It is up to the plug-in&#xA; * to document what interfaces are available and how they are to be&#xA; * used.  Readers will silently ignore any extended features of an&#xA; * &lt;code>ImageReadParam&lt;/code> subclass of which they are not aware.&#xA; * Also, they may ignore any optional features that they normally&#xA; * disable when creating their own &lt;code>ImageReadParam&lt;/code>&#xA; * instances via &lt;code>getDefaultReadParam&lt;/code>.&#xA; *&#xA; * &lt;p> Note that unless a query method exists for a capability, it must&#xA; * be supported by all &lt;code>ImageReader&lt;/code> implementations&#xA; * (&lt;i>e.g.&lt;/i> source render size is optional, but subsampling must be&#xA; * supported).&#xA; *&#xA; * @version 0.5&#xA; *&#xA; * @see ImageReader&#xA; * @see ImageWriter&#xA; * @see ImageWriteParam&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="IIOParam.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
