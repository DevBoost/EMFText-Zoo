<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:annotations="http://www.emftext.org/java/annotations" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/annotations ../../../java.ecore#/0 http://www.emftext.org/java/arrays ../../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16 http://www.emftext.org/java/variables ../../../java.ecore#/17" name="View.java">
  <comments>/*&#xA; * @(#)View.java&#x9;1.70 04/05/18&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>swing</namespaces>
  <namespaces>text</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>swing</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../SwingConstants.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>javax</namespaces>
    <namespaces>swing</namespaces>
    <namespaces>event</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="View">
    <members xsi:type="members:Constructor" name="View">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="elem">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new &lt;code>View&lt;/code> object.&#xA;     *&#xA;     * @param elem the &lt;code>Element&lt;/code> to represent&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getParent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the parent of the view.&#xA;     *&#xA;     * @return the parent, or &lt;code>null&lt;/code> if none exists&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isVisible">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  Returns a boolean that indicates whether&#xA;     *  the view is visible or not.  By default&#xA;     *  all views are visible.&#xA;     *&#xA;     *  @return always returns true&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPreferredSpan">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="axis">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines the preferred span for this view along an&#xA;     * axis.&#xA;     *&#xA;     * @param axis may be either &lt;code>View.X_AXIS&lt;/code> or&#xA;     *&#x9;&#x9;&lt;code>View.Y_AXIS&lt;/code>&#xA;     * @return   the span the view would like to be rendered into.&#xA;     *           Typically the view is told to render into the span&#xA;     *           that is returned, although there is no guarantee.  &#xA;     *           The parent may choose to resize or break the view&#xA;     * @see View#getPreferredSpan&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getMinimumSpan">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="axis">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines the minimum span for this view along an&#xA;     * axis.&#xA;     *&#xA;     * @param axis may be either &lt;code>View.X_AXIS&lt;/code> or&#xA;     *&#x9;&#x9;&lt;code>View.Y_AXIS&lt;/code>&#xA;     * @return  the minimum span the view can be rendered into&#xA;     * @see View#getPreferredSpan&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.35">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <comments>// can't resize</comments>
            <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.3">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMaximumSpan">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="axis">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines the maximum span for this view along an&#xA;     * axis.&#xA;     *&#xA;     * @param axis may be either &lt;code>View.X_AXIS&lt;/code> or&#xA;     *&#x9;&#x9;&lt;code>View.Y_AXIS&lt;/code>&#xA;     * @return  the maximum span the view can be rendered into&#xA;     * @see View#getPreferredSpan&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.35">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <comments>// can't resize</comments>
            <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.3">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../../../java/lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Integer.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="preferenceChanged">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="child">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Child views can call this on the parent to indicate that&#xA;     * the preference has changed and should be reconsidered&#xA;     * for layout.  By default this just propagates upward to &#xA;     * the next parent.  The root view will call &#xA;     * &lt;code>revalidate&lt;/code> on the associated text component.&#xA;     *&#xA;     * @param child the child view&#xA;     * @param width true if the width preference has changed&#xA;     * @param height true if the height preference has changed&#xA;     * @see javax.swing.JComponent#revalidate&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="parent">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.1"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.2"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAlignment">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="axis">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines the desired alignment for this view along an&#xA;     * axis.  The desired alignment is returned.  This should be&#xA;     * a value >= 0.0 and &lt;= 1.0, where 0 indicates alignment at&#xA;     * the origin and 1.0 indicates alignment to the full span&#xA;     * away from the origin.  An alignment of 0.5 would be the&#xA;     * center of the view.&#xA;     *&#xA;     * @param axis may be either &lt;code>View.X_AXIS&lt;/code> or&#xA;     *&#x9;&#x9;&lt;code>View.Y_AXIS&lt;/code>&#xA;     * @return the value 0.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:DecimalFloatLiteral" decimalValue="0.5"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="paint">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="g">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/awt/Graphics.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="allocation">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Renders using the given rendering surface and area on that&#xA;     * surface.  The view may need to do layout and create child&#xA;     * views to enable itself to render into the given allocation.&#xA;     *&#xA;     * @param g the rendering surface to use&#xA;     * @param allocation the allocated region to render into&#xA;     * @see View#paint&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="setParent">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parent">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Establishes the parent view for this view.  This is&#xA;     * guaranteed to be called before any other methods if the&#xA;     * parent view is functioning properly.  This is also&#xA;     * the last method called, since it is called to indicate&#xA;     * the view has been removed from the hierarchy as &#xA;     * well. When this method is called to set the parent to&#xA;     * null, this method does the same for each of its children,&#xA;     * propogating the notification that they have been&#xA;     * disconnected from the view tree. If this is&#xA;     * reimplemented, &lt;code>super.setParent()&lt;/code> should&#xA;     * be called.&#xA;     *&#xA;     * @param parent the new parent, or &lt;code>null&lt;/code> if the view is&#xA;     * &#x9;&#x9;being removed from a parent&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// if the parent is null then propogate down the view tree</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
                      <comments>// in FlowView.java view might be referenced </comments>
                      <comments>// from two super-views as a child. see logicalView</comments>
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.9">
                        <arguments xsi:type="literals:NullLiteral"/>
                      </next>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@statement/@statements.0/@init"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@statement/@statements.0/@init"/>
                  </children>
                  <children xsi:type="references:SelfReference">
                    <self xsi:type="literals:This"/>
                  </children>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@statement/@statements.0/@init"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.10"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@statement/@statements.0/@init"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getViewCount">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Returns the number of views in this view.  Since&#xA;     * the default is to not be a composite view this&#xA;     * returns 0.&#xA;     *&#xA;     * @return the number of views >= 0&#xA;     * @see View#getViewCount&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getView">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Gets the &lt;i>n&lt;/i>th child view.  Since there are no&#xA;     * children by default, this returns &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @param n the number of the view to get, >= 0 &amp;&amp; &lt; getViewCount()&#xA;     * @return the view&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeAll">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes all of the children.  This is a convenience&#xA;     * call to &lt;code>replace&lt;/code>.&#xA;     *&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.10"/>
          <arguments xsi:type="literals:NullLiteral"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="remove">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes one of the children at the given position.&#xA;     * This is a convenience call to &lt;code>replace&lt;/code>.&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <arguments xsi:type="literals:NullLiteral"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="insert">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offs">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts a single child view.  This is a convenience &#xA;     * call to &lt;code>replace&lt;/code>.&#xA;     *&#xA;     * @param offs the offset of the view to insert before >= 0&#xA;     * @param v the view&#xA;     * @see #replace&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="one">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends a single child view.  This is a convenience &#xA;     * call to &lt;code>replace&lt;/code>.&#xA;     *&#xA;     * @param v the view&#xA;     * @see #replace&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="one">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@variable">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.10"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@variable"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="replace">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="views">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Replaces child views.  If there are no views to remove&#xA;     * this acts as an insert.  If there are no views to&#xA;     * add this acts as a remove.  Views being removed will&#xA;     * have the parent set to &lt;code>null&lt;/code>, and the internal reference&#xA;     * to them removed so that they can be garbage collected.&#xA;     * This is implemented to do nothing, because by default&#xA;     * a view has no children.&#xA;     *&#xA;     * @param offset the starting index into the child views to insert&#xA;     *   the new views.  This should be a value >= 0 and &lt;= getViewCount&#xA;     * @param length the number of existing child views to remove&#xA;     *   This should be a value >= 0 and &lt;= (getViewCount() - offset).&#xA;     * @param views the child views to add.  This value can be&#xA;     *   &lt;code>null&lt;/code> to indicate no children are being added&#xA;     *   (useful to remove).&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getViewIndex">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>Position</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the child view index representing the given position in&#xA;     * the model.  By default a view has no children so this is implemented&#xA;     * to return -1 to indicate there is no valid child index for any&#xA;     * position.&#xA;     *&#xA;     * @param pos the position >= 0&#xA;     * @return  index of the view representing the given position, or &#xA;     *   -1 if no view represents that position&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getChildAllocation">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Fetches the allocation for the given child view. &#xA;     * This enables finding out where various views&#xA;     * are located, without assuming how the views store&#xA;     * their location.  This returns &lt;code>null&lt;/code> since the&#xA;     * default is to not have any child views.&#xA;     *&#xA;     * @param index the index of the child, >= 0 &amp;&amp; &lt;&#xA;     *&#x9;&#x9;&lt;code>getViewCount()&lt;/code>&#xA;     * @param a  the allocation to this view&#xA;     * @return the allocation to the child&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNextVisualPositionFrom">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>Position</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="direction">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="biasRet">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>Position</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BadLocationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Provides a way to determine the next visually represented model &#xA;     * location at which one might place a caret.&#xA;     * Some views may not be visible,&#xA;     * they might not be in the same order found in the model, or they just&#xA;     * might not allow access to some of the locations in the model.&#xA;     *&#xA;     * @param pos the position to convert >= 0&#xA;     * @param a the allocated region in which to render&#xA;     * @param direction the direction from the current position that can&#xA;     *  be thought of as the arrow keys typically found on a keyboard.&#xA;     *  This will be one of the following values:&#xA;     * &lt;ul>&#xA;     * &lt;li>SwingConstants.WEST&#xA;     * &lt;li>SwingConstants.EAST&#xA;     * &lt;li>SwingConstants.NORTH&#xA;     * &lt;li>SwingConstants.SOUTH&#xA;     * &lt;/ul>&#xA;     * @return the location within the model that best represents the next&#xA;     *  location visual position&#xA;     * @exception BadLocationException&#xA;     * @exception IllegalArgumentException if &lt;code>direction&lt;/code>&#xA;     *&#x9;&#x9;doesn't have one of the legal values above&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.4">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="Position$Bias.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
            </next>
            <target xsi:type="classifiers:Interface" href="Position.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Switch">
        <cases xsi:type="statements:NormalSwitchCase">
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../SwingConstants.class.xmi#//@classifiers.0/@members.5"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="expressions:ConditionalExpression">
                      <child xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:EqualityExpression">
                          <equalityOperators xsi:type="operators:Equal"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.3"/>
                          <children xsi:type="references:IdentifierReference">
                            <target xsi:type="members:Field" href="../SwingConstants.class.xmi#//@classifiers.0/@members.5"/>
                          </children>
                        </expression>
                      </child>
                      <expressionIf xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../../../java/lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                          <arguments xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.28"/>
                            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                            <additiveOperators xsi:type="operators:Subtraction"/>
                          </arguments>
                        </next>
                        <target xsi:type="classifiers:Class" href="../../../java/lang/Math.class.xmi#//@classifiers.0"/>
                      </expressionIf>
                      <expressionElse xsi:type="references:MethodCall" target="//@classifiers.0/@members.27"/>
                    </value>
                  </expression>
                </statements>
                <statements xsi:type="statements:Break"/>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                <children xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Subtraction"/>
                  <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </children>
              </condition>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="target">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="JTextComponent.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <initialValue xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="JTextComponent.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.37"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="c">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="Caret.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <initialValue xsi:type="expressions:ConditionalExpression">
                  <child xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.1/@variable"/>
                      <children xsi:type="literals:NullLiteral"/>
                    </expression>
                  </child>
                  <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.1/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="JTextComponent.class.xmi#//@classifiers.0/@members.48"/>
                    </next>
                  </expressionIf>
                  <expressionElse xsi:type="literals:NullLiteral"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="mcp">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <comments>// YECK! Ideally, the x location from the magic caret position</comments>
                    <comments>// would be passed in.</comments>
                    <target xsi:type="classifiers:Class" href="../../../java/awt/Point.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.3/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.2/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:InterfaceMethod" href="Caret.class.xmi#//@classifiers.0/@members.10"/>
                      </next>
                    </value>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.2/@variable"/>
                <children xsi:type="literals:NullLiteral"/>
              </condition>
              <elseStatement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.3/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="literals:NullLiteral"/>
                  </expression>
                </statements>
              </elseStatement>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="x">
                <typeReference xsi:type="types:Int"/>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:LocalVariableStatement">
                  <variable name="loc">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.1/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="JTextComponent.class.xmi#//@classifiers.0/@members.73"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                      </next>
                    </initialValue>
                  </variable>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.5/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="expressions:ConditionalExpression">
                      <child xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:EqualityExpression">
                          <equalityOperators xsi:type="operators:Equal"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.6/@statement/@statements.0/@variable"/>
                          <children xsi:type="literals:NullLiteral"/>
                        </expression>
                      </child>
                      <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.6/@statement/@statements.0/@variable">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.0"/>
                        </next>
                      </expressionElse>
                    </value>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.3/@variable"/>
                <children xsi:type="literals:NullLiteral"/>
              </condition>
              <elseStatement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.5/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.3/@variable">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="../../../java/awt/Point.class.xmi#//@classifiers.0/@members.0"/>
                      </next>
                    </value>
                  </expression>
                </statements>
              </elseStatement>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="Utilities.class.xmi#//@classifiers.0/@members.14"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.1/@variable"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.5/@variable"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="Utilities.class.xmi#//@classifiers.0"/>
                    </value>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.3"/>
                <children xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../SwingConstants.class.xmi#//@classifiers.0/@members.5"/>
                </children>
              </condition>
              <elseStatement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="Utilities.class.xmi#//@classifiers.0/@members.15"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.1/@variable"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@cases.1/@statements.0/@statements.5/@variable"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="Utilities.class.xmi#//@classifiers.0"/>
                    </value>
                  </expression>
                </statements>
              </elseStatement>
            </statements>
          </statements>
          <statements xsi:type="statements:Break"/>
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../SwingConstants.class.xmi#//@classifiers.0/@members.9"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../../java/lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                      <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.28"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="../../../java/lang/Math.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
              <children xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </children>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../../java/lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                      <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="../../../java/lang/Math.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Break"/>
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../SwingConstants.class.xmi#//@classifiers.0/@members.11"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.27"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
              <children xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </children>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../../java/lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </arguments>
                      <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.26">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:InterfaceMethod" href="Document.class.xmi#//@classifiers.0/@members.2"/>
                        </next>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="../../../java/lang/Math.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Break"/>
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../SwingConstants.class.xmi#//@classifiers.0/@members.7"/>
          </condition>
        </cases>
        <cases xsi:type="statements:DefaultSwitchCase">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Bad direction: "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.3"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </cases>
        <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.3"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="modelToView">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>Position</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BadLocationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Provides a mapping, for a given character,&#xA;     * from the document model coordinate space&#xA;     * to the view coordinate space.  &#xA;     *&#xA;     * @param pos the position of the desired character (>=0)&#xA;     * @param a the area of the view, which encompasses the requested character&#xA;     * @param b the bias toward the previous character or the&#xA;     *  next character represented by the offset, in case the &#xA;     *  position is a boundary of two views; &lt;code>b&lt;/code> will have one&#xA;     *  of these values:&#xA;     * &lt;ul>&#xA;     * &lt;li> &lt;code>Position.Bias.Forward&lt;/code>&#xA;     * &lt;li> &lt;code>Position.Bias.Backward&lt;/code>&#xA;     * &lt;/ul>&#xA;     * @return the bounding box, in view coordinate space,&#xA;     *&#x9;&#x9;of the character at the specified position&#xA;     * @exception BadLocationException  if the specified position does&#xA;     *   not represent a valid location in the associated document&#xA;     * @exception IllegalArgumentException if &lt;code>b&lt;/code> is not one of the&#xA;     *&#x9;&#x9;legal &lt;code>Position.Bias&lt;/code> values listed above&#xA;     * @see View#viewToModel&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="modelToView">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="p0">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b0">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>Position</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="p1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b1">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>Position</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BadLocationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Provides a mapping, for a given region,&#xA;     * from the document model coordinate space&#xA;     * to the view coordinate space. The specified region is&#xA;     * created as a union of the first and last character positions.&#xA;     *&#xA;     * @param p0 the position of the first character (>=0)&#xA;     * @param b0 the bias of the first character position,&#xA;     *  toward the previous character or the&#xA;     *  next character represented by the offset, in case the &#xA;     *  position is a boundary of two views; &lt;code>b0&lt;/code> will have one&#xA;     *  of these values:&#xA;     * &lt;ul>&#xA;     * &lt;li> &lt;code>Position.Bias.Forward&lt;/code>&#xA;     * &lt;li> &lt;code>Position.Bias.Backward&lt;/code>&#xA;     * &lt;/ul>&#xA;     * @param p1 the position of the last character (>=0)&#xA;     * @param b1 the bias for the second character position, defined&#xA;     *&#x9;&#x9;one of the legal values shown above&#xA;     * @param a the area of the view, which encompasses the requested region&#xA;     * @return the bounding box which is a union of the region specified&#xA;     *&#x9;&#x9;by the first and last character positions&#xA;     * @exception BadLocationException  if the given position does&#xA;     *   not represent a valid location in the associated document&#xA;     * @exception IllegalArgumentException if &lt;code>b0&lt;/code> or&#xA;     *&#x9;&#x9;&lt;code>b1&lt;/code> are not one of the&#xA;     *&#x9;&#x9;legal &lt;code>Position.Bias&lt;/code> values listed above&#xA;     * @see View#viewToModel&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="s0">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.20">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.4"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="s1">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:TryBlock">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.20">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.4"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.3"/>
                </value>
              </expression>
            </statements>
            <catcheBlocks>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:NullLiteral"/>
                </expression>
              </statements>
              <parameter name="ble">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="BadLocationException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </parameter>
            </catcheBlocks>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="alloc">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <comments>// Assume extends left to right.</comments>
                      <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <initialValue xsi:type="expressions:ConditionalExpression">
                    <child xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:InstanceOfExpression">
                        <typeReference xsi:type="types:NamespaceClassifierReference">
                          <classifierReferences>
                            <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                          </classifierReferences>
                        </typeReference>
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.4"/>
                      </expression>
                    </child>
                    <expressionIf xsi:type="expressions:CastExpression">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.4"/>
                    </expressionIf>
                    <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.4">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:InterfaceMethod" href="../../../java/awt/Shape.class.xmi#//@classifiers.0/@members.0"/>
                      </next>
                    </expressionElse>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.0"/>
                        </next>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.2"/>
                        </next>
                      </children>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.1"/>
                      </next>
                    </arguments>
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.3"/>
                      </next>
                    </arguments>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.1/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.28"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.20">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.4"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.3"/>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="r0">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../../../java/awt/Shape.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="r1">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:InstanceOfExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.1/@variable"/>
              </expression>
            </child>
            <expressionIf xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.1/@variable"/>
            </expressionIf>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../../../java/awt/Shape.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </expressionElse>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="alloc">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <comments>// If it spans lines, force it to be the width of the view.</comments>
                  <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:ConditionalExpression">
                <child xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:InstanceOfExpression">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.4"/>
                  </expression>
                </child>
                <expressionIf xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.4"/>
                </expressionIf>
                <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.4">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../../java/awt/Shape.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                </expressionElse>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.5/@statement/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.2"/>
                </next>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.5/@statement/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.2"/>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.3/@variable">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.4/@variable">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.3/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0/@members.42"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.4/@variable"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.3/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="viewToModel">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="biasReturn">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>Position</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Provides a mapping from the view coordinate space to the logical&#xA;     * coordinate space of the model.  The &lt;code>biasReturn&lt;/code>&#xA;     * argument will be filled in to indicate that the point given is&#xA;     * closer to the next character in the model or the previous&#xA;     * character in the model.&#xA;     *&#xA;     * @param x the X coordinate >= 0&#xA;     * @param y the Y coordinate >= 0&#xA;     * @param a the allocated region in which to render&#xA;     * @return the location within the model that best represents the&#xA;     *  given point in the view >= 0.  The &lt;code>biasReturn&lt;/code>&#xA;     *  argument will be&#xA;     * filled in to indicate that the point given is closer to the next&#xA;     * character in the model or the previous character in the model.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="insertUpdate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="e">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/DocumentEvent.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="ViewFactory.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gives notification that something was inserted into &#xA;     * the document in a location that this view is responsible for.  &#xA;     * To reduce the burden to subclasses, this functionality is&#xA;     * spread out into the following calls that subclasses can&#xA;     * reimplement:&#xA;     * &lt;ol>&#xA;     * &lt;li>&lt;a href=&quot;#updateChildren&quot;>updateChildren&lt;/a> is called&#xA;     * if there were any changes to the element this view is&#xA;     * responsible for.  If this view has child views that are&#xA;     * represent the child elements, then this method should do&#xA;     * whatever is necessary to make sure the child views correctly&#xA;     * represent the model.&#xA;     * &lt;li>&lt;a href=&quot;#forwardUpdate&quot;>forwardUpdate&lt;/a> is called&#xA;     * to forward the DocumentEvent to the appropriate child views.&#xA;     * &lt;li>&lt;a href=&quot;#updateLayout&quot;>updateLayout&lt;/a> is called to&#xA;     * give the view a chance to either repair its layout, to reschedule&#xA;     * layout, or do nothing.&#xA;     * &lt;/ol>&#xA;     *&#xA;     * @param e the change information from the associated document&#xA;     * @param a the current allocation of the view&#xA;     * @param f the factory to use to rebuild if the view has children&#xA;     * @see View#insertUpdate&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="elem">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.29"/>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="ec">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>DocumentEvent</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="../event/DocumentEvent$ElementChange.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../event/DocumentEvent.class.xmi#//@classifiers.0/@members.4"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@statement/@statements.0/@variable"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@statement/@statements.1/@variable">
                        <comments>// don't consider the element changes they</comments>
                        <comments>// are for a view further down.</comments>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="literals:NullLiteral"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Negate"/>
                  <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.41">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@statement/@statements.1/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
                  </child>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@statement/@statements.1/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.42">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@statement/@statements.1/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.44">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@statement/@statements.1/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.10"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeUpdate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="e">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/DocumentEvent.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="ViewFactory.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gives notification that something was removed from the document&#xA;     * in a location that this view is responsible for.&#xA;     * To reduce the burden to subclasses, this functionality is&#xA;     * spread out into the following calls that subclasses can&#xA;     * reimplement:&#xA;     * &lt;ol>&#xA;     * &lt;li>&lt;a href=&quot;#updateChildren&quot;>updateChildren&lt;/a> is called&#xA;     * if there were any changes to the element this view is&#xA;     * responsible for.  If this view has child views that are&#xA;     * represent the child elements, then this method should do&#xA;     * whatever is necessary to make sure the child views correctly&#xA;     * represent the model.&#xA;     * &lt;li>&lt;a href=&quot;#forwardUpdate&quot;>forwardUpdate&lt;/a> is called&#xA;     * to forward the DocumentEvent to the appropriate child views.&#xA;     * &lt;li>&lt;a href=&quot;#updateLayout&quot;>updateLayout&lt;/a> is called to&#xA;     * give the view a chance to either repair its layout, to reschedule&#xA;     * layout, or do nothing.&#xA;     * &lt;/ol>&#xA;     *&#xA;     * @param e the change information from the associated document&#xA;     * @param a the current allocation of the view&#xA;     * @param f the factory to use to rebuild if the view has children&#xA;     * @see View#removeUpdate&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="elem">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.29"/>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="ec">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>DocumentEvent</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="../event/DocumentEvent$ElementChange.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../event/DocumentEvent.class.xmi#//@classifiers.0/@members.4"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@statement/@statements.0/@variable"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@statement/@statements.1/@variable">
                        <comments>// don't consider the element changes they</comments>
                        <comments>// are for a view further down.</comments>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="literals:NullLiteral"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Negate"/>
                  <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.41">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@statement/@statements.1/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.2"/>
                  </child>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@statement/@statements.1/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.42">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@statement/@statements.1/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.2"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.44">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@statement/@statements.1/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.10"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="changedUpdate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="e">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/DocumentEvent.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="ViewFactory.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gives notification from the document that attributes were changed&#xA;     * in a location that this view is responsible for.&#xA;     * To reduce the burden to subclasses, this functionality is&#xA;     * spread out into the following calls that subclasses can&#xA;     * reimplement:&#xA;     * &lt;ol>&#xA;     * &lt;li>&lt;a href=&quot;#updateChildren&quot;>updateChildren&lt;/a> is called&#xA;     * if there were any changes to the element this view is&#xA;     * responsible for.  If this view has child views that are&#xA;     * represent the child elements, then this method should do&#xA;     * whatever is necessary to make sure the child views correctly&#xA;     * represent the model.&#xA;     * &lt;li>&lt;a href=&quot;#forwardUpdate&quot;>forwardUpdate&lt;/a> is called&#xA;     * to forward the DocumentEvent to the appropriate child views.&#xA;     * &lt;li>&lt;a href=&quot;#updateLayout&quot;>updateLayout&lt;/a> is called to&#xA;     * give the view a chance to either repair its layout, to reschedule&#xA;     * layout, or do nothing.&#xA;     * &lt;/ol>&#xA;     *&#xA;     * @param e the change information from the associated document&#xA;     * @param a the current allocation of the view&#xA;     * @param f the factory to use to rebuild if the view has children&#xA;     * @see View#changedUpdate&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="elem">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.29"/>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="ec">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>DocumentEvent</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="../event/DocumentEvent$ElementChange.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../event/DocumentEvent.class.xmi#//@classifiers.0/@members.4"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@statement/@statements.0/@variable"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@statement/@statements.1/@variable">
                        <comments>// don't consider the element changes they</comments>
                        <comments>// are for a view further down.</comments>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="literals:NullLiteral"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Negate"/>
                  <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.41">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@statement/@statements.1/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
                  </child>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@statement/@statements.1/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.42">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@statement/@statements.1/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.44">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@statement/@statements.1/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.10"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDocument">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Document.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Fetches the model associated with the view.&#xA;     *&#xA;     * @return the view model, &lt;code>null&lt;/code> if none&#xA;     * @see View#getDocument&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="Element.class.xmi#//@classifiers.0/@members.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getStartOffset">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Fetches the portion of the model for which this view is&#xA;     * responsible.&#xA;     *&#xA;     * @return the starting offset into the model >= 0&#xA;     * @see View#getStartOffset&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="Element.class.xmi#//@classifiers.0/@members.4"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getEndOffset">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Fetches the portion of the model for which this view is&#xA;     * responsible.&#xA;     *&#xA;     * @return the ending offset into the model >= 0&#xA;     * @see View#getEndOffset&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="Element.class.xmi#//@classifiers.0/@members.5"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getElement">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Fetches the structural portion of the subject that this&#xA;     * view is mapped to.  The view may not be responsible for the&#xA;     * entire portion of the element.&#xA;     *&#xA;     * @return the subject&#xA;     * @see View#getElement&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getGraphics">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/awt/Graphics.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Fetch a &lt;code>Graphics&lt;/code> for rendering.&#xA;     * This can be used to determine&#xA;     * font characteristics, and will be different for a print view&#xA;     * than a component view.&#xA;     *&#xA;     * @return a &lt;code>Graphics&lt;/code> object for rendering&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// PENDING(prinz) this is a temporary implementation</comments>
              <target xsi:type="classifiers:Class" href="../../../java/awt/Component.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.37"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../java/awt/Component.class.xmi#//@classifiers.0/@members.192"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAttributes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="AttributeSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Fetches the attributes to use when rendering.  By default&#xA;     * this simply returns the attributes of the associated element.&#xA;     * This method should be used rather than using the element&#xA;     * directly to obtain access to the attributes to allow&#xA;     * view-specific attributes to be mixed in or to allow the&#xA;     * view to have view-specific conversion of attributes by&#xA;     * subclasses.&#xA;     * Each view should document what attributes it recognizes&#xA;     * for the purpose of rendering or layout, and should always&#xA;     * access them through the &lt;code>AttributeSet&lt;/code> returned&#xA;     * by this method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="Element.class.xmi#//@classifiers.0/@members.3"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="breakView">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="axis">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tries to break this view on the given axis.  This is&#xA;     * called by views that try to do formatting of their&#xA;     * children.  For example, a view of a paragraph will&#xA;     * typically try to place its children into row and &#xA;     * views representing chunks of text can sometimes be &#xA;     * broken down into smaller pieces.&#xA;     * &lt;p>&#xA;     * This is implemented to return the view itself, which&#xA;     * represents the default behavior on not being&#xA;     * breakable.  If the view does support breaking, the&#xA;     * starting offset of the view returned should be the&#xA;     * given offset, and the end offset should be less than&#xA;     * or equal to the end offset of the view being broken.&#xA;     *&#xA;     * @param axis may be either &lt;code>View.X_AXIS&lt;/code> or&#xA;     *&#x9;&#x9;&lt;code>View.Y_AXIS&lt;/code>&#xA;     * @param offset the location in the document model&#xA;     *   that a broken fragment would occupy >= 0.  This&#xA;     *   would be the starting offset of the fragment&#xA;     *   returned&#xA;     * @param pos the position along the axis that the&#xA;     *  broken view would occupy >= 0.  This may be useful for&#xA;     *  things like tab calculations&#xA;     * @param len specifies the distance along the axis&#xA;     *  where a potential break is desired >= 0&#xA;     * @return the fragment of the view that represents the&#xA;     *  given span, if the view can be broken.  If the view&#xA;     *  doesn't support breaking behavior, the view itself is&#xA;     *  returned.&#xA;     * @see ParagraphView&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createFragment">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="p0">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="p1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a view that represents a portion of the element.&#xA;     * This is potentially useful during formatting operations&#xA;     * for taking measurements of fragments of the view.  If &#xA;     * the view doesn't support fragmenting (the default), it &#xA;     * should return itself.  &#xA;     *&#xA;     * @param p0 the starting offset >= 0.  This should be a value&#xA;     *   greater or equal to the element starting offset and&#xA;     *   less than the element ending offset.&#xA;     * @param p1 the ending offset > p0.  This should be a value&#xA;     *   less than or equal to the elements end offset and&#xA;     *   greater than the elements starting offset.&#xA;     * @return the view fragment, or itself if the view doesn't&#xA;     *   support breaking into fragments&#xA;     * @see LabelView&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getBreakWeight">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="axis">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines how attractive a break opportunity in &#xA;     * this view is.  This can be used for determining which&#xA;     * view is the most attractive to call &lt;code>breakView&lt;/code>&#xA;     * on in the process of formatting.  A view that represents&#xA;     * text that has whitespace in it might be more attractive&#xA;     * than a view that has no whitespace, for example.  The&#xA;     * higher the weight, the more attractive the break.  A&#xA;     * value equal to or lower than &lt;code>BadBreakWeight&lt;/code>&#xA;     * should not be considered for a break.  A value greater&#xA;     * than or equal to &lt;code>ForcedBreakWeight&lt;/code> should&#xA;     * be broken.&#xA;     * &lt;p>&#xA;     * This is implemented to provide the default behavior&#xA;     * of returning &lt;code>BadBreakWeight&lt;/code> unless the length&#xA;     * is greater than the length of the view in which case the &#xA;     * entire view represents the fragment.  Unless a view has&#xA;     * been written to support breaking behavior, it is not&#xA;     * attractive to try and break the view.  An example of&#xA;     * a view that does support breaking is &lt;code>LabelView&lt;/code>.&#xA;     * An example of a view that uses break weight is &#xA;     * &lt;code>ParagraphView&lt;/code>.&#xA;     *&#xA;     * @param axis may be either &lt;code>View.X_AXIS&lt;/code> or&#xA;     *&#x9;&#x9;&lt;code>View.Y_AXIS&lt;/code>&#xA;     * @param pos the potential location of the start of the &#xA;     *   broken view >= 0.  This may be useful for calculating tab&#xA;     *   positions&#xA;     * @param len specifies the relative length from &lt;em>pos&lt;/em>&#xA;     *   where a potential break is desired >= 0&#xA;     * @return the weight, which should be a value between&#xA;     *   ForcedBreakWeight and BadBreakWeight&#xA;     * @see LabelView&#xA;     * @see ParagraphView&#xA;     * @see #BadBreakWeight&#xA;     * @see #GoodBreakWeight&#xA;     * @see #ExcellentBreakWeight&#xA;     * @see #ForcedBreakWeight&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.2"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.3">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getResizeWeight">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="axis">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines the resizability of the view along the&#xA;     * given axis.  A value of 0 or less is not resizable.&#xA;     *&#xA;     * @param axis may be either &lt;code>View.X_AXIS&lt;/code> or&#xA;     *&#x9;&#x9;&lt;code>View.Y_AXIS&lt;/code>&#xA;     * @return the weight&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setSize">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the size of the view.  This should cause &#xA;     * layout of the view along the given axis, if it &#xA;     * has any layout duties.&#xA;     *&#xA;     * @param width the width >= 0&#xA;     * @param height the height >= 0&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getContainer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/awt/Container.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Fetches the container hosting the view.  This is useful for&#xA;     * things like scheduling a repaint, finding out the host &#xA;     * components font, etc.  The default implementation&#xA;     * of this is to forward the query to the parent view.&#xA;     *&#xA;     * @return the container, &lt;code>null&lt;/code> if none&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.37"/>
          </expressionIf>
          <expressionElse xsi:type="literals:NullLiteral"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getViewFactory">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="ViewFactory.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Fetches the &lt;code>ViewFactory&lt;/code> implementation that is feeding&#xA;     * the view hierarchy.  Normally the views are given this&#xA;     * as an argument to updates from the model when they&#xA;     * are most likely to need the factory, but this&#xA;     * method serves to provide it at other times.&#xA;     *&#xA;     * @return the factory, &lt;code>null&lt;/code> if none&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.38"/>
          </expressionIf>
          <expressionElse xsi:type="literals:NullLiteral"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getToolTipText">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="allocation">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the tooltip text at the specified location. The default&#xA;     * implementation returns the value from the child View identified by&#xA;     * the passed in location.&#xA;     *&#xA;     * @since 1.4&#xA;     * @see JTextComponent#getToolTipText&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="viewIndex">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.2"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.0/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.2"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="rect">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:ConditionalExpression">
                <child xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:InstanceOfExpression">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.2"/>
                  </expression>
                </child>
                <expressionIf xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.2"/>
                </expressionIf>
                <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.2">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../../java/awt/Shape.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                </expressionElse>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.39">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.2"/>
                  </next>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.0/@variable"/>
                </returnValue>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.1/@statement/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../java/awt/geom/Rectangle2D.class.xmi#//@classifiers.0/@members.13"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
              </next>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getViewIndex">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="allocation">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the child view index representing the given position in&#xA;     * the view. This iterates over all the children returning the&#xA;     * first with a bounds that contains &lt;code>x&lt;/code>, &lt;code>y&lt;/code>.&#xA;     *&#xA;     * @param x the x coordinate&#xA;     * @param y the y coordinate&#xA;     * @param allocation current allocation of the View.&#xA;     * @return  index of the view representing the given location, or &#xA;     *   -1 if no view represents that position&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="childAllocation">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@init"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.2"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="rect">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <initialValue xsi:type="expressions:ConditionalExpression">
                    <child xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:InstanceOfExpression">
                        <typeReference xsi:type="types:NamespaceClassifierReference">
                          <classifierReferences>
                            <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                          </classifierReferences>
                        </typeReference>
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@statement/@statements.0/@variable"/>
                      </expression>
                    </child>
                    <expressionIf xsi:type="expressions:CastExpression">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../../../java/awt/Rectangle.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@statement/@statements.0/@variable"/>
                    </expressionIf>
                    <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.2">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:InterfaceMethod" href="../../../java/awt/Shape.class.xmi#//@classifiers.0/@members.0"/>
                      </next>
                    </expressionElse>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Return">
                    <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@init"/>
                  </statements>
                </statement>
                <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../java/awt/geom/Rectangle2D.class.xmi#//@classifiers.0/@members.13"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
                  </next>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@init"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="counter">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.10"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@init"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="updateChildren">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ec">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>DocumentEvent</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/DocumentEvent$ElementChange.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="e">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/DocumentEvent.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="ViewFactory.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Updates the child views in response to receiving notification&#xA;     * that the model changed, and there is change record for the &#xA;     * element this view is responsible for.  This is implemented&#xA;     * to assume the child views are directly responsible for the&#xA;     * child elements of the element this view represents.  The&#xA;     * &lt;code>ViewFactory&lt;/code> is used to create child views for each element&#xA;     * specified as added in the &lt;code>ElementChange&lt;/code>, starting at the&#xA;     * index specified in the given &lt;code>ElementChange&lt;/code>.  The number of&#xA;     * child views representing the removed elements specified are &#xA;     * removed.&#xA;     * &#xA;     * @param ec the change information for the element this view&#xA;     *  is responsible for.  This should not be &lt;code>null&lt;/code> if &#xA;     *  this method gets called&#xA;     * @param e the change information from the associated document&#xA;     * @param f the factory to use to build child views&#xA;     * @return whether or not the child views represent the&#xA;     *  child elements of the element this view is responsible&#xA;     *  for.  Some views create children that represent a portion &#xA;     *  of the element they are responsible for, and should return&#xA;     *  false.  This information is used to determine if views &#xA;     *  in the range of the added elements should be forwarded to&#xA;     *  or not&#xA;     * @see #insertUpdate&#xA;     * @see #removeUpdate&#xA;     * @see #changedUpdate&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="removedElems">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../event/DocumentEvent$ElementChange.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="addedElems">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../event/DocumentEvent$ElementChange.class.xmi#//@classifiers.0/@members.3"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="added">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="arrays:ArrayInstantiationBySize">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.1/@variable">
                  <next xsi:type="references:IdentifierReference"/>
                </sizes>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.2/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@statement/@statements.1/@init"/>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.2">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="ViewFactory.class.xmi#//@classifiers.0/@members.0"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.1/@variable">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@statement/@statements.1/@init"/>
                        </arraySelectors>
                      </arguments>
                    </next>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@statement/@statements.1/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@statement/@statements.1/@init"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.1/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="nremoved">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="index">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../event/DocumentEvent$ElementChange.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.4/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.5/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.4/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.2/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="forwardUpdate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ec">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>DocumentEvent</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/DocumentEvent$ElementChange.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="e">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/DocumentEvent.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="ViewFactory.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Forwards the given &lt;code>DocumentEvent&lt;/code> to the child views&#xA;     * that need to be notified of the change to the model.&#xA;     * If there were changes to the element this view is &#xA;     * responsible for, that should be considered when &#xA;     * forwarding (i.e. new child views should not get&#xA;     * notified).&#xA;     *&#xA;     * @param ec changes to the element this view is responsible&#xA;     *  for (may be &lt;code>null&lt;/code> if there were no changes).&#xA;     * @param e the change information from the associated document&#xA;     * @param a the current allocation of the view&#xA;     * @param f the factory to use to rebuild if the view has children&#xA;     * @see #insertUpdate&#xA;     * @see #removeUpdate&#xA;     * @see #changedUpdate     &#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="elem">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.29"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="pos">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../event/DocumentEvent.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="index0">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.17">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.1/@variable"/>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Position$Bias.class.xmi#//@classifiers.0/@members.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
              </next>
              <target xsi:type="classifiers:Interface" href="Position.class.xmi#//@classifiers.0"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.2/@variable">
                <comments>// Event beyond our offsets. We may have represented this, that is</comments>
                <comments>// the remove may have removed one of our child Elements that</comments>
                <comments>// represented this, so, we should foward to last element.</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.10"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.2/@variable"/>
            <children xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </children>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../event/DocumentEvent.class.xmi#//@classifiers.0/@members.3"/>
              </next>
            </children>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../event/DocumentEvent$EventType.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="../event/DocumentEvent$EventType.class.xmi#//@classifiers.0"/>
              </next>
              <target xsi:type="classifiers:Interface" href="../event/DocumentEvent.class.xmi#//@classifiers.0"/>
            </children>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.1/@variable"/>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.28"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="index1">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.2/@variable"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.2/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </expression>
            </child>
            <expressionIf xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.2/@variable"/>
            </expressionIf>
            <expressionElse xsi:type="literals:NullLiteral"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.2/@variable">
                    <comments>// If v is at a boundary, forward the event to the previous</comments>
                    <comments>// view too.</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../../java/lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.2/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </arguments>
                      <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../../../java/lang/Math.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.5/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.27"/>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.1/@variable"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.1/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </expression>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.5/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.4/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.17">
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.1/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.1">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="../event/DocumentEvent.class.xmi#//@classifiers.0/@members.1"/>
                    </next>
                  </children>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="Position$Bias.class.xmi#//@classifiers.0/@members.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
                  </next>
                  <target xsi:type="classifiers:Interface" href="Position.class.xmi#//@classifiers.0"/>
                </arguments>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.4/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.10"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Subtraction"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.4/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../event/DocumentEvent.class.xmi#//@classifiers.0/@members.3"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../event/DocumentEvent$EventType.class.xmi#//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="../event/DocumentEvent$EventType.class.xmi#//@classifiers.0"/>
            </next>
            <target xsi:type="classifiers:Interface" href="../event/DocumentEvent.class.xmi#//@classifiers.0"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="hole0">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.4/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="hole1">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.8/@variable"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="addedElems">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
                <children xsi:type="literals:NullLiteral"/>
              </expression>
            </child>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../event/DocumentEvent$ElementChange.class.xmi#//@classifiers.0/@members.3"/>
              </next>
            </expressionIf>
            <expressionElse xsi:type="literals:NullLiteral"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.8/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../event/DocumentEvent$ElementChange.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.9/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.8/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.10/@variable">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.10/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.10/@variable">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.2/@variable">
            <comments>// forward to any view not in the forwarding hole </comments>
            <comments>// formed by added elements (i.e. they will be updated</comments>
            <comments>// by initialization.</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../java/lang/Math.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.2/@variable"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Math.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.5/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.13/@init"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="childAlloc">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.13/@init"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.2"/>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.43">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.5/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.1"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.13/@statement/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.3"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.5/@variable"/>
                  <children xsi:type="literals:NullLiteral"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.13/@init"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.8/@variable"/>
                      <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                    </expression>
                  </children>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.13/@init"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.9/@variable"/>
                      <relationOperators xsi:type="operators:LessThanOrEqual"/>
                    </expression>
                  </children>
                </expression>
              </child>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.13/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.4/@variable"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.2/@variable"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.13/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="forwardUpdateToView">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="e">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/DocumentEvent.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="ViewFactory.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Forwards the &lt;code>DocumentEvent&lt;/code> to the give child view.  This&#xA;     * simply messages the view with a call to &lt;code>insertUpdate&lt;/code>, &#xA;     * &lt;code>removeUpdate&lt;/code>, or &lt;code>changedUpdate&lt;/code> depending&#xA;     * upon the type of the event.  This is called by&#xA;     * &lt;a href=&quot;#forwardUpdate&quot;>forwardUpdate&lt;/a> to forward &#xA;     * the event to children that need it.&#xA;     *&#xA;     * @param v the child view to forward the event to&#xA;     * @param e the change information from the associated document&#xA;     * @param a the current allocation of the view&#xA;     * @param f the factory to use to rebuild if the view has children&#xA;     * @see #forwardUpdate&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="type">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <namespaces>DocumentEvent</namespaces>
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../event/DocumentEvent$EventType.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../event/DocumentEvent.class.xmi#//@classifiers.0/@members.3"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.1"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.2"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.3"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../event/DocumentEvent$EventType.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../event/DocumentEvent$EventType.class.xmi#//@classifiers.0"/>
            </next>
            <target xsi:type="classifiers:Interface" href="../event/DocumentEvent.class.xmi#//@classifiers.0"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.2"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.3"/>
                </next>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../event/DocumentEvent$EventType.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="../event/DocumentEvent$EventType.class.xmi#//@classifiers.0"/>
              </next>
              <target xsi:type="classifiers:Interface" href="../event/DocumentEvent.class.xmi#//@classifiers.0"/>
            </children>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.2"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.3"/>
                </next>
              </expression>
            </statements>
          </elseStatement>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="updateLayout">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ec">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>DocumentEvent</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/DocumentEvent$ElementChange.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="e">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/DocumentEvent.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Updates the layout in response to receiving notification of&#xA;     * change from the model.  This is implemented to call&#xA;     * &lt;code>preferenceChanged&lt;/code> to reschedule a new layout&#xA;     * if the &lt;code>ElementChange&lt;/code> record is not &lt;code>null&lt;/code>.&#xA;     *&#xA;     * @param ec changes to the element this view is responsible&#xA;     *  for (may be &lt;code>null&lt;/code> if there were no changes)&#xA;     * @param e the change information from the associated document&#xA;     * @param a the current allocation of the view&#xA;     * @see #insertUpdate&#xA;     * @see #removeUpdate&#xA;     * @see #changedUpdate     &#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
              <comments>// should damage more intelligently</comments>
              <arguments xsi:type="literals:NullLiteral"/>
              <arguments xsi:type="literals:BooleanLiteral" value="true"/>
              <arguments xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="host">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../java/awt/Container.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.37"/>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.0/@statement/@statements.1/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../java/awt/Component.class.xmi#//@classifiers.0/@members.203"/>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.0/@statement/@statements.1/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.2"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:Field" name="BadBreakWeight">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The weight to indicate a view is a bad break&#xA;     * opportunity for the purpose of formatting.  This&#xA;     * value indicates that no attempt should be made to&#xA;     * break the view into fragments as the view has &#xA;     * not been written to support fragmenting.&#xA;     *&#xA;     * @see #getBreakWeight&#xA;     * @see #GoodBreakWeight&#xA;     * @see #ExcellentBreakWeight&#xA;     * @see #ForcedBreakWeight&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="GoodBreakWeight">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1000"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The weight to indicate a view supports breaking,&#xA;     * but better opportunities probably exist.&#xA;     * &#xA;     * @see #getBreakWeight&#xA;     * @see #BadBreakWeight&#xA;     * @see #ExcellentBreakWeight&#xA;     * @see #ForcedBreakWeight&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ExcellentBreakWeight">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2000"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The weight to indicate a view supports breaking,&#xA;     * and this represents a very attractive place to&#xA;     * break.&#xA;     *&#xA;     * @see #getBreakWeight&#xA;     * @see #BadBreakWeight&#xA;     * @see #GoodBreakWeight&#xA;     * @see #ForcedBreakWeight&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ForcedBreakWeight">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3000"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The weight to indicate a view supports breaking,&#xA;     * and must be broken to be represented properly &#xA;     * when placed in a view that formats its children&#xA;     * by breaking them.&#xA;     *&#xA;     * @see #getBreakWeight&#xA;     * @see #BadBreakWeight&#xA;     * @see #GoodBreakWeight&#xA;     * @see #ExcellentBreakWeight&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="X_AXIS">
      <initialValue xsi:type="references:IdentifierReference">
        <target xsi:type="members:Field" href="../SwingConstants.class.xmi#//@classifiers.0/@members.13"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Axis for format/break operations.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="Y_AXIS">
      <initialValue xsi:type="references:IdentifierReference">
        <target xsi:type="members:Field" href="../SwingConstants.class.xmi#//@classifiers.0/@members.14"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Axis for format/break operations.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="modelToView">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BadLocationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Provides a mapping from the document model coordinate space&#xA;     * to the coordinate space of the view mapped to it. This is &#xA;     * implemented to default the bias to &lt;code>Position.Bias.Forward&lt;/code>&#xA;     * which was previously implied.&#xA;     *&#xA;     * @param pos the position to convert >= 0&#xA;     * @param a the allocated region in which to render&#xA;     * @return the bounding box of the given position is returned&#xA;     * @exception BadLocationException  if the given position does&#xA;     *   not represent a valid location in the associated document&#xA;     * @see View#modelToView&#xA;     * @deprecated&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="../../../java/lang/Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.20">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="Position$Bias.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
            </next>
            <target xsi:type="classifiers:Interface" href="Position.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="viewToModel">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/awt/Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Provides a mapping from the view coordinate space to the logical&#xA;     * coordinate space of the model.&#xA;     *&#xA;     * @param x the X coordinate >= 0&#xA;     * @param y the Y coordinate >= 0&#xA;     * @param a the allocated region in which to render&#xA;     * @return the location within the model that best represents the&#xA;     *  given point in the view >= 0&#xA;     * @see View#viewToModel&#xA;     * @deprecated&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="../../../java/lang/Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="Position$Bias.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
            </next>
            <target xsi:type="classifiers:Interface" href="Position.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="sharedBiasReturn">
      <initialValue xsi:type="arrays:ArrayInstantiationBySize">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>Position</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <namespaces>Position</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Position$Bias.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>// static argument available for viewToModel calls since only</comments>
        <comments>// one thread at a time may call this method.</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="parent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="elem">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;p>&#xA; * A very important part of the text package is the &lt;code>View&lt;/code> class.&#xA; * As the name suggests it represents a view of the text model,&#xA; * or a piece of the text model. &#xA; * It is this class that is responsible for the look of the text component.  &#xA; * The view is not intended to be some completely new thing that one must&#xA; * learn, but rather is much like a lightweight component.&#xA; * In fact, the original &lt;code>View&lt;/code> implementation was a&#xA; * lightweight component.   There were several reasons why&#xA; * the &lt;code>Component&lt;/code> implementation was abandoned in favor of&#xA; * an alternative.&#xA; * &lt;ol>&#xA; * &lt;li>&#xA; * &lt;p>&#xA; * There was barely time to get the lightweight component support in the &#xA; * 1.1 version of the JDK.  There simply wasn't time to lighten up the &#xA; * component further to where it would need to be to be used for text purposes.&#xA; * The additions made to &lt;code>JComponent&lt;/code> increased the memory&#xA; * consumption, and as it currently stands its much too heavy for&#xA; * representing text.&#xA; * &lt;/p>&#xA; * &lt;li>&#xA; * &lt;p>&#xA; * The layout semantics aren't quite right for text,&#xA; * and changing the current layout &#xA; * semantics of component might break existing applications.&#xA; * &lt;/p>&#xA; * &lt;li>&#xA; * &lt;p>&#xA; * The component api uses integers, but in 1.2 one can use floating point&#xA; * device independent coordinates.  An api that works in both 1.1 and 1.2&#xA; * would be convenient for minimizing transition difficulties.  The&#xA; * &lt;code>View&lt;/code> class uses the &lt;code>Shape&lt;/code> interface and&#xA; * float arguments to enable View implementations for the Java 2 platform&#xA; * v1.2 and later while still functioning in the older 1.1 JDK.&#xA; * &lt;/p>&#xA; * &lt;/ol>&#xA; * &lt;p>&#xA;By default, a view is very light.  It contains a reference to the parent &#xA;view from which it can fetch many things without holding state, and it &#xA;contains a reference to a portion of the model (&lt;/code>Element&lt;/code>).&#xA;A view does not &#xA;have to exactly represent an element in the model, that is simply a typical &#xA;and therefore convenient mapping.  A view can alternatively maintain a couple &#xA;of Position objects to maintain its location in the model (i.e. represent &#xA;a fragment of an element).  This is typically the result of formatting where &#xA;views have been broken down into pieces.  The convenience of a substantial &#xA;relationship to the element makes it easier to build factories to produce the &#xA;views, and makes it easier  to keep track of the view pieces as the model is &#xA;changed and the view must be changed to reflect the model.  Simple views &#xA;therefore represent an Element directly and complex views do not.&#xA;&lt;p>&#xA;A view has the following responsibilities:&#xA;  &lt;dl>&#xA;&#xA;    &lt;dt>&lt;b>Participate in layout.&lt;/b>&#xA;    &lt;dd>&#xA;    &lt;p>The view has a &lt;code>setSize&lt;/code> method which is like&#xA;    &lt;code>doLayout&lt;/code> and &lt;code>setSize&lt;/code> in &lt;code>Component&lt;/code> combined.&#xA;    The view has a &lt;code>preferenceChanged&lt;/code> method which is &#xA;    like &lt;code>invalidate&lt;/code> in &lt;code>Component&lt;/code> except that one can&#xA;    invalidate just one axis &#xA;    and the child requesting the change is identified.&#xA;    &lt;p>A View expresses the size that it would like to be in terms of three&#xA;    values, a minimum, a preferred, and a maximum span.  Layout in a view is&#xA;    can be done independently upon each axis.  For a properly functioning View&#xA;    implementation, the minimum span will be &amp;lt;= the preferred span which in turn&#xA;    will be &amp;lt;= the maximum span.&#xA;    &lt;/p>&#xA;    &lt;p align=center>&lt;img src=&quot;doc-files/View-flexibility.jpg&quot; &#xA;                     alt=&quot;The above text describes this graphic.&quot;>&#xA;    &lt;p>The minimum set of methods for layout are:&#xA;    &lt;ul>&#xA;    &lt;li>&lt;a href=&quot;#getMinimumSpan(int)&quot;>getMinimumSpan&lt;/a>&#xA;    &lt;li>&lt;a href=&quot;#getPreferredSpan(int)&quot;>getPreferredSpan&lt;/a>&#xA;    &lt;li>&lt;a href=&quot;#getMaximumSpan(int)&quot;>getMaximumSpan&lt;/a>&#xA;    &lt;li>&lt;a href=&quot;#getAlignment(int)&quot;>getAlignment&lt;/a>&#xA;    &lt;li>&lt;a href=&quot;#preferenceChanged(javax.swing.text.View, boolean, boolean)&quot;>preferenceChanged&lt;/a>&#xA;    &lt;li>&lt;a href=&quot;#setSize(float, float)&quot;>setSize&lt;/a>&#xA;    &lt;/ul>&#xA;  &#xA;  &lt;p>The &lt;code>setSize&lt;/code> method should be prepared to be called a number of times&#xA;    (i.e. It may be called even if the size didn't change). &#xA;    The &lt;code>setSize&lt;/code> method&#xA;    is generally called to make sure the View layout is complete prior to trying&#xA;    to perform an operation on it that requires an up-to-date layout.  A view's&#xA;    size should &lt;em>always&lt;/em> be set to a value within the minimum and maximum&#xA;    span specified by that view.  Additionally, the view must always call the&#xA;    &lt;code>preferenceChanged&lt;/code> method on the parent if it has changed the&#xA;    values for the&#xA;    layout it would like, and expects the parent to honor.  The parent View is&#xA;    not required to recognize a change until the &lt;code>preferenceChanged&lt;/code>&#xA;    has been sent.&#xA;    This allows parent View implementations to cache the child requirements if&#xA;    desired.  The calling sequence looks something like the following:&#xA;    &lt;/p>&#xA;    &lt;p align=center>&#xA;      &lt;img src=&quot;doc-files/View-layout.jpg&quot; &#xA;       alt=&quot;Sample calling sequence between parent view and child view: &#xA;       setSize, getMinimum, getPreferred, getMaximum, getAlignment, setSize&quot;>&#xA;    &lt;p>The exact calling sequence is up to the layout functionality of&#xA;    the parent view (if the view has any children).  The view may collect&#xA;    the preferences of the children prior to determining what it will give &#xA;    each child, or it might iteratively update the children one at a time.&#xA;    &lt;/p>&#xA;&#xA;    &lt;dt>&lt;b>Render a portion of the model.&lt;/b>&#xA;    &lt;dd>&#xA;    &lt;p>This is done in the paint method, which is pretty much like a component &#xA;    paint method.  Views are expected to potentially populate a fairly large &#xA;    tree.  A &lt;code>View&lt;/code> has the following semantics for rendering:&#xA;    &lt;/p>&#xA;    &lt;ul>&#xA;    &lt;li>The view gets its allocation from the parent at paint time, so it &#xA;    must be prepared to redo layout if the allocated area is different from &#xA;    what it is prepared to deal with.&#xA;    &lt;li>The coordinate system is the same as the hosting &lt;code>Component&lt;/code>&#xA;    (i.e. the &lt;code>Component&lt;/code> returned by the&#xA;    &lt;a href=&quot;#getContainer&quot;>getContainer&lt;/a> method).&#xA;    This means a child view lives in the same coordinate system as the parent&#xA;    view unless the parent has explicitly changed the coordinate system.&#xA;    To schedule itself to be repainted a view can call repaint on the hosting&#xA;    &lt;code>Component&lt;/code>.&#xA;    &lt;li>The default is to &lt;em>not clip&lt;/em> the children.  It is more efficient&#xA;    to allow a view to clip only if it really feels it needs clipping.&#xA;    &lt;li>The &lt;code>Graphics&lt;/code> object given is not initialized in any way. &#xA;    A view should set any settings needed.&#xA;    &lt;li>A &lt;code>View&lt;/code> is inherently transparent.  While a view may render into its&#xA;    entire allocation, typically a view does not.  Rendering is performed by&#xA;    tranversing down the tree of &lt;code>View&lt;/code> implementations. &#xA;    Each &lt;code>View&lt;/code> is responsible&#xA;    for rendering its children.  This behavior is depended upon for thread&#xA;    safety.  While view implementations do not necessarily have to be implemented&#xA;    with thread safety in mind, other view implementations that do make use of&#xA;    concurrency can depend upon a tree traversal to guarantee thread safety.&#xA;    &lt;li>The order of views relative to the model is up to the implementation.&#xA;    Although child views will typically be arranged in the same order that they&#xA;    occur in the model, they may be visually arranged in an entirely different &#xA;    order.  View implementations may have Z-Order associated with them if the&#xA;    children are overlapping.&#xA;    &lt;/ul>&#xA;    &lt;p>The methods for rendering are:&#xA;    &lt;ul>&#xA;    &lt;li>&lt;a href=&quot;#paint(java.awt.Graphics, java.awt.Shape)&quot;>paint&lt;/a>&#xA;    &lt;/ul>&#xA;    &lt;p>&#xA;&#xA;    &lt;dt>&lt;b>Translate between the model and view coordinate systems.&lt;/b>&#xA;    &lt;dd>&#xA;    &lt;p>Because the view objects are produced from a factory and therefore cannot &#xA;    necessarily be counted upon to be in a particular pattern, one must be able &#xA;    to perform translation to properly locate spatial representation of the model.  &#xA;    The methods for doing this are:&#xA;    &lt;ul>&#xA;    &lt;li>&lt;a href=&quot;#modelToView(int, javax.swing.text.Position.Bias, int, javax.swing.text.Position.Bias, java.awt.Shape)&quot;>modelToView&lt;/a>&#xA;    &lt;li>&lt;a href=&quot;#viewToModel(float, float, java.awt.Shape, javax.swing.text.Position.Bias[])&quot;>viewToModel&lt;/a>&#xA;    &lt;li>&lt;a href=&quot;#getDocument()&quot;>getDocument&lt;/a>&#xA;    &lt;li>&lt;a href=&quot;#getElement()&quot;>getElement&lt;/a>&#xA;    &lt;li>&lt;a href=&quot;#getStartOffset()&quot;>getStartOffset&lt;/a>&#xA;    &lt;li>&lt;a href=&quot;#getEndOffset()&quot;>getEndOffset&lt;/a>&#xA;    &lt;/ul>&#xA;    &lt;p>The layout must be valid prior to attempting to make the translation.&#xA;    The translation is not valid, and must not be attempted while changes&#xA;    are being broadcasted from the model via a &lt;code>DocumentEvent&lt;/code>.  &#xA;    &lt;/p>&#xA;&#xA;    &lt;dt>&lt;b>Respond to changes from the model.&lt;/b>&#xA;    &lt;dd>&#xA;    &lt;p>If the overall view is represented by many pieces (which is the best situation &#xA;    if one want to be able to change the view and write the least amount of new code), &#xA;    it would be impractical to have a huge number of &lt;code>DocumentListener&lt;/code>s.&#xA;    If each &#xA;    view listened to the model, only a few would actually be interested in the &#xA;    changes broadcasted at any given time.   Since the model has no knowledge of &#xA;    views, it has no way to filter the broadcast of change information.  The view &#xA;    hierarchy itself is instead responsible for propagating the change information.  &#xA;    At any level in the view hierarchy, that view knows enough about its children to &#xA;    best distribute the change information further.   Changes are therefore broadcasted &#xA;    starting from the root of the view hierarchy.&#xA;    The methods for doing this are:&#xA;    &lt;ul>&#xA;    &lt;li>&lt;a href=&quot;#insertUpdate&quot;>insertUpdate&lt;/a>&#xA;    &lt;li>&lt;a href=&quot;#removeUpdate&quot;>removeUpdate&lt;/a>&#xA;    &lt;li>&lt;a href=&quot;#changedUpdate&quot;>changedUpdate&lt;/a>&#xA;    &lt;/ul>    &#xA;    &lt;p>&#xA;&lt;/dl>&#xA; *&#xA; * @author  Timothy Prinzing&#xA; * @version 1.70 05/18/04&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../SwingConstants.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
