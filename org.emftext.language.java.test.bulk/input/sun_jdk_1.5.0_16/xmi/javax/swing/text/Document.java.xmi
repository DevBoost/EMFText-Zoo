<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/types ../../../java.ecore#/16" name="Document.java">
  <comments>/*&#xA; * @(#)Document.java&#x9;1.43 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>swing</namespaces>
  <namespaces>text</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>javax</namespaces>
    <namespaces>swing</namespaces>
    <namespaces>event</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="Document">
    <members xsi:type="members:InterfaceMethod" name="getLength">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns number of characters of content currently &#xA;     * in the document.&#xA;     *&#xA;     * @return number of characters >= 0&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addDocumentListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/DocumentListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Registers the given observer to begin receiving notifications&#xA;     * when changes are made to the document.&#xA;     *&#xA;     * @param listener the observer to register&#xA;     * @see Document#removeDocumentListener&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removeDocumentListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/DocumentListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Unregisters the given observer from the notification list&#xA;     * so it will no longer receive change updates.  &#xA;     *&#xA;     * @param listener the observer to register&#xA;     * @see Document#addDocumentListener&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addUndoableEditListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/UndoableEditListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Registers the given observer to begin receiving notifications&#xA;     * when undoable edits are made to the document.&#xA;     *&#xA;     * @param listener the observer to register&#xA;     * @see javax.swing.event.UndoableEditEvent&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removeUndoableEditListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../event/UndoableEditListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Unregisters the given observer from the notification list&#xA;     * so it will no longer receive updates.&#xA;     *&#xA;     * @param listener the observer to register&#xA;     * @see javax.swing.event.UndoableEditEvent&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getProperty">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the properties associated with the document.&#xA;     *&#xA;     * @param key a non-&lt;code>null&lt;/code> property key&#xA;     * @return the properties&#xA;     * @see #putProperty(Object, Object)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putProperty">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Associates a property with the document.  Two standard &#xA;     * property keys provided are: &lt;a href=&quot;#StreamDescriptionProperty&quot;>&#xA;     * &lt;code>StreamDescriptionProperty&lt;/code>&lt;/a> and&#xA;     * &lt;a href=&quot;#TitleProperty&quot;>&lt;code>TitleProperty&lt;/code>&lt;/a>.&#xA;     * Other properties, such as author, may also be defined.&#xA;     *&#xA;     * @param key the non-&lt;code>null&lt;/code> property key&#xA;     * @param value the property value&#xA;     * @see #getProperty(Object)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="remove">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offs">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BadLocationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes a portion of the content of the document.  &#xA;     * This will cause a DocumentEvent of type &#xA;     * DocumentEvent.EventType.REMOVE to be sent to the &#xA;     * registered DocumentListeners, unless an exception&#xA;     * is thrown.  The notification will be sent to the&#xA;     * listeners by calling the removeUpdate method on the&#xA;     * DocumentListeners.&#xA;     * &lt;p>&#xA;     * To ensure reasonable behavior in the face &#xA;     * of concurrency, the event is dispatched after the &#xA;     * mutation has occurred. This means that by the time a &#xA;     * notification of removal is dispatched, the document&#xA;     * has already been updated and any marks created by&#xA;     * &lt;code>createPosition&lt;/code> have already changed.&#xA;     * For a removal, the end of the removal range is collapsed &#xA;     * down to the start of the range, and any marks in the removal &#xA;     * range are collapsed down to the start of the range.&#xA;     * &lt;p align=center>&lt;img src=&quot;doc-files/Document-remove.gif&quot;&#xA;     *  alt=&quot;Diagram shows removal of 'quick' from 'The quick brown fox.'&quot;>&#xA;     * &lt;p>&#xA;     * If the Document structure changed as result of the removal,&#xA;     * the details of what Elements were inserted and removed in&#xA;     * response to the change will also be contained in the generated&#xA;     * DocumentEvent. It is up to the implementation of a Document&#xA;     * to decide how the structure should change in response to a&#xA;     * remove.&#xA;     * &lt;p>&#xA;     * If the Document supports undo/redo, an UndoableEditEvent will&#xA;     * also be generated.  &#xA;     *&#xA;     * @param offs  the offset from the beginning >= 0&#xA;     * @param len   the number of characters to remove >= 0&#xA;     * @exception BadLocationException  some portion of the removal range&#xA;     *   was not a valid part of the document.  The location in the exception&#xA;     *   is the first bad position encountered.&#xA;     * @see javax.swing.event.DocumentEvent&#xA;     * @see javax.swing.event.DocumentListener&#xA;     * @see javax.swing.event.UndoableEditEvent&#xA;     * @see javax.swing.event.UndoableEditListener&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insertString">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="AttributeSet.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BadLocationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts a string of content.  This will cause a DocumentEvent&#xA;     * of type DocumentEvent.EventType.INSERT to be sent to the&#xA;     * registered DocumentListers, unless an exception is thrown.&#xA;     * The DocumentEvent will be delivered by calling the&#xA;     * insertUpdate method on the DocumentListener.&#xA;     * The offset and length of the generated DocumentEvent&#xA;     * will indicate what change was actually made to the Document.&#xA;     * &lt;p align=center>&lt;img src=&quot;doc-files/Document-insert.gif&quot;&#xA;     *  alt=&quot;Diagram shows insertion of 'quick' in 'The quick brown fox'&quot;>&#xA;     * &lt;p>&#xA;     * If the Document structure changed as result of the insertion,&#xA;     * the details of what Elements were inserted and removed in&#xA;     * response to the change will also be contained in the generated&#xA;     * DocumentEvent.  It is up to the implementation of a Document&#xA;     * to decide how the structure should change in response to an&#xA;     * insertion.&#xA;     * &lt;p>&#xA;     * If the Document supports undo/redo, an UndoableEditEvent will&#xA;     * also be generated.  &#xA;     *&#xA;     * @param offset  the offset into the document to insert the content >= 0.&#xA;     *    All positions that track change at or after the given location &#xA;     *    will move.  &#xA;     * @param str    the string to insert&#xA;     * @param a      the attributes to associate with the inserted&#xA;     *   content.  This may be null if there are no attributes.&#xA;     * @exception BadLocationException  the given insert position is not a valid &#xA;     * position within the document&#xA;     * @see javax.swing.event.DocumentEvent&#xA;     * @see javax.swing.event.DocumentListener&#xA;     * @see javax.swing.event.UndoableEditEvent&#xA;     * @see javax.swing.event.UndoableEditListener&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getText">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BadLocationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Fetches the text contained within the given portion &#xA;     * of the document.&#xA;     *&#xA;     * @param offset  the offset into the document representing the desired &#xA;     *   start of the text >= 0&#xA;     * @param length  the length of the desired string >= 0&#xA;     * @return the text, in a String of length >= 0&#xA;     * @exception BadLocationException  some portion of the given range&#xA;     *   was not a valid part of the document.  The location in the exception&#xA;     *   is the first bad position encountered.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getText">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="txt">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Segment.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BadLocationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Fetches the text contained within the given portion &#xA;     * of the document.&#xA;     * &lt;p>&#xA;     * If the partialReturn property on the txt parameter is false, the&#xA;     * data returned in the Segment will be the entire length requested and&#xA;     * may or may not be a copy depending upon how the data was stored.&#xA;     * If the partialReturn property is true, only the amount of text that&#xA;     * can be returned without creating a copy is returned.  Using partial&#xA;     * returns will give better performance for situations where large &#xA;     * parts of the document are being scanned.  The following is an example&#xA;     * of using the partial return to access the entire document:&#xA;     * &lt;p>&#xA;     * &lt;pre>&lt;code>&#xA;     *&#xA;     * &amp;nbsp; int nleft = doc.getDocumentLength();&#xA;     * &amp;nbsp; Segment text = new Segment();&#xA;     * &amp;nbsp; int offs = 0;&#xA;     * &amp;nbsp; text.setPartialReturn(true);   &#xA;     * &amp;nbsp; while (nleft > 0) {&#xA;     * &amp;nbsp;     doc.getText(offs, nleft, text);&#xA;     * &amp;nbsp;     // do someting with text&#xA;     * &amp;nbsp;     nleft -= text.count;&#xA;     * &amp;nbsp;     offs += text.count;&#xA;     * &amp;nbsp; }&#xA;     *&#xA;     * &lt;/code>&lt;/pre>&#xA;     *&#xA;     * @param offset  the offset into the document representing the desired &#xA;     *   start of the text >= 0&#xA;     * @param length  the length of the desired string >= 0&#xA;     * @param txt the Segment object to return the text in&#xA;     *&#xA;     * @exception BadLocationException  Some portion of the given range&#xA;     *   was not a valid part of the document.  The location in the exception&#xA;     *   is the first bad position encountered.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getStartPosition">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Position.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a position that represents the start of the document.  The &#xA;     * position returned can be counted on to track change and stay &#xA;     * located at the beginning of the document.&#xA;     *&#xA;     * @return the position&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getEndPosition">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Position.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a position that represents the end of the document.  The&#xA;     * position returned can be counted on to track change and stay &#xA;     * located at the end of the document.&#xA;     *&#xA;     * @return the position&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createPosition">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Position.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offs">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BadLocationException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * This method allows an application to mark a place in&#xA;     * a sequence of character content. This mark can then be &#xA;     * used to tracks change as insertions and removals are made &#xA;     * in the content. The policy is that insertions always&#xA;     * occur prior to the current position (the most common case) &#xA;     * unless the insertion location is zero, in which case the &#xA;     * insertion is forced to a position that follows the&#xA;     * original position. &#xA;     *&#xA;     * @param offs  the offset from the start of the document >= 0&#xA;     * @return the position&#xA;     * @exception BadLocationException  if the given position does not&#xA;     *   represent a valid location in the associated document&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getRootElements">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns all of the root elements that are defined.&#xA;     * &lt;p>&#xA;     * Typically there will be only one document structure, but the interface&#xA;     * supports building an arbitrary number of structural projections over the &#xA;     * text data. The document can have multiple root elements to support &#xA;     * multiple document structures.  Some examples might be:&#xA;     * &lt;/p>&#xA;     * &lt;ul>&#xA;     * &lt;li>Text direction.&#xA;     * &lt;li>Lexical token streams.&#xA;     * &lt;li>Parse trees.&#xA;     * &lt;li>Conversions to formats other than the native format.&#xA;     * &lt;li>Modification specifications.&#xA;     * &lt;li>Annotations.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @return the root element&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDefaultRootElement">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the root element that views should be based upon,&#xA;     * unless some other mechanism for assigning views to element&#xA;     * structures is provided.&#xA;     *&#xA;     * @return the root element&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="render">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="r">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/lang/Runnable.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allows the model to be safely rendered in the presence&#xA;     * of concurrency, if the model supports being updated asynchronously.&#xA;     * The given runnable will be executed in a way that allows it&#xA;     * to safely read the model with no changes while the runnable&#xA;     * is being executed.  The runnable itself may &lt;em>not&lt;/em>&#xA;     * make any mutations.  &#xA;     *&#xA;     * @param r a &lt;code>Runnable&lt;/code> used to render the model&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="StreamDescriptionProperty">
      <initialValue xsi:type="references:StringReference" value="stream"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The property name for the description of the stream&#xA;     * used to initialize the document.  This should be used&#xA;     * if the document was initialized from a stream and &#xA;     * anything is known about the stream.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="TitleProperty">
      <initialValue xsi:type="references:StringReference" value="title"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The property name for the title of the document, if &#xA;     * there is one.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;p>&#xA; * The &lt;code>Document&lt;/code> is a container for text that serves&#xA; * as the model for swing text components.  The goal for this&#xA; * interface is to scale from very simple needs (a plain text textfield)&#xA; * to complex needs (an HTML or XML document, for example).&#xA; *&#xA; * &lt;p>&lt;b>&lt;font size=+1>Content&lt;/font>&lt;/b>&#xA; * &lt;p>&#xA; * At the simplest level, text can be &#xA; * modeled as a linear sequence of characters. To support &#xA; * internationalization, the Swing text model uses &#xA; * &lt;a href=&quot;http://www.unicode.org/&quot;>unicode&lt;/a> characters. &#xA; * The sequence of characters displayed in a text component is &#xA; * generally referred to as the component's &lt;em>content&lt;/em>.&#xA; * &lt;p>&#xA; * To refer to locations within the sequence, the coordinates&#xA; * used are the location between two characters.  As the diagram &#xA; * below shows, a location in a text document can be referred to &#xA; * as a position, or an offset. This position is zero-based.&#xA; * &lt;p align=center>&lt;img src=&quot;doc-files/Document-coord.gif&quot; &#xA; * alt=&quot;The following text describes this graphic.&quot;>&#xA; * &lt;p>&#xA; * In the example, if the content of a document is the&#xA; * sequence &quot;The quick brown fox,&quot; as shown in the preceding diagram, &#xA; * the location just before the word &quot;The&quot; is 0, and the location after &#xA; * the word &quot;The&quot; and before the whitespace that follows it is 3. &#xA; * The entire sequence of characters in the sequence &quot;The&quot; is called a &#xA; * &lt;em>range&lt;/em>.&#xA; * &lt;p>The following methods give access to the character data&#xA; * that makes up the content.&#xA; * &lt;ul>&#xA; * &lt;li>&lt;a href=&quot;#getLength()&quot;>getLength()&lt;/a>&#xA; * &lt;li>&lt;a href=&quot;#getText(int, int)&quot;>getText(int, int)&lt;/a>&#xA; * &lt;li>&lt;a href=&quot;#getText(int, int, javax.swing.text.Segment)&quot;>getText(int, int, Segment)&lt;/a>&#xA; * &lt;/ul>&#xA; * &lt;p>&lt;b>&lt;font size=+1>Structure&lt;/font>&lt;/b>&#xA; * &lt;p>&#xA; * Text is rarely represented simply as featureless content. Rather, &#xA; * text typically has some sort of structure associated with it.&#xA; * Exactly what structure is modeled is up to a particular Document&#xA; * implementation.  It might be as simple as no structure (i.e. a&#xA; * simple text field), or it might be something like diagram below.&#xA; * &lt;p align=center>&lt;img src=&quot;doc-files/Document-structure.gif&quot;&#xA; * alt=&quot;Diagram shows Book->Chapter->Paragraph&quot;>&#xA; * &lt;p>&#xA; * The unit of structure (i.e. a node of the tree) is referred to&#xA; * by the &lt;a href=&quot;Element.html&quot;>Element&lt;/a> interface.  Each Element&#xA; * can be tagged with a set of attributes.  These attributes&#xA; * (name/value pairs) are defined by the &#xA; * &lt;a href=&quot;AttributeSet.html&quot;>AttributeSet&lt;/a> interface.&#xA; * &lt;p>The following methods give access to the document structure.&#xA; * &lt;ul>&#xA; * &lt;li>&lt;a href=&quot;#getDefaultRootElement()&quot;>getDefaultRootElement&lt;/a>&#xA; * &lt;li>&lt;a href=&quot;#getRootElements()&quot;>getRootElements&lt;/a>&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p>&lt;b>&lt;font size=+1>Mutations&lt;/font>&lt;/b>&#xA; * &lt;p>&#xA; * All documents need to be able to add and remove simple text.&#xA; * Typically, text is inserted and removed via gestures from&#xA; * a keyboard or a mouse.  What effect the insertion or removal&#xA; * has upon the document structure is entirely up to the&#xA; * implementation of the document.&#xA; * &lt;p>The following methods are related to mutation of the &#xA; * document content:&#xA; * &lt;ul>&#xA; * &lt;li>&lt;a href=&quot;#insertString(int, java.lang.String, javax.swing.text.AttributeSet)&quot;>insertString(int, String, AttributeSet)&lt;/a>&#xA; * &lt;li>&lt;a href=&quot;#remove(int, int)&quot;>remove(int, int)&lt;/a>&#xA; * &lt;li>&lt;a href=&quot;#createPosition(int)&quot;>createPosition(int)&lt;/a>&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p>&lt;b>&lt;font size=+1>Notification&lt;/font>&lt;/b>&#xA; * &lt;p>&#xA; * Mutations to the &lt;code>Document&lt;/code> must be communicated to&#xA; * interested observers.  The notification of change follows the event model&#xA; * guidelines that are specified for JavaBeans.  In the JavaBeans&#xA; * event model, once an event notification is dispatched, all listeners &#xA; * must be notified before any further mutations occur to the source &#xA; * of the event.  Further, order of delivery is not guaranteed.&#xA; * &lt;p>&#xA; * Notification is provided as two separate events, &#xA; * &lt;a href=&quot;../event/DocumentEvent.html&quot;>DocumentEvent&lt;/a>, and&#xA; * &lt;a href=&quot;../event/UndoableEditEvent.html&quot;>UndoableEditEvent&lt;/a>.&#xA; * If a mutation is made to a &lt;code>Document&lt;/code> through its api, &#xA; * a &lt;code>DocumentEvent&lt;/code> will be sent to all of the registered &#xA; * &lt;code>DocumentListeners&lt;/code>.  If the &lt;code>Document&lt;/code>&#xA; * implementation supports undo/redo capabilities, an&#xA; * &lt;code>UndoableEditEvent&lt;/code> will be sent&#xA; * to all of the registered &lt;code>UndoableEditListener&lt;/code>s.&#xA; * If an undoable edit is undone, a &lt;code>DocumentEvent&lt;/code> should be&#xA; * fired from the Document to indicate it has changed again.&#xA; * In this case however, there should be no &lt;code>UndoableEditEvent&lt;/code>&#xA; * generated since that edit is actually the source of the change&#xA; * rather than a mutation to the &lt;code>Document&lt;/code> made through its &#xA; * api.&#xA; * &lt;p align=center>&lt;img src=&quot;doc-files/Document-notification.gif&quot;&#xA; * alt=&quot;The preceeding text describes this graphic.&quot;>&#xA; * &lt;p>&#xA; * Referring to the above diagram, suppose that the component shown &#xA; * on the left mutates the document object represented by the blue &#xA; * rectangle. The document responds by dispatching a DocumentEvent to &#xA; * both component views and sends an UndoableEditEvent to the listening &#xA; * logic, which maintains a history buffer.&#xA; * &lt;p>&#xA; * Now suppose that the component shown on the right mutates the same &#xA; * document.  Again, the document dispatches a DocumentEvent to both &#xA; * component views and sends an UndoableEditEvent to the listening logic &#xA; * that is maintaining the history buffer. &#xA; * &lt;p>&#xA; * If the history buffer is then rolled back (i.e. the last UndoableEdit&#xA; * undone), a DocumentEvent is sent to both views, causing both of them to &#xA; * reflect the undone mutation to the document (that is, the&#xA; * removal of the right component's mutation). If the history buffer again &#xA; * rolls back another change, another DocumentEvent is sent to both views, &#xA; * causing them to reflect the undone mutation to the document -- that is, &#xA; * the removal of the left component's mutation. &#xA; * &lt;p>&#xA; * The methods related to observing mutations to the document are:&#xA; * &lt;ul>&#xA; * &lt;li>&lt;a href=&quot;#addDocumentListener(javax.swing.event.DocumentListener)&quot;>addDocumentListener(DocumentListener)&lt;/a>&#xA; * &lt;li>&lt;a href=&quot;#removeDocumentListener(javax.swing.event.DocumentListener)&quot;>removeDocumentListener(DocumentListener)&lt;/a>&#xA; * &lt;li>&lt;a href=&quot;#addUndoableEditListener(javax.swing.event.UndoableEditListener)&quot;>addUndoableEditListener(UndoableEditListener)&lt;/a>&#xA; * &lt;li>&lt;a href=&quot;#removeUndoableEditListener(javax.swing.event.UndoableEditListener)&quot;>removeUndoableEditListener(UndoableEditListener)&lt;/a>&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p>&lt;b>&lt;font size=+1>Properties&lt;/font>&lt;/b>&#xA; * &lt;p>&#xA; * Document implementations will generally have some set of properties&#xA; * associated with them at runtime.  Two well known properties are the&#xA; * &lt;a href=&quot;#StreamDescriptionProperty&quot;>StreamDescriptionProperty&lt;/a>,&#xA; * which can be used to describe where the &lt;code>Document&lt;/code> came from,&#xA; * and the &lt;a href=&quot;#TitleProperty&quot;>TitleProperty&lt;/a>, which can be used to&#xA; * name the &lt;code>Document&lt;/code>.  The methods related to the properties are:&#xA; * &lt;ul>&#xA; * &lt;li>&lt;a href=&quot;#getProperty(java.lang.Object)&quot;>getProperty(Object)&lt;/a>&#xA; * &lt;li>&lt;a href=&quot;#putProperty(java.lang.Object, java.lang.Object)&quot;>putProperty(Object, Object)&lt;/a>&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p>For more information on the &lt;code>Document&lt;/code> class, see&#xA; * &lt;a href=&quot;http://java.sun.com/products/jfc/tsc&quot;>The Swing Connection&lt;/a>&#xA; * and most particularly the article,&#xA; * &lt;a href=&quot;http://java.sun.com/products/jfc/tsc/articles/text/element_interface&quot;>&#xA; * The Element Interface&lt;/a>.&#xA; *&#xA; * @author  Timothy Prinzing&#xA; * @version 1.43 12/19/03&#xA; *&#xA; * @see javax.swing.event.DocumentEvent&#xA; * @see javax.swing.event.DocumentListener&#xA; * @see javax.swing.event.UndoableEditEvent&#xA; * @see javax.swing.event.UndoableEditListener&#xA; * @see Element&#xA; * @see Position&#xA; * @see AttributeSet&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
