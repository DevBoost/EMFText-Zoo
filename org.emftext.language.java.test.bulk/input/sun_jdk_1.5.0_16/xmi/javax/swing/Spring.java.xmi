<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="Spring.java">
  <comments>/*&#xA; * @(#)Spring.java&#x9;1.9 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>javax</namespaces>
  <namespaces>swing</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../java/awt/Component.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Spring">
    <members xsi:type="members:Field" name="UNSET">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="../../java/lang/Integer.class.xmi#//@classifiers.0/@members.0"/>
        </next>
        <target xsi:type="classifiers:Class" href="../../java/lang/Integer.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An integer value signifying that a property value has not yet been calculated.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="Spring">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Used by factory methods to create a &lt;code>Spring&lt;/code>.&#xA;     * &#xA;     * @see #constant(int)&#xA;     * @see #constant(int, int, int)&#xA;     * @see #max&#xA;     * @see #minus&#xA;     * @see #sum&#xA;     * @see SpringLayout.Constraints&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMinimumValue">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;em>minimum&lt;/em> value of this &lt;code>Spring&lt;/code>.&#xA;     *&#xA;     * @return the &lt;code>minimumValue&lt;/code> property of this &lt;code>Spring&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPreferredValue">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;em>preferred&lt;/em> value of this &lt;code>Spring&lt;/code>.&#xA;     *&#xA;     * @return the &lt;code>preferredValue&lt;/code> of this &lt;code>Spring&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaximumValue">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;em>maximum&lt;/em> value of this &lt;code>Spring&lt;/code>.&#xA;     *&#xA;     * @return the &lt;code>maximumValue&lt;/code> property of this &lt;code>Spring&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getValue">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current &lt;em>value&lt;/em> of this &lt;code>Spring&lt;/code>.&#xA;     *&#xA;     * @return  the &lt;code>value&lt;/code> property of this &lt;code>Spring&lt;/code>&#xA;     *&#xA;     * @see #setValue&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setValue">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the current &lt;em>value&lt;/em> of this &lt;code>Spring&lt;/code> to &lt;code>value&lt;/code>.&#xA;     *&#xA;     * @param   value the new setting of the &lt;code>value&lt;/code> property&#xA;     *&#xA;     * @see #getValue&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="range">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="contract">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          <expressionIf xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </expression>
          </expressionIf>
          <expressionElse xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </expression>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getStrain">
      <typeReference xsi:type="types:Double">
        <comments>/*pp*/</comments>
      </typeReference>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="delta">
          <typeReference xsi:type="types:Double"/>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.5"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:MultiplicativeExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="expressions:RelationExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.5"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </arguments>
          </children>
          <multiplicativeOperators xsi:type="operators:Division"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setStrain">
      <typeReference xsi:type="types:Void">
        <comments>/*pp*/</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="strain">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
            <children xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:MultiplicativeExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
                  <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
                    <arguments xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <relationOperators xsi:type="operators:LessThan"/>
                    </arguments>
                  </children>
                  <multiplicativeOperators xsi:type="operators:Multiplication"/>
                </expression>
              </child>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isCyclic">
      <typeReference xsi:type="types:Boolean">
        <comments>/*pp*/</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SpringLayout.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="classifiers:Class" name="AbstractSpring">
      <members xsi:type="members:Field" name="size">
        <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
      </members>
      <members xsi:type="members:ClassMethod" name="getValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@members.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </child>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@members.0"/>
            <expressionElse xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="setValue">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="size">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.11/@members.3"/>
            </statements>
            <statements xsi:type="statements:Return"/>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@members.2/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@members.0"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@members.2/@parameters.0"/>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="clear">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </expression>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/*pp*/</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="StaticSpring">
      <members xsi:type="members:Field" name="min">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
      </members>
      <members xsi:type="members:Field" name="pref">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
      </members>
      <members xsi:type="members:Field" name="max">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
      </members>
      <members xsi:type="members:Constructor" name="StaticSpring">
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
      </members>
      <members xsi:type="members:Constructor" name="StaticSpring">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.4/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.4/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.4/@parameters.0"/>
            <callTarget xsi:type="literals:This"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="pref">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
      </members>
      <members xsi:type="members:Constructor" name="StaticSpring">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.0"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.5/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.1"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.5/@parameters.1"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.2"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.5/@parameters.2"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@members.0"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.5/@parameters.1"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="min">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="pref">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="max">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
      </members>
      <members xsi:type="members:ClassMethod" name="toString">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:StringReference" value="StaticSpring ["/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.0"/>
            <children xsi:type="references:StringReference" value=", "/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.1"/>
            <children xsi:type="references:StringReference" value=", "/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.2"/>
            <children xsi:type="references:StringReference" value="]"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getMinimumValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.0"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getPreferredValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.1"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getMaximumValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.2"/>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.11"/>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="NegativeSpring">
      <members xsi:type="members:Field" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Constructor" name="NegativeSpring">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1/@parameters.0"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
      </members>
      <members xsi:type="members:ClassMethod" name="getMinimumValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>// Note the use of max value rather than minimum value here.</comments>
          <comments>// See the opening preamble on arithmetic with springs.</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
            </child>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getPreferredValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
            </child>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getMaximumValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
            </child>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.5"/>
            </child>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="setValue">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="size">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
            <comments>// No need to check for UNSET as</comments>
            <comments>// Integer.MIN_VALUE == -Integer.MIN_VALUE.</comments>
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
              <arguments xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.6/@parameters.0"/>
              </arguments>
            </next>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="isCyclic">
        <typeReference xsi:type="types:Boolean">
          <comments>/*pp*/</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="l">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="SpringLayout.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.10">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.7/@parameters.0"/>
            </next>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="ScaleSpring">
      <members xsi:type="members:Field" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Field" name="factor">
        <typeReference xsi:type="types:Float"/>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Constructor" name="ScaleSpring">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.2/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.1"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.2/@parameters.1"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="factor">
          <typeReference xsi:type="types:Float"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:ClassMethod" name="getMinimumValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../java/lang/Math.class.xmi#//@classifiers.0/@members.25"/>
              <arguments xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ConditionalExpression">
                    <child xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.1"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <relationOperators xsi:type="operators:LessThan"/>
                    </child>
                    <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
                    </expressionIf>
                    <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
                    </expressionElse>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.1"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../java/lang/Math.class.xmi#//@classifiers.0"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getPreferredValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../java/lang/Math.class.xmi#//@classifiers.0/@members.25"/>
              <arguments xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.1"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../java/lang/Math.class.xmi#//@classifiers.0"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getMaximumValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../java/lang/Math.class.xmi#//@classifiers.0/@members.25"/>
              <arguments xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ConditionalExpression">
                    <child xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.1"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <relationOperators xsi:type="operators:LessThan"/>
                    </child>
                    <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
                    </expressionIf>
                    <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
                    </expressionElse>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.1"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../java/lang/Math.class.xmi#//@classifiers.0"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../java/lang/Math.class.xmi#//@classifiers.0/@members.25"/>
              <arguments xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.5"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.1"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../java/lang/Math.class.xmi#//@classifiers.0"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="setValue">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="value">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                </next>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.7/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../java/lang/Math.class.xmi#//@classifiers.0/@members.25"/>
                      <arguments xsi:type="expressions:MultiplicativeExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.7/@parameters.0"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.1"/>
                        <multiplicativeOperators xsi:type="operators:Division"/>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="../../java/lang/Math.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
              </expression>
            </statements>
          </elseStatement>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="isCyclic">
        <typeReference xsi:type="types:Boolean">
          <comments>/*pp*/</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="l">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="SpringLayout.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.10">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.8/@parameters.0"/>
            </next>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="WidthSpring">
      <members xsi:type="members:Field" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/*pp*/</comments>
            <target xsi:type="classifiers:Class" href="../../java/awt/Component.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Constructor" name="WidthSpring">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.1/@parameters.0"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="c">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../java/awt/Component.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
      </members>
      <members xsi:type="members:ClassMethod" name="getMinimumValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../../java/awt/Dimension.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="members:ClassMethod" href="../../java/awt/Component.class.xmi#//@classifiers.0/@members.181"/>
            </next>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getPreferredValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../../java/awt/Dimension.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="members:ClassMethod" href="../../java/awt/Component.class.xmi#//@classifiers.0/@members.177"/>
            </next>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getMaximumValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <comments>// We will be doing arithmetic with the results of this call,</comments>
          <comments>// so if a returned value is Integer.MAX_VALUE we will get</comments>
          <comments>// arithmetic overflow. Truncate such values.</comments>
          <returnValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../java/lang/Math.class.xmi#//@classifiers.0/@members.37"/>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../../java/lang/Short.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../java/lang/Short.class.xmi#//@classifiers.0"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0">
                <next xsi:type="references:MethodCall">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../../java/awt/Dimension.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="members:ClassMethod" href="../../java/awt/Component.class.xmi#//@classifiers.0/@members.185"/>
                </next>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../java/lang/Math.class.xmi#//@classifiers.0"/>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/*pp*/</comments>
      </annotationsAndModifiers>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.11"/>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="HeightSpring">
      <members xsi:type="members:Field" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/*pp*/</comments>
            <target xsi:type="classifiers:Class" href="../../java/awt/Component.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Constructor" name="HeightSpring">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.0"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.1/@parameters.0"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="c">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../java/awt/Component.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
      </members>
      <members xsi:type="members:ClassMethod" name="getMinimumValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.0">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../../java/awt/Dimension.class.xmi#//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="members:ClassMethod" href="../../java/awt/Component.class.xmi#//@classifiers.0/@members.181"/>
            </next>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getPreferredValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.0">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../../java/awt/Dimension.class.xmi#//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="members:ClassMethod" href="../../java/awt/Component.class.xmi#//@classifiers.0/@members.177"/>
            </next>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getMaximumValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../java/lang/Math.class.xmi#//@classifiers.0/@members.37"/>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../../java/lang/Short.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../java/lang/Short.class.xmi#//@classifiers.0"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.0">
                <next xsi:type="references:MethodCall">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../../java/awt/Dimension.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="members:ClassMethod" href="../../java/awt/Component.class.xmi#//@classifiers.0/@members.185"/>
                </next>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../java/lang/Math.class.xmi#//@classifiers.0"/>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/*pp*/</comments>
      </annotationsAndModifiers>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.11"/>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="CompoundSpring">
      <members xsi:type="members:Field" name="s1">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
      </members>
      <members xsi:type="members:Field" name="s2">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
      </members>
      <members xsi:type="members:Constructor" name="CompoundSpring">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.17/@members.4"/>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.2/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.2/@parameters.1"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s1">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s2">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
      </members>
      <members xsi:type="members:ClassMethod" name="toString">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:StringReference" value="CompoundSpring of "/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0"/>
            <children xsi:type="references:StringReference" value=" and "/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="clear">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.2"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@members.0"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                </value>
              </value>
            </value>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="setValue">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="size">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:SelfReference">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.11/@members.2">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.5/@parameters.0"/>
                    </next>
                    <self xsi:type="literals:Super"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                    </next>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                    </next>
                  </expression>
                </statements>
                <statements xsi:type="statements:Return"/>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@members.0"/>
                  <self xsi:type="literals:This"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.5/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.11/@members.2">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.5/@parameters.0"/>
            </next>
            <self xsi:type="literals:Super"/>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:InterfaceMethod" name="op">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="x">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="y">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
      </members>
      <members xsi:type="members:ClassMethod" name="getMinimumValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.0"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.17/@members.6">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
                  </arguments>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.0"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getPreferredValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.1"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.17/@members.6">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
                  </arguments>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.1"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getMaximumValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.2"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.17/@members.6">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
                  </arguments>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@members.2"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getValue">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@members.0"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.17/@members.6">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.5"/>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.5"/>
                  </arguments>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@members.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@members.0"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="isCyclic">
        <typeReference xsi:type="types:Boolean">
          <comments>/*pp*/</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="l">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="SpringLayout.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:ConditionalOrExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.11/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="SpringLayout.class.xmi#//@classifiers.0/@members.11"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0"/>
              </next>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.11/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="SpringLayout.class.xmi#//@classifiers.0/@members.11"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1"/>
              </next>
            </children>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>// Use the instance variables of the StaticSpring superclass to</comments>
        <comments>// cache values that have already been calculated.</comments>
        <comments>/*pp*/</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.12"/>
      </extends>
    </members>
    <members xsi:type="members:EmptyMember"/>
    <members xsi:type="classifiers:Class" name="SumSpring">
      <members xsi:type="members:Constructor" name="SumSpring">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@members.0/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@members.0/@parameters.1"/>
            <callTarget xsi:type="literals:Super"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s1">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s2">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
      </members>
      <members xsi:type="members:ClassMethod" name="op">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="x">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="y">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@members.1/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@members.1/@parameters.1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="setValue">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="size">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.17/@members.5">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@members.2/@parameters.0"/>
            </next>
            <self xsi:type="literals:Super"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Return"/>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@members.2/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.9">
              <arguments xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.8"/>
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@members.2/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.5"/>
                </children>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </arguments>
            </next>
          </expression>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.17"/>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="MaxSpring">
      <members xsi:type="members:Constructor" name="MaxSpring">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@members.0/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@members.0/@parameters.1"/>
            <callTarget xsi:type="literals:Super"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s1">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s2">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
      </members>
      <members xsi:type="members:ClassMethod" name="op">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="x">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="y">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../java/lang/Math.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@members.1/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@members.1/@parameters.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../java/lang/Math.class.xmi#//@classifiers.0"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="setValue">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="size">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.17/@members.5">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@members.2/@parameters.0"/>
            </next>
            <self xsi:type="literals:Super"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Return"/>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@members.2/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <comments>// Pending should also check max bounds here.</comments>
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../java/lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@members.2/@parameters.0"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0">
                        <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="../../java/lang/Math.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@members.2/@parameters.0"/>
                </next>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@members.2/@parameters.0"/>
                </next>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../java/lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@members.2/@parameters.0"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
                        <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="../../java/lang/Math.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
              </expression>
            </statements>
          </elseStatement>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.17"/>
      </extends>
    </members>
    <members xsi:type="members:ClassMethod" name="constant">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pref">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a strut -- a spring whose &lt;em>minimum&lt;/em>, &lt;em>preferred&lt;/em>, and&#xA;     * &lt;em>maximum&lt;/em> values each have the value &lt;code>pref&lt;/code>.&#xA;     *&#xA;     * @param  pref the &lt;em>minimum&lt;/em>, &lt;em>preferred&lt;/em>, and&#xA;     *         &lt;em>maximum&lt;/em> values of the new spring&#xA;     * @return a spring whose &lt;em>minimum&lt;/em>, &lt;em>preferred&lt;/em>, and&#xA;     *         &lt;em>maximum&lt;/em> values each have the value &lt;code>pref&lt;/code>&#xA;     *&#xA;     * @see Spring&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="constant">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="min">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pref">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="max">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a spring whose &lt;em>minimum&lt;/em>, &lt;em>preferred&lt;/em>, and&#xA;     * &lt;em>maximum&lt;/em> values have the values: &lt;code>min&lt;/code>, &lt;code>pref&lt;/code>,&#xA;     * and &lt;code>max&lt;/code> respectively.&#xA;     *&#xA;     * @param  min the &lt;em>minimum&lt;/em> value of the new spring&#xA;     * @param  pref the &lt;em>preferred&lt;/em> value of the new spring&#xA;     * @param  max the &lt;em>maximum&lt;/em> value of the new spring&#xA;     * @return a spring whose &lt;em>minimum&lt;/em>, &lt;em>preferred&lt;/em>, and&#xA;     *         &lt;em>maximum&lt;/em> values have the values: &lt;code>min&lt;/code>, &lt;code>pref&lt;/code>,&#xA;     *         and &lt;code>max&lt;/code> respectively&#xA;     *&#xA;     * @see Spring&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.12"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="minus">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>-s&lt;/code>: a spring running in the opposite direction to &lt;code>s&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>-s&lt;/code>: a spring running in the opposite direction to &lt;code>s&lt;/code>&#xA;     *&#xA;     * @see Spring&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.13"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="sum">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s1">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s2">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>s1+s2&lt;/code>: a spring representing &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>&#xA;     * in series. In a sum, &lt;code>s3&lt;/code>, of two springs, &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>,&#xA;     * the &lt;em>strains&lt;/em> of &lt;code>s1&lt;/code>, &lt;code>s2&lt;/code>, and &lt;code>s3&lt;/code> are maintained&#xA;     * at the same level (to within the precision implied by their integer &lt;em>value&lt;/em>s).&#xA;     * The strain of a spring in compression is:&#xA;     * &lt;pre>&#xA;     *         value - pref&#xA;     *         ------------&#xA;     *          pref - min&#xA;     * &lt;/pre>&#xA;     * and the strain of a spring in tension is:&#xA;     * &lt;pre>&#xA;     *         value - pref&#xA;     *         ------------&#xA;     *          max - pref&#xA;     * &lt;/pre>&#xA;     * When &lt;code>setValue&lt;/code> is called on the sum spring, &lt;code>s3&lt;/code>, the strain&#xA;     * in &lt;code>s3&lt;/code> is calculated using one of the formulas above. Once the strain of&#xA;     * the sum is known, the &lt;em>value&lt;/em>s of &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code> are&#xA;     * then set so that they are have a strain equal to that of the sum. The formulas are&#xA;     * evaluated so as to take rounding errors into account and ensure that the sum of&#xA;     * the &lt;em>value&lt;/em>s of &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code> is exactly equal to&#xA;     * the &lt;em>value&lt;/em> of &lt;code>s3&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>s1+s2&lt;/code>: a spring representing &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code> in series&#xA;     *&#xA;     * @see Spring&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.19"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="max">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s1">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s2">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>max(s1, s2)&lt;/code>: a spring whose value is always greater than (or equal to)&#xA;     *         the values of both &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>max(s1, s2)&lt;/code>: a spring whose value is always greater than (or equal to)&#xA;     *         the values of both &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>&#xA;     * @see Spring&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.20"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="difference">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s1">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s2">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>// Remove these, they're not used often and can be created using minus -</comments>
        <comments>// as per these implementations.</comments>
        <comments>/*pp*/</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.1"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="scale">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="factor">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/*&#xA;    public static Spring min(Spring s1, Spring s2) {&#xA;        return minus(max(minus(s1), minus(s2)));&#xA;    }&#xA;    */</comments>
        <comments>/**&#xA;     * Returns a spring whose &lt;em>minimum&lt;/em>, &lt;em>preferred&lt;/em>, &lt;em>maximum&lt;/em>&#xA;     * and &lt;em>value&lt;/em> properties are each multiples of the properties of the&#xA;     * argument spring, &lt;code>s&lt;/code>. Minimum and maximum properties are&#xA;     * swapped when &lt;code>factor&lt;/code> is negative (in accordance with the&#xA;     * rules of interval arithmetic).&#xA;     * &lt;p>&#xA;     * When factor is, for example, 0.5f the result represents 'the mid-point'&#xA;     * of its input - an operation that is useful for centering components in&#xA;     * a container.&#xA;     *&#xA;     * @param s the spring to scale&#xA;     * @param factor amount to scale by.&#xA;     * @return  a spring whose properties are those of the input spring &lt;code>s&lt;/code>&#xA;     * multiplied by &lt;code>factor&lt;/code>&#xA;     * @throws NullPointerException if &lt;code>s&lt;/code> is null&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.30">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.14"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="width">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/awt/Component.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a spring whose &lt;em>minimum&lt;/em>, &lt;em>preferred&lt;/em>, &lt;em>maximum&lt;/em>&#xA;     * and &lt;em>value&lt;/em> properties are defined by the widths of the &lt;em>minimumSize&lt;/em>,&#xA;     * &lt;em>preferredSize&lt;/em>, &lt;em>maximumSize&lt;/em> and &lt;em>size&lt;/em> properties&#xA;     * of the supplied component. The returned spring is a 'wrapper' implementation&#xA;     * whose methods call the appropriate size methods of the supplied component.&#xA;     * The minimum, preferred, maximum and value properties of the returned spring&#xA;     * therefore report the current state of the appropriate properties in the&#xA;     * component and track them as they change.&#xA;     *&#xA;     * @param c Component used for calculating size&#xA;     * @return  a spring whose properties are defined by the horizontal component&#xA;     * of the component's size methods.&#xA;     * @throws NullPointerException if &lt;code>c&lt;/code> is null&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.30">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.15"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="height">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/awt/Component.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a spring whose &lt;em>minimum&lt;/em>, &lt;em>preferred&lt;/em>, &lt;em>maximum&lt;/em>&#xA;     * and &lt;em>value&lt;/em> properties are defined by the heights of the &lt;em>minimumSize&lt;/em>,&#xA;     * &lt;em>preferredSize&lt;/em>, &lt;em>maximumSize&lt;/em> and &lt;em>size&lt;/em> properties&#xA;     * of the supplied component. The returned spring is a 'wrapper' implementation&#xA;     * whose methods call the appropriate size methods of the supplied component.&#xA;     * The minimum, preferred, maximum and value properties of the returned spring&#xA;     * therefore report the current state of the appropriate properties in the&#xA;     * component and track them as they change.&#xA;     *&#xA;     * @param c Component used for calculating size&#xA;     * @return  a spring whose properties are defined by the vertical component&#xA;     * of the component's size methods.&#xA;     * @throws NullPointerException if &lt;code>c&lt;/code> is null&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.30">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.16"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkArg">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * If &lt;code>s&lt;/code> is null, this throws an NullPointerException.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../java/lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Argument must not be null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; *  An instance of the &lt;code>Spring&lt;/code> class holds three properties that&#xA; *  characterize its behavior: the &lt;em>minimum&lt;/em>, &lt;em>preferred&lt;/em>, and&#xA; *  &lt;em>maximum&lt;/em> values. Each of these properties may be involved in&#xA; *  defining its fourth, &lt;em>value&lt;/em>, property based on a series of rules.&#xA; *  &lt;p>&#xA; *  An instance of the &lt;code>Spring&lt;/code> class can be visualized as a&#xA; *  mechanical spring that provides a corrective force as the spring is compressed&#xA; *  or stretched away from its preferred value. This force is modelled&#xA; *  as linear function of the distance from the preferred value, but with&#xA; *  two different constants -- one for the compressional force and one for the&#xA; *  tensional one. Those constants are specified by the minimum and maximum&#xA; *  values of the spring such that a spring at its minimum value produces an&#xA; *  equal and opposite force to that which is created when it is at its&#xA; *  maximum value. The difference between the &lt;em>preferred&lt;/em> and&#xA; *  &lt;em>minimum&lt;/em> values, therefore, represents the ease with which the&#xA; *  spring can be compressed and the difference between its &lt;em>maximum&lt;/em>&#xA; *  and &lt;em>preferred&lt;/em> values, indicates the ease with which the&#xA; *  &lt;code>Spring&lt;/code> can be extended.&#xA; *  See the {@link #sum} method for details.&#xA; *&#xA; *  &lt;p>&#xA; *  By defining simple arithmetic operations on &lt;code>Spring&lt;/code>s,&#xA; *  the behavior of a collection of &lt;code>Spring&lt;/code>s&#xA; *  can be reduced to that of an ordinary (non-compound) &lt;code>Spring&lt;/code>. We define&#xA; *  the &quot;+&quot;, &quot;-&quot;, &lt;em>max&lt;/em>, and &lt;em>min&lt;/em> operators on&#xA; *  &lt;code>Spring&lt;/code>s so that, in each case, the result is a &lt;code>Spring&lt;/code>&#xA; *  whose characteristics bear a useful mathematical relationship to its constituent&#xA; *  springs.&#xA; *&#xA; *  &lt;p>&#xA; *  A &lt;code>Spring&lt;/code> can be treated as a pair of intervals&#xA; *  with a single common point: the preferred value.&#xA; *  The following rules define some of the &#xA; *  arithmetic operators that can be applied to intervals&#xA; *  (&lt;code>[a, b]&lt;/code> refers to the interval&#xA; *  from &lt;code>a&lt;/code>&#xA; *  to &lt;code>b&lt;/code>,&#xA; *  where &lt;code>a &amp;lt;= b&lt;/code>).&#xA; *  &lt;p>&#xA; *  &lt;pre>&#xA; *          [a1, b1] + [a2, b2] = [a1 + a2, b1 + b2]&#xA; *&#xA; *                      -[a, b] = [-b, -a]&#xA; *&#xA; *      max([a1, b1], [a2, b2]) = [max(a1, a2), max(b1, b2)]&#xA; *  &lt;/pre>&#xA; *  &lt;p>&#xA; *  &#xA; *  If we denote &lt;code>Spring&lt;/code>s as &lt;code>[a, b, c]&lt;/code>,&#xA; *  where &lt;code>a &amp;lt;= b &amp;lt;= c&lt;/code>, we can define the same&#xA; *  arithmetic operators on &lt;code>Spring&lt;/code>s:&#xA; *  &lt;p>&#xA; *  &lt;pre>&#xA; *          [a1, b1, c1] + [a2, b2, c2] = [a1 + a2, b1 + b2, c1 + c2]&#xA; *&#xA; *                           -[a, b, c] = [-c, -b, -a]&#xA; *&#xA; *      max([a1, b1, c1], [a2, b2, c2]) = [max(a1, a2), max(b1, b2), max(c1, c2)]&#xA; *  &lt;/pre>&#xA; *  &lt;p>&#xA; *  With both intervals and &lt;code>Spring&lt;/code>s we can define &quot;-&quot; and &lt;em>min&lt;/em>&#xA; *  in terms of negation:&#xA; *  &lt;p>&#xA; *  &lt;pre>&#xA; *      X - Y = X + (-Y)&#xA; *&#xA; *      min(X, Y) = -max(-X, -Y)&#xA; *  &lt;/pre>&#xA; *  &lt;p>&#xA; *  For the static methods in this class that embody the arithmetic&#xA; *  operators, we do not actually perform the operation in question as&#xA; *  that would snapshot the values of the properties of the method's arguments&#xA; *  at the time the static method is called. Instead, the static methods&#xA; *  create a new &lt;code>Spring&lt;/code> instance containing references to&#xA; *  the method's arguments so that the characteristics of the new spring track the&#xA; *  potentially changing characteristics of the springs from which it&#xA; *  was made. This is a little like the idea of a &lt;em>lazy value&lt;/em>&#xA; *  in a functional language.&#xA; * &lt;p>&#xA; * If you are implementing a &lt;code>SpringLayout&lt;/code> you&#xA; * can find further information and examples in&#xA; * &lt;a&#xA; href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/layout/spring.html&quot;>How to Use SpringLayout&lt;/a>,&#xA; * a section in &lt;em>The Java Tutorial.&lt;/em>&#xA; * &lt;p>&#xA; * &lt;strong>Warning:&lt;/strong>&#xA; * Serialized objects of this class will not be compatible with&#xA; * future Swing releases. The current serialization support is&#xA; * appropriate for short term storage or RMI between applications running&#xA; * the same version of Swing.  As of 1.4, support for long term storage&#xA; * of all JavaBeans&lt;sup>&lt;font size=&quot;-2&quot;>TM&lt;/font>&lt;/sup>&#xA; * has been added to the &lt;code>java.beans&lt;/code> package.&#xA; * Please see {@link java.beans.XMLEncoder}.&#xA; *&#xA; * @see SpringLayout&#xA; * @see SpringLayout.Constraints&#xA; *&#xA; * @version 1.9 12/19/03&#xA; * @author &#x9;Philip Milne&#xA; * @since       1.4&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
