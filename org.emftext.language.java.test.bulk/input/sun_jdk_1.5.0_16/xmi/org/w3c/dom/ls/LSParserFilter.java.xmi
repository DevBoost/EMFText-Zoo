<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../../java.ecore#/7 http://www.emftext.org/java/literals ../../../../java.ecore#/9 http://www.emftext.org/java/members ../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../../java.ecore#/13 http://www.emftext.org/java/types ../../../../java.ecore#/16" name="LSParserFilter.java">
  <comments>/*&#xA; * Copyright (c) 2004 World Wide Web Consortium,&#xA; *&#xA; * (Massachusetts Institute of Technology, European Research Consortium for&#xA; * Informatics and Mathematics, Keio University). All Rights Reserved. This&#xA; * work is distributed under the W3C(r) Software License [1] in the hope that&#xA; * it will be useful, but WITHOUT ANY WARRANTY; without even the implied&#xA; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&#xA; *&#xA; * [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231&#xA; */</comments>
  <namespaces>org</namespaces>
  <namespaces>w3c</namespaces>
  <namespaces>dom</namespaces>
  <namespaces>ls</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>w3c</namespaces>
    <namespaces>dom</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>w3c</namespaces>
    <namespaces>dom</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../Element.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="LSParserFilter">
    <members xsi:type="members:Field" name="FILTER_ACCEPT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Constants returned by startElement and acceptNode</comments>
        <comments>/**&#xA;     * Accept the node.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="FILTER_REJECT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reject the node and its children.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="FILTER_SKIP">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Skip this single node. The children of this node will still be &#xA;     * considered. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="FILTER_INTERRUPT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  Interrupt the normal processing of the document. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="startElement">
      <typeReference xsi:type="types:Short"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="elementArg">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Element.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  The parser will call this method after each &lt;code>Element&lt;/code> start &#xA;     * tag has been scanned, but before the remainder of the &#xA;     * &lt;code>Element&lt;/code> is processed. The intent is to allow the &#xA;     * element, including any children, to be efficiently skipped. Note that &#xA;     * only element nodes are passed to the &lt;code>startElement&lt;/code> &#xA;     * function. &#xA;     * &lt;br>The element node passed to &lt;code>startElement&lt;/code> for filtering &#xA;     * will include all of the Element's attributes, but none of the &#xA;     * children nodes. The Element may not yet be in place in the document &#xA;     * being constructed (it may not have a parent node.) &#xA;     * &lt;br>A &lt;code>startElement&lt;/code> filter function may access or change &#xA;     * the attributes for the Element. Changing Namespace declarations will &#xA;     * have no effect on namespace resolution by the parser.&#xA;     * &lt;br>For efficiency, the Element node passed to the filter may not be &#xA;     * the same one as is actually placed in the tree if the node is &#xA;     * accepted. And the actual node (node object identity) may be reused &#xA;     * during the process of reading in and filtering a document.&#xA;     * @param elementArg The newly encountered element. At the time this &#xA;     *   method is called, the element is incomplete - it will have its &#xA;     *   attributes, but no children. &#xA;     * @return &#xA;     * &lt;ul>&#xA;     * &lt;li> &lt;code>FILTER_ACCEPT&lt;/code> if the &lt;code>Element&lt;/code> should &#xA;     *   be included in the DOM document being built. &#xA;     * &lt;/li>&#xA;     * &lt;li> &#xA;     *   &lt;code>FILTER_REJECT&lt;/code> if the &lt;code>Element&lt;/code> and all of &#xA;     *   its children should be rejected. &#xA;     * &lt;/li>&#xA;     * &lt;li> &lt;code>FILTER_SKIP&lt;/code> if the &#xA;     *   &lt;code>Element&lt;/code> should be skipped. All of its children are &#xA;     *   inserted in place of the skipped &lt;code>Element&lt;/code> node. &#xA;     * &lt;/li>&#xA;     * &lt;li> &#xA;     *   &lt;code>FILTER_INTERRUPT&lt;/code> if the filter wants to stop the &#xA;     *   processing of the document. Interrupting the processing of the &#xA;     *   document does no longer guarantee that the resulting DOM tree is &#xA;     *   XML well-formed. The &lt;code>Element&lt;/code> is rejected. &#xA;     * &lt;/li>&#xA;     * &lt;/ul> Returning &#xA;     *   any other values will result in unspecified behavior. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="acceptNode">
      <typeReference xsi:type="types:Short"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeArg">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * This method will be called by the parser at the completion of the &#xA;     * parsing of each node. The node and all of its descendants will exist &#xA;     * and be complete. The parent node will also exist, although it may be &#xA;     * incomplete, i.e. it may have additional children that have not yet &#xA;     * been parsed. Attribute nodes are never passed to this function.&#xA;     * &lt;br>From within this method, the new node may be freely modified - &#xA;     * children may be added or removed, text nodes modified, etc. The state &#xA;     * of the rest of the document outside this node is not defined, and the &#xA;     * affect of any attempt to navigate to, or to modify any other part of &#xA;     * the document is undefined. &#xA;     * &lt;br>For validating parsers, the checks are made on the original &#xA;     * document, before any modification by the filter. No validity checks &#xA;     * are made on any document modifications made by the filter.&#xA;     * &lt;br>If this new node is rejected, the parser might reuse the new node &#xA;     * and any of its descendants.&#xA;     * @param nodeArg The newly constructed element. At the time this method &#xA;     *   is called, the element is complete - it has all of its children &#xA;     *   (and their children, recursively) and attributes, and is attached &#xA;     *   as a child to its parent. &#xA;     * @return &#xA;     * &lt;ul>&#xA;     * &lt;li> &lt;code>FILTER_ACCEPT&lt;/code> if this &lt;code>Node&lt;/code> should &#xA;     *   be included in the DOM document being built. &#xA;     * &lt;/li>&#xA;     * &lt;li> &#xA;     *   &lt;code>FILTER_REJECT&lt;/code> if the &lt;code>Node&lt;/code> and all of its &#xA;     *   children should be rejected. &#xA;     * &lt;/li>&#xA;     * &lt;li> &lt;code>FILTER_SKIP&lt;/code> if the &#xA;     *   &lt;code>Node&lt;/code> should be skipped and the &lt;code>Node&lt;/code> &#xA;     *   should be replaced by all the children of the &lt;code>Node&lt;/code>. &#xA;     * &lt;/li>&#xA;     * &lt;li> &#xA;     *   &lt;code>FILTER_INTERRUPT&lt;/code> if the filter wants to stop the &#xA;     *   processing of the document. Interrupting the processing of the &#xA;     *   document does no longer guarantee that the resulting DOM tree is &#xA;     *   XML well-formed. The &lt;code>Node&lt;/code> is accepted and will be the &#xA;     *   last completely parsed node. &#xA;     * &lt;/li>&#xA;     * &lt;/ul>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getWhatToShow">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  Tells the &lt;code>LSParser&lt;/code> what types of nodes to show to the &#xA;     * method &lt;code>LSParserFilter.acceptNode&lt;/code>. If a node is not shown &#xA;     * to the filter using this attribute, it is automatically included in &#xA;     * the DOM document being built. See &lt;code>NodeFilter&lt;/code> for &#xA;     * definition of the constants. The constants &lt;code>SHOW_ATTRIBUTE&lt;/code>&#xA;     * , &lt;code>SHOW_DOCUMENT&lt;/code>, &lt;code>SHOW_DOCUMENT_TYPE&lt;/code>, &#xA;     * &lt;code>SHOW_NOTATION&lt;/code>, &lt;code>SHOW_ENTITY&lt;/code>, and &#xA;     * &lt;code>SHOW_DOCUMENT_FRAGMENT&lt;/code> are meaningless here. Those nodes &#xA;     * will never be passed to &lt;code>LSParserFilter.acceptNode&lt;/code>. &#xA;     * &lt;br> The constants used here are defined in [&lt;a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>DOM Level 2 Traversal and      Range&lt;/a>]&#xA;     * . &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; *  &lt;code>LSParserFilter&lt;/code>s provide applications the ability to examine &#xA; * nodes as they are being constructed while parsing. As each node is &#xA; * examined, it may be modified or removed, or the entire parse may be &#xA; * terminated early. &#xA; * &lt;p> At the time any of the filter methods are called by the parser, the &#xA; * owner Document and DOMImplementation objects exist and are accessible. &#xA; * The document element is never passed to the &lt;code>LSParserFilter&lt;/code> &#xA; * methods, i.e. it is not possible to filter out the document element. &#xA; * &lt;code>Document&lt;/code>, &lt;code>DocumentType&lt;/code>, &lt;code>Notation&lt;/code>, &#xA; * &lt;code>Entity&lt;/code>, and &lt;code>Attr&lt;/code> nodes are never passed to the &#xA; * &lt;code>acceptNode&lt;/code> method on the filter. The child nodes of an &#xA; * &lt;code>EntityReference&lt;/code> node are passed to the filter if the &#xA; * parameter &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-entities'>&#xA; * entities&lt;/a>&quot; is set to &lt;code>false&lt;/code>. Note that, as described by the parameter &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-entities'>&#xA; * entities&lt;/a>&quot;, unexpanded entity reference nodes are never discarded and are always &#xA; * passed to the filter. &#xA; * &lt;p> All validity checking while parsing a document occurs on the source &#xA; * document as it appears on the input stream, not on the DOM document as it &#xA; * is built in memory. With filters, the document in memory may be a subset &#xA; * of the document on the stream, and its validity may have been affected by &#xA; * the filtering. &#xA; * &lt;p> All default attributes must be present on elements when the elements &#xA; * are passed to the filter methods. All other default content must be &#xA; * passed to the filter methods. &#xA; * &lt;p> DOM applications must not raise exceptions in a filter. The effect of &#xA; * throwing exceptions from a filter is DOM implementation dependent. &#xA; * &lt;p>See also the &lt;a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407'>Document Object Model (DOM) Level 3 Load&#xA;and Save Specification&lt;/a>.&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
