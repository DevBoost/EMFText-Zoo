<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../../java.ecore#/7 http://www.emftext.org/java/members ../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../../java.ecore#/13 http://www.emftext.org/java/types ../../../../java.ecore#/16" name="LSSerializer.java">
  <comments>/*&#xA; * Copyright (c) 2004 World Wide Web Consortium,&#xA; *&#xA; * (Massachusetts Institute of Technology, European Research Consortium for&#xA; * Informatics and Mathematics, Keio University). All Rights Reserved. This&#xA; * work is distributed under the W3C(r) Software License [1] in the hope that&#xA; * it will be useful, but WITHOUT ANY WARRANTY; without even the implied&#xA; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&#xA; *&#xA; * [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231&#xA; */</comments>
  <namespaces>org</namespaces>
  <namespaces>w3c</namespaces>
  <namespaces>dom</namespaces>
  <namespaces>ls</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>w3c</namespaces>
    <namespaces>dom</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../DOMConfiguration.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>w3c</namespaces>
    <namespaces>dom</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>w3c</namespaces>
    <namespaces>dom</namespaces>
    <classifier xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="LSSerializer">
    <members xsi:type="members:InterfaceMethod" name="getDomConfig">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../DOMConfiguration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  The &lt;code>DOMConfiguration&lt;/code> object used by the &#xA;     * &lt;code>LSSerializer&lt;/code> when serializing a DOM node. &#xA;     * &lt;br> In addition to the parameters recognized by the &lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMConfiguration'>&#xA;     * DOMConfiguration&lt;/a> interface defined in [&lt;a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>DOM Level 3 Core&lt;/a>]&#xA;     * , the &lt;code>DOMConfiguration&lt;/code> objects for &#xA;     * &lt;code>LSSerializer&lt;/code> adds, or modifies, the following &#xA;     * parameters: &#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;code>&quot;canonical-form&quot;&lt;/code>&lt;/dt>&#xA;     * &lt;dd>&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;code>true&lt;/code>&lt;/dt>&#xA;     * &lt;dd>[&lt;em>optional&lt;/em>] Writes the document according to the rules specified in [&lt;a href='http://www.w3.org/TR/2001/REC-xml-c14n-20010315'>Canonical XML&lt;/a>]. &#xA;     * In addition to the behavior described in &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-canonical-form'>&#xA;     * canonical-form&lt;/a>&quot; [&lt;a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>DOM Level 3 Core&lt;/a>]&#xA;     * , setting this parameter to &lt;code>true&lt;/code> will set the parameters &#xA;     * &quot;format-pretty-print&quot;, &quot;discard-default-content&quot;, and &quot;xml-declaration&#xA;     * &quot;, to &lt;code>false&lt;/code>. Setting one of those parameters to &#xA;     * &lt;code>true&lt;/code> will set this parameter to &lt;code>false&lt;/code>. &#xA;     * Serializing an XML 1.1 document when &quot;canonical-form&quot; is &#xA;     * &lt;code>true&lt;/code> will generate a fatal error. &lt;/dd>&#xA;     * &lt;dt>&lt;code>false&lt;/code>&lt;/dt>&#xA;     * &lt;dd>[&lt;em>required&lt;/em>] (&lt;em>default&lt;/em>) Do not canonicalize the output. &lt;/dd>&#xA;     * &lt;/dl>&lt;/dd>&#xA;     * &lt;dt>&lt;code>&quot;discard-default-content&quot;&lt;/code>&lt;/dt>&#xA;     * &lt;dd>&#xA;     * &lt;dl>&#xA;     * &lt;dt>&#xA;     * &lt;code>true&lt;/code>&lt;/dt>&#xA;     * &lt;dd>[&lt;em>required&lt;/em>] (&lt;em>default&lt;/em>) Use the &lt;code>Attr.specified&lt;/code> attribute to decide what attributes &#xA;     * should be discarded. Note that some implementations might use &#xA;     * whatever information available to the implementation (i.e. XML &#xA;     * schema, DTD, the &lt;code>Attr.specified&lt;/code> attribute, and so on) to &#xA;     * determine what attributes and content to discard if this parameter is &#xA;     * set to &lt;code>true&lt;/code>. &lt;/dd>&#xA;     * &lt;dt>&lt;code>false&lt;/code>&lt;/dt>&#xA;     * &lt;dd>[&lt;em>required&lt;/em>]Keep all attributes and all content.&lt;/dd>&#xA;     * &lt;/dl>&lt;/dd>&#xA;     * &lt;dt>&lt;code>&quot;format-pretty-print&quot;&lt;/code>&lt;/dt>&#xA;     * &lt;dd>&#xA;     * &lt;dl>&#xA;     * &lt;dt>&#xA;     * &lt;code>true&lt;/code>&lt;/dt>&#xA;     * &lt;dd>[&lt;em>optional&lt;/em>] Formatting the output by adding whitespace to produce a pretty-printed, &#xA;     * indented, human-readable form. The exact form of the transformations &#xA;     * is not specified by this specification. Pretty-printing changes the &#xA;     * content of the document and may affect the validity of the document, &#xA;     * validating implementations should preserve validity. &lt;/dd>&#xA;     * &lt;dt>&#xA;     * &lt;code>false&lt;/code>&lt;/dt>&#xA;     * &lt;dd>[&lt;em>required&lt;/em>] (&lt;em>default&lt;/em>) Don't pretty-print the result. &lt;/dd>&#xA;     * &lt;/dl>&lt;/dd>&#xA;     * &lt;dt> &#xA;     * &lt;code>&quot;ignore-unknown-character-denormalizations&quot;&lt;/code> &lt;/dt>&#xA;     * &lt;dd>&#xA;     * &lt;dl>&#xA;     * &lt;dt>&#xA;     * &lt;code>true&lt;/code>&lt;/dt>&#xA;     * &lt;dd>[&lt;em>required&lt;/em>] (&lt;em>default&lt;/em>) If, while verifying full normalization when [&lt;a href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1&lt;/a>] is &#xA;     * supported, a character is encountered for which the normalization &#xA;     * properties cannot be determined, then raise a &#xA;     * &lt;code>&quot;unknown-character-denormalization&quot;&lt;/code> warning (instead of &#xA;     * raising an error, if this parameter is not set) and ignore any &#xA;     * possible denormalizations caused by these characters. &lt;/dd>&#xA;     * &lt;dt>&#xA;     * &lt;code>false&lt;/code>&lt;/dt>&#xA;     * &lt;dd>[&lt;em>optional&lt;/em>] Report a fatal error if a character is encountered for which the &#xA;     * processor cannot determine the normalization properties. &lt;/dd>&#xA;     * &lt;/dl>&lt;/dd>&#xA;     * &lt;dt>&#xA;     * &lt;code>&quot;normalize-characters&quot;&lt;/code>&lt;/dt>&#xA;     * &lt;dd> This parameter is equivalent to &#xA;     * the one defined by &lt;code>DOMConfiguration&lt;/code> in [&lt;a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>DOM Level 3 Core&lt;/a>]&#xA;     * . Unlike in the Core, the default value for this parameter is &#xA;     * &lt;code>true&lt;/code>. While DOM implementations are not required to &#xA;     * support &lt;a href='http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm'>fully &#xA;     * normalizing&lt;/a> the characters in the document according to appendix E of [&lt;a href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1&lt;/a>], this &#xA;     * parameter must be activated by default if supported. &lt;/dd>&#xA;     * &lt;dt>&#xA;     * &lt;code>&quot;xml-declaration&quot;&lt;/code>&lt;/dt>&#xA;     * &lt;dd>&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;code>true&lt;/code>&lt;/dt>&#xA;     * &lt;dd>[&lt;em>required&lt;/em>] (&lt;em>default&lt;/em>) If a &lt;code>Document&lt;/code>, &lt;code>Element&lt;/code>, or &lt;code>Entity&lt;/code>&#xA;     *  node is serialized, the XML declaration, or text declaration, should &#xA;     * be included. The version (&lt;code>Document.xmlVersion&lt;/code> if the &#xA;     * document is a Level 3 document and the version is non-null, otherwise &#xA;     * use the value &quot;1.0&quot;), and the output encoding (see &#xA;     * &lt;code>LSSerializer.write&lt;/code> for details on how to find the output &#xA;     * encoding) are specified in the serialized XML declaration. &lt;/dd>&#xA;     * &lt;dt>&#xA;     * &lt;code>false&lt;/code>&lt;/dt>&#xA;     * &lt;dd>[&lt;em>required&lt;/em>] Do not serialize the XML and text declarations. Report a &#xA;     * &lt;code>&quot;xml-declaration-needed&quot;&lt;/code> warning if this will cause &#xA;     * problems (i.e. the serialized data is of an XML version other than [&lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0&lt;/a>], or an &#xA;     * encoding would be needed to be able to re-parse the serialized data). &lt;/dd>&#xA;     * &lt;/dl>&lt;/dd>&#xA;     * &lt;/dl>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNewLine">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  The end-of-line sequence of characters to be used in the XML being &#xA;     * written out. Any string is supported, but XML treats only a certain &#xA;     * set of characters sequence as end-of-line (See section 2.11, &#xA;     * &quot;End-of-Line Handling&quot; in [&lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0&lt;/a>], if the &#xA;     * serialized content is XML 1.0 or section 2.11, &quot;End-of-Line Handling&quot; &#xA;     * in [&lt;a href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1&lt;/a>], if the &#xA;     * serialized content is XML 1.1). Using other character sequences than &#xA;     * the recommended ones can result in a document that is either not &#xA;     * serializable or not well-formed). &#xA;     * &lt;br> On retrieval, the default value of this attribute is the &#xA;     * implementation specific default end-of-line sequence. DOM &#xA;     * implementations should choose the default to match the usual &#xA;     * convention for text files in the environment being used. &#xA;     * Implementations must choose a default sequence that matches one of &#xA;     * those allowed by XML 1.0 or XML 1.1, depending on the serialized &#xA;     * content. Setting this attribute to &lt;code>null&lt;/code> will reset its &#xA;     * value to the default value. &#xA;     * &lt;br> &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setNewLine">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newLine">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  The end-of-line sequence of characters to be used in the XML being &#xA;     * written out. Any string is supported, but XML treats only a certain &#xA;     * set of characters sequence as end-of-line (See section 2.11, &#xA;     * &quot;End-of-Line Handling&quot; in [&lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0&lt;/a>], if the &#xA;     * serialized content is XML 1.0 or section 2.11, &quot;End-of-Line Handling&quot; &#xA;     * in [&lt;a href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1&lt;/a>], if the &#xA;     * serialized content is XML 1.1). Using other character sequences than &#xA;     * the recommended ones can result in a document that is either not &#xA;     * serializable or not well-formed). &#xA;     * &lt;br> On retrieval, the default value of this attribute is the &#xA;     * implementation specific default end-of-line sequence. DOM &#xA;     * implementations should choose the default to match the usual &#xA;     * convention for text files in the environment being used. &#xA;     * Implementations must choose a default sequence that matches one of &#xA;     * those allowed by XML 1.0 or XML 1.1, depending on the serialized &#xA;     * content. Setting this attribute to &lt;code>null&lt;/code> will reset its &#xA;     * value to the default value. &#xA;     * &lt;br> &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFilter">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="LSSerializerFilter.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  When the application provides a filter, the serializer will call out &#xA;     * to the filter before serializing each Node. The filter implementation &#xA;     * can choose to remove the node from the stream or to terminate the &#xA;     * serialization early. &#xA;     * &lt;br> The filter is invoked after the operations requested by the &#xA;     * &lt;code>DOMConfiguration&lt;/code> parameters have been applied. For &#xA;     * example, CDATA sections won't be passed to the filter if &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-cdata-sections'>&#xA;     * cdata-sections&lt;/a>&quot; is set to &lt;code>false&lt;/code>. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setFilter">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filter">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="LSSerializerFilter.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  When the application provides a filter, the serializer will call out &#xA;     * to the filter before serializing each Node. The filter implementation &#xA;     * can choose to remove the node from the stream or to terminate the &#xA;     * serialization early. &#xA;     * &lt;br> The filter is invoked after the operations requested by the &#xA;     * &lt;code>DOMConfiguration&lt;/code> parameters have been applied. For &#xA;     * example, CDATA sections won't be passed to the filter if &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-cdata-sections'>&#xA;     * cdata-sections&lt;/a>&quot; is set to &lt;code>false&lt;/code>. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="write">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeArg">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="destination">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="LSOutput.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="LSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  Serialize the specified node as described above in the general &#xA;     * description of the &lt;code>LSSerializer&lt;/code> interface. The output is &#xA;     * written to the supplied &lt;code>LSOutput&lt;/code>. &#xA;     * &lt;br> When writing to a &lt;code>LSOutput&lt;/code>, the encoding is found by &#xA;     * looking at the encoding information that is reachable through the &#xA;     * &lt;code>LSOutput&lt;/code> and the item to be written (or its owner &#xA;     * document) in this order: &#xA;     * &lt;ol>&#xA;     * &lt;li> &lt;code>LSOutput.encoding&lt;/code>, &#xA;     * &lt;/li>&#xA;     * &lt;li> &#xA;     * &lt;code>Document.inputEncoding&lt;/code>, &#xA;     * &lt;/li>&#xA;     * &lt;li> &#xA;     * &lt;code>Document.xmlEncoding&lt;/code>. &#xA;     * &lt;/li>&#xA;     * &lt;/ol>&#xA;     * &lt;br> If no encoding is reachable through the above properties, a &#xA;     * default encoding of &quot;UTF-8&quot; will be used. If the specified encoding &#xA;     * is not supported an &quot;unsupported-encoding&quot; fatal error is raised. &#xA;     * &lt;br> If no output is specified in the &lt;code>LSOutput&lt;/code>, a &#xA;     * &quot;no-output-specified&quot; fatal error is raised. &#xA;     * &lt;br> The implementation is responsible of associating the appropriate &#xA;     * media type with the serialized data. &#xA;     * &lt;br> When writing to a HTTP URI, a HTTP PUT is performed. When writing &#xA;     * to other types of URIs, the mechanism for writing the data to the URI &#xA;     * is implementation dependent. &#xA;     * @param nodeArg  The node to serialize. &#xA;     * @param destination The destination for the serialized DOM.&#xA;     * @return  Returns &lt;code>true&lt;/code> if &lt;code>node&lt;/code> was &#xA;     *   successfully serialized. Return &lt;code>false&lt;/code> in case the &#xA;     *   normal processing stopped but the implementation kept serializing &#xA;     *   the document; the result of the serialization being implementation &#xA;     *   dependent then. &#xA;     * @exception LSException&#xA;     *    SERIALIZE_ERR: Raised if the &lt;code>LSSerializer&lt;/code> was unable to &#xA;     *   serialize the node. DOM applications should attach a &#xA;     *   &lt;code>DOMErrorHandler&lt;/code> using the parameter &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-error-handler'>&#xA;     *   error-handler&lt;/a>&quot; if they wish to get details on the error. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeToURI">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeArg">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="uri">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="LSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  A convenience method that acts as if &lt;code>LSSerializer.write&lt;/code> &#xA;     * was called with a &lt;code>LSOutput&lt;/code> with no encoding specified &#xA;     * and &lt;code>LSOutput.systemId&lt;/code> set to the &lt;code>uri&lt;/code> &#xA;     * argument. &#xA;     * @param nodeArg  The node to serialize. &#xA;     * @param uri The URI to write to.&#xA;     * @return  Returns &lt;code>true&lt;/code> if &lt;code>node&lt;/code> was &#xA;     *   successfully serialized. Return &lt;code>false&lt;/code> in case the &#xA;     *   normal processing stopped but the implementation kept serializing &#xA;     *   the document; the result of the serialization being implementation &#xA;     *   dependent then. &#xA;     * @exception LSException&#xA;     *    SERIALIZE_ERR: Raised if the &lt;code>LSSerializer&lt;/code> was unable to &#xA;     *   serialize the node. DOM applications should attach a &#xA;     *   &lt;code>DOMErrorHandler&lt;/code> using the parameter &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-error-handler'>&#xA;     *   error-handler&lt;/a>&quot; if they wish to get details on the error. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeToString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeArg">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="LSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  Serialize the specified node as described above in the general &#xA;     * description of the &lt;code>LSSerializer&lt;/code> interface. The output is &#xA;     * written to a &lt;code>DOMString&lt;/code> that is returned to the caller. &#xA;     * The encoding used is the encoding of the &lt;code>DOMString&lt;/code> type, &#xA;     * i.e. UTF-16. Note that no Byte Order Mark is generated in a &#xA;     * &lt;code>DOMString&lt;/code> object. &#xA;     * @param nodeArg  The node to serialize. &#xA;     * @return  Returns the serialized data. &#xA;     * @exception DOMException&#xA;     *    DOMSTRING_SIZE_ERR: Raised if the resulting string is too long to &#xA;     *   fit in a &lt;code>DOMString&lt;/code>. &#xA;     * @exception LSException&#xA;     *    SERIALIZE_ERR: Raised if the &lt;code>LSSerializer&lt;/code> was unable to &#xA;     *   serialize the node. DOM applications should attach a &#xA;     *   &lt;code>DOMErrorHandler&lt;/code> using the parameter &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-error-handler'>&#xA;     *   error-handler&lt;/a>&quot; if they wish to get details on the error. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; *  A &lt;code>LSSerializer&lt;/code> provides an API for serializing (writing) a &#xA; * DOM document out into XML. The XML data is written to a string or an &#xA; * output stream. Any changes or fixups made during the serialization affect &#xA; * only the serialized data. The &lt;code>Document&lt;/code> object and its &#xA; * children are never altered by the serialization operation. &#xA; * &lt;p> During serialization of XML data, namespace fixup is done as defined in [&lt;a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>DOM Level 3 Core&lt;/a>]&#xA; * , Appendix B. [&lt;a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113'>DOM Level 2 Core&lt;/a>]&#xA; *  allows empty strings as a real namespace URI. If the &#xA; * &lt;code>namespaceURI&lt;/code> of a &lt;code>Node&lt;/code> is empty string, the &#xA; * serialization will treat them as &lt;code>null&lt;/code>, ignoring the prefix &#xA; * if any. &#xA; * &lt;p> &lt;code>LSSerializer&lt;/code> accepts any node type for serialization. For &#xA; * nodes of type &lt;code>Document&lt;/code> or &lt;code>Entity&lt;/code>, well-formed &#xA; * XML will be created when possible (well-formedness is guaranteed if the &#xA; * document or entity comes from a parse operation and is unchanged since it &#xA; * was created). The serialized output for these node types is either as a &#xA; * XML document or an External XML Entity, respectively, and is acceptable &#xA; * input for an XML parser. For all other types of nodes the serialized form &#xA; * is implementation dependent. &#xA; * &lt;p>Within a &lt;code>Document&lt;/code>, &lt;code>DocumentFragment&lt;/code>, or &#xA; * &lt;code>Entity&lt;/code> being serialized, &lt;code>Nodes&lt;/code> are processed as &#xA; * follows&#xA; * &lt;ul>&#xA; * &lt;li> &lt;code>Document&lt;/code> nodes are written, including the XML &#xA; * declaration (unless the parameter &quot;xml-declaration&quot; is set to &#xA; * &lt;code>false&lt;/code>) and a DTD subset, if one exists in the DOM. Writing a &#xA; * &lt;code>Document&lt;/code> node serializes the entire document. &#xA; * &lt;/li>&#xA; * &lt;li> &#xA; * &lt;code>Entity&lt;/code> nodes, when written directly by &#xA; * &lt;code>LSSerializer.write&lt;/code>, outputs the entity expansion but no &#xA; * namespace fixup is done. The resulting output will be valid as an &#xA; * external entity. &#xA; * &lt;/li>&#xA; * &lt;li> If the parameter &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-entities'>&#xA; * entities&lt;/a>&quot; is set to &lt;code>true&lt;/code>, &lt;code>EntityReference&lt;/code> nodes are &#xA; * serialized as an entity reference of the form &quot;&#xA; * &lt;code>&amp;amp;entityName;&lt;/code>&quot; in the output. Child nodes (the expansion) &#xA; * of the entity reference are ignored. If the parameter &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-entities'>&#xA; * entities&lt;/a>&quot; is set to &lt;code>false&lt;/code>, only the children of the entity reference &#xA; * are serialized. &lt;code>EntityReference&lt;/code> nodes with no children (no &#xA; * corresponding &lt;code>Entity&lt;/code> node or the corresponding &#xA; * &lt;code>Entity&lt;/code> nodes have no children) are always serialized. &#xA; * &lt;/li>&#xA; * &lt;li> &#xA; * &lt;code>CDATAsections&lt;/code> containing content characters that cannot be &#xA; * represented in the specified output encoding are handled according to the &#xA; * &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-split-cdata-sections'>&#xA; * split-cdata-sections&lt;/a>&quot; parameter.  If the parameter is set to &lt;code>true&lt;/code>, &#xA; * &lt;code>CDATAsections&lt;/code> are split, and the unrepresentable characters &#xA; * are serialized as numeric character references in ordinary content. The &#xA; * exact position and number of splits is not specified.  If the parameter &#xA; * is set to &lt;code>false&lt;/code>, unrepresentable characters in a &#xA; * &lt;code>CDATAsection&lt;/code> are reported as &#xA; * &lt;code>&quot;wf-invalid-character&quot;&lt;/code> errors if the parameter &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-well-formed'>&#xA; * well-formed&lt;/a>&quot; is set to &lt;code>true&lt;/code>. The error is not recoverable - there is no &#xA; * mechanism for supplying alternative characters and continuing with the &#xA; * serialization. &#xA; * &lt;/li>&#xA; * &lt;li> &lt;code>DocumentFragment&lt;/code> nodes are serialized by &#xA; * serializing the children of the document fragment in the order they &#xA; * appear in the document fragment. &#xA; * &lt;/li>&#xA; * &lt;li> All other node types (Element, Text, &#xA; * etc.) are serialized to their corresponding XML source form. &#xA; * &lt;/li>&#xA; * &lt;/ul>&#xA; * &lt;p >&lt;b>Note:&lt;/b>  The serialization of a &lt;code>Node&lt;/code> does not always &#xA; * generate a well-formed XML document, i.e. a &lt;code>LSParser&lt;/code> might &#xA; * throw fatal errors when parsing the resulting serialization. &#xA; * &lt;p> Within the character data of a document (outside of markup), any &#xA; * characters that cannot be represented directly are replaced with &#xA; * character references. Occurrences of '&amp;lt;' and '&amp;amp;' are replaced by &#xA; * the predefined entities &amp;amp;lt; and &amp;amp;amp;. The other predefined &#xA; * entities (&amp;amp;gt;, &amp;amp;apos;, and &amp;amp;quot;) might not be used, except &#xA; * where needed (e.g. using &amp;amp;gt; in cases such as ']]&amp;gt;'). Any &#xA; * characters that cannot be represented directly in the output character &#xA; * encoding are serialized as numeric character references (and since &#xA; * character encoding standards commonly use hexadecimal representations of &#xA; * characters, using the hexadecimal representation when serializing &#xA; * character references is encouraged). &#xA; * &lt;p> To allow attribute values to contain both single and double quotes, the &#xA; * apostrophe or single-quote character (') may be represented as &#xA; * &quot;&amp;amp;apos;&quot;, and the double-quote character (&quot;)  as &quot;&amp;amp;quot;&quot;. New &#xA; * line characters and other characters that cannot be represented directly &#xA; * in attribute values in the output character encoding are serialized as a &#xA; * numeric character reference. &#xA; * &lt;p> Within markup, but outside of attributes, any occurrence of a character &#xA; * that cannot be represented in the output character encoding is reported &#xA; * as a &lt;code>DOMError&lt;/code> fatal error. An example would be serializing &#xA; * the element &amp;lt;LaCa\u00f1ada/&amp;gt; with &lt;code>encoding=&quot;us-ascii&quot;&lt;/code>. &#xA; * This will result with a generation of a &lt;code>DOMError&lt;/code> &#xA; * &quot;wf-invalid-character-in-node-name&quot; (as proposed in &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-well-formed'>&#xA; * well-formed&lt;/a>&quot;). &#xA; * &lt;p> When requested by setting the parameter &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-normalize-characters'>&#xA; * normalize-characters&lt;/a>&quot; on &lt;code>LSSerializer&lt;/code> to true, character normalization is &#xA; * performed according to the definition of &lt;a href='http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm'>fully &#xA; * normalized&lt;/a> characters included in appendix E of [&lt;a href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1&lt;/a>] on all &#xA; * data to be serialized, both markup and character data. The character &#xA; * normalization process affects only the data as it is being written; it &#xA; * does not alter the DOM's view of the document after serialization has &#xA; * completed. &#xA; * &lt;p> Implementations are required to support the encodings &quot;UTF-8&quot;, &#xA; * &quot;UTF-16&quot;, &quot;UTF-16BE&quot;, and &quot;UTF-16LE&quot; to guarantee that data is &#xA; * serializable in all encodings that are required to be supported by all &#xA; * XML parsers. When the encoding is UTF-8, whether or not a byte order mark &#xA; * is serialized, or if the output is big-endian or little-endian, is &#xA; * implementation dependent. When the encoding is UTF-16, whether or not the &#xA; * output is big-endian or little-endian is implementation dependent, but a &#xA; * Byte Order Mark must be generated for non-character outputs, such as &#xA; * &lt;code>LSOutput.byteStream&lt;/code> or &lt;code>LSOutput.systemId&lt;/code>. If &#xA; * the Byte Order Mark is not generated, a &quot;byte-order-mark-needed&quot; warning &#xA; * is reported. When the encoding is UTF-16LE or UTF-16BE, the output is &#xA; * big-endian (UTF-16BE) or little-endian (UTF-16LE) and the Byte Order Mark &#xA; * is not be generated. In all cases, the encoding declaration, if &#xA; * generated, will correspond to the encoding used during the serialization &#xA; * (e.g. &lt;code>encoding=&quot;UTF-16&quot;&lt;/code> will appear if UTF-16 was &#xA; * requested). &#xA; * &lt;p> Namespaces are fixed up during serialization, the serialization process &#xA; * will verify that namespace declarations, namespace prefixes and the &#xA; * namespace URI associated with elements and attributes are consistent. If &#xA; * inconsistencies are found, the serialized form of the document will be &#xA; * altered to remove them. The method used for doing the namespace fixup &#xA; * while serializing a document is the algorithm defined in Appendix B.1, &#xA; * &quot;Namespace normalization&quot;, of [&lt;a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>DOM Level 3 Core&lt;/a>]&#xA; * . &#xA; * &lt;p> While serializing a document, the parameter &quot;discard-default-content&quot; &#xA; * controls whether or not non-specified data is serialized. &#xA; * &lt;p> While serializing, errors and warnings are reported to the application &#xA; * through the error handler (&lt;code>LSSerializer.domConfig&lt;/code>'s &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-error-handler'>&#xA; * error-handler&lt;/a>&quot; parameter). This specification does in no way try to define all possible &#xA; * errors and warnings that can occur while serializing a DOM node, but some &#xA; * common error and warning cases are defined. The types (&#xA; * &lt;code>DOMError.type&lt;/code>) of errors and warnings defined by this &#xA; * specification are: &#xA; * &lt;dl>&#xA; * &lt;dt>&lt;code>&quot;no-output-specified&quot; [fatal]&lt;/code>&lt;/dt>&#xA; * &lt;dd> Raised when &#xA; * writing to a &lt;code>LSOutput&lt;/code> if no output is specified in the &#xA; * &lt;code>LSOutput&lt;/code>. &lt;/dd>&#xA; * &lt;dt> &#xA; * &lt;code>&quot;unbound-prefix-in-entity-reference&quot; [fatal]&lt;/code> &lt;/dt>&#xA; * &lt;dd> Raised if the &#xA; * configuration parameter &quot;&lt;a href='http://www.w3.org/TR/DOM-Level-3-Core/core.html#parameter-namespaces'>&#xA; * namespaces&lt;/a>&quot; is set to &lt;code>true&lt;/code> and an entity whose replacement text &#xA; * contains unbound namespace prefixes is referenced in a location where &#xA; * there are no bindings for the namespace prefixes. &lt;/dd>&#xA; * &lt;dt>&#xA; * &lt;code>&quot;unsupported-encoding&quot; [fatal]&lt;/code>&lt;/dt>&#xA; * &lt;dd> Raised if an unsupported &#xA; * encoding is encountered. &lt;/dd>&#xA; * &lt;/dl> &#xA; * &lt;p> In addition to raising the defined errors and warnings, implementations &#xA; * are expected to raise implementation specific errors and warnings for any &#xA; * other error and warning cases such as IO errors (file not found, &#xA; * permission denied,...) and so on. &#xA; * &lt;p>See also the &lt;a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407'>Document Object Model (DOM) Level 3 Load&#xA;and Save Specification&lt;/a>.&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
