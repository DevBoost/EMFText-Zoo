<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="Document.java">
  <comments>/*&#xA; * Copyright (c) 2004 World Wide Web Consortium,&#xA; *&#xA; * (Massachusetts Institute of Technology, European Research Consortium for&#xA; * Informatics and Mathematics, Keio University). All Rights Reserved. This&#xA; * work is distributed under the W3C(r) Software License [1] in the hope that&#xA; * it will be useful, but WITHOUT ANY WARRANTY; without even the implied&#xA; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&#xA; *&#xA; * [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231&#xA; */</comments>
  <namespaces>org</namespaces>
  <namespaces>w3c</namespaces>
  <namespaces>dom</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Document">
    <members xsi:type="members:InterfaceMethod" name="getDoctype">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="DocumentType.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The Document Type Declaration (see &lt;code>DocumentType&lt;/code>) &#xA;     * associated with this document. For XML documents without a document &#xA;     * type declaration this returns &lt;code>null&lt;/code>. For HTML documents, &#xA;     * a &lt;code>DocumentType&lt;/code> object may be returned, independently of &#xA;     * the presence or absence of document type declaration in the HTML &#xA;     * document.&#xA;     * &lt;br>This provides direct access to the &lt;code>DocumentType&lt;/code> node, &#xA;     * child node of this &lt;code>Document&lt;/code>. This node can be set at &#xA;     * document creation time and later changed through the use of child &#xA;     * nodes manipulation methods, such as &lt;code>Node.insertBefore&lt;/code>, &#xA;     * or &lt;code>Node.replaceChild&lt;/code>. Note, however, that while some &#xA;     * implementations may instantiate different types of &#xA;     * &lt;code>Document&lt;/code> objects supporting additional features than the &#xA;     * &quot;Core&quot;, such as &quot;HTML&quot; [&lt;a href='http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109'>DOM Level 2 HTML&lt;/a>]&#xA;     * , based on the &lt;code>DocumentType&lt;/code> specified at creation time, &#xA;     * changing it afterwards is very unlikely to result in a change of the &#xA;     * features supported.&#xA;     * @version DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getImplementation">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="DOMImplementation.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The &lt;code>DOMImplementation&lt;/code> object that handles this document. A &#xA;     * DOM application may use objects from multiple implementations.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDocumentElement">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * This is a convenience attribute that allows direct access to the child &#xA;     * node that is the document element of the document.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createElement">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tagName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an element of the type specified. Note that the instance &#xA;     * returned implements the &lt;code>Element&lt;/code> interface, so attributes &#xA;     * can be specified directly on the returned object.&#xA;     * &lt;br>In addition, if there are known attributes with default values, &#xA;     * &lt;code>Attr&lt;/code> nodes representing them are automatically created &#xA;     * and attached to the element.&#xA;     * &lt;br>To create an element with a qualified name and namespace URI, use &#xA;     * the &lt;code>createElementNS&lt;/code> method.&#xA;     * @param tagName The name of the element type to instantiate. For XML, &#xA;     *   this is case-sensitive, otherwise it depends on the &#xA;     *   case-sensitivity of the markup language in use. In that case, the &#xA;     *   name is mapped to the canonical form of that markup by the DOM &#xA;     *   implementation.&#xA;     * @return A new &lt;code>Element&lt;/code> object with the &#xA;     *   &lt;code>nodeName&lt;/code> attribute set to &lt;code>tagName&lt;/code>, and &#xA;     *   &lt;code>localName&lt;/code>, &lt;code>prefix&lt;/code>, and &#xA;     *   &lt;code>namespaceURI&lt;/code> set to &lt;code>null&lt;/code>.&#xA;     * @exception DOMException&#xA;     *   INVALID_CHARACTER_ERR: Raised if the specified name is not an XML &#xA;     *   name according to the XML version in use specified in the &#xA;     *   &lt;code>Document.xmlVersion&lt;/code> attribute.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createDocumentFragment">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="DocumentFragment.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an empty &lt;code>DocumentFragment&lt;/code> object.&#xA;     * @return A new &lt;code>DocumentFragment&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createTextNode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Text.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a &lt;code>Text&lt;/code> node given the specified string.&#xA;     * @param data The data for the node.&#xA;     * @return The new &lt;code>Text&lt;/code> object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createComment">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Comment.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a &lt;code>Comment&lt;/code> node given the specified string.&#xA;     * @param data The data for the node.&#xA;     * @return The new &lt;code>Comment&lt;/code> object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createCDATASection">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="CDATASection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a &lt;code>CDATASection&lt;/code> node whose value is the specified &#xA;     * string.&#xA;     * @param data The data for the &lt;code>CDATASection&lt;/code> contents.&#xA;     * @return The new &lt;code>CDATASection&lt;/code> object.&#xA;     * @exception DOMException&#xA;     *   NOT_SUPPORTED_ERR: Raised if this document is an HTML document.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createProcessingInstruction">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="ProcessingInstruction.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="target">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a &lt;code>ProcessingInstruction&lt;/code> node given the specified &#xA;     * name and data strings.&#xA;     * @param target The target part of the processing instruction.Unlike &#xA;     *   &lt;code>Document.createElementNS&lt;/code> or &#xA;     *   &lt;code>Document.createAttributeNS&lt;/code>, no namespace well-formed &#xA;     *   checking is done on the target name. Applications should invoke &#xA;     *   &lt;code>Document.normalizeDocument()&lt;/code> with the parameter &quot;&#xA;     *   namespaces&quot; set to &lt;code>true&lt;/code> in order to ensure that the &#xA;     *   target name is namespace well-formed. &#xA;     * @param data The data for the node.&#xA;     * @return The new &lt;code>ProcessingInstruction&lt;/code> object.&#xA;     * @exception DOMException&#xA;     *   INVALID_CHARACTER_ERR: Raised if the specified target is not an XML &#xA;     *   name according to the XML version in use specified in the &#xA;     *   &lt;code>Document.xmlVersion&lt;/code> attribute.&#xA;     *   &lt;br>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createAttribute">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Attr.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an &lt;code>Attr&lt;/code> of the given name. Note that the &#xA;     * &lt;code>Attr&lt;/code> instance can then be set on an &lt;code>Element&lt;/code> &#xA;     * using the &lt;code>setAttributeNode&lt;/code> method. &#xA;     * &lt;br>To create an attribute with a qualified name and namespace URI, use &#xA;     * the &lt;code>createAttributeNS&lt;/code> method.&#xA;     * @param name The name of the attribute.&#xA;     * @return A new &lt;code>Attr&lt;/code> object with the &lt;code>nodeName&lt;/code> &#xA;     *   attribute set to &lt;code>name&lt;/code>, and &lt;code>localName&lt;/code>, &#xA;     *   &lt;code>prefix&lt;/code>, and &lt;code>namespaceURI&lt;/code> set to &#xA;     *   &lt;code>null&lt;/code>. The value of the attribute is the empty string.&#xA;     * @exception DOMException&#xA;     *   INVALID_CHARACTER_ERR: Raised if the specified name is not an XML &#xA;     *   name according to the XML version in use specified in the &#xA;     *   &lt;code>Document.xmlVersion&lt;/code> attribute.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createEntityReference">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="EntityReference.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an &lt;code>EntityReference&lt;/code> object. In addition, if the &#xA;     * referenced entity is known, the child list of the &#xA;     * &lt;code>EntityReference&lt;/code> node is made the same as that of the &#xA;     * corresponding &lt;code>Entity&lt;/code> node.&#xA;     * &lt;p >&lt;b>Note:&lt;/b> If any descendant of the &lt;code>Entity&lt;/code> node has &#xA;     * an unbound namespace prefix, the corresponding descendant of the &#xA;     * created &lt;code>EntityReference&lt;/code> node is also unbound; (its &#xA;     * &lt;code>namespaceURI&lt;/code> is &lt;code>null&lt;/code>). The DOM Level 2 and &#xA;     * 3 do not support any mechanism to resolve namespace prefixes in this &#xA;     * case.&#xA;     * @param name The name of the entity to reference.Unlike &#xA;     *   &lt;code>Document.createElementNS&lt;/code> or &#xA;     *   &lt;code>Document.createAttributeNS&lt;/code>, no namespace well-formed &#xA;     *   checking is done on the entity name. Applications should invoke &#xA;     *   &lt;code>Document.normalizeDocument()&lt;/code> with the parameter &quot;&#xA;     *   namespaces&quot; set to &lt;code>true&lt;/code> in order to ensure that the &#xA;     *   entity name is namespace well-formed. &#xA;     * @return The new &lt;code>EntityReference&lt;/code> object.&#xA;     * @exception DOMException&#xA;     *   INVALID_CHARACTER_ERR: Raised if the specified name is not an XML &#xA;     *   name according to the XML version in use specified in the &#xA;     *   &lt;code>Document.xmlVersion&lt;/code> attribute.&#xA;     *   &lt;br>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getElementsByTagName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="NodeList.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tagname">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>NodeList&lt;/code> of all the &lt;code>Elements&lt;/code> in &#xA;     * document order with a given tag name and are contained in the &#xA;     * document.&#xA;     * @param tagname  The name of the tag to match on. The special value &quot;*&quot; &#xA;     *   matches all tags. For XML, the &lt;code>tagname&lt;/code> parameter is &#xA;     *   case-sensitive, otherwise it depends on the case-sensitivity of the &#xA;     *   markup language in use. &#xA;     * @return A new &lt;code>NodeList&lt;/code> object containing all the matched &#xA;     *   &lt;code>Elements&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="importNode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Node.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="importedNode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="deep">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Imports a node from another document to this document, without altering &#xA;     * or removing the source node from the original document; this method &#xA;     * creates a new copy of the source node. The returned node has no &#xA;     * parent; (&lt;code>parentNode&lt;/code> is &lt;code>null&lt;/code>).&#xA;     * &lt;br>For all nodes, importing a node creates a node object owned by the &#xA;     * importing document, with attribute values identical to the source &#xA;     * node's &lt;code>nodeName&lt;/code> and &lt;code>nodeType&lt;/code>, plus the &#xA;     * attributes related to namespaces (&lt;code>prefix&lt;/code>, &#xA;     * &lt;code>localName&lt;/code>, and &lt;code>namespaceURI&lt;/code>). As in the &#xA;     * &lt;code>cloneNode&lt;/code> operation, the source node is not altered. &#xA;     * User data associated to the imported node is not carried over. &#xA;     * However, if any &lt;code>UserDataHandlers&lt;/code> has been specified &#xA;     * along with the associated data these handlers will be called with the &#xA;     * appropriate parameters before this method returns.&#xA;     * &lt;br>Additional information is copied as appropriate to the &#xA;     * &lt;code>nodeType&lt;/code>, attempting to mirror the behavior expected if &#xA;     * a fragment of XML or HTML source was copied from one document to &#xA;     * another, recognizing that the two documents may have different DTDs &#xA;     * in the XML case. The following list describes the specifics for each &#xA;     * type of node. &#xA;     * &lt;dl>&#xA;     * &lt;dt>ATTRIBUTE_NODE&lt;/dt>&#xA;     * &lt;dd>The &lt;code>ownerElement&lt;/code> attribute &#xA;     * is set to &lt;code>null&lt;/code> and the &lt;code>specified&lt;/code> flag is &#xA;     * set to &lt;code>true&lt;/code> on the generated &lt;code>Attr&lt;/code>. The &#xA;     * descendants of the source &lt;code>Attr&lt;/code> are recursively imported &#xA;     * and the resulting nodes reassembled to form the corresponding subtree.&#xA;     * Note that the &lt;code>deep&lt;/code> parameter has no effect on &#xA;     * &lt;code>Attr&lt;/code> nodes; they always carry their children with them &#xA;     * when imported.&lt;/dd>&#xA;     * &lt;dt>DOCUMENT_FRAGMENT_NODE&lt;/dt>&#xA;     * &lt;dd>If the &lt;code>deep&lt;/code> option &#xA;     * was set to &lt;code>true&lt;/code>, the descendants of the source &#xA;     * &lt;code>DocumentFragment&lt;/code> are recursively imported and the &#xA;     * resulting nodes reassembled under the imported &#xA;     * &lt;code>DocumentFragment&lt;/code> to form the corresponding subtree. &#xA;     * Otherwise, this simply generates an empty &#xA;     * &lt;code>DocumentFragment&lt;/code>.&lt;/dd>&#xA;     * &lt;dt>DOCUMENT_NODE&lt;/dt>&#xA;     * &lt;dd>&lt;code>Document&lt;/code> &#xA;     * nodes cannot be imported.&lt;/dd>&#xA;     * &lt;dt>DOCUMENT_TYPE_NODE&lt;/dt>&#xA;     * &lt;dd>&lt;code>DocumentType&lt;/code> &#xA;     * nodes cannot be imported.&lt;/dd>&#xA;     * &lt;dt>ELEMENT_NODE&lt;/dt>&#xA;     * &lt;dd>&lt;em>Specified&lt;/em> attribute nodes of the source element are imported, and the generated &#xA;     * &lt;code>Attr&lt;/code> nodes are attached to the generated &#xA;     * &lt;code>Element&lt;/code>. Default attributes are &lt;em>not&lt;/em> copied, though if the document being imported into defines default &#xA;     * attributes for this element name, those are assigned. If the &#xA;     * &lt;code>importNode&lt;/code> &lt;code>deep&lt;/code> parameter was set to &#xA;     * &lt;code>true&lt;/code>, the descendants of the source element are &#xA;     * recursively imported and the resulting nodes reassembled to form the &#xA;     * corresponding subtree.&lt;/dd>&#xA;     * &lt;dt>ENTITY_NODE&lt;/dt>&#xA;     * &lt;dd>&lt;code>Entity&lt;/code> nodes can be &#xA;     * imported, however in the current release of the DOM the &#xA;     * &lt;code>DocumentType&lt;/code> is readonly. Ability to add these imported &#xA;     * nodes to a &lt;code>DocumentType&lt;/code> will be considered for addition &#xA;     * to a future release of the DOM.On import, the &lt;code>publicId&lt;/code>, &#xA;     * &lt;code>systemId&lt;/code>, and &lt;code>notationName&lt;/code> attributes are &#xA;     * copied. If a &lt;code>deep&lt;/code> import is requested, the descendants &#xA;     * of the the source &lt;code>Entity&lt;/code> are recursively imported and &#xA;     * the resulting nodes reassembled to form the corresponding subtree.&lt;/dd>&#xA;     * &lt;dt>&#xA;     * ENTITY_REFERENCE_NODE&lt;/dt>&#xA;     * &lt;dd>Only the &lt;code>EntityReference&lt;/code> itself is &#xA;     * copied, even if a &lt;code>deep&lt;/code> import is requested, since the &#xA;     * source and destination documents might have defined the entity &#xA;     * differently. If the document being imported into provides a &#xA;     * definition for this entity name, its value is assigned.&lt;/dd>&#xA;     * &lt;dt>NOTATION_NODE&lt;/dt>&#xA;     * &lt;dd>&#xA;     * &lt;code>Notation&lt;/code> nodes can be imported, however in the current &#xA;     * release of the DOM the &lt;code>DocumentType&lt;/code> is readonly. Ability &#xA;     * to add these imported nodes to a &lt;code>DocumentType&lt;/code> will be &#xA;     * considered for addition to a future release of the DOM.On import, the &#xA;     * &lt;code>publicId&lt;/code> and &lt;code>systemId&lt;/code> attributes are copied.&#xA;     * Note that the &lt;code>deep&lt;/code> parameter has no effect on this type &#xA;     * of nodes since they cannot have any children.&lt;/dd>&#xA;     * &lt;dt>&#xA;     * PROCESSING_INSTRUCTION_NODE&lt;/dt>&#xA;     * &lt;dd>The imported node copies its &#xA;     * &lt;code>target&lt;/code> and &lt;code>data&lt;/code> values from those of the &#xA;     * source node.Note that the &lt;code>deep&lt;/code> parameter has no effect &#xA;     * on this type of nodes since they cannot have any children.&lt;/dd>&#xA;     * &lt;dt>TEXT_NODE, &#xA;     * CDATA_SECTION_NODE, COMMENT_NODE&lt;/dt>&#xA;     * &lt;dd>These three types of nodes inheriting &#xA;     * from &lt;code>CharacterData&lt;/code> copy their &lt;code>data&lt;/code> and &#xA;     * &lt;code>length&lt;/code> attributes from those of the source node.Note &#xA;     * that the &lt;code>deep&lt;/code> parameter has no effect on these types of &#xA;     * nodes since they cannot have any children.&lt;/dd>&#xA;     * &lt;/dl> &#xA;     * @param importedNode The node to import.&#xA;     * @param deep If &lt;code>true&lt;/code>, recursively import the subtree under &#xA;     *   the specified node; if &lt;code>false&lt;/code>, import only the node &#xA;     *   itself, as explained above. This has no effect on nodes that cannot &#xA;     *   have any children, and on &lt;code>Attr&lt;/code>, and &#xA;     *   &lt;code>EntityReference&lt;/code> nodes.&#xA;     * @return The imported node that belongs to this &lt;code>Document&lt;/code>.&#xA;     * @exception DOMException&#xA;     *   NOT_SUPPORTED_ERR: Raised if the type of node being imported is not &#xA;     *   supported.&#xA;     *   &lt;br>INVALID_CHARACTER_ERR: Raised if one of the imported names is not &#xA;     *   an XML name according to the XML version in use specified in the &#xA;     *   &lt;code>Document.xmlVersion&lt;/code> attribute. This may happen when &#xA;     *   importing an XML 1.1 [&lt;a href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1&lt;/a>] element &#xA;     *   into an XML 1.0 document, for instance.&#xA;     * @since DOM Level 2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createElementNS">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespaceURI">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="qualifiedName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an element of the given qualified name and namespace URI.&#xA;     * &lt;br>Per [&lt;a href='http://www.w3.org/TR/1999/REC-xml-names-19990114/'>XML Namespaces&lt;/a>]&#xA;     * , applications must use the value &lt;code>null&lt;/code> as the &#xA;     * namespaceURI parameter for methods if they wish to have no namespace.&#xA;     * @param namespaceURI The namespace URI of the element to create.&#xA;     * @param qualifiedName The qualified name of the element type to &#xA;     *   instantiate.&#xA;     * @return A new &lt;code>Element&lt;/code> object with the following &#xA;     *   attributes:&#xA;     * &lt;table border='1' cellpadding='3'>&#xA;     * &lt;tr>&#xA;     * &lt;th>Attribute&lt;/th>&#xA;     * &lt;th>Value&lt;/th>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Node.nodeName&lt;/code>&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&#xA;     *   &lt;code>qualifiedName&lt;/code>&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Node.namespaceURI&lt;/code>&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&#xA;     *   &lt;code>namespaceURI&lt;/code>&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Node.prefix&lt;/code>&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>prefix, extracted &#xA;     *   from &lt;code>qualifiedName&lt;/code>, or &lt;code>null&lt;/code> if there is &#xA;     *   no prefix&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Node.localName&lt;/code>&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>local name, extracted from &#xA;     *   &lt;code>qualifiedName&lt;/code>&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Element.tagName&lt;/code>&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&#xA;     *   &lt;code>qualifiedName&lt;/code>&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;/table>&#xA;     * @exception DOMException&#xA;     *   INVALID_CHARACTER_ERR: Raised if the specified &#xA;     *   &lt;code>qualifiedName&lt;/code> is not an XML name according to the XML &#xA;     *   version in use specified in the &lt;code>Document.xmlVersion&lt;/code> &#xA;     *   attribute.&#xA;     *   &lt;br>NAMESPACE_ERR: Raised if the &lt;code>qualifiedName&lt;/code> is a &#xA;     *   malformed qualified name, if the &lt;code>qualifiedName&lt;/code> has a &#xA;     *   prefix and the &lt;code>namespaceURI&lt;/code> is &lt;code>null&lt;/code>, or &#xA;     *   if the &lt;code>qualifiedName&lt;/code> has a prefix that is &quot;xml&quot; and &#xA;     *   the &lt;code>namespaceURI&lt;/code> is different from &quot;&lt;a href='http://www.w3.org/XML/1998/namespace'>&#xA;     *   http://www.w3.org/XML/1998/namespace&lt;/a>&quot; [&lt;a href='http://www.w3.org/TR/1999/REC-xml-names-19990114/'>XML Namespaces&lt;/a>]&#xA;     *   , or if the &lt;code>qualifiedName&lt;/code> or its prefix is &quot;xmlns&quot; and &#xA;     *   the &lt;code>namespaceURI&lt;/code> is different from &quot;&lt;a href='http://www.w3.org/2000/xmlns/'>http://www.w3.org/2000/xmlns/&lt;/a>&quot;, or if the &lt;code>namespaceURI&lt;/code> is &quot;&lt;a href='http://www.w3.org/2000/xmlns/'>http://www.w3.org/2000/xmlns/&lt;/a>&quot; and neither the &lt;code>qualifiedName&lt;/code> nor its prefix is &quot;xmlns&quot;.&#xA;     *   &lt;br>NOT_SUPPORTED_ERR: Always thrown if the current document does not &#xA;     *   support the &lt;code>&quot;XML&quot;&lt;/code> feature, since namespaces were &#xA;     *   defined by XML.&#xA;     * @since DOM Level 2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createAttributeNS">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Attr.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespaceURI">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="qualifiedName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an attribute of the given qualified name and namespace URI.&#xA;     * &lt;br>Per [&lt;a href='http://www.w3.org/TR/1999/REC-xml-names-19990114/'>XML Namespaces&lt;/a>]&#xA;     * , applications must use the value &lt;code>null&lt;/code> as the &#xA;     * &lt;code>namespaceURI&lt;/code> parameter for methods if they wish to have &#xA;     * no namespace.&#xA;     * @param namespaceURI The namespace URI of the attribute to create.&#xA;     * @param qualifiedName The qualified name of the attribute to &#xA;     *   instantiate.&#xA;     * @return A new &lt;code>Attr&lt;/code> object with the following attributes:&#xA;     * &lt;table border='1' cellpadding='3'>&#xA;     * &lt;tr>&#xA;     * &lt;th>&#xA;     *   Attribute&lt;/th>&#xA;     * &lt;th>Value&lt;/th>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Node.nodeName&lt;/code>&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>qualifiedName&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&#xA;     *   &lt;code>Node.namespaceURI&lt;/code>&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>namespaceURI&lt;/code>&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&#xA;     *   &lt;code>Node.prefix&lt;/code>&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>prefix, extracted from &#xA;     *   &lt;code>qualifiedName&lt;/code>, or &lt;code>null&lt;/code> if there is no &#xA;     *   prefix&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Node.localName&lt;/code>&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>local name, extracted from &#xA;     *   &lt;code>qualifiedName&lt;/code>&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Attr.name&lt;/code>&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&#xA;     *   &lt;code>qualifiedName&lt;/code>&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Node.nodeValue&lt;/code>&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>the empty &#xA;     *   string&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;/table>&#xA;     * @exception DOMException&#xA;     *   INVALID_CHARACTER_ERR: Raised if the specified &#xA;     *   &lt;code>qualifiedName&lt;/code> is not an XML name according to the XML &#xA;     *   version in use specified in the &lt;code>Document.xmlVersion&lt;/code> &#xA;     *   attribute.&#xA;     *   &lt;br>NAMESPACE_ERR: Raised if the &lt;code>qualifiedName&lt;/code> is a &#xA;     *   malformed qualified name, if the &lt;code>qualifiedName&lt;/code> has a &#xA;     *   prefix and the &lt;code>namespaceURI&lt;/code> is &lt;code>null&lt;/code>, if &#xA;     *   the &lt;code>qualifiedName&lt;/code> has a prefix that is &quot;xml&quot; and the &#xA;     *   &lt;code>namespaceURI&lt;/code> is different from &quot;&lt;a href='http://www.w3.org/XML/1998/namespace'>&#xA;     *   http://www.w3.org/XML/1998/namespace&lt;/a>&quot;, if the &lt;code>qualifiedName&lt;/code> or its prefix is &quot;xmlns&quot; and the &#xA;     *   &lt;code>namespaceURI&lt;/code> is different from &quot;&lt;a href='http://www.w3.org/2000/xmlns/'>http://www.w3.org/2000/xmlns/&lt;/a>&quot;, or if the &lt;code>namespaceURI&lt;/code> is &quot;&lt;a href='http://www.w3.org/2000/xmlns/'>http://www.w3.org/2000/xmlns/&lt;/a>&quot; and neither the &lt;code>qualifiedName&lt;/code> nor its prefix is &quot;xmlns&quot;.&#xA;     *   &lt;br>NOT_SUPPORTED_ERR: Always thrown if the current document does not &#xA;     *   support the &lt;code>&quot;XML&quot;&lt;/code> feature, since namespaces were &#xA;     *   defined by XML.&#xA;     * @since DOM Level 2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getElementsByTagNameNS">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="NodeList.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespaceURI">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="localName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>NodeList&lt;/code> of all the &lt;code>Elements&lt;/code> with a &#xA;     * given local name and namespace URI in document order.&#xA;     * @param namespaceURI The namespace URI of the elements to match on. The &#xA;     *   special value &lt;code>&quot;*&quot;&lt;/code> matches all namespaces.&#xA;     * @param localName The local name of the elements to match on. The &#xA;     *   special value &quot;*&quot; matches all local names.&#xA;     * @return A new &lt;code>NodeList&lt;/code> object containing all the matched &#xA;     *   &lt;code>Elements&lt;/code>.&#xA;     * @since DOM Level 2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getElementById">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="elementId">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>Element&lt;/code> that has an ID attribute with the &#xA;     * given value. If no such element exists, this returns &lt;code>null&lt;/code>&#xA;     * . If more than one element has an ID attribute with that value, what &#xA;     * is returned is undefined. &#xA;     * &lt;br> The DOM implementation is expected to use the attribute &#xA;     * &lt;code>Attr.isId&lt;/code> to determine if an attribute is of type ID. &#xA;     * &lt;p >&lt;b>Note:&lt;/b> Attributes with the name &quot;ID&quot; or &quot;id&quot; are not of type &#xA;     * ID unless so defined.&#xA;     * @param elementId The unique &lt;code>id&lt;/code> value for an element.&#xA;     * @return The matching element or &lt;code>null&lt;/code> if there is none.&#xA;     * @since DOM Level 2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getInputEncoding">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An attribute specifying the encoding used for this document at the time &#xA;     * of the parsing. This is &lt;code>null&lt;/code> when it is not known, such &#xA;     * as when the &lt;code>Document&lt;/code> was created in memory.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getXmlEncoding">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An attribute specifying, as part of the &lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl'>XML declaration&lt;/a>, the encoding of this document. This is &lt;code>null&lt;/code> when &#xA;     * unspecified or when it is not known, such as when the &#xA;     * &lt;code>Document&lt;/code> was created in memory.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getXmlStandalone">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An attribute specifying, as part of the &lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl'>XML declaration&lt;/a>, whether this document is standalone. This is &lt;code>false&lt;/code> when &#xA;     * unspecified.&#xA;     * &lt;p >&lt;b>Note:&lt;/b>  No verification is done on the value when setting &#xA;     * this attribute. Applications should use &#xA;     * &lt;code>Document.normalizeDocument()&lt;/code> with the &quot;validate&quot; &#xA;     * parameter to verify if the value matches the &lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204#sec-rmd'>validity &#xA;     * constraint for standalone document declaration&lt;/a> as defined in [&lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0&lt;/a>]. &#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setXmlStandalone">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="xmlStandalone">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An attribute specifying, as part of the &lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl'>XML declaration&lt;/a>, whether this document is standalone. This is &lt;code>false&lt;/code> when &#xA;     * unspecified.&#xA;     * &lt;p >&lt;b>Note:&lt;/b>  No verification is done on the value when setting &#xA;     * this attribute. Applications should use &#xA;     * &lt;code>Document.normalizeDocument()&lt;/code> with the &quot;validate&quot; &#xA;     * parameter to verify if the value matches the &lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204#sec-rmd'>validity &#xA;     * constraint for standalone document declaration&lt;/a> as defined in [&lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0&lt;/a>]. &#xA;     * @exception DOMException&#xA;     *    NOT_SUPPORTED_ERR: Raised if this document does not support the &#xA;     *   &quot;XML&quot; feature. &#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getXmlVersion">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  An attribute specifying, as part of the &lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl'>XML declaration&lt;/a>, the version number of this document. If there is no declaration and if &#xA;     * this document supports the &quot;XML&quot; feature, the value is &#xA;     * &lt;code>&quot;1.0&quot;&lt;/code>. If this document does not support the &quot;XML&quot; &#xA;     * feature, the value is always &lt;code>null&lt;/code>. Changing this &#xA;     * attribute will affect methods that check for invalid characters in &#xA;     * XML names. Application should invoke &#xA;     * &lt;code>Document.normalizeDocument()&lt;/code> in order to check for &#xA;     * invalid characters in the &lt;code>Node&lt;/code>s that are already part of &#xA;     * this &lt;code>Document&lt;/code>. &#xA;     * &lt;br> DOM applications may use the &#xA;     * &lt;code>DOMImplementation.hasFeature(feature, version)&lt;/code> method &#xA;     * with parameter values &quot;XMLVersion&quot; and &quot;1.0&quot; (respectively) to &#xA;     * determine if an implementation supports [&lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0&lt;/a>]. DOM &#xA;     * applications may use the same method with parameter values &#xA;     * &quot;XMLVersion&quot; and &quot;1.1&quot; (respectively) to determine if an &#xA;     * implementation supports [&lt;a href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1&lt;/a>]. In both &#xA;     * cases, in order to support XML, an implementation must also support &#xA;     * the &quot;XML&quot; feature defined in this specification. &lt;code>Document&lt;/code>&#xA;     *  objects supporting a version of the &quot;XMLVersion&quot; feature must not &#xA;     * raise a &lt;code>NOT_SUPPORTED_ERR&lt;/code> exception for the same version &#xA;     * number when using &lt;code>Document.xmlVersion&lt;/code>. &#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setXmlVersion">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="xmlVersion">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  An attribute specifying, as part of the &lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl'>XML declaration&lt;/a>, the version number of this document. If there is no declaration and if &#xA;     * this document supports the &quot;XML&quot; feature, the value is &#xA;     * &lt;code>&quot;1.0&quot;&lt;/code>. If this document does not support the &quot;XML&quot; &#xA;     * feature, the value is always &lt;code>null&lt;/code>. Changing this &#xA;     * attribute will affect methods that check for invalid characters in &#xA;     * XML names. Application should invoke &#xA;     * &lt;code>Document.normalizeDocument()&lt;/code> in order to check for &#xA;     * invalid characters in the &lt;code>Node&lt;/code>s that are already part of &#xA;     * this &lt;code>Document&lt;/code>. &#xA;     * &lt;br> DOM applications may use the &#xA;     * &lt;code>DOMImplementation.hasFeature(feature, version)&lt;/code> method &#xA;     * with parameter values &quot;XMLVersion&quot; and &quot;1.0&quot; (respectively) to &#xA;     * determine if an implementation supports [&lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0&lt;/a>]. DOM &#xA;     * applications may use the same method with parameter values &#xA;     * &quot;XMLVersion&quot; and &quot;1.1&quot; (respectively) to determine if an &#xA;     * implementation supports [&lt;a href='http://www.w3.org/TR/2004/REC-xml11-20040204/'>XML 1.1&lt;/a>]. In both &#xA;     * cases, in order to support XML, an implementation must also support &#xA;     * the &quot;XML&quot; feature defined in this specification. &lt;code>Document&lt;/code>&#xA;     *  objects supporting a version of the &quot;XMLVersion&quot; feature must not &#xA;     * raise a &lt;code>NOT_SUPPORTED_ERR&lt;/code> exception for the same version &#xA;     * number when using &lt;code>Document.xmlVersion&lt;/code>. &#xA;     * @exception DOMException&#xA;     *    NOT_SUPPORTED_ERR: Raised if the version is set to a value that is &#xA;     *   not supported by this &lt;code>Document&lt;/code> or if this document &#xA;     *   does not support the &quot;XML&quot; feature. &#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getStrictErrorChecking">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An attribute specifying whether error checking is enforced or not. When &#xA;     * set to &lt;code>false&lt;/code>, the implementation is free to not test &#xA;     * every possible error case normally defined on DOM operations, and not &#xA;     * raise any &lt;code>DOMException&lt;/code> on DOM operations or report &#xA;     * errors while using &lt;code>Document.normalizeDocument()&lt;/code>. In case &#xA;     * of error, the behavior is undefined. This attribute is &#xA;     * &lt;code>true&lt;/code> by default.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setStrictErrorChecking">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="strictErrorChecking">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * An attribute specifying whether error checking is enforced or not. When &#xA;     * set to &lt;code>false&lt;/code>, the implementation is free to not test &#xA;     * every possible error case normally defined on DOM operations, and not &#xA;     * raise any &lt;code>DOMException&lt;/code> on DOM operations or report &#xA;     * errors while using &lt;code>Document.normalizeDocument()&lt;/code>. In case &#xA;     * of error, the behavior is undefined. This attribute is &#xA;     * &lt;code>true&lt;/code> by default.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDocumentURI">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  The location of the document or &lt;code>null&lt;/code> if undefined or if &#xA;     * the &lt;code>Document&lt;/code> was created using &#xA;     * &lt;code>DOMImplementation.createDocument&lt;/code>. No lexical checking is &#xA;     * performed when setting this attribute; this could result in a &#xA;     * &lt;code>null&lt;/code> value returned when using &lt;code>Node.baseURI&lt;/code>&#xA;     * . &#xA;     * &lt;br> Beware that when the &lt;code>Document&lt;/code> supports the feature &#xA;     * &quot;HTML&quot; [&lt;a href='http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109'>DOM Level 2 HTML&lt;/a>]&#xA;     * , the href attribute of the HTML BASE element takes precedence over &#xA;     * this attribute when computing &lt;code>Node.baseURI&lt;/code>. &#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setDocumentURI">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="documentURI">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  The location of the document or &lt;code>null&lt;/code> if undefined or if &#xA;     * the &lt;code>Document&lt;/code> was created using &#xA;     * &lt;code>DOMImplementation.createDocument&lt;/code>. No lexical checking is &#xA;     * performed when setting this attribute; this could result in a &#xA;     * &lt;code>null&lt;/code> value returned when using &lt;code>Node.baseURI&lt;/code>&#xA;     * . &#xA;     * &lt;br> Beware that when the &lt;code>Document&lt;/code> supports the feature &#xA;     * &quot;HTML&quot; [&lt;a href='http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109'>DOM Level 2 HTML&lt;/a>]&#xA;     * , the href attribute of the HTML BASE element takes precedence over &#xA;     * this attribute when computing &lt;code>Node.baseURI&lt;/code>. &#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="adoptNode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Node.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  Attempts to adopt a node from another document to this document. If &#xA;     * supported, it changes the &lt;code>ownerDocument&lt;/code> of the source &#xA;     * node, its children, as well as the attached attribute nodes if there &#xA;     * are any. If the source node has a parent it is first removed from the &#xA;     * child list of its parent. This effectively allows moving a subtree &#xA;     * from one document to another (unlike &lt;code>importNode()&lt;/code> which &#xA;     * create a copy of the source node instead of moving it). When it &#xA;     * fails, applications should use &lt;code>Document.importNode()&lt;/code> &#xA;     * instead. Note that if the adopted node is already part of this &#xA;     * document (i.e. the source and target document are the same), this &#xA;     * method still has the effect of removing the source node from the &#xA;     * child list of its parent, if any. The following list describes the &#xA;     * specifics for each type of node. &#xA;     * &lt;dl>&#xA;     * &lt;dt>ATTRIBUTE_NODE&lt;/dt>&#xA;     * &lt;dd>The &#xA;     * &lt;code>ownerElement&lt;/code> attribute is set to &lt;code>null&lt;/code> and &#xA;     * the &lt;code>specified&lt;/code> flag is set to &lt;code>true&lt;/code> on the &#xA;     * adopted &lt;code>Attr&lt;/code>. The descendants of the source &#xA;     * &lt;code>Attr&lt;/code> are recursively adopted.&lt;/dd>&#xA;     * &lt;dt>DOCUMENT_FRAGMENT_NODE&lt;/dt>&#xA;     * &lt;dd>The &#xA;     * descendants of the source node are recursively adopted.&lt;/dd>&#xA;     * &lt;dt>DOCUMENT_NODE&lt;/dt>&#xA;     * &lt;dd>&#xA;     * &lt;code>Document&lt;/code> nodes cannot be adopted.&lt;/dd>&#xA;     * &lt;dt>DOCUMENT_TYPE_NODE&lt;/dt>&#xA;     * &lt;dd>&#xA;     * &lt;code>DocumentType&lt;/code> nodes cannot be adopted.&lt;/dd>&#xA;     * &lt;dt>ELEMENT_NODE&lt;/dt>&#xA;     * &lt;dd>&lt;em>Specified&lt;/em> attribute nodes of the source element are adopted. Default attributes &#xA;     * are discarded, though if the document being adopted into defines &#xA;     * default attributes for this element name, those are assigned. The &#xA;     * descendants of the source element are recursively adopted.&lt;/dd>&#xA;     * &lt;dt>ENTITY_NODE&lt;/dt>&#xA;     * &lt;dd>&#xA;     * &lt;code>Entity&lt;/code> nodes cannot be adopted.&lt;/dd>&#xA;     * &lt;dt>ENTITY_REFERENCE_NODE&lt;/dt>&#xA;     * &lt;dd>Only &#xA;     * the &lt;code>EntityReference&lt;/code> node itself is adopted, the &#xA;     * descendants are discarded, since the source and destination documents &#xA;     * might have defined the entity differently. If the document being &#xA;     * imported into provides a definition for this entity name, its value &#xA;     * is assigned.&lt;/dd>&#xA;     * &lt;dt>NOTATION_NODE&lt;/dt>&#xA;     * &lt;dd>&lt;code>Notation&lt;/code> nodes cannot be &#xA;     * adopted.&lt;/dd>&#xA;     * &lt;dt>PROCESSING_INSTRUCTION_NODE, TEXT_NODE, CDATA_SECTION_NODE, &#xA;     * COMMENT_NODE&lt;/dt>&#xA;     * &lt;dd>These nodes can all be adopted. No specifics.&lt;/dd>&#xA;     * &lt;/dl> &#xA;     * &lt;p >&lt;b>Note:&lt;/b>  Since it does not create new nodes unlike the &#xA;     * &lt;code>Document.importNode()&lt;/code> method, this method does not raise &#xA;     * an &lt;code>INVALID_CHARACTER_ERR&lt;/code> exception, and applications &#xA;     * should use the &lt;code>Document.normalizeDocument()&lt;/code> method to &#xA;     * check if an imported name is not an XML name according to the XML &#xA;     * version in use. &#xA;     * @param source The node to move into this document.&#xA;     * @return The adopted node, or &lt;code>null&lt;/code> if this operation &#xA;     *   fails, such as when the source node comes from a different &#xA;     *   implementation.&#xA;     * @exception DOMException&#xA;     *   NOT_SUPPORTED_ERR: Raised if the source node is of type &#xA;     *   &lt;code>DOCUMENT&lt;/code>, &lt;code>DOCUMENT_TYPE&lt;/code>.&#xA;     *   &lt;br>NO_MODIFICATION_ALLOWED_ERR: Raised when the source node is &#xA;     *   readonly.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDomConfig">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="DOMConfiguration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  The configuration used when &lt;code>Document.normalizeDocument()&lt;/code> &#xA;     * is invoked. &#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="normalizeDocument">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  This method acts as if the document was going through a save and load &#xA;     * cycle, putting the document in a &quot;normal&quot; form. As a consequence, &#xA;     * this method updates the replacement tree of &#xA;     * &lt;code>EntityReference&lt;/code> nodes and normalizes &lt;code>Text&lt;/code> &#xA;     * nodes, as defined in the method &lt;code>Node.normalize()&lt;/code>. &#xA;     * &lt;br> Otherwise, the actual result depends on the features being set on &#xA;     * the &lt;code>Document.domConfig&lt;/code> object and governing what &#xA;     * operations actually take place. Noticeably this method could also &#xA;     * make the document namespace well-formed according to the algorithm &#xA;     * described in , check the character normalization, remove the &#xA;     * &lt;code>CDATASection&lt;/code> nodes, etc. See &#xA;     * &lt;code>DOMConfiguration&lt;/code> for details. &#xA;     * &lt;pre>// Keep in the document &#xA;     * the information defined // in the XML Information Set (Java example) &#xA;     * DOMConfiguration docConfig = myDocument.getDomConfig(); &#xA;     * docConfig.setParameter(&quot;infoset&quot;, Boolean.TRUE); &#xA;     * myDocument.normalizeDocument();&lt;/pre>&#xA;     * &#xA;     * &lt;br>Mutation events, when supported, are generated to reflect the &#xA;     * changes occurring on the document.&#xA;     * &lt;br> If errors occur during the invocation of this method, such as an &#xA;     * attempt to update a read-only node or a &lt;code>Node.nodeName&lt;/code> &#xA;     * contains an invalid character according to the XML version in use, &#xA;     * errors or warnings (&lt;code>DOMError.SEVERITY_ERROR&lt;/code> or &#xA;     * &lt;code>DOMError.SEVERITY_WARNING&lt;/code>) will be reported using the &#xA;     * &lt;code>DOMErrorHandler&lt;/code> object associated with the &quot;error-handler&#xA;     * &quot; parameter. Note this method might also report fatal errors (&#xA;     * &lt;code>DOMError.SEVERITY_FATAL_ERROR&lt;/code>) if an implementation &#xA;     * cannot recover from an error. &#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="renameNode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Node.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespaceURI">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="qualifiedName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Rename an existing node of type &lt;code>ELEMENT_NODE&lt;/code> or &#xA;     * &lt;code>ATTRIBUTE_NODE&lt;/code>.&#xA;     * &lt;br>When possible this simply changes the name of the given node, &#xA;     * otherwise this creates a new node with the specified name and &#xA;     * replaces the existing node with the new node as described below.&#xA;     * &lt;br>If simply changing the name of the given node is not possible, the &#xA;     * following operations are performed: a new node is created, any &#xA;     * registered event listener is registered on the new node, any user &#xA;     * data attached to the old node is removed from that node, the old node &#xA;     * is removed from its parent if it has one, the children are moved to &#xA;     * the new node, if the renamed node is an &lt;code>Element&lt;/code> its &#xA;     * attributes are moved to the new node, the new node is inserted at the &#xA;     * position the old node used to have in its parent's child nodes list &#xA;     * if it has one, the user data that was attached to the old node is &#xA;     * attached to the new node.&#xA;     * &lt;br>When the node being renamed is an &lt;code>Element&lt;/code> only the &#xA;     * specified attributes are moved, default attributes originated from &#xA;     * the DTD are updated according to the new element name. In addition, &#xA;     * the implementation may update default attributes from other schemas. &#xA;     * Applications should use &lt;code>Document.normalizeDocument()&lt;/code> to &#xA;     * guarantee these attributes are up-to-date.&#xA;     * &lt;br>When the node being renamed is an &lt;code>Attr&lt;/code> that is &#xA;     * attached to an &lt;code>Element&lt;/code>, the node is first removed from &#xA;     * the &lt;code>Element&lt;/code> attributes map. Then, once renamed, either &#xA;     * by modifying the existing node or creating a new one as described &#xA;     * above, it is put back.&#xA;     * &lt;br>In addition,&#xA;     * &lt;ul>&#xA;     * &lt;li> a user data event &lt;code>NODE_RENAMED&lt;/code> is fired, &#xA;     * &lt;/li>&#xA;     * &lt;li> &#xA;     * when the implementation supports the feature &quot;MutationNameEvents&quot;, &#xA;     * each mutation operation involved in this method fires the appropriate &#xA;     * event, and in the end the event {&#xA;     * &lt;code>http://www.w3.org/2001/xml-events&lt;/code>, &#xA;     * &lt;code>DOMElementNameChanged&lt;/code>} or {&#xA;     * &lt;code>http://www.w3.org/2001/xml-events&lt;/code>, &#xA;     * &lt;code>DOMAttributeNameChanged&lt;/code>} is fired. &#xA;     * &lt;/li>&#xA;     * &lt;/ul>&#xA;     * @param n The node to rename.&#xA;     * @param namespaceURI The new namespace URI.&#xA;     * @param qualifiedName The new qualified name.&#xA;     * @return The renamed node. This is either the specified node or the new &#xA;     *   node that was created to replace the specified node.&#xA;     * @exception DOMException&#xA;     *   NOT_SUPPORTED_ERR: Raised when the type of the specified node is &#xA;     *   neither &lt;code>ELEMENT_NODE&lt;/code> nor &lt;code>ATTRIBUTE_NODE&lt;/code>, &#xA;     *   or if the implementation does not support the renaming of the &#xA;     *   document element.&#xA;     *   &lt;br>INVALID_CHARACTER_ERR: Raised if the new qualified name is not an &#xA;     *   XML name according to the XML version in use specified in the &#xA;     *   &lt;code>Document.xmlVersion&lt;/code> attribute.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised when the specified node was created &#xA;     *   from a different document than this document.&#xA;     *   &lt;br>NAMESPACE_ERR: Raised if the &lt;code>qualifiedName&lt;/code> is a &#xA;     *   malformed qualified name, if the &lt;code>qualifiedName&lt;/code> has a &#xA;     *   prefix and the &lt;code>namespaceURI&lt;/code> is &lt;code>null&lt;/code>, or &#xA;     *   if the &lt;code>qualifiedName&lt;/code> has a prefix that is &quot;xml&quot; and &#xA;     *   the &lt;code>namespaceURI&lt;/code> is different from &quot;&lt;a href='http://www.w3.org/XML/1998/namespace'>&#xA;     *   http://www.w3.org/XML/1998/namespace&lt;/a>&quot; [&lt;a href='http://www.w3.org/TR/1999/REC-xml-names-19990114/'>XML Namespaces&lt;/a>]&#xA;     *   . Also raised, when the node being renamed is an attribute, if the &#xA;     *   &lt;code>qualifiedName&lt;/code>, or its prefix, is &quot;xmlns&quot; and the &#xA;     *   &lt;code>namespaceURI&lt;/code> is different from &quot;&lt;a href='http://www.w3.org/2000/xmlns/'>http://www.w3.org/2000/xmlns/&lt;/a>&quot;.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>Document&lt;/code> interface represents the entire HTML or XML &#xA; * document. Conceptually, it is the root of the document tree, and provides &#xA; * the primary access to the document's data.&#xA; * &lt;p>Since elements, text nodes, comments, processing instructions, etc. &#xA; * cannot exist outside the context of a &lt;code>Document&lt;/code>, the &#xA; * &lt;code>Document&lt;/code> interface also contains the factory methods needed &#xA; * to create these objects. The &lt;code>Node&lt;/code> objects created have a &#xA; * &lt;code>ownerDocument&lt;/code> attribute which associates them with the &#xA; * &lt;code>Document&lt;/code> within whose context they were created.&#xA; * &lt;p>See also the &lt;a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>Document Object Model (DOM) Level 3 Core Specification&lt;/a>.&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Node.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
