<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="Attr.java">
  <comments>/*&#xA; * Copyright (c) 2004 World Wide Web Consortium,&#xA; *&#xA; * (Massachusetts Institute of Technology, European Research Consortium for&#xA; * Informatics and Mathematics, Keio University). All Rights Reserved. This&#xA; * work is distributed under the W3C(r) Software License [1] in the hope that&#xA; * it will be useful, but WITHOUT ANY WARRANTY; without even the implied&#xA; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&#xA; *&#xA; * [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231&#xA; */</comments>
  <namespaces>org</namespaces>
  <namespaces>w3c</namespaces>
  <namespaces>dom</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Attr">
    <members xsi:type="members:InterfaceMethod" name="getName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the name of this attribute. If &lt;code>Node.localName&lt;/code> is &#xA;     * different from &lt;code>null&lt;/code>, this attribute is a qualified name.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSpecified">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  &lt;code>True&lt;/code> if this attribute was explicitly given a value in &#xA;     * the instance document, &lt;code>false&lt;/code> otherwise. If the &#xA;     * application changed the value of this attribute node (even if it ends &#xA;     * up having the same value as the default value) then it is set to &#xA;     * &lt;code>true&lt;/code>. The implementation may handle attributes with &#xA;     * default values from other schemas similarly but applications should &#xA;     * use &lt;code>Document.normalizeDocument()&lt;/code> to guarantee this &#xA;     * information is up-to-date. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getValue">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * On retrieval, the value of the attribute is returned as a string. &#xA;     * Character and general entity references are replaced with their &#xA;     * values. See also the method &lt;code>getAttribute&lt;/code> on the &#xA;     * &lt;code>Element&lt;/code> interface.&#xA;     * &lt;br>On setting, this creates a &lt;code>Text&lt;/code> node with the unparsed &#xA;     * contents of the string, i.e. any characters that an XML processor &#xA;     * would recognize as markup are instead treated as literal text. See &#xA;     * also the method &lt;code>Element.setAttribute()&lt;/code>.&#xA;     * &lt;br> Some specialized implementations, such as some [&lt;a href='http://www.w3.org/TR/2003/REC-SVG11-20030114/'>SVG 1.1&lt;/a>] &#xA;     * implementations, may do normalization automatically, even after &#xA;     * mutation; in such case, the value on retrieval may differ from the &#xA;     * value on setting. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setValue">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * On retrieval, the value of the attribute is returned as a string. &#xA;     * Character and general entity references are replaced with their &#xA;     * values. See also the method &lt;code>getAttribute&lt;/code> on the &#xA;     * &lt;code>Element&lt;/code> interface.&#xA;     * &lt;br>On setting, this creates a &lt;code>Text&lt;/code> node with the unparsed &#xA;     * contents of the string, i.e. any characters that an XML processor &#xA;     * would recognize as markup are instead treated as literal text. See &#xA;     * also the method &lt;code>Element.setAttribute()&lt;/code>.&#xA;     * &lt;br> Some specialized implementations, such as some [&lt;a href='http://www.w3.org/TR/2003/REC-SVG11-20030114/'>SVG 1.1&lt;/a>] &#xA;     * implementations, may do normalization automatically, even after &#xA;     * mutation; in such case, the value on retrieval may differ from the &#xA;     * value on setting. &#xA;     * @exception DOMException&#xA;     *   NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getOwnerElement">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Element.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The &lt;code>Element&lt;/code> node this attribute is attached to or &#xA;     * &lt;code>null&lt;/code> if this attribute is not in use.&#xA;     * @since DOM Level 2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSchemaTypeInfo">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="TypeInfo.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  The type information associated with this attribute. While the type &#xA;     * information contained in this attribute is guarantee to be correct &#xA;     * after loading the document or invoking &#xA;     * &lt;code>Document.normalizeDocument()&lt;/code>, &lt;code>schemaTypeInfo&lt;/code>&#xA;     *  may not be reliable if the node was moved. &#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isId">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  Returns whether this attribute is known to be of type ID (i.e. to &#xA;     * contain an identifier for its owner element) or not. When it is and &#xA;     * its value is unique, the &lt;code>ownerElement&lt;/code> of this attribute &#xA;     * can be retrieved using the method &lt;code>Document.getElementById&lt;/code>&#xA;     * . The implementation could use several ways to determine if an &#xA;     * attribute node is known to contain an identifier: &#xA;     * &lt;ul>&#xA;     * &lt;li> If validation &#xA;     * occurred using an XML Schema [&lt;a href='http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/'>XML Schema Part 1&lt;/a>]&#xA;     *  while loading the document or while invoking &#xA;     * &lt;code>Document.normalizeDocument()&lt;/code>, the post-schema-validation &#xA;     * infoset contributions (PSVI contributions) values are used to &#xA;     * determine if this attribute is a schema-determined ID attribute using &#xA;     * the &lt;a href='http://www.w3.org/TR/2003/REC-xptr-framework-20030325/#term-sdi'>&#xA;     * schema-determined ID&lt;/a> definition in [&lt;a href='http://www.w3.org/TR/2003/REC-xptr-framework-20030325/'>XPointer&lt;/a>]&#xA;     * . &#xA;     * &lt;/li>&#xA;     * &lt;li> If validation occurred using a DTD while loading the document or &#xA;     * while invoking &lt;code>Document.normalizeDocument()&lt;/code>, the infoset &lt;b>[type definition]&lt;/b> value is used to determine if this attribute is a DTD-determined ID &#xA;     * attribute using the &lt;a href='http://www.w3.org/TR/2003/REC-xptr-framework-20030325/#term-ddi'>&#xA;     * DTD-determined ID&lt;/a> definition in [&lt;a href='http://www.w3.org/TR/2003/REC-xptr-framework-20030325/'>XPointer&lt;/a>]&#xA;     * . &#xA;     * &lt;/li>&#xA;     * &lt;li> from the use of the methods &lt;code>Element.setIdAttribute()&lt;/code>, &#xA;     * &lt;code>Element.setIdAttributeNS()&lt;/code>, or &#xA;     * &lt;code>Element.setIdAttributeNode()&lt;/code>, i.e. it is an &#xA;     * user-determined ID attribute; &#xA;     * &lt;p >&lt;b>Note:&lt;/b>  XPointer framework (see section 3.2 in [&lt;a href='http://www.w3.org/TR/2003/REC-xptr-framework-20030325/'>XPointer&lt;/a>]&#xA;     * ) consider the DOM user-determined ID attribute as being part of the &#xA;     * XPointer externally-determined ID definition. &#xA;     * &lt;/li>&#xA;     * &lt;li> using mechanisms that &#xA;     * are outside the scope of this specification, it is then an &#xA;     * externally-determined ID attribute. This includes using schema &#xA;     * languages different from XML schema and DTD. &#xA;     * &lt;/li>&#xA;     * &lt;/ul>&#xA;     * &lt;br> If validation occurred while invoking &#xA;     * &lt;code>Document.normalizeDocument()&lt;/code>, all user-determined ID &#xA;     * attributes are reset and all attribute nodes ID information are then &#xA;     * reevaluated in accordance to the schema used. As a consequence, if &#xA;     * the &lt;code>Attr.schemaTypeInfo&lt;/code> attribute contains an ID type, &#xA;     * &lt;code>isId&lt;/code> will always return true. &#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>Attr&lt;/code> interface represents an attribute in an &#xA; * &lt;code>Element&lt;/code> object. Typically the allowable values for the &#xA; * attribute are defined in a schema associated with the document.&#xA; * &lt;p>&lt;code>Attr&lt;/code> objects inherit the &lt;code>Node&lt;/code> interface, but &#xA; * since they are not actually child nodes of the element they describe, the &#xA; * DOM does not consider them part of the document tree. Thus, the &#xA; * &lt;code>Node&lt;/code> attributes &lt;code>parentNode&lt;/code>, &#xA; * &lt;code>previousSibling&lt;/code>, and &lt;code>nextSibling&lt;/code> have a &#xA; * &lt;code>null&lt;/code> value for &lt;code>Attr&lt;/code> objects. The DOM takes the &#xA; * view that attributes are properties of elements rather than having a &#xA; * separate identity from the elements they are associated with; this should &#xA; * make it more efficient to implement such features as default attributes &#xA; * associated with all elements of a given type. Furthermore, &#xA; * &lt;code>Attr&lt;/code> nodes may not be immediate children of a &#xA; * &lt;code>DocumentFragment&lt;/code>. However, they can be associated with &#xA; * &lt;code>Element&lt;/code> nodes contained within a &#xA; * &lt;code>DocumentFragment&lt;/code>. In short, users and implementors of the &#xA; * DOM need to be aware that &lt;code>Attr&lt;/code> nodes have some things in &#xA; * common with other objects inheriting the &lt;code>Node&lt;/code> interface, but &#xA; * they also are quite distinct.&#xA; * &lt;p>The attribute's effective value is determined as follows: if this &#xA; * attribute has been explicitly assigned any value, that value is the &#xA; * attribute's effective value; otherwise, if there is a declaration for &#xA; * this attribute, and that declaration includes a default value, then that &#xA; * default value is the attribute's effective value; otherwise, the &#xA; * attribute does not exist on this element in the structure model until it &#xA; * has been explicitly added. Note that the &lt;code>Node.nodeValue&lt;/code> &#xA; * attribute on the &lt;code>Attr&lt;/code> instance can also be used to retrieve &#xA; * the string version of the attribute's value(s).&#xA; * &lt;p> If the attribute was not explicitly given a value in the instance &#xA; * document but has a default value provided by the schema associated with &#xA; * the document, an attribute node will be created with &#xA; * &lt;code>specified&lt;/code> set to &lt;code>false&lt;/code>. Removing attribute &#xA; * nodes for which a default value is defined in the schema generates a new &#xA; * attribute node with the default value and &lt;code>specified&lt;/code> set to &#xA; * &lt;code>false&lt;/code>. If validation occurred while invoking &#xA; * &lt;code>Document.normalizeDocument()&lt;/code>, attribute nodes with &#xA; * &lt;code>specified&lt;/code> equals to &lt;code>false&lt;/code> are recomputed &#xA; * according to the default attribute values provided by the schema. If no &#xA; * default value is associate with this attribute in the schema, the &#xA; * attribute node is discarded. &#xA; * &lt;p>In XML, where the value of an attribute can contain entity references, &#xA; * the child nodes of the &lt;code>Attr&lt;/code> node may be either &#xA; * &lt;code>Text&lt;/code> or &lt;code>EntityReference&lt;/code> nodes (when these are &#xA; * in use; see the description of &lt;code>EntityReference&lt;/code> for &#xA; * discussion). &#xA; * &lt;p>The DOM Core represents all attribute values as simple strings, even if &#xA; * the DTD or schema associated with the document declares them of some &#xA; * specific type such as tokenized. &#xA; * &lt;p>The way attribute value normalization is performed by the DOM &#xA; * implementation depends on how much the implementation knows about the &#xA; * schema in use. Typically, the &lt;code>value&lt;/code> and &#xA; * &lt;code>nodeValue&lt;/code> attributes of an &lt;code>Attr&lt;/code> node initially &#xA; * returns the normalized value given by the parser. It is also the case &#xA; * after &lt;code>Document.normalizeDocument()&lt;/code> is called (assuming the &#xA; * right options have been set). But this may not be the case after &#xA; * mutation, independently of whether the mutation is performed by setting &#xA; * the string value directly or by changing the &lt;code>Attr&lt;/code> child &#xA; * nodes. In particular, this is true when &lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204#dt-charref'>character &#xA; * references&lt;/a> are involved, given that they are not represented in the DOM and they &#xA; * impact attribute value normalization. On the other hand, if the &#xA; * implementation knows about the schema in use when the attribute value is &#xA; * changed, and it is of a different type than CDATA, it may normalize it &#xA; * again at that time. This is especially true of specialized DOM &#xA; * implementations, such as SVG DOM implementations, which store attribute &#xA; * values in an internal form different from a string.&#xA; * &lt;p>The following table gives some examples of the relations between the &#xA; * attribute value in the original document (parsed attribute), the value as &#xA; * exposed in the DOM, and the serialization of the value: &#xA; * &lt;table border='1' cellpadding='3'>&#xA; * &lt;tr>&#xA; * &lt;th>Examples&lt;/th>&#xA; * &lt;th>Parsed &#xA; * attribute value&lt;/th>&#xA; * &lt;th>Initial &lt;code>Attr.value&lt;/code>&lt;/th>&#xA; * &lt;th>Serialized attribute value&lt;/th>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * Character reference&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;pre>&quot;x&amp;amp;#178;=5&quot;&lt;/pre>&#xA; * &lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;pre>&quot;x\u00b2=5&quot;&lt;/pre>&#xA; * &lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;pre>&quot;x&amp;amp;#178;=5&quot;&lt;/pre>&#xA; * &lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>Built-in &#xA; * character entity&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;pre>&quot;y&amp;amp;lt;6&quot;&lt;/pre>&#xA; * &lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;pre>&quot;y&amp;lt;6&quot;&lt;/pre>&#xA; * &lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;pre>&quot;y&amp;amp;lt;6&quot;&lt;/pre>&#xA; * &lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>Literal newline between&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;pre>&#xA; * &quot;x=5&amp;amp;#10;y=6&quot;&lt;/pre>&#xA; * &lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;pre>&quot;x=5 y=6&quot;&lt;/pre>&#xA; * &lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;pre>&quot;x=5&amp;amp;#10;y=6&quot;&lt;/pre>&#xA; * &lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>Normalized newline between&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;pre>&quot;x=5 &#xA; * y=6&quot;&lt;/pre>&#xA; * &lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;pre>&quot;x=5 y=6&quot;&lt;/pre>&#xA; * &lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;pre>&quot;x=5 y=6&quot;&lt;/pre>&#xA; * &lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>Entity &lt;code>e&lt;/code> with literal newline&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;pre>&#xA; * &amp;lt;!ENTITY e '...&amp;amp;#10;...'&amp;gt; [...]&amp;gt; &quot;x=5&amp;amp;e;y=6&quot;&lt;/pre>&#xA; * &lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;em>Dependent on Implementation and Load Options&lt;/em>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;em>Dependent on Implementation and Load/Save Options&lt;/em>&lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;/table>&#xA; * &lt;p>See also the &lt;a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>Document Object Model (DOM) Level 3 Core Specification&lt;/a>.&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Node.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
