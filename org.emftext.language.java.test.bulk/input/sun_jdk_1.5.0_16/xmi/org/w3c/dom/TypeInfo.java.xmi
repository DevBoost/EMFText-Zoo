<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="TypeInfo.java">
  <comments>/*&#xA; * Copyright (c) 2004 World Wide Web Consortium,&#xA; *&#xA; * (Massachusetts Institute of Technology, European Research Consortium for&#xA; * Informatics and Mathematics, Keio University). All Rights Reserved. This&#xA; * work is distributed under the W3C(r) Software License [1] in the hope that&#xA; * it will be useful, but WITHOUT ANY WARRANTY; without even the implied&#xA; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&#xA; *&#xA; * [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231&#xA; */</comments>
  <namespaces>org</namespaces>
  <namespaces>w3c</namespaces>
  <namespaces>dom</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="TypeInfo">
    <members xsi:type="members:InterfaceMethod" name="getTypeName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  The name of a type declared for the associated element or attribute, &#xA;     * or &lt;code>null&lt;/code> if unknown. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTypeNamespace">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  The namespace of the type declared for the associated element or &#xA;     * attribute or &lt;code>null&lt;/code> if the element does not have &#xA;     * declaration or if no namespace information is available. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="DERIVATION_RESTRICTION">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// DerivationMethods</comments>
        <comments>/**&#xA;     *  If the document's schema is an XML Schema [&lt;a href='http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/'>XML Schema Part 1&lt;/a>]&#xA;     * , this constant represents the derivation by &lt;a href='http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeRestriction'>&#xA;     * restriction&lt;/a> if complex types are involved, or a &lt;a href='http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-restriction'>&#xA;     * restriction&lt;/a> if simple types are involved. &#xA;     * &lt;br>  The reference type definition is derived by restriction from the &#xA;     * other type definition if the other type definition is the same as the &#xA;     * reference type definition, or if the other type definition can be &#xA;     * reached recursively following the {base type definition} property &#xA;     * from the reference type definition, and all the &lt;em>derivation methods&lt;/em> involved are restriction. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DERIVATION_EXTENSION">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  If the document's schema is an XML Schema [&lt;a href='http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/'>XML Schema Part 1&lt;/a>]&#xA;     * , this constant represents the derivation by &lt;a href='http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeExtension'>&#xA;     * extension&lt;/a>. &#xA;     * &lt;br>  The reference type definition is derived by extension from the &#xA;     * other type definition if the other type definition can be reached &#xA;     * recursively following the {base type definition} property from the &#xA;     * reference type definition, and at least one of the &lt;em>derivation methods&lt;/em> involved is an extension. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DERIVATION_UNION">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="4"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  If the document's schema is an XML Schema [&lt;a href='http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/'>XML Schema Part 1&lt;/a>]&#xA;     * , this constant represents the &lt;a href='http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-union'>&#xA;     * union&lt;/a> if simple types are involved. &#xA;     * &lt;br> The reference type definition is derived by union from the other &#xA;     * type definition if there exists two type definitions T1 and T2 such &#xA;     * as the reference type definition is derived from T1 by &#xA;     * &lt;code>DERIVATION_RESTRICTION&lt;/code> or &#xA;     * &lt;code>DERIVATION_EXTENSION&lt;/code>, T2 is derived from the other type &#xA;     * definition by &lt;code>DERIVATION_RESTRICTION&lt;/code>, T1 has {variety} &lt;em>union&lt;/em>, and one of the {member type definitions} is T2. Note that T1 could be &#xA;     * the same as the reference type definition, and T2 could be the same &#xA;     * as the other type definition. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DERIVATION_LIST">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="8"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  If the document's schema is an XML Schema [&lt;a href='http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/'>XML Schema Part 1&lt;/a>]&#xA;     * , this constant represents the &lt;a href='http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-list'>list&lt;/a>. &#xA;     * &lt;br> The reference type definition is derived by list from the other &#xA;     * type definition if there exists two type definitions T1 and T2 such &#xA;     * as the reference type definition is derived from T1 by &#xA;     * &lt;code>DERIVATION_RESTRICTION&lt;/code> or &#xA;     * &lt;code>DERIVATION_EXTENSION&lt;/code>, T2 is derived from the other type &#xA;     * definition by &lt;code>DERIVATION_RESTRICTION&lt;/code>, T1 has {variety} &lt;em>list&lt;/em>, and T2 is the {item type definition}. Note that T1 could be the same as &#xA;     * the reference type definition, and T2 could be the same as the other &#xA;     * type definition. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isDerivedFrom">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="typeNamespaceArg">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="typeNameArg">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="derivationMethod">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  This method returns if there is a derivation between the reference &#xA;     * type definition, i.e. the &lt;code>TypeInfo&lt;/code> on which the method &#xA;     * is being called, and the other type definition, i.e. the one passed &#xA;     * as parameters. &#xA;     * @param typeNamespaceArg  the namespace of the other type definition. &#xA;     * @param typeNameArg  the name of the other type definition. &#xA;     * @param derivationMethod  the type of derivation and conditions applied &#xA;     *   between two types, as described in the list of constants provided &#xA;     *   in this interface. &#xA;     * @return  If the document's schema is a DTD or no schema is associated &#xA;     *   with the document, this method will always return &lt;code>false&lt;/code>&#xA;     *   .  If the document's schema is an XML Schema, the method will &#xA;     *   &lt;code>true&lt;/code> if the reference type definition is derived from &#xA;     *   the other type definition according to the derivation parameter. If &#xA;     *   the value of the parameter is &lt;code>0&lt;/code> (no bit is set to &#xA;     *   &lt;code>1&lt;/code> for the &lt;code>derivationMethod&lt;/code> parameter), &#xA;     *   the method will return &lt;code>true&lt;/code> if the other type &#xA;     *   definition can be reached by recursing any combination of {base &#xA;     *   type definition}, {item type definition}, or {member type &#xA;     *   definitions} from the reference type definition. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; *  The &lt;code>TypeInfo&lt;/code> interface represents a type referenced from &#xA; * &lt;code>Element&lt;/code> or &lt;code>Attr&lt;/code> nodes, specified in the schemas &#xA; * associated with the document. The type is a pair of a namespace URI and &#xA; * name properties, and depends on the document's schema. &#xA; * &lt;p> If the document's schema is an XML DTD [&lt;a href='http://www.w3.org/TR/2004/REC-xml-20040204'>XML 1.0&lt;/a>], the values &#xA; * are computed as follows: &#xA; * &lt;ul>&#xA; * &lt;li> If this type is referenced from an &#xA; * &lt;code>Attr&lt;/code> node, &lt;code>typeNamespace&lt;/code> is &#xA; * &lt;code>&quot;http://www.w3.org/TR/REC-xml&quot;&lt;/code> and &lt;code>typeName&lt;/code> &#xA; * represents the &lt;b>[attribute type]&lt;/b> property in the [&lt;a href='http://www.w3.org/TR/2004/REC-xml-infoset-20040204/'>XML Information Set&lt;/a>]&#xA; * . If there is no declaration for the attribute, &lt;code>typeNamespace&lt;/code>&#xA; *  and &lt;code>typeName&lt;/code> are &lt;code>null&lt;/code>. &#xA; * &lt;/li>&#xA; * &lt;li> If this type is &#xA; * referenced from an &lt;code>Element&lt;/code> node, &lt;code>typeNamespace&lt;/code> &#xA; * and &lt;code>typeName&lt;/code> are &lt;code>null&lt;/code>. &#xA; * &lt;/li>&#xA; * &lt;/ul>&#xA; * &lt;p> If the document's schema is an XML Schema [&lt;a href='http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/'>XML Schema Part 1&lt;/a>]&#xA; * , the values are computed as follows using the post-schema-validation &#xA; * infoset contributions (also called PSVI contributions): &#xA; * &lt;ul>&#xA; * &lt;li> If the &lt;b>[validity]&lt;/b> property exists AND is &lt;em>&quot;invalid&quot;&lt;/em> or &lt;em>&quot;notKnown&quot;&lt;/em>: the {target namespace} and {name} properties of the declared type if &#xA; * available, otherwise &lt;code>null&lt;/code>. &#xA; * &lt;p >&lt;b>Note:&lt;/b>  At the time of writing, the XML Schema specification does &#xA; * not require exposing the declared type. Thus, DOM implementations might &#xA; * choose not to provide type information if validity is not valid. &#xA; * &lt;/li>&#xA; * &lt;li> If the &lt;b>[validity]&lt;/b> property exists and is &lt;em>&quot;valid&quot;&lt;/em>: &#xA; * &lt;ol>&#xA; * &lt;li> If &lt;b>[member type definition]&lt;/b> exists: &#xA; * &lt;ol>&#xA; * &lt;li>If {name} is not absent, then expose {name} and {target &#xA; * namespace} properties of the &lt;b>[member type definition]&lt;/b> property;&#xA; * &lt;/li>&#xA; * &lt;li>Otherwise, expose the namespace and local name of the &#xA; * corresponding anonymous type name.&#xA; * &lt;/li>&#xA; * &lt;/ol>&#xA; * &lt;/li>&#xA; * &lt;li> If the &lt;b>[type definition]&lt;/b> property exists: &#xA; * &lt;ol>&#xA; * &lt;li>If {name} is not absent, then expose {name} and {target &#xA; * namespace} properties of the &lt;b>[type definition]&lt;/b> property;&#xA; * &lt;/li>&#xA; * &lt;li>Otherwise, expose the namespace and local name of the &#xA; * corresponding anonymous type name.&#xA; * &lt;/li>&#xA; * &lt;/ol> &#xA; * &lt;/li>&#xA; * &lt;li> If the &lt;b>[member type definition anonymous]&lt;/b> exists: &#xA; * &lt;ol>&#xA; * &lt;li>If it is false, then expose &lt;b>[member type definition name]&lt;/b> and &lt;b>[member type definition namespace]&lt;/b> properties;&#xA; * &lt;/li>&#xA; * &lt;li>Otherwise, expose the namespace and local name of the &#xA; * corresponding anonymous type name.&#xA; * &lt;/li>&#xA; * &lt;/ol> &#xA; * &lt;/li>&#xA; * &lt;li> If the &lt;b>[type definition anonymous]&lt;/b> exists: &#xA; * &lt;ol>&#xA; * &lt;li>If it is false, then expose &lt;b>[type definition name]&lt;/b> and &lt;b>[type definition namespace]&lt;/b> properties;&#xA; * &lt;/li>&#xA; * &lt;li>Otherwise, expose the namespace and local name of the &#xA; * corresponding anonymous type name.&#xA; * &lt;/li>&#xA; * &lt;/ol> &#xA; * &lt;/li>&#xA; * &lt;/ol>&#xA; * &lt;/li>&#xA; * &lt;/ul>&#xA; * &lt;p >&lt;b>Note:&lt;/b>  Other schema languages are outside the scope of the W3C &#xA; * and therefore should define how to represent their type systems using &#xA; * &lt;code>TypeInfo&lt;/code>. &#xA; * &lt;p>See also the &lt;a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>Document Object Model (DOM) Level 3 Core Specification&lt;/a>.&#xA; * @since DOM Level 3&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
