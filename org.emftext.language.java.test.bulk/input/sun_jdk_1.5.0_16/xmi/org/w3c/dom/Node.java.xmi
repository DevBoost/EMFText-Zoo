<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="Node.java">
  <comments>/*&#xA; * Copyright (c) 2004 World Wide Web Consortium,&#xA; *&#xA; * (Massachusetts Institute of Technology, European Research Consortium for&#xA; * Informatics and Mathematics, Keio University). All Rights Reserved. This&#xA; * work is distributed under the W3C(r) Software License [1] in the hope that&#xA; * it will be useful, but WITHOUT ANY WARRANTY; without even the implied&#xA; * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&#xA; *&#xA; * [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231&#xA; */</comments>
  <namespaces>org</namespaces>
  <namespaces>w3c</namespaces>
  <namespaces>dom</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Node">
    <members xsi:type="members:Field" name="ELEMENT_NODE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// NodeType</comments>
        <comments>/**&#xA;     * The node is an &lt;code>Element&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ATTRIBUTE_NODE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node is an &lt;code>Attr&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="TEXT_NODE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node is a &lt;code>Text&lt;/code> node.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="CDATA_SECTION_NODE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node is a &lt;code>CDATASection&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ENTITY_REFERENCE_NODE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node is an &lt;code>EntityReference&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ENTITY_NODE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node is an &lt;code>Entity&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="PROCESSING_INSTRUCTION_NODE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node is a &lt;code>ProcessingInstruction&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="COMMENT_NODE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node is a &lt;code>Comment&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DOCUMENT_NODE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node is a &lt;code>Document&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DOCUMENT_TYPE_NODE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node is a &lt;code>DocumentType&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DOCUMENT_FRAGMENT_NODE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node is a &lt;code>DocumentFragment&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="NOTATION_NODE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node is a &lt;code>Notation&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNodeName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The name of this node, depending on its type; see the table above.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNodeValue">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The value of this node, depending on its type; see the table above. &#xA;     * When it is defined to be &lt;code>null&lt;/code>, setting it has no effect, &#xA;     * including if the node is read-only.&#xA;     * @exception DOMException&#xA;     *   DOMSTRING_SIZE_ERR: Raised when it would return more characters than &#xA;     *   fit in a &lt;code>DOMString&lt;/code> variable on the implementation &#xA;     *   platform.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setNodeValue">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeValue">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The value of this node, depending on its type; see the table above. &#xA;     * When it is defined to be &lt;code>null&lt;/code>, setting it has no effect, &#xA;     * including if the node is read-only.&#xA;     * @exception DOMException&#xA;     *   NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly and if &#xA;     *   it is not defined to be &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNodeType">
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A code representing the type of the underlying object, as defined above.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getParentNode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The parent of this node. All nodes, except &lt;code>Attr&lt;/code>, &#xA;     * &lt;code>Document&lt;/code>, &lt;code>DocumentFragment&lt;/code>, &#xA;     * &lt;code>Entity&lt;/code>, and &lt;code>Notation&lt;/code> may have a parent. &#xA;     * However, if a node has just been created and not yet added to the &#xA;     * tree, or if it has been removed from the tree, this is &#xA;     * &lt;code>null&lt;/code>. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getChildNodes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="NodeList.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A &lt;code>NodeList&lt;/code> that contains all children of this node. If &#xA;     * there are no children, this is a &lt;code>NodeList&lt;/code> containing no &#xA;     * nodes.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFirstChild">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The first child of this node. If there is no such node, this returns &#xA;     * &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLastChild">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The last child of this node. If there is no such node, this returns &#xA;     * &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPreviousSibling">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node immediately preceding this node. If there is no such node, &#xA;     * this returns &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNextSibling">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node immediately following this node. If there is no such node, &#xA;     * this returns &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAttributes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="NamedNodeMap.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A &lt;code>NamedNodeMap&lt;/code> containing the attributes of this node (if &#xA;     * it is an &lt;code>Element&lt;/code>) or &lt;code>null&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getOwnerDocument">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Document.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The &lt;code>Document&lt;/code> object associated with this node. This is &#xA;     * also the &lt;code>Document&lt;/code> object used to create new nodes. When &#xA;     * this node is a &lt;code>Document&lt;/code> or a &lt;code>DocumentType&lt;/code> &#xA;     * which is not used with any &lt;code>Document&lt;/code> yet, this is &#xA;     * &lt;code>null&lt;/code>.&#xA;     * @version DOM Level 2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insertBefore">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newChild">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="refChild">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts the node &lt;code>newChild&lt;/code> before the existing child node &#xA;     * &lt;code>refChild&lt;/code>. If &lt;code>refChild&lt;/code> is &lt;code>null&lt;/code>, &#xA;     * insert &lt;code>newChild&lt;/code> at the end of the list of children.&#xA;     * &lt;br>If &lt;code>newChild&lt;/code> is a &lt;code>DocumentFragment&lt;/code> object, &#xA;     * all of its children are inserted, in the same order, before &#xA;     * &lt;code>refChild&lt;/code>. If the &lt;code>newChild&lt;/code> is already in the &#xA;     * tree, it is first removed.&#xA;     * &lt;p >&lt;b>Note:&lt;/b>  Inserting a node before itself is implementation &#xA;     * dependent. &#xA;     * @param newChild The node to insert.&#xA;     * @param refChild The reference node, i.e., the node before which the &#xA;     *   new node must be inserted.&#xA;     * @return The node being inserted.&#xA;     * @exception DOMException&#xA;     *   HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not &#xA;     *   allow children of the type of the &lt;code>newChild&lt;/code> node, or if &#xA;     *   the node to insert is one of this node's ancestors or this node &#xA;     *   itself, or if this node is of type &lt;code>Document&lt;/code> and the &#xA;     *   DOM application attempts to insert a second &#xA;     *   &lt;code>DocumentType&lt;/code> or &lt;code>Element&lt;/code> node.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised if &lt;code>newChild&lt;/code> was created &#xA;     *   from a different document than the one that created this node.&#xA;     *   &lt;br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or &#xA;     *   if the parent of the node being inserted is readonly.&#xA;     *   &lt;br>NOT_FOUND_ERR: Raised if &lt;code>refChild&lt;/code> is not a child of &#xA;     *   this node.&#xA;     *   &lt;br>NOT_SUPPORTED_ERR: if this node is of type &lt;code>Document&lt;/code>, &#xA;     *   this exception might be raised if the DOM implementation doesn't &#xA;     *   support the insertion of a &lt;code>DocumentType&lt;/code> or &#xA;     *   &lt;code>Element&lt;/code> node.&#xA;     * @version DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="replaceChild">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newChild">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="oldChild">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Replaces the child node &lt;code>oldChild&lt;/code> with &lt;code>newChild&lt;/code>&#xA;     *  in the list of children, and returns the &lt;code>oldChild&lt;/code> node.&#xA;     * &lt;br>If &lt;code>newChild&lt;/code> is a &lt;code>DocumentFragment&lt;/code> object, &#xA;     * &lt;code>oldChild&lt;/code> is replaced by all of the &#xA;     * &lt;code>DocumentFragment&lt;/code> children, which are inserted in the &#xA;     * same order. If the &lt;code>newChild&lt;/code> is already in the tree, it &#xA;     * is first removed.&#xA;     * &lt;p >&lt;b>Note:&lt;/b>  Replacing a node with itself is implementation &#xA;     * dependent. &#xA;     * @param newChild The new node to put in the child list.&#xA;     * @param oldChild The node being replaced in the list.&#xA;     * @return The node replaced.&#xA;     * @exception DOMException&#xA;     *   HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not &#xA;     *   allow children of the type of the &lt;code>newChild&lt;/code> node, or if &#xA;     *   the node to put in is one of this node's ancestors or this node &#xA;     *   itself, or if this node is of type &lt;code>Document&lt;/code> and the &#xA;     *   result of the replacement operation would add a second &#xA;     *   &lt;code>DocumentType&lt;/code> or &lt;code>Element&lt;/code> on the &#xA;     *   &lt;code>Document&lt;/code> node.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised if &lt;code>newChild&lt;/code> was created &#xA;     *   from a different document than the one that created this node.&#xA;     *   &lt;br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the parent of &#xA;     *   the new node is readonly.&#xA;     *   &lt;br>NOT_FOUND_ERR: Raised if &lt;code>oldChild&lt;/code> is not a child of &#xA;     *   this node.&#xA;     *   &lt;br>NOT_SUPPORTED_ERR: if this node is of type &lt;code>Document&lt;/code>, &#xA;     *   this exception might be raised if the DOM implementation doesn't &#xA;     *   support the replacement of the &lt;code>DocumentType&lt;/code> child or &#xA;     *   &lt;code>Element&lt;/code> child.&#xA;     * @version DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removeChild">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="oldChild">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes the child node indicated by &lt;code>oldChild&lt;/code> from the list &#xA;     * of children, and returns it.&#xA;     * @param oldChild The node being removed.&#xA;     * @return The node removed.&#xA;     * @exception DOMException&#xA;     *   NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.&#xA;     *   &lt;br>NOT_FOUND_ERR: Raised if &lt;code>oldChild&lt;/code> is not a child of &#xA;     *   this node.&#xA;     *   &lt;br>NOT_SUPPORTED_ERR: if this node is of type &lt;code>Document&lt;/code>, &#xA;     *   this exception might be raised if the DOM implementation doesn't &#xA;     *   support the removal of the &lt;code>DocumentType&lt;/code> child or the &#xA;     *   &lt;code>Element&lt;/code> child.&#xA;     * @version DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="appendChild">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newChild">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds the node &lt;code>newChild&lt;/code> to the end of the list of children &#xA;     * of this node. If the &lt;code>newChild&lt;/code> is already in the tree, it &#xA;     * is first removed.&#xA;     * @param newChild The node to add.If it is a &#xA;     *   &lt;code>DocumentFragment&lt;/code> object, the entire contents of the &#xA;     *   document fragment are moved into the child list of this node&#xA;     * @return The node added.&#xA;     * @exception DOMException&#xA;     *   HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not &#xA;     *   allow children of the type of the &lt;code>newChild&lt;/code> node, or if &#xA;     *   the node to append is one of this node's ancestors or this node &#xA;     *   itself, or if this node is of type &lt;code>Document&lt;/code> and the &#xA;     *   DOM application attempts to append a second &#xA;     *   &lt;code>DocumentType&lt;/code> or &lt;code>Element&lt;/code> node.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised if &lt;code>newChild&lt;/code> was created &#xA;     *   from a different document than the one that created this node.&#xA;     *   &lt;br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or &#xA;     *   if the previous parent of the node being inserted is readonly.&#xA;     *   &lt;br>NOT_SUPPORTED_ERR: if the &lt;code>newChild&lt;/code> node is a child &#xA;     *   of the &lt;code>Document&lt;/code> node, this exception might be raised &#xA;     *   if the DOM implementation doesn't support the removal of the &#xA;     *   &lt;code>DocumentType&lt;/code> child or &lt;code>Element&lt;/code> child.&#xA;     * @version DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="hasChildNodes">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns whether this node has any children.&#xA;     * @return Returns &lt;code>true&lt;/code> if this node has any children, &#xA;     *   &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="cloneNode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="deep">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a duplicate of this node, i.e., serves as a generic copy &#xA;     * constructor for nodes. The duplicate node has no parent (&#xA;     * &lt;code>parentNode&lt;/code> is &lt;code>null&lt;/code>) and no user data. User &#xA;     * data associated to the imported node is not carried over. However, if &#xA;     * any &lt;code>UserDataHandlers&lt;/code> has been specified along with the &#xA;     * associated data these handlers will be called with the appropriate &#xA;     * parameters before this method returns.&#xA;     * &lt;br>Cloning an &lt;code>Element&lt;/code> copies all attributes and their &#xA;     * values, including those generated by the XML processor to represent &#xA;     * defaulted attributes, but this method does not copy any children it &#xA;     * contains unless it is a deep clone. This includes text contained in &#xA;     * an the &lt;code>Element&lt;/code> since the text is contained in a child &#xA;     * &lt;code>Text&lt;/code> node. Cloning an &lt;code>Attr&lt;/code> directly, as &#xA;     * opposed to be cloned as part of an &lt;code>Element&lt;/code> cloning &#xA;     * operation, returns a specified attribute (&lt;code>specified&lt;/code> is &#xA;     * &lt;code>true&lt;/code>). Cloning an &lt;code>Attr&lt;/code> always clones its &#xA;     * children, since they represent its value, no matter whether this is a &#xA;     * deep clone or not. Cloning an &lt;code>EntityReference&lt;/code> &#xA;     * automatically constructs its subtree if a corresponding &#xA;     * &lt;code>Entity&lt;/code> is available, no matter whether this is a deep &#xA;     * clone or not. Cloning any other type of node simply returns a copy of &#xA;     * this node.&#xA;     * &lt;br>Note that cloning an immutable subtree results in a mutable copy, &#xA;     * but the children of an &lt;code>EntityReference&lt;/code> clone are readonly&#xA;     * . In addition, clones of unspecified &lt;code>Attr&lt;/code> nodes are &#xA;     * specified. And, cloning &lt;code>Document&lt;/code>, &#xA;     * &lt;code>DocumentType&lt;/code>, &lt;code>Entity&lt;/code>, and &#xA;     * &lt;code>Notation&lt;/code> nodes is implementation dependent.&#xA;     * @param deep If &lt;code>true&lt;/code>, recursively clone the subtree under &#xA;     *   the specified node; if &lt;code>false&lt;/code>, clone only the node &#xA;     *   itself (and its attributes, if it is an &lt;code>Element&lt;/code>).&#xA;     * @return The duplicate node.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="normalize">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  Puts all &lt;code>Text&lt;/code> nodes in the full depth of the sub-tree &#xA;     * underneath this &lt;code>Node&lt;/code>, including attribute nodes, into a &#xA;     * &quot;normal&quot; form where only structure (e.g., elements, comments, &#xA;     * processing instructions, CDATA sections, and entity references) &#xA;     * separates &lt;code>Text&lt;/code> nodes, i.e., there are neither adjacent &#xA;     * &lt;code>Text&lt;/code> nodes nor empty &lt;code>Text&lt;/code> nodes. This can &#xA;     * be used to ensure that the DOM view of a document is the same as if &#xA;     * it were saved and re-loaded, and is useful when operations (such as &#xA;     * XPointer [&lt;a href='http://www.w3.org/TR/2003/REC-xptr-framework-20030325/'>XPointer&lt;/a>]&#xA;     *  lookups) that depend on a particular document tree structure are to &#xA;     * be used. If the parameter &quot;normalize-characters&quot; of the &#xA;     * &lt;code>DOMConfiguration&lt;/code> object attached to the &#xA;     * &lt;code>Node.ownerDocument&lt;/code> is &lt;code>true&lt;/code>, this method &#xA;     * will also fully normalize the characters of the &lt;code>Text&lt;/code> &#xA;     * nodes. &#xA;     * &lt;p >&lt;b>Note:&lt;/b> In cases where the document contains &#xA;     * &lt;code>CDATASections&lt;/code>, the normalize operation alone may not be &#xA;     * sufficient, since XPointers do not differentiate between &#xA;     * &lt;code>Text&lt;/code> nodes and &lt;code>CDATASection&lt;/code> nodes.&#xA;     * @version DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isSupported">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="feature">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="version">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  Tests whether the DOM implementation implements a specific feature and &#xA;     * that feature is supported by this node, as specified in . &#xA;     * @param feature  The name of the feature to test. &#xA;     * @param version  This is the version number of the feature to test. &#xA;     * @return Returns &lt;code>true&lt;/code> if the specified feature is &#xA;     *   supported on this node, &lt;code>false&lt;/code> otherwise.&#xA;     * @since DOM Level 2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNamespaceURI">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The namespace URI of this node, or &lt;code>null&lt;/code> if it is &#xA;     * unspecified (see ).&#xA;     * &lt;br>This is not a computed value that is the result of a namespace &#xA;     * lookup based on an examination of the namespace declarations in &#xA;     * scope. It is merely the namespace URI given at creation time.&#xA;     * &lt;br>For nodes of any type other than &lt;code>ELEMENT_NODE&lt;/code> and &#xA;     * &lt;code>ATTRIBUTE_NODE&lt;/code> and nodes created with a DOM Level 1 &#xA;     * method, such as &lt;code>Document.createElement()&lt;/code>, this is always &#xA;     * &lt;code>null&lt;/code>.&#xA;     * &lt;p >&lt;b>Note:&lt;/b> Per the &lt;em>Namespaces in XML&lt;/em> Specification [&lt;a href='http://www.w3.org/TR/1999/REC-xml-names-19990114/'>XML Namespaces&lt;/a>]&#xA;     *  an attribute does not inherit its namespace from the element it is &#xA;     * attached to. If an attribute is not explicitly given a namespace, it &#xA;     * simply has no namespace.&#xA;     * @since DOM Level 2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPrefix">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The namespace prefix of this node, or &lt;code>null&lt;/code> if it is &#xA;     * unspecified. When it is defined to be &lt;code>null&lt;/code>, setting it &#xA;     * has no effect, including if the node is read-only.&#xA;     * &lt;br>Note that setting this attribute, when permitted, changes the &#xA;     * &lt;code>nodeName&lt;/code> attribute, which holds the qualified name, as &#xA;     * well as the &lt;code>tagName&lt;/code> and &lt;code>name&lt;/code> attributes of &#xA;     * the &lt;code>Element&lt;/code> and &lt;code>Attr&lt;/code> interfaces, when &#xA;     * applicable.&#xA;     * &lt;br>Setting the prefix to &lt;code>null&lt;/code> makes it unspecified, &#xA;     * setting it to an empty string is implementation dependent.&#xA;     * &lt;br>Note also that changing the prefix of an attribute that is known to &#xA;     * have a default value, does not make a new attribute with the default &#xA;     * value and the original prefix appear, since the &#xA;     * &lt;code>namespaceURI&lt;/code> and &lt;code>localName&lt;/code> do not change.&#xA;     * &lt;br>For nodes of any type other than &lt;code>ELEMENT_NODE&lt;/code> and &#xA;     * &lt;code>ATTRIBUTE_NODE&lt;/code> and nodes created with a DOM Level 1 &#xA;     * method, such as &lt;code>createElement&lt;/code> from the &#xA;     * &lt;code>Document&lt;/code> interface, this is always &lt;code>null&lt;/code>.&#xA;     * @since DOM Level 2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setPrefix">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The namespace prefix of this node, or &lt;code>null&lt;/code> if it is &#xA;     * unspecified. When it is defined to be &lt;code>null&lt;/code>, setting it &#xA;     * has no effect, including if the node is read-only.&#xA;     * &lt;br>Note that setting this attribute, when permitted, changes the &#xA;     * &lt;code>nodeName&lt;/code> attribute, which holds the qualified name, as &#xA;     * well as the &lt;code>tagName&lt;/code> and &lt;code>name&lt;/code> attributes of &#xA;     * the &lt;code>Element&lt;/code> and &lt;code>Attr&lt;/code> interfaces, when &#xA;     * applicable.&#xA;     * &lt;br>Setting the prefix to &lt;code>null&lt;/code> makes it unspecified, &#xA;     * setting it to an empty string is implementation dependent.&#xA;     * &lt;br>Note also that changing the prefix of an attribute that is known to &#xA;     * have a default value, does not make a new attribute with the default &#xA;     * value and the original prefix appear, since the &#xA;     * &lt;code>namespaceURI&lt;/code> and &lt;code>localName&lt;/code> do not change.&#xA;     * &lt;br>For nodes of any type other than &lt;code>ELEMENT_NODE&lt;/code> and &#xA;     * &lt;code>ATTRIBUTE_NODE&lt;/code> and nodes created with a DOM Level 1 &#xA;     * method, such as &lt;code>createElement&lt;/code> from the &#xA;     * &lt;code>Document&lt;/code> interface, this is always &lt;code>null&lt;/code>.&#xA;     * @exception DOMException&#xA;     *   INVALID_CHARACTER_ERR: Raised if the specified prefix contains an &#xA;     *   illegal character according to the XML version in use specified in &#xA;     *   the &lt;code>Document.xmlVersion&lt;/code> attribute.&#xA;     *   &lt;br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.&#xA;     *   &lt;br>NAMESPACE_ERR: Raised if the specified &lt;code>prefix&lt;/code> is &#xA;     *   malformed per the Namespaces in XML specification, if the &#xA;     *   &lt;code>namespaceURI&lt;/code> of this node is &lt;code>null&lt;/code>, if the &#xA;     *   specified prefix is &quot;xml&quot; and the &lt;code>namespaceURI&lt;/code> of this &#xA;     *   node is different from &quot;&lt;a href='http://www.w3.org/XML/1998/namespace'>&#xA;     *   http://www.w3.org/XML/1998/namespace&lt;/a>&quot;, if this node is an attribute and the specified prefix is &quot;xmlns&quot; and &#xA;     *   the &lt;code>namespaceURI&lt;/code> of this node is different from &quot;&lt;a href='http://www.w3.org/2000/xmlns/'>http://www.w3.org/2000/xmlns/&lt;/a>&quot;, or if this node is an attribute and the &lt;code>qualifiedName&lt;/code> of &#xA;     *   this node is &quot;xmlns&quot; [&lt;a href='http://www.w3.org/TR/1999/REC-xml-names-19990114/'>XML Namespaces&lt;/a>]&#xA;     *   .&#xA;     * @since DOM Level 2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLocalName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the local part of the qualified name of this node.&#xA;     * &lt;br>For nodes of any type other than &lt;code>ELEMENT_NODE&lt;/code> and &#xA;     * &lt;code>ATTRIBUTE_NODE&lt;/code> and nodes created with a DOM Level 1 &#xA;     * method, such as &lt;code>Document.createElement()&lt;/code>, this is always &#xA;     * &lt;code>null&lt;/code>.&#xA;     * @since DOM Level 2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="hasAttributes">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns whether this node (if it is an element) has any attributes.&#xA;     * @return Returns &lt;code>true&lt;/code> if this node has any attributes, &#xA;     *   &lt;code>false&lt;/code> otherwise.&#xA;     * @since DOM Level 2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBaseURI">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The absolute base URI of this node or &lt;code>null&lt;/code> if the &#xA;     * implementation wasn't able to obtain an absolute URI. This value is &#xA;     * computed as described in . However, when the &lt;code>Document&lt;/code> &#xA;     * supports the feature &quot;HTML&quot; [&lt;a href='http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109'>DOM Level 2 HTML&lt;/a>]&#xA;     * , the base URI is computed using first the value of the href &#xA;     * attribute of the HTML BASE element if any, and the value of the &#xA;     * &lt;code>documentURI&lt;/code> attribute from the &lt;code>Document&lt;/code> &#xA;     * interface otherwise.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="DOCUMENT_POSITION_DISCONNECTED">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="1"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// DocumentPosition</comments>
        <comments>/**&#xA;     * The two nodes are disconnected. Order between disconnected nodes is &#xA;     * always implementation-specific.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DOCUMENT_POSITION_PRECEDING">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="2"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The second node precedes the reference node.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DOCUMENT_POSITION_FOLLOWING">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="4"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node follows the reference node.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DOCUMENT_POSITION_CONTAINS">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="8"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node contains the reference node. A node which contains is always &#xA;     * preceding, too.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DOCUMENT_POSITION_CONTAINED_BY">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="16"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The node is contained by the reference node. A node which is contained &#xA;     * is always following, too.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="32"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The determination of preceding versus following is &#xA;     * implementation-specific.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="compareDocumentPosition">
      <typeReference xsi:type="types:Short"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="other">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares the reference node, i.e. the node on which this method is &#xA;     * being called, with a node, i.e. the one passed as a parameter, with &#xA;     * regard to their position in the document and according to the &#xA;     * document order.&#xA;     * @param other The node to compare against the reference node.&#xA;     * @return Returns how the node is positioned relatively to the reference &#xA;     *   node.&#xA;     * @exception DOMException&#xA;     *   NOT_SUPPORTED_ERR: when the compared nodes are from different DOM &#xA;     *   implementations that do not coordinate to return consistent &#xA;     *   implementation-specific results.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTextContent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * This attribute returns the text content of this node and its &#xA;     * descendants. When it is defined to be &lt;code>null&lt;/code>, setting it &#xA;     * has no effect. On setting, any possible children this node may have &#xA;     * are removed and, if it the new string is not empty or &#xA;     * &lt;code>null&lt;/code>, replaced by a single &lt;code>Text&lt;/code> node &#xA;     * containing the string this attribute is set to. &#xA;     * &lt;br> On getting, no serialization is performed, the returned string &#xA;     * does not contain any markup. No whitespace normalization is performed &#xA;     * and the returned string does not contain the white spaces in element &#xA;     * content (see the attribute &#xA;     * &lt;code>Text.isElementContentWhitespace&lt;/code>). Similarly, on setting, &#xA;     * no parsing is performed either, the input string is taken as pure &#xA;     * textual content. &#xA;     * &lt;br>The string returned is made of the text content of this node &#xA;     * depending on its type, as defined below: &#xA;     * &lt;table border='1' cellpadding='3'>&#xA;     * &lt;tr>&#xA;     * &lt;th>Node type&lt;/th>&#xA;     * &lt;th>Content&lt;/th>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&#xA;     * ELEMENT_NODE, ATTRIBUTE_NODE, ENTITY_NODE, ENTITY_REFERENCE_NODE, &#xA;     * DOCUMENT_FRAGMENT_NODE&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>concatenation of the &lt;code>textContent&lt;/code> &#xA;     * attribute value of every child node, excluding COMMENT_NODE and &#xA;     * PROCESSING_INSTRUCTION_NODE nodes. This is the empty string if the &#xA;     * node has no children.&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE, &#xA;     * PROCESSING_INSTRUCTION_NODE&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>nodeValue&lt;/code>&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>DOCUMENT_NODE, &#xA;     * DOCUMENT_TYPE_NODE, NOTATION_NODE&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;em>null&lt;/em>&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;/table>&#xA;     * @exception DOMException&#xA;     *   DOMSTRING_SIZE_ERR: Raised when it would return more characters than &#xA;     *   fit in a &lt;code>DOMString&lt;/code> variable on the implementation &#xA;     *   platform.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setTextContent">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="textContent">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * This attribute returns the text content of this node and its &#xA;     * descendants. When it is defined to be &lt;code>null&lt;/code>, setting it &#xA;     * has no effect. On setting, any possible children this node may have &#xA;     * are removed and, if it the new string is not empty or &#xA;     * &lt;code>null&lt;/code>, replaced by a single &lt;code>Text&lt;/code> node &#xA;     * containing the string this attribute is set to. &#xA;     * &lt;br> On getting, no serialization is performed, the returned string &#xA;     * does not contain any markup. No whitespace normalization is performed &#xA;     * and the returned string does not contain the white spaces in element &#xA;     * content (see the attribute &#xA;     * &lt;code>Text.isElementContentWhitespace&lt;/code>). Similarly, on setting, &#xA;     * no parsing is performed either, the input string is taken as pure &#xA;     * textual content. &#xA;     * &lt;br>The string returned is made of the text content of this node &#xA;     * depending on its type, as defined below: &#xA;     * &lt;table border='1' cellpadding='3'>&#xA;     * &lt;tr>&#xA;     * &lt;th>Node type&lt;/th>&#xA;     * &lt;th>Content&lt;/th>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&#xA;     * ELEMENT_NODE, ATTRIBUTE_NODE, ENTITY_NODE, ENTITY_REFERENCE_NODE, &#xA;     * DOCUMENT_FRAGMENT_NODE&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>concatenation of the &lt;code>textContent&lt;/code> &#xA;     * attribute value of every child node, excluding COMMENT_NODE and &#xA;     * PROCESSING_INSTRUCTION_NODE nodes. This is the empty string if the &#xA;     * node has no children.&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE, &#xA;     * PROCESSING_INSTRUCTION_NODE&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>nodeValue&lt;/code>&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>DOCUMENT_NODE, &#xA;     * DOCUMENT_TYPE_NODE, NOTATION_NODE&lt;/td>&#xA;     * &lt;td valign='top' rowspan='1' colspan='1'>&lt;em>null&lt;/em>&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;/table>&#xA;     * @exception DOMException&#xA;     *   NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isSameNode">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="other">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns whether this node is the same node as the given one.&#xA;     * &lt;br>This method provides a way to determine whether two &#xA;     * &lt;code>Node&lt;/code> references returned by the implementation reference &#xA;     * the same object. When two &lt;code>Node&lt;/code> references are references &#xA;     * to the same object, even if through a proxy, the references may be &#xA;     * used completely interchangeably, such that all attributes have the &#xA;     * same values and calling the same DOM method on either reference &#xA;     * always has exactly the same effect.&#xA;     * @param other The node to test against.&#xA;     * @return Returns &lt;code>true&lt;/code> if the nodes are the same, &#xA;     *   &lt;code>false&lt;/code> otherwise.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="lookupPrefix">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespaceURI">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Look up the prefix associated to the given namespace URI, starting from &#xA;     * this node. The default namespace declarations are ignored by this &#xA;     * method.&#xA;     * &lt;br>See  for details on the algorithm used by this method.&#xA;     * @param namespaceURI The namespace URI to look for.&#xA;     * @return Returns an associated namespace prefix if found or &#xA;     *   &lt;code>null&lt;/code> if none is found. If more than one prefix are &#xA;     *   associated to the namespace prefix, the returned namespace prefix &#xA;     *   is implementation dependent.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isDefaultNamespace">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespaceURI">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  This method checks if the specified &lt;code>namespaceURI&lt;/code> is the &#xA;     * default namespace or not. &#xA;     * @param namespaceURI The namespace URI to look for.&#xA;     * @return Returns &lt;code>true&lt;/code> if the specified &#xA;     *   &lt;code>namespaceURI&lt;/code> is the default namespace, &#xA;     *   &lt;code>false&lt;/code> otherwise. &#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="lookupNamespaceURI">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Look up the namespace URI associated to the given prefix, starting from &#xA;     * this node.&#xA;     * &lt;br>See  for details on the algorithm used by this method.&#xA;     * @param prefix The prefix to look for. If this parameter is &#xA;     *   &lt;code>null&lt;/code>, the method will return the default namespace URI &#xA;     *   if any.&#xA;     * @return Returns the associated namespace URI or &lt;code>null&lt;/code> if &#xA;     *   none is found.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isEqualNode">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="arg">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests whether two nodes are equal.&#xA;     * &lt;br>This method tests for equality of nodes, not sameness (i.e., &#xA;     * whether the two nodes are references to the same object) which can be &#xA;     * tested with &lt;code>Node.isSameNode()&lt;/code>. All nodes that are the &#xA;     * same will also be equal, though the reverse may not be true.&#xA;     * &lt;br>Two nodes are equal if and only if the following conditions are &#xA;     * satisfied: &#xA;     * &lt;ul>&#xA;     * &lt;li>The two nodes are of the same type.&#xA;     * &lt;/li>&#xA;     * &lt;li>The following string &#xA;     * attributes are equal: &lt;code>nodeName&lt;/code>, &lt;code>localName&lt;/code>, &#xA;     * &lt;code>namespaceURI&lt;/code>, &lt;code>prefix&lt;/code>, &lt;code>nodeValue&lt;/code>&#xA;     * . This is: they are both &lt;code>null&lt;/code>, or they have the same &#xA;     * length and are character for character identical.&#xA;     * &lt;/li>&#xA;     * &lt;li>The &#xA;     * &lt;code>attributes&lt;/code> &lt;code>NamedNodeMaps&lt;/code> are equal. This &#xA;     * is: they are both &lt;code>null&lt;/code>, or they have the same length and &#xA;     * for each node that exists in one map there is a node that exists in &#xA;     * the other map and is equal, although not necessarily at the same &#xA;     * index.&#xA;     * &lt;/li>&#xA;     * &lt;li>The &lt;code>childNodes&lt;/code> &lt;code>NodeLists&lt;/code> are equal. &#xA;     * This is: they are both &lt;code>null&lt;/code>, or they have the same &#xA;     * length and contain equal nodes at the same index. Note that &#xA;     * normalization can affect equality; to avoid this, nodes should be &#xA;     * normalized before being compared.&#xA;     * &lt;/li>&#xA;     * &lt;/ul> &#xA;     * &lt;br>For two &lt;code>DocumentType&lt;/code> nodes to be equal, the following &#xA;     * conditions must also be satisfied: &#xA;     * &lt;ul>&#xA;     * &lt;li>The following string attributes &#xA;     * are equal: &lt;code>publicId&lt;/code>, &lt;code>systemId&lt;/code>, &#xA;     * &lt;code>internalSubset&lt;/code>.&#xA;     * &lt;/li>&#xA;     * &lt;li>The &lt;code>entities&lt;/code> &#xA;     * &lt;code>NamedNodeMaps&lt;/code> are equal.&#xA;     * &lt;/li>&#xA;     * &lt;li>The &lt;code>notations&lt;/code> &#xA;     * &lt;code>NamedNodeMaps&lt;/code> are equal.&#xA;     * &lt;/li>&#xA;     * &lt;/ul> &#xA;     * &lt;br>On the other hand, the following do not affect equality: the &#xA;     * &lt;code>ownerDocument&lt;/code>, &lt;code>baseURI&lt;/code>, and &#xA;     * &lt;code>parentNode&lt;/code> attributes, the &lt;code>specified&lt;/code> &#xA;     * attribute for &lt;code>Attr&lt;/code> nodes, the &lt;code>schemaTypeInfo&lt;/code>&#xA;     *  attribute for &lt;code>Attr&lt;/code> and &lt;code>Element&lt;/code> nodes, the &#xA;     * &lt;code>Text.isElementContentWhitespace&lt;/code> attribute for &#xA;     * &lt;code>Text&lt;/code> nodes, as well as any user data or event listeners &#xA;     * registered on the nodes. &#xA;     * &lt;p >&lt;b>Note:&lt;/b>  As a general rule, anything not mentioned in the &#xA;     * description above is not significant in consideration of equality &#xA;     * checking. Note that future versions of this specification may take &#xA;     * into account more attributes and implementations conform to this &#xA;     * specification are expected to be updated accordingly. &#xA;     * @param arg The node to compare equality with.&#xA;     * @return Returns &lt;code>true&lt;/code> if the nodes are equal, &#xA;     *   &lt;code>false&lt;/code> otherwise.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFeature">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="feature">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="version">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  This method returns a specialized object which implements the &#xA;     * specialized APIs of the specified feature and version, as specified &#xA;     * in . The specialized object may also be obtained by using &#xA;     * binding-specific casting methods but is not necessarily expected to, &#xA;     * as discussed in . This method also allow the implementation to &#xA;     * provide specialized objects which do not support the &lt;code>Node&lt;/code>&#xA;     *  interface. &#xA;     * @param feature  The name of the feature requested. Note that any plus &#xA;     *   sign &quot;+&quot; prepended to the name of the feature will be ignored since &#xA;     *   it is not significant in the context of this method. &#xA;     * @param version  This is the version number of the feature to test. &#xA;     * @return  Returns an object which implements the specialized APIs of &#xA;     *   the specified feature and version, if any, or &lt;code>null&lt;/code> if &#xA;     *   there is no object which implements interfaces associated with that &#xA;     *   feature. If the &lt;code>DOMObject&lt;/code> returned by this method &#xA;     *   implements the &lt;code>Node&lt;/code> interface, it must delegate to the &#xA;     *   primary core &lt;code>Node&lt;/code> and not return results inconsistent &#xA;     *   with the primary core &lt;code>Node&lt;/code> such as attributes, &#xA;     *   childNodes, etc. &#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setUserData">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="handler">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="UserDataHandler.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Associate an object to a key on this node. The object can later be &#xA;     * retrieved from this node by calling &lt;code>getUserData&lt;/code> with the &#xA;     * same key.&#xA;     * @param key The key to associate the object to.&#xA;     * @param data The object to associate to the given key, or &#xA;     *   &lt;code>null&lt;/code> to remove any existing association to that key.&#xA;     * @param handler The handler to associate to that key, or &#xA;     *   &lt;code>null&lt;/code>.&#xA;     * @return Returns the &lt;code>DOMUserData&lt;/code> previously associated to &#xA;     *   the given key on this node, or &lt;code>null&lt;/code> if there was none.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getUserData">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the object associated to a key on a this node. The object &#xA;     * must first have been set to this node by calling &#xA;     * &lt;code>setUserData&lt;/code> with the same key.&#xA;     * @param key The key the object is associated to.&#xA;     * @return Returns the &lt;code>DOMUserData&lt;/code> associated to the given &#xA;     *   key on this node, or &lt;code>null&lt;/code> if there was none.&#xA;     * @since DOM Level 3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>Node&lt;/code> interface is the primary datatype for the entire &#xA; * Document Object Model. It represents a single node in the document tree. &#xA; * While all objects implementing the &lt;code>Node&lt;/code> interface expose &#xA; * methods for dealing with children, not all objects implementing the &#xA; * &lt;code>Node&lt;/code> interface may have children. For example, &#xA; * &lt;code>Text&lt;/code> nodes may not have children, and adding children to &#xA; * such nodes results in a &lt;code>DOMException&lt;/code> being raised.&#xA; * &lt;p>The attributes &lt;code>nodeName&lt;/code>, &lt;code>nodeValue&lt;/code> and &#xA; * &lt;code>attributes&lt;/code> are included as a mechanism to get at node &#xA; * information without casting down to the specific derived interface. In &#xA; * cases where there is no obvious mapping of these attributes for a &#xA; * specific &lt;code>nodeType&lt;/code> (e.g., &lt;code>nodeValue&lt;/code> for an &#xA; * &lt;code>Element&lt;/code> or &lt;code>attributes&lt;/code> for a &lt;code>Comment&lt;/code>&#xA; * ), this returns &lt;code>null&lt;/code>. Note that the specialized interfaces &#xA; * may contain additional and more convenient mechanisms to get and set the &#xA; * relevant information.&#xA; * &lt;p>The values of &lt;code>nodeName&lt;/code>, &#xA; * &lt;code>nodeValue&lt;/code>, and &lt;code>attributes&lt;/code> vary according to the &#xA; * node type as follows: &#xA; * &lt;table border='1' cellpadding='3'>&#xA; * &lt;tr>&#xA; * &lt;th>Interface&lt;/th>&#xA; * &lt;th>nodeName&lt;/th>&#xA; * &lt;th>nodeValue&lt;/th>&#xA; * &lt;th>attributes&lt;/th>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;code>Attr&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>same as &lt;code>Attr.name&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>same as &#xA; * &lt;code>Attr.value&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>CDATASection&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;code>&quot;#cdata-section&quot;&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>same as &lt;code>CharacterData.data&lt;/code>, the &#xA; * content of the CDATA Section&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Comment&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;code>&quot;#comment&quot;&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>same as &lt;code>CharacterData.data&lt;/code>, the &#xA; * content of the comment&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Document&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;code>&quot;#document&quot;&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;code>DocumentFragment&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>&quot;#document-fragment&quot;&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>DocumentType&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>same as &#xA; * &lt;code>DocumentType.name&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;code>Element&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>same as &lt;code>Element.tagName&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;code>NamedNodeMap&lt;/code>&lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Entity&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>entity name&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>EntityReference&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>name of entity referenced&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Notation&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>notation name&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>ProcessingInstruction&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>same &#xA; * as &lt;code>ProcessingInstruction.target&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>same as &#xA; * &lt;code>ProcessingInstruction.data&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;tr>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>Text&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&#xA; * &lt;code>&quot;#text&quot;&lt;/code>&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>same as &lt;code>CharacterData.data&lt;/code>, the content &#xA; * of the text node&lt;/td>&#xA; * &lt;td valign='top' rowspan='1' colspan='1'>&lt;code>null&lt;/code>&lt;/td>&#xA; * &lt;/tr>&#xA; * &lt;/table> &#xA; * &lt;p>See also the &lt;a href='http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407'>Document Object Model (DOM) Level 3 Core Specification&lt;/a>.&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
