<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../../java.ecore#/7 http://www.emftext.org/java/literals ../../../../java.ecore#/9 http://www.emftext.org/java/members ../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../../java.ecore#/13 http://www.emftext.org/java/types ../../../../java.ecore#/16" name="Range.java">
  <comments>/*&#xA; * Copyright (c) 2000 World Wide Web Consortium,&#xA; * (Massachusetts Institute of Technology, Institut National de&#xA; * Recherche en Informatique et en Automatique, Keio University). All&#xA; * Rights Reserved. This program is distributed under the W3C's Software&#xA; * Intellectual Property License. This program is distributed in the&#xA; * hope that it will be useful, but WITHOUT ANY WARRANTY; without even&#xA; * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR&#xA; * PURPOSE.&#xA; * See W3C License http://www.w3.org/Consortium/Legal/ for more details.&#xA; */</comments>
  <namespaces>org</namespaces>
  <namespaces>w3c</namespaces>
  <namespaces>dom</namespaces>
  <namespaces>ranges</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>w3c</namespaces>
    <namespaces>dom</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>w3c</namespaces>
    <namespaces>dom</namespaces>
    <classifier xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>w3c</namespaces>
    <namespaces>dom</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../DocumentFragment.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="Range">
    <members xsi:type="members:InterfaceMethod" name="getStartContainer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Node within which the Range begins &#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getStartOffset">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Offset within the starting node of the Range. &#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getEndContainer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Node within which the Range ends &#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getEndOffset">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Offset within the ending node of the Range. &#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCollapsed">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * TRUE if the Range is collapsed &#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCommonAncestorContainer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The deepest common ancestor container of the Range's two &#xA;     * boundary-points.&#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setStart">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="refNode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RangeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the attributes describing the start of the Range. &#xA;     * @param refNode The &lt;code>refNode&lt;/code> value. This parameter must be &#xA;     *   different from &lt;code>null&lt;/code>.&#xA;     * @param offset The &lt;code>startOffset&lt;/code> value. &#xA;     * @exception RangeException&#xA;     *   INVALID_NODE_TYPE_ERR: Raised if &lt;code>refNode&lt;/code> or an ancestor &#xA;     *   of &lt;code>refNode&lt;/code> is an Entity, Notation, or DocumentType &#xA;     *   node.&#xA;     * @exception DOMException&#xA;     *   INDEX_SIZE_ERR: Raised if &lt;code>offset&lt;/code> is negative or greater &#xA;     *   than the number of child units in &lt;code>refNode&lt;/code>. Child units &#xA;     *   are 16-bit units if &lt;code>refNode&lt;/code> is a type of CharacterData &#xA;     *   node (e.g., a Text or Comment node) or a ProcessingInstruction &#xA;     *   node. Child units are Nodes in all other cases.&#xA;     *   &lt;br>INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already &#xA;     *   been invoked on this object.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised if &lt;code>refNode&lt;/code> was created &#xA;     *   from a different document than the one that created this range.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setEnd">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="refNode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RangeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the attributes describing the end of a Range.&#xA;     * @param refNode The &lt;code>refNode&lt;/code> value. This parameter must be &#xA;     *   different from &lt;code>null&lt;/code>.&#xA;     * @param offset The &lt;code>endOffset&lt;/code> value. &#xA;     * @exception RangeException&#xA;     *   INVALID_NODE_TYPE_ERR: Raised if &lt;code>refNode&lt;/code> or an ancestor &#xA;     *   of &lt;code>refNode&lt;/code> is an Entity, Notation, or DocumentType &#xA;     *   node.&#xA;     * @exception DOMException&#xA;     *   INDEX_SIZE_ERR: Raised if &lt;code>offset&lt;/code> is negative or greater &#xA;     *   than the number of child units in &lt;code>refNode&lt;/code>. Child units &#xA;     *   are 16-bit units if &lt;code>refNode&lt;/code> is a type of CharacterData &#xA;     *   node (e.g., a Text or Comment node) or a ProcessingInstruction &#xA;     *   node. Child units are Nodes in all other cases.&#xA;     *   &lt;br>INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already &#xA;     *   been invoked on this object.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised if &lt;code>refNode&lt;/code> was created &#xA;     *   from a different document than the one that created this range.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setStartBefore">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="refNode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RangeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the start position to be before a node&#xA;     * @param refNode Range starts before &lt;code>refNode&lt;/code> &#xA;     * @exception RangeException&#xA;     *   INVALID_NODE_TYPE_ERR: Raised if the root container of &#xA;     *   &lt;code>refNode&lt;/code> is not an Attr, Document, or DocumentFragment &#xA;     *   node or if &lt;code>refNode&lt;/code> is a Document, DocumentFragment, &#xA;     *   Attr, Entity, or Notation node.&#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised if &lt;code>refNode&lt;/code> was created &#xA;     *   from a different document than the one that created this range.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setStartAfter">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="refNode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RangeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the start position to be after a node&#xA;     * @param refNode Range starts after &lt;code>refNode&lt;/code> &#xA;     * @exception RangeException&#xA;     *   INVALID_NODE_TYPE_ERR: Raised if the root container of &#xA;     *   &lt;code>refNode&lt;/code> is not an Attr, Document, or DocumentFragment &#xA;     *   node or if &lt;code>refNode&lt;/code> is a Document, DocumentFragment, &#xA;     *   Attr, Entity, or Notation node.&#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised if &lt;code>refNode&lt;/code> was created &#xA;     *   from a different document than the one that created this range.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setEndBefore">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="refNode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RangeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the end position to be before a node. &#xA;     * @param refNode Range ends before &lt;code>refNode&lt;/code> &#xA;     * @exception RangeException&#xA;     *   INVALID_NODE_TYPE_ERR: Raised if the root container of &#xA;     *   &lt;code>refNode&lt;/code> is not an Attr, Document, or DocumentFragment &#xA;     *   node or if &lt;code>refNode&lt;/code> is a Document, DocumentFragment, &#xA;     *   Attr, Entity, or Notation node.&#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised if &lt;code>refNode&lt;/code> was created &#xA;     *   from a different document than the one that created this range.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setEndAfter">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="refNode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RangeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the end of a Range to be after a node &#xA;     * @param refNode Range ends after &lt;code>refNode&lt;/code>. &#xA;     * @exception RangeException&#xA;     *   INVALID_NODE_TYPE_ERR: Raised if the root container of &#xA;     *   &lt;code>refNode&lt;/code> is not an Attr, Document or DocumentFragment &#xA;     *   node or if &lt;code>refNode&lt;/code> is a Document, DocumentFragment, &#xA;     *   Attr, Entity, or Notation node.&#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised if &lt;code>refNode&lt;/code> was created &#xA;     *   from a different document than the one that created this range.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="collapse">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toStart">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Collapse a Range onto one of its boundary-points &#xA;     * @param toStart If TRUE, collapses the Range onto its start; if FALSE, &#xA;     *   collapses it onto its end. &#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="selectNode">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="refNode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RangeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Select a node and its contents &#xA;     * @param refNode The node to select. &#xA;     * @exception RangeException&#xA;     *   INVALID_NODE_TYPE_ERR: Raised if an ancestor of &lt;code>refNode&lt;/code> &#xA;     *   is an Entity, Notation or DocumentType node or if &#xA;     *   &lt;code>refNode&lt;/code> is a Document, DocumentFragment, Attr, Entity, &#xA;     *   or Notation node.&#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised if &lt;code>refNode&lt;/code> was created &#xA;     *   from a different document than the one that created this range.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="selectNodeContents">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="refNode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RangeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Select the contents within a node &#xA;     * @param refNode Node to select from &#xA;     * @exception RangeException&#xA;     *   INVALID_NODE_TYPE_ERR: Raised if &lt;code>refNode&lt;/code> or an ancestor &#xA;     *   of &lt;code>refNode&lt;/code> is an Entity, Notation or DocumentType node.&#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised if &lt;code>refNode&lt;/code> was created &#xA;     *   from a different document than the one that created this range.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="START_TO_START">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// CompareHow</comments>
        <comments>/**&#xA;     * Compare start boundary-point of &lt;code>sourceRange&lt;/code> to start &#xA;     * boundary-point of Range on which &lt;code>compareBoundaryPoints&lt;/code> &#xA;     * is invoked.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="START_TO_END">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compare start boundary-point of &lt;code>sourceRange&lt;/code> to end &#xA;     * boundary-point of Range on which &lt;code>compareBoundaryPoints&lt;/code> &#xA;     * is invoked.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="END_TO_END">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compare end boundary-point of &lt;code>sourceRange&lt;/code> to end &#xA;     * boundary-point of Range on which &lt;code>compareBoundaryPoints&lt;/code> &#xA;     * is invoked.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="END_TO_START">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compare end boundary-point of &lt;code>sourceRange&lt;/code> to start &#xA;     * boundary-point of Range on which &lt;code>compareBoundaryPoints&lt;/code> &#xA;     * is invoked.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="compareBoundaryPoints">
      <typeReference xsi:type="types:Short"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="how">
        <typeReference xsi:type="types:Short"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sourceRange">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compare the boundary-points of two Ranges in a document.&#xA;     * @param how A code representing the type of comparison, as defined &#xA;     *   above.&#xA;     * @param sourceRange The &lt;code>Range&lt;/code> on which this current &#xA;     *   &lt;code>Range&lt;/code> is compared to.&#xA;     * @return  -1, 0 or 1 depending on whether the corresponding &#xA;     *   boundary-point of the Range is respectively before, equal to, or &#xA;     *   after the corresponding boundary-point of &lt;code>sourceRange&lt;/code>. &#xA;     * @exception DOMException&#xA;     *   WRONG_DOCUMENT_ERR: Raised if the two Ranges are not in the same &#xA;     *   Document or DocumentFragment.&#xA;     *   &lt;br>INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already &#xA;     *   been invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="deleteContents">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes the contents of a Range from the containing document or &#xA;     * document fragment without returning a reference to the removed &#xA;     * content.  &#xA;     * @exception DOMException&#xA;     *   NO_MODIFICATION_ALLOWED_ERR: Raised if any portion of the content of &#xA;     *   the Range is read-only or any of the nodes that contain any of the &#xA;     *   content of the Range are read-only.&#xA;     *   &lt;br>INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already &#xA;     *   been invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="extractContents">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../DocumentFragment.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Moves the contents of a Range from the containing document or document &#xA;     * fragment to a new DocumentFragment. &#xA;     * @return A DocumentFragment containing the extracted contents. &#xA;     * @exception DOMException&#xA;     *   NO_MODIFICATION_ALLOWED_ERR: Raised if any portion of the content of &#xA;     *   the Range is read-only or any of the nodes which contain any of the &#xA;     *   content of the Range are read-only.&#xA;     *   &lt;br>HIERARCHY_REQUEST_ERR: Raised if a DocumentType node would be &#xA;     *   extracted into the new DocumentFragment.&#xA;     *   &lt;br>INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already &#xA;     *   been invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="cloneContents">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../DocumentFragment.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Duplicates the contents of a Range &#xA;     * @return A DocumentFragment that contains content equivalent to this &#xA;     *   Range.&#xA;     * @exception DOMException&#xA;     *   HIERARCHY_REQUEST_ERR: Raised if a DocumentType node would be &#xA;     *   extracted into the new DocumentFragment.&#xA;     *   &lt;br>INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already &#xA;     *   been invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insertNode">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newNode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RangeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts a node into the Document or DocumentFragment at the start of &#xA;     * the Range. If the container is a Text node, this will be split at the &#xA;     * start of the Range (as if the Text node's splitText method was &#xA;     * performed at the insertion point) and the insertion will occur &#xA;     * between the two resulting Text nodes. Adjacent Text nodes will not be &#xA;     * automatically merged. If the node to be inserted is a &#xA;     * DocumentFragment node, the children will be inserted rather than the &#xA;     * DocumentFragment node itself.&#xA;     * @param newNode The node to insert at the start of the Range &#xA;     * @exception DOMException&#xA;     *   NO_MODIFICATION_ALLOWED_ERR: Raised if an ancestor container of the &#xA;     *   start of the Range is read-only.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised if &lt;code>newNode&lt;/code> and the &#xA;     *   container of the start of the Range were not created from the same &#xA;     *   document.&#xA;     *   &lt;br>HIERARCHY_REQUEST_ERR: Raised if the container of the start of &#xA;     *   the Range is of a type that does not allow children of the type of &#xA;     *   &lt;code>newNode&lt;/code> or if &lt;code>newNode&lt;/code> is an ancestor of &#xA;     *   the container.&#xA;     *   &lt;br>INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already &#xA;     *   been invoked on this object.&#xA;     * @exception RangeException&#xA;     *   INVALID_NODE_TYPE_ERR: Raised if &lt;code>newNode&lt;/code> is an Attr, &#xA;     *   Entity, Notation, or Document node.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="surroundContents">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newParent">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../Node.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RangeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reparents the contents of the Range to the given node and inserts the &#xA;     * node at the position of the start of the Range. &#xA;     * @param newParent The node to surround the contents with. &#xA;     * @exception DOMException&#xA;     *   NO_MODIFICATION_ALLOWED_ERR: Raised if an ancestor container of &#xA;     *   either boundary-point of the Range is read-only.&#xA;     *   &lt;br>WRONG_DOCUMENT_ERR: Raised if &lt;code> newParent&lt;/code> and the &#xA;     *   container of the start of the Range were not created from the same &#xA;     *   document.&#xA;     *   &lt;br>HIERARCHY_REQUEST_ERR: Raised if the container of the start of &#xA;     *   the Range is of a type that does not allow children of the type of &#xA;     *   &lt;code>newParent&lt;/code> or if &lt;code>newParent&lt;/code> is an ancestor &#xA;     *   of the container or if &lt;code>node&lt;/code> would end up with a child &#xA;     *   node of a type not allowed by the type of &lt;code>node&lt;/code>.&#xA;     *   &lt;br>INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already &#xA;     *   been invoked on this object.&#xA;     * @exception RangeException&#xA;     *   BAD_BOUNDARYPOINTS_ERR: Raised if the Range partially selects a &#xA;     *   non-text node.&#xA;     *   &lt;br>INVALID_NODE_TYPE_ERR: Raised if &lt;code> node&lt;/code> is an Attr, &#xA;     *   Entity, DocumentType, Notation, Document, or DocumentFragment node.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="cloneRange">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Produces a new Range whose boundary-points are equal to the &#xA;     * boundary-points of the Range. &#xA;     * @return The duplicated Range. &#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the contents of a Range as a string. This string contains only &#xA;     * the data characters, not any markup. &#xA;     * @return The contents of the Range.&#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="detach">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DOMException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Called to indicate that the Range is no longer in use and that the &#xA;     * implementation may relinquish any resources associated with this &#xA;     * Range. Subsequent calls to any methods or attribute getters on this &#xA;     * Range will result in a &lt;code>DOMException&lt;/code> being thrown with an &#xA;     * error code of &lt;code>INVALID_STATE_ERR&lt;/code>.&#xA;     * @exception DOMException&#xA;     *   INVALID_STATE_ERR: Raised if &lt;code>detach()&lt;/code> has already been &#xA;     *   invoked on this object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;p>See also the &lt;a href='http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113'>Document Object Model (DOM) Level 2 Traversal and Range Specification&lt;/a>.&#xA; * @since DOM Level 2&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
