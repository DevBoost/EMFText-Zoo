<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="XMLReader.java">
  <comments>// XMLReader.java - read an XML document.</comments>
  <comments>// http://www.saxproject.org</comments>
  <comments>// Written by David Megginson</comments>
  <comments>// NO WARRANTY!  This class is in the Public Domain.</comments>
  <comments>// $Id: XMLReader.java,v 1.2.22.1 2004/05/01 08:34:40 jsuttor Exp $</comments>
  <namespaces>org</namespaces>
  <namespaces>xml</namespaces>
  <namespaces>sax</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="XMLReader">
    <members xsi:type="members:InterfaceMethod" name="getFeature">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SAXNotRecognizedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SAXNotSupportedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>////////////////////////////////////////////////////////////////////</comments>
        <comments>// Configuration.</comments>
        <comments>////////////////////////////////////////////////////////////////////</comments>
        <comments>/**&#xA;     * Look up the value of a feature flag.&#xA;     *&#xA;     * &lt;p>The feature name is any fully-qualified URI.  It is&#xA;     * possible for an XMLReader to recognize a feature name but&#xA;     * temporarily be unable to return its value.&#xA;     * Some feature values may be available only in specific&#xA;     * contexts, such as before, during, or after a parse.&#xA;     * Also, some feature values may not be programmatically accessible.&#xA;     * (In the case of an adapter for SAX1 {@link Parser}, there is no&#xA;     * implementation-independent way to expose whether the underlying&#xA;     * parser is performing validation, expanding external entities,&#xA;     * and so forth.) &lt;/p>&#xA;     *&#xA;     * &lt;p>All XMLReaders are required to recognize the&#xA;     * http://xml.org/sax/features/namespaces and the&#xA;     * http://xml.org/sax/features/namespace-prefixes feature names.&lt;/p>&#xA;     *&#xA;     * &lt;p>Typical usage is something like this:&lt;/p>&#xA;     *&#xA;     * &lt;pre>&#xA;     * XMLReader r = new MySAXDriver();&#xA;     *&#xA;     *                         // try to activate validation&#xA;     * try {&#xA;     *   r.setFeature(&quot;http://xml.org/sax/features/validation&quot;, true);&#xA;     * } catch (SAXException e) {&#xA;     *   System.err.println(&quot;Cannot activate validation.&quot;); &#xA;     * }&#xA;     *&#xA;     *                         // register event handlers&#xA;     * r.setContentHandler(new MyContentHandler());&#xA;     * r.setErrorHandler(new MyErrorHandler());&#xA;     *&#xA;     *                         // parse the first document&#xA;     * try {&#xA;     *   r.parse(&quot;http://www.foo.com/mydoc.xml&quot;);&#xA;     * } catch (IOException e) {&#xA;     *   System.err.println(&quot;I/O exception reading XML document&quot;);&#xA;     * } catch (SAXException e) {&#xA;     *   System.err.println(&quot;XML exception reading document.&quot;);&#xA;     * }&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;p>Implementors are free (and encouraged) to invent their own features,&#xA;     * using names built on their own URIs.&lt;/p>&#xA;     *&#xA;     * @param name The feature name, which is a fully-qualified URI.&#xA;     * @return The current value of the feature (true or false).&#xA;     * @exception org.xml.sax.SAXNotRecognizedException If the feature&#xA;     *            value can't be assigned or retrieved.&#xA;     * @exception org.xml.sax.SAXNotSupportedException When the&#xA;     *            XMLReader recognizes the feature name but &#xA;     *            cannot determine its value at this time.&#xA;     * @see #setFeature&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setFeature">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SAXNotRecognizedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SAXNotSupportedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set the value of a feature flag.&#xA;     *&#xA;     * &lt;p>The feature name is any fully-qualified URI.  It is&#xA;     * possible for an XMLReader to expose a feature value but&#xA;     * to be unable to change the current value.&#xA;     * Some feature values may be immutable or mutable only &#xA;     * in specific contexts, such as before, during, or after &#xA;     * a parse.&lt;/p>&#xA;     *&#xA;     * &lt;p>All XMLReaders are required to support setting&#xA;     * http://xml.org/sax/features/namespaces to true and&#xA;     * http://xml.org/sax/features/namespace-prefixes to false.&lt;/p>&#xA;     *&#xA;     * @param name The feature name, which is a fully-qualified URI.&#xA;     * @param value The requested value of the feature (true or false).&#xA;     * @exception org.xml.sax.SAXNotRecognizedException If the feature&#xA;     *            value can't be assigned or retrieved.&#xA;     * @exception org.xml.sax.SAXNotSupportedException When the&#xA;     *            XMLReader recognizes the feature name but &#xA;     *            cannot set the requested value.&#xA;     * @see #getFeature&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getProperty">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SAXNotRecognizedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SAXNotSupportedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Look up the value of a property.&#xA;     *&#xA;     * &lt;p>The property name is any fully-qualified URI.  It is&#xA;     * possible for an XMLReader to recognize a property name but&#xA;     * temporarily be unable to return its value.&#xA;     * Some property values may be available only in specific&#xA;     * contexts, such as before, during, or after a parse.&lt;/p>&#xA;     *&#xA;     * &lt;p>XMLReaders are not required to recognize any specific&#xA;     * property names, though an initial core set is documented for&#xA;     * SAX2.&lt;/p>&#xA;     *&#xA;     * &lt;p>Implementors are free (and encouraged) to invent their own properties,&#xA;     * using names built on their own URIs.&lt;/p>&#xA;     *&#xA;     * @param name The property name, which is a fully-qualified URI.&#xA;     * @return The current value of the property.&#xA;     * @exception org.xml.sax.SAXNotRecognizedException If the property&#xA;     *            value can't be assigned or retrieved.&#xA;     * @exception org.xml.sax.SAXNotSupportedException When the&#xA;     *            XMLReader recognizes the property name but &#xA;     *            cannot determine its value at this time.&#xA;     * @see #setProperty&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setProperty">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SAXNotRecognizedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SAXNotSupportedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set the value of a property.&#xA;     *&#xA;     * &lt;p>The property name is any fully-qualified URI.  It is&#xA;     * possible for an XMLReader to recognize a property name but&#xA;     * to be unable to change the current value.&#xA;     * Some property values may be immutable or mutable only &#xA;     * in specific contexts, such as before, during, or after &#xA;     * a parse.&lt;/p>&#xA;     *&#xA;     * &lt;p>XMLReaders are not required to recognize setting&#xA;     * any specific property names, though a core set is defined by &#xA;     * SAX2.&lt;/p>&#xA;     *&#xA;     * &lt;p>This method is also the standard mechanism for setting&#xA;     * extended handlers.&lt;/p>&#xA;     *&#xA;     * @param name The property name, which is a fully-qualified URI.&#xA;     * @param value The requested value for the property.&#xA;     * @exception org.xml.sax.SAXNotRecognizedException If the property&#xA;     *            value can't be assigned or retrieved.&#xA;     * @exception org.xml.sax.SAXNotSupportedException When the&#xA;     *            XMLReader recognizes the property name but &#xA;     *            cannot set the requested value.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setEntityResolver">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="resolver">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="EntityResolver.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>////////////////////////////////////////////////////////////////////</comments>
        <comments>// Event handlers.</comments>
        <comments>////////////////////////////////////////////////////////////////////</comments>
        <comments>/**&#xA;     * Allow an application to register an entity resolver.&#xA;     *&#xA;     * &lt;p>If the application does not register an entity resolver,&#xA;     * the XMLReader will perform its own default resolution.&lt;/p>&#xA;     *&#xA;     * &lt;p>Applications may register a new or different resolver in the&#xA;     * middle of a parse, and the SAX parser must begin using the new&#xA;     * resolver immediately.&lt;/p>&#xA;     *&#xA;     * @param resolver The entity resolver.&#xA;     * @see #getEntityResolver&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getEntityResolver">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="EntityResolver.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return the current entity resolver.&#xA;     *&#xA;     * @return The current entity resolver, or null if none&#xA;     *         has been registered.&#xA;     * @see #setEntityResolver&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setDTDHandler">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="handler">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="DTDHandler.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allow an application to register a DTD event handler.&#xA;     *&#xA;     * &lt;p>If the application does not register a DTD handler, all DTD&#xA;     * events reported by the SAX parser will be silently ignored.&lt;/p>&#xA;     *&#xA;     * &lt;p>Applications may register a new or different handler in the&#xA;     * middle of a parse, and the SAX parser must begin using the new&#xA;     * handler immediately.&lt;/p>&#xA;     *&#xA;     * @param handler The DTD handler.&#xA;     * @see #getDTDHandler&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDTDHandler">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="DTDHandler.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return the current DTD handler.&#xA;     *&#xA;     * @return The current DTD handler, or null if none&#xA;     *         has been registered.&#xA;     * @see #setDTDHandler&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setContentHandler">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="handler">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="ContentHandler.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allow an application to register a content event handler.&#xA;     *&#xA;     * &lt;p>If the application does not register a content handler, all&#xA;     * content events reported by the SAX parser will be silently&#xA;     * ignored.&lt;/p>&#xA;     *&#xA;     * &lt;p>Applications may register a new or different handler in the&#xA;     * middle of a parse, and the SAX parser must begin using the new&#xA;     * handler immediately.&lt;/p>&#xA;     *&#xA;     * @param handler The content handler.&#xA;     * @see #getContentHandler&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getContentHandler">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="ContentHandler.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return the current content handler.&#xA;     *&#xA;     * @return The current content handler, or null if none&#xA;     *         has been registered.&#xA;     * @see #setContentHandler&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setErrorHandler">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="handler">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="ErrorHandler.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allow an application to register an error event handler.&#xA;     *&#xA;     * &lt;p>If the application does not register an error handler, all&#xA;     * error events reported by the SAX parser will be silently&#xA;     * ignored; however, normal processing may not continue.  It is&#xA;     * highly recommended that all SAX applications implement an&#xA;     * error handler to avoid unexpected bugs.&lt;/p>&#xA;     *&#xA;     * &lt;p>Applications may register a new or different handler in the&#xA;     * middle of a parse, and the SAX parser must begin using the new&#xA;     * handler immediately.&lt;/p>&#xA;     *&#xA;     * @param handler The error handler.&#xA;     * @see #getErrorHandler&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getErrorHandler">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="ErrorHandler.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return the current error handler.&#xA;     *&#xA;     * @return The current error handler, or null if none&#xA;     *         has been registered.&#xA;     * @see #setErrorHandler&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="parse">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="input">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="InputSource.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>////////////////////////////////////////////////////////////////////</comments>
        <comments>// Parsing.</comments>
        <comments>////////////////////////////////////////////////////////////////////</comments>
        <comments>/**&#xA;     * Parse an XML document.&#xA;     *&#xA;     * &lt;p>The application can use this method to instruct the XML&#xA;     * reader to begin parsing an XML document from any valid input&#xA;     * source (a character stream, a byte stream, or a URI).&lt;/p>&#xA;     *&#xA;     * &lt;p>Applications may not invoke this method while a parse is in&#xA;     * progress (they should create a new XMLReader instead for each&#xA;     * nested XML document).  Once a parse is complete, an&#xA;     * application may reuse the same XMLReader object, possibly with a&#xA;     * different input source.&#xA;     * Configuration of the XMLReader object (such as handler bindings and&#xA;     * values established for feature flags and properties) is unchanged&#xA;     * by completion of a parse, unless the definition of that aspect of&#xA;     * the configuration explicitly specifies other behavior.&#xA;     * (For example, feature flags or properties exposing&#xA;     * characteristics of the document being parsed.)&#xA;     * &lt;/p>&#xA;     *&#xA;     * &lt;p>During the parse, the XMLReader will provide information&#xA;     * about the XML document through the registered event&#xA;     * handlers.&lt;/p>&#xA;     *&#xA;     * &lt;p>This method is synchronous: it will not return until parsing&#xA;     * has ended.  If a client application wants to terminate &#xA;     * parsing early, it should throw an exception.&lt;/p>&#xA;     *&#xA;     * @param input The input source for the top-level of the&#xA;     *        XML document.&#xA;     * @exception org.xml.sax.SAXException Any SAX exception, possibly&#xA;     *            wrapping another exception.&#xA;     * @exception java.io.IOException An IO exception from the parser,&#xA;     *            possibly from a byte stream or character stream&#xA;     *            supplied by the application.&#xA;     * @see org.xml.sax.InputSource&#xA;     * @see #parse(java.lang.String)&#xA;     * @see #setEntityResolver&#xA;     * @see #setDTDHandler&#xA;     * @see #setContentHandler&#xA;     * @see #setErrorHandler &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="parse">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="systemId">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Parse an XML document from a system identifier (URI).&#xA;     *&#xA;     * &lt;p>This method is a shortcut for the common case of reading a&#xA;     * document from a system identifier.  It is the exact&#xA;     * equivalent of the following:&lt;/p>&#xA;     *&#xA;     * &lt;pre>&#xA;     * parse(new InputSource(systemId));&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;p>If the system identifier is a URL, it must be fully resolved&#xA;     * by the application before it is passed to the parser.&lt;/p>&#xA;     *&#xA;     * @param systemId The system identifier (URI).&#xA;     * @exception org.xml.sax.SAXException Any SAX exception, possibly&#xA;     *            wrapping another exception.&#xA;     * @exception java.io.IOException An IO exception from the parser,&#xA;     *            possibly from a byte stream or character stream&#xA;     *            supplied by the application.&#xA;     * @see #parse(org.xml.sax.InputSource)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Interface for reading an XML document using callbacks.&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;em>This module, both source code and documentation, is in the&#xA; * Public Domain, and comes with &lt;strong>NO WARRANTY&lt;/strong>.&lt;/em>&#xA; * See &lt;a href='http://www.saxproject.org'>http://www.saxproject.org&lt;/a>&#xA; * for further information.&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p>&lt;strong>Note:&lt;/strong> despite its name, this interface does &#xA; * &lt;em>not&lt;/em> extend the standard Java {@link java.io.Reader Reader} &#xA; * interface, because reading XML is a fundamentally different activity &#xA; * than reading character data.&lt;/p>&#xA; *&#xA; * &lt;p>XMLReader is the interface that an XML parser's SAX2 driver must&#xA; * implement.  This interface allows an application to set and&#xA; * query features and properties in the parser, to register&#xA; * event handlers for document processing, and to initiate&#xA; * a document parse.&lt;/p>&#xA; *&#xA; * &lt;p>All SAX interfaces are assumed to be synchronous: the&#xA; * {@link #parse parse} methods must not return until parsing&#xA; * is complete, and readers must wait for an event-handler callback&#xA; * to return before reporting the next event.&lt;/p>&#xA; *&#xA; * &lt;p>This interface replaces the (now deprecated) SAX 1.0 {@link&#xA; * org.xml.sax.Parser Parser} interface.  The XMLReader interface&#xA; * contains two important enhancements over the old Parser&#xA; * interface (as well as some minor ones):&lt;/p>&#xA; *&#xA; * &lt;ol>&#xA; * &lt;li>it adds a standard way to query and set features and &#xA; *  properties; and&lt;/li>&#xA; * &lt;li>it adds Namespace support, which is required for many&#xA; *  higher-level XML standards.&lt;/li>&#xA; * &lt;/ol>&#xA; *&#xA; * &lt;p>There are adapters available to convert a SAX1 Parser to&#xA; * a SAX2 XMLReader and vice-versa.&lt;/p>&#xA; *&#xA; * @since SAX 2.0&#xA; * @author David Megginson&#xA; * @version 2.0.1+ (sax2r3pre1)&#xA; * @see org.xml.sax.XMLFilter&#xA; * @see org.xml.sax.helpers.ParserAdapter&#xA; * @see org.xml.sax.helpers.XMLReaderAdapter &#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
