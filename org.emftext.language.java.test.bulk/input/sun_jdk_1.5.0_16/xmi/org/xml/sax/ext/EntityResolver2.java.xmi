<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../../java.ecore#/7 http://www.emftext.org/java/members ../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../../java.ecore#/13 http://www.emftext.org/java/types ../../../../java.ecore#/16" name="EntityResolver2.java">
  <comments>// EntityResolver2.java - Extended SAX entity resolver.</comments>
  <comments>// http://www.saxproject.org</comments>
  <comments>// No warranty; no copyright -- use this as you will.</comments>
  <comments>// $Id: EntityResolver2.java,v 1.1.2.1 2004/05/01 08:34:43 jsuttor Exp $</comments>
  <namespaces>org</namespaces>
  <namespaces>xml</namespaces>
  <namespaces>sax</namespaces>
  <namespaces>ext</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../java/io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>sax</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../EntityResolver.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>sax</namespaces>
    <classifier xsi:type="classifiers:Class" href="../InputSource.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>sax</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../XMLReader.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>sax</namespaces>
    <classifier xsi:type="classifiers:Class" href="../SAXException.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="EntityResolver2">
    <members xsi:type="members:InterfaceMethod" name="getExternalSubset">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../InputSource.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="baseURI">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allows applications to provide an external subset for documents&#xA;     * that don't explicitly define one.  Documents with DOCTYPE declarations&#xA;     * that omit an external subset can thus augment the declarations&#xA;     * available for validation, entity processing, and attribute processing&#xA;     * (normalization, defaulting, and reporting types including ID).&#xA;     * This augmentation is reported&#xA;     * through the {@link LexicalHandler#startDTD startDTD()} method as if&#xA;     * the document text had originally included the external subset;&#xA;     * this callback is made before any internal subset data or errors&#xA;     * are reported.&lt;/p>&#xA;     *&#xA;     * &lt;p>This method can also be used with documents that have no DOCTYPE&#xA;     * declaration.  When the root element is encountered,&#xA;     * but no DOCTYPE declaration has been seen, this method is&#xA;     * invoked.  If it returns a value for the external subset, that root&#xA;     * element is declared to be the root element, giving the effect of&#xA;     * splicing a DOCTYPE declaration at the end the prolog of a document&#xA;     * that could not otherwise be valid.  The sequence of parser callbacks&#xA;     * in that case logically resembles this:&lt;/p>&#xA;     *&#xA;     * &lt;pre>&#xA;     * ... comments and PIs from the prolog (as usual)&#xA;     * startDTD (&quot;rootName&quot;, source.getPublicId (), source.getSystemId ());&#xA;     * startEntity (&quot;[dtd]&quot;);&#xA;     * ... declarations, comments, and PIs from the external subset&#xA;     * endEntity (&quot;[dtd]&quot;);&#xA;     * endDTD ();&#xA;     * ... then the rest of the document (as usual)&#xA;     * startElement (..., &quot;rootName&quot;, ...);&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;p>Note that the InputSource gets no further resolution.&#xA;     * Implementations of this method may wish to invoke&#xA;     * {@link #resolveEntity resolveEntity()} to gain benefits such as use&#xA;     * of local caches of DTD entities.  Also, this method will never be&#xA;     * used by a (non-validating) processor that is not including external&#xA;     * parameter entities. &lt;/p>&#xA;     *&#xA;     * &lt;p>Uses for this method include facilitating data validation when&#xA;     * interoperating with XML processors that would always require&#xA;     * undesirable network accesses for external entities, or which for&#xA;     * other reasons adopt a &quot;no DTDs&quot; policy.&#xA;     * Non-validation motives include forcing documents to include DTDs so&#xA;     * that attributes are handled consistently.&#xA;     * For example, an XPath processor needs to know which attibutes have&#xA;     * type &quot;ID&quot; before it can process a widely used type of reference.&lt;/p>&#xA;     * &#xA;     * &lt;p>&lt;strong>Warning:&lt;/strong> Returning an external subset modifies&#xA;     * the input document.  By providing definitions for general entities,&#xA;     * it can make a malformed document appear to be well formed.&#xA;     * &lt;/p>&#xA;     *&#xA;     * @param name Identifies the document root element.  This name comes&#xA;     *&#x9;from a DOCTYPE declaration (where available) or from the actual&#xA;     *&#x9;root element. &#xA;     * @param baseURI The document's base URI, serving as an additional&#xA;     *&#x9;hint for selecting the external subset.  This is always an absolute&#xA;     *&#x9;URI, unless it is null because the XMLReader was given an InputSource&#xA;     *&#x9;without one.&#xA;     *&#xA;     * @return An InputSource object describing the new external subset&#xA;     *&#x9;to be used by the parser, or null to indicate that no external&#xA;     *&#x9;subset is provided.&#xA;     *&#xA;     * @exception SAXException Any SAX exception, possibly wrapping&#xA;     *&#x9;another exception.&#xA;     * @exception IOException Probably indicating a failure to create&#xA;     *&#x9;a new InputStream or Reader, or an illegal URL.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="resolveEntity">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../InputSource.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="publicId">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="baseURI">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="systemId">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allows applications to map references to external entities into input&#xA;     * sources, or tell the parser it should use conventional URI resolution.&#xA;     * This method is only called for external entities which have been&#xA;     * properly declared.&#xA;     * This method provides more flexibility than the {@link EntityResolver}&#xA;     * interface, supporting implementations of more complex catalogue&#xA;     * schemes such as the one defined by the &lt;a href=&#xA;&#x9;&quot;http://www.oasis-open.org/committees/entity/spec-2001-08-06.html&quot;&#xA;&#x9;>OASIS XML Catalogs&lt;/a> specification.&lt;/p>&#xA;     *&#xA;     * &lt;p>Parsers configured to use this resolver method will call it&#xA;     * to determine the input source to use for any external entity&#xA;     * being included because of a reference in the XML text.&#xA;     * That excludes the document entity, and any external entity returned&#xA;     * by {@link #getExternalSubset getExternalSubset()}.&#xA;     * When a (non-validating) processor is configured not to include&#xA;     * a class of entities (parameter or general) through use of feature&#xA;     * flags, this method is not invoked for such entities.  &lt;/p>&#xA;     *&#xA;     * &lt;p>Note that the entity naming scheme used here is the same one&#xA;     * used in the {@link LexicalHandler}, or in the {@link&#xA;&#x9;org.xml.sax.ContentHandler#skippedEntity&#xA;&#x9;ContentHandler.skippedEntity()}&#xA;     * method. &lt;/p>&#xA;     *&#xA;     * @param name Identifies the external entity being resolved.&#xA;     *&#x9;Either &quot;[dtd]&quot; for the external subset, or a name starting&#xA;     *&#x9;with &quot;%&quot; to indicate a parameter entity, or else the name of&#xA;     *&#x9;a general entity.  This is never null when invoked by a SAX2&#xA;     *&#x9;parser.&#xA;     * @param publicId The public identifier of the external entity being&#xA;     *&#x9;referenced (normalized as required by the XML specification), or&#xA;     *&#x9;null if none was supplied.&#xA;     * @param baseURI The URI with respect to which relative systemIDs&#xA;     *&#x9;are interpreted.  This is always an absolute URI, unless it is&#xA;     *&#x9;null (likely because the XMLReader was given an InputSource without&#xA;     *  one).  This URI is defined by the XML specification to be the one&#xA;     *&#x9;associated with the &quot;&amp;lt;&quot; starting the relevant declaration.&#xA;     * @param systemId The system identifier of the external entity&#xA;     *&#x9;being referenced; either a relative or absolute URI.&#xA;     *  This is never null when invoked by a SAX2 parser; only declared&#xA;     *&#x9;entities, and any external subset, are resolved by such parsers.&#xA;     *&#xA;     * @return An InputSource object describing the new input source to&#xA;     *&#x9;be used by the parser.  Returning null directs the parser to&#xA;     *&#x9;resolve the system ID against the base URI and open a connection&#xA;     *&#x9;to resulting URI.&#xA;     *&#xA;     * @exception SAXException Any SAX exception, possibly wrapping&#xA;     *&#x9;another exception.&#xA;     * @exception IOException Probably indicating a failure to create&#xA;     *&#x9;a new InputStream or Reader, or an illegal URL.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Extended interface for mapping external entity references to input&#xA; * sources, or providing a missing external subset.  The&#xA; * {@link XMLReader#setEntityResolver XMLReader.setEntityResolver()} method&#xA; * is used to provide implementations of this interface to parsers.&#xA; * When a parser uses the methods in this interface, the&#xA; * {@link EntityResolver2#resolveEntity EntityResolver2.resolveEntity()}&#xA; * method (in this interface) is used &lt;em>instead of&lt;/em> the older (SAX 1.0)&#xA; * {@link EntityResolver#resolveEntity EntityResolver.resolveEntity()} method.&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;em>This module, both source code and documentation, is in the&#xA; * Public Domain, and comes with &lt;strong>NO WARRANTY&lt;/strong>.&lt;/em>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p>If a SAX application requires the customized handling which this&#xA; * interface defines for external entities, it must ensure that it uses&#xA; * an XMLReader with the&#xA; * &lt;em>http://xml.org/sax/features/use-entity-resolver2&lt;/em> feature flag&#xA; * set to &lt;em>true&lt;/em> (which is its default value when the feature is&#xA; * recognized).  If that flag is unrecognized, or its value is false,&#xA; * or the resolver does not implement this interface, then only the&#xA; * {@link EntityResolver} method will be used.&#xA; * &lt;/p>&#xA; *&#xA; * &lt;p>That supports three categories of application that modify entity&#xA; * resolution.  &lt;em>Old Style&lt;/em> applications won't know about this interface;&#xA; * they will provide an EntityResolver.&#xA; * &lt;em>Transitional Mode&lt;/em> provide an EntityResolver2 and automatically&#xA; * get the benefit of its methods in any systems (parsers or other tools)&#xA; * supporting it, due to polymorphism.&#xA; * Both &lt;em>Old Style&lt;/em> and &lt;em>Transitional Mode&lt;/em> applications will&#xA; * work with any SAX2 parser.&#xA; * &lt;em>New style&lt;/em> applications will fail to run except on SAX2 parsers&#xA; * that support this particular feature.&#xA; * They will insist that feature flag have a value of &quot;true&quot;, and the&#xA; * EntityResolver2 implementation they provide  might throw an exception&#xA; * if the original SAX 1.0 style entity resolution method is invoked.&#xA; * &lt;/p>&#xA; *&#xA; * @see org.xml.sax.XMLReader#setEntityResolver&#xA; *&#xA; * @since SAX 2.0 (extensions 1.1 alpha)&#xA; * @author David Brownell&#xA; * @version TBD&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../EntityResolver.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
