<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="DynAnyOperations.java">
  <namespaces>org</namespaces>
  <namespaces>omg</namespaces>
  <namespaces>DynamicAny</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="DynAnyOperations">
    <members xsi:type="members:InterfaceMethod" name="type">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;        * Returns the TypeCode associated with this DynAny object.&#xA;        * A DynAny object is created with a TypeCode value assigned to it.&#xA;        * This TypeCode value determines the type of the value handled through the DynAny object.&#xA;        * Note that the TypeCode associated with a DynAny object is initialized at the time the&#xA;        * DynAny is created and cannot be changed during lifetime of the DynAny object.&#xA;        *&#xA;        * @return The TypeCode associated with this DynAny object&#xA;        */</comments>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>CORBA</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../CORBA/TypeCode.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="assign">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Initializes the value associated with a DynAny object with the value&#xA;        * associated with another DynAny object.&#xA;        * The current position of the target DynAny is set to zero for values that have components&#xA;        * and to -1 for values that do not have components.&#xA;        *&#xA;        * @param dyn_any&#xA;        * @exception TypeMismatch if the type of the passed DynAny is not equivalent to the type of target DynAny&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dyn_any">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>omg</namespaces>
          <namespaces>DynamicAny</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="DynAny.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="from_any">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Initializes the value associated with a DynAny object with the value contained in an any.&#xA;        * The current position of the target DynAny is set to zero for values that have components&#xA;        * and to -1 for values that do not have components.&#xA;        *&#xA;        * @exception TypeMismatch if the type of the passed Any is not equivalent to the type of target DynAny&#xA;        * @exception InvalidValue if the passed Any does not contain a legal value (such as a null string)&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>omg</namespaces>
          <namespaces>CORBA</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../CORBA/Any.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="to_any">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;        * Creates an any value from a DynAny object.&#xA;        * A copy of the TypeCode associated with the DynAny object is assigned to the resulting any.&#xA;        * The value associated with the DynAny object is copied into the any.&#xA;        *&#xA;        * @return a new Any object with the same value and TypeCode&#xA;        */</comments>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>CORBA</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../CORBA/Any.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="equal">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;        * Compares two DynAny values for equality.&#xA;        * Two DynAny values are equal if their TypeCodes are equivalent and, recursively, all component DynAnys&#xA;        * have equal values.&#xA;        * The current position of the two DynAnys being compared has no effect on the result of equal.&#xA;        *&#xA;        * @return true of the DynAnys are equal, false otherwise&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dyn_any">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>omg</namespaces>
          <namespaces>DynamicAny</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="DynAny.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="destroy">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Destroys a DynAny object.&#xA;        * This operation frees any resources used to represent the data value associated with a DynAny object.&#xA;        * It must be invoked on references obtained from one of the creation operations on the ORB interface&#xA;        * or on a reference returned by DynAny.copy() to avoid resource leaks.&#xA;        * Invoking destroy on component DynAny objects (for example, on objects returned by the&#xA;        * current_component operation) does nothing.&#xA;        * Destruction of a DynAny object implies destruction of all DynAny objects obtained from it.&#xA;        * That is, references to components of a destroyed DynAny become invalid.&#xA;        * Invocations on such references raise OBJECT_NOT_EXIST.&#xA;        * It is possible to manipulate a component of a DynAny beyond the life time of the DynAny&#xA;        * from which the component was obtained by making a copy of the component with the copy operation&#xA;        * before destroying the DynAny from which the component was obtained.&#xA;        */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="copy">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;        * Creates a new DynAny object whose value is a deep copy of the DynAny on which it is invoked.&#xA;        * The operation is polymorphic, that is, invoking it on one of the types derived from DynAny,&#xA;        * such as DynStruct, creates the derived type but returns its reference as the DynAny base type.&#xA;        *&#xA;        * @return a deep copy of the DynAny object&#xA;        */</comments>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="DynAny.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_boolean">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a boolean value into the DynAny.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_octet">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a byte value into the DynAny. The IDL octet data type is mapped to the Java byte data type.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Byte"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_char">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a char value into the DynAny.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_short">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a short value into the DynAny.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Short"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_ushort">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a short value into the DynAny. The IDL ushort data type is mapped to the Java short data type.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Short"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_long">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts an integer value into the DynAny. The IDL long data type is mapped to the Java int data type.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_ulong">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts an integer value into the DynAny. The IDL ulong data type is mapped to the Java int data type.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_float">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a float value into the DynAny.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_double">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a double value into the DynAny.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_string">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a string value into the DynAny.&#xA;        * Both bounded and unbounded strings are inserted using this method.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception InvalidValue if the string inserted is longer than the bound of a bounded string&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_reference">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a reference to a CORBA object into the DynAny.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>omg</namespaces>
          <namespaces>CORBA</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../CORBA/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_typecode">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a TypeCode object into the DynAny.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>omg</namespaces>
          <namespaces>CORBA</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../CORBA/TypeCode.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_longlong">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a long value into the DynAny. The IDL long long data type is mapped to the Java long data type.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_ulonglong">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a long value into the DynAny.&#xA;        * The IDL unsigned long long data type is mapped to the Java long data type.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_wchar">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a char value into the DynAny. The IDL wchar data type is mapped to the Java char data type.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_wstring">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a string value into the DynAny.&#xA;        * Both bounded and unbounded strings are inserted using this method.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception InvalidValue if the string inserted is longer than the bound of a bounded string&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_any">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts an Any value into the Any represented by this DynAny.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>omg</namespaces>
          <namespaces>CORBA</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../CORBA/Any.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_dyn_any">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts the Any value contained in the parameter DynAny into the Any represented by this DynAny.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>omg</namespaces>
          <namespaces>DynamicAny</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="DynAny.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insert_val">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Inserts a reference to a Serializable object into this DynAny.&#xA;        * The IDL ValueBase type is mapped to the Java Serializable type.&#xA;        *&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../java/io/Serializable.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_boolean">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;        * Extracts the boolean value from this DynAny.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_octet">
      <typeReference xsi:type="types:Byte">
        <comments>/**&#xA;        * Extracts the byte value from this DynAny. The IDL octet data type is mapped to the Java byte data type.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_char">
      <typeReference xsi:type="types:Char">
        <comments>/**&#xA;        * Extracts the char value from this DynAny.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_short">
      <typeReference xsi:type="types:Short">
        <comments>/**&#xA;        * Extracts the short value from this DynAny.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_ushort">
      <typeReference xsi:type="types:Short">
        <comments>/**&#xA;        * Extracts the short value from this DynAny. The IDL ushort data type is mapped to the Java short data type.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_long">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;        * Extracts the integer value from this DynAny. The IDL long data type is mapped to the Java int data type.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_ulong">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;        * Extracts the integer value from this DynAny. The IDL ulong data type is mapped to the Java int data type.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_float">
      <typeReference xsi:type="types:Float">
        <comments>/**&#xA;        * Extracts the float value from this DynAny.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_double">
      <typeReference xsi:type="types:Double">
        <comments>/**&#xA;        * Extracts the double value from this DynAny.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_string">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;        * Extracts the string value from this DynAny.&#xA;        * Both bounded and unbounded strings are extracted using this method.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_reference">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;        * Extracts the reference to a CORBA Object from this DynAny.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>CORBA</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../CORBA/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_typecode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;        * Extracts the TypeCode object from this DynAny.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>CORBA</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../CORBA/TypeCode.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_longlong">
      <typeReference xsi:type="types:Long">
        <comments>/**&#xA;        * Extracts the long value from this DynAny. The IDL long long data type is mapped to the Java long data type.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_ulonglong">
      <typeReference xsi:type="types:Long">
        <comments>/**&#xA;        * Extracts the long value from this DynAny.&#xA;        * The IDL unsigned long long data type is mapped to the Java long data type.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_wchar">
      <typeReference xsi:type="types:Char">
        <comments>/**&#xA;        * Extracts the long value from this DynAny. The IDL wchar data type is mapped to the Java char data type.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_wstring">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;        * Extracts the string value from this DynAny.&#xA;        * Both bounded and unbounded strings are extracted using this method.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_any">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;        * Extracts an Any value contained in the Any represented by this DynAny.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>CORBA</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../CORBA/Any.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_dyn_any">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;        * Extracts the Any value contained in the Any represented by this DynAny and returns it wrapped&#xA;        * into a new DynAny.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="DynAny.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_val">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;        * Extracts a Serializable object from this DynAny.&#xA;        * The IDL ValueBase type is mapped to the Java Serializable type.&#xA;        *&#xA;        * @exception TypeMismatch if the accessed component in the DynAny is of a type&#xA;        * that is not equivalent to the requested type.&#xA;        * @exception TypeMismatch if called on a DynAny whose current component itself has components&#xA;        * @exception InvalidValue if this DynAny has components but has a current position of -1&#xA;        */</comments>
        <namespaces>java</namespaces>
        <namespaces>io</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../java/io/Serializable.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/InvalidValue.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="seek">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;        * Sets the current position to index. The current position is indexed 0 to n-1, that is,&#xA;        * index zero corresponds to the first component. The operation returns true if the resulting&#xA;        * current position indicates a component of the DynAny and false if index indicates&#xA;        * a position that does not correspond to a component.&#xA;        * Calling seek with a negative index is legal. It sets the current position to -1 to indicate&#xA;        * no component and returns false. Passing a non-negative index value for a DynAny that does not&#xA;        * have a component at the corresponding position sets the current position to -1 and returns false.&#xA;        */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rewind">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;        * Is equivalent to seek(0).&#xA;        */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="next">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;        * Advances the current position to the next component.&#xA;        * The operation returns true while the resulting current position indicates a component, false otherwise.&#xA;        * A false return value leaves the current position at -1.&#xA;        * Invoking next on a DynAny without components leaves the current position at -1 and returns false.&#xA;        */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="component_count">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;        * Returns the number of components of a DynAny.&#xA;        * For a DynAny without components, it returns zero.&#xA;        * The operation only counts the components at the top level.&#xA;        * For example, if component_count is invoked on a DynStruct with a single member,&#xA;        * the return value is 1, irrespective of the type of the member.&#xA;        * &lt;UL>&#xA;        * &lt;LI>For sequences, the operation returns the current number of elements.&#xA;        * &lt;LI>For structures, exceptions, and value types, the operation returns the number of members.&#xA;        * &lt;LI>For arrays, the operation returns the number of elements.&#xA;        * &lt;LI>For unions, the operation returns 2 if the discriminator indicates that a named member is active,&#xA;        * otherwise, it returns 1.&#xA;        * &lt;LI>For DynFixed and DynEnum, the operation returns zero.&#xA;        * &lt;/UL>&#xA;        */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="current_component">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;        * Returns the DynAny for the component at the current position.&#xA;        * It does not advance the current position, so repeated calls to current_component&#xA;        * without an intervening call to rewind, next, or seek return the same component.&#xA;        * The returned DynAny object reference can be used to get/set the value of the current component.&#xA;        * If the current component represents a complex type, the returned reference can be narrowed&#xA;        * based on the TypeCode to get the interface corresponding to the to the complex type.&#xA;        * Calling current_component on a DynAny that cannot have components,&#xA;        * such as a DynEnum or an empty exception, raises TypeMismatch.&#xA;        * Calling current_component on a DynAny whose current position is -1 returns a nil reference.&#xA;        * The iteration operations, together with current_component, can be used&#xA;        * to dynamically compose an any value. After creating a dynamic any, such as a DynStruct,&#xA;        * current_component and next can be used to initialize all the components of the value.&#xA;        * Once the dynamic value is completely initialized, to_any creates the corresponding any value.&#xA;        *&#xA;        * @exception TypeMismatch If called on a DynAny that cannot have components,&#xA;        * such as a DynEnum or an empty exception&#xA;        */</comments>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="DynAny.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>DynamicAny</namespaces>
        <namespaces>DynAnyPackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DynAnyPackage/TypeMismatch.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xD;&#xA;* org/omg/DynamicAny/DynAnyOperations.java .&#xD;&#xA;* Generated by the IDL-to-Java compiler (portable), version &quot;3.2&quot;&#xD;&#xA;* from ../../../../src/share/classes/org/omg/DynamicAny/DynamicAny.idl&#xD;&#xA;* Wednesday, May 28, 2008 8:37:43 AM GMT&#xD;&#xA;*/</comments>
      <comments>/**&#xA;    * Any values can be dynamically interpreted (traversed) and constructed through DynAny objects.&#xA;    * A DynAny object is associated with a data value which corresponds to a copy of the value&#xA;    * inserted into an any.&#xA;    * &lt;P>A DynAny object may be viewed as an ordered collection of component DynAnys.&#xA;    * For DynAnys representing a basic type, such as long, or a type without components,&#xA;    * such as an empty exception, the ordered collection of components is empty.&#xA;    * Each DynAny object maintains the notion of a current position into its collection&#xA;    * of component DynAnys. The current position is identified by an index value that runs&#xA;    * from 0 to n-1, where n is the number of components.&#xA;    * The special index value -1 indicates a current position that points nowhere.&#xA;    * For values that cannot have a current position (such as an empty exception),&#xA;    * the index value is fixed at -1.&#xA;    * If a DynAny is initialized with a value that has components, the index is initialized to 0.&#xA;    * After creation of an uninitialized DynAny (that is, a DynAny that has no value but a TypeCode&#xA;    * that permits components), the current position depends on the type of value represented by&#xA;    * the DynAny. (The current position is set to 0 or -1, depending on whether the new DynAny&#xA;    * gets default values for its components.)&#xA;    * &lt;P>The iteration operations rewind, seek, and next can be used to change the current position&#xA;    * and the current_component operation returns the component at the current position.&#xA;    * The component_count operation returns the number of components of a DynAny.&#xA;    * Collectively, these operations enable iteration over the components of a DynAny, for example,&#xA;    * to (recursively) examine its contents.&#xA;    * &lt;P>A constructed DynAny object is a DynAny object associated with a constructed type.&#xA;    * There is a different interface, inheriting from the DynAny interface, associated with&#xA;    * each kind of constructed type in IDL (fixed, enum, struct, sequence, union, array,&#xA;    * exception, and value type).&#xA;    * &lt;P>A constructed DynAny object exports operations that enable the creation of new DynAny objects,&#xA;    * each of them associated with a component of the constructed data value.&#xA;    * As an example, a DynStruct is associated with a struct value. This means that the DynStruct&#xA;    * may be seen as owning an ordered collection of components, one for each structure member.&#xA;    * The DynStruct object exports operations that enable the creation of new DynAny objects,&#xA;    * each of them associated with a member of the struct.&#xA;    * &lt;P>If a DynAny object has been obtained from another (constructed) DynAny object,&#xA;    * such as a DynAny representing a structure member that was created from a DynStruct,&#xA;    * the member DynAny is logically contained in the DynStruct.&#xA;    * Calling an insert or get operation leaves the current position unchanged.&#xA;    * Destroying a top-level DynAny object (one that was not obtained as a component of another DynAny)&#xA;    * also destroys any component DynAny objects obtained from it.&#xA;    * Destroying a non-top level DynAny object does nothing.&#xA;    * Invoking operations on a destroyed top-level DynAny or any of its descendants raises OBJECT_NOT_EXIST.&#xA;    * If the programmer wants to destroy a DynAny object but still wants to manipulate some component&#xA;    * of the data value associated with it, then he or she should first create a DynAny for the component&#xA;    * and, after that, make a copy of the created DynAny object.&#xA;    * &lt;P>The behavior of DynAny objects has been defined in order to enable efficient implementations&#xA;    * in terms of allocated memory space and speed of access. DynAny objects are intended to be used&#xA;    * for traversing values extracted from anys or constructing values of anys at runtime.&#xA;    * Their use for other purposes is not recommended.&#xA;    * &lt;P>Insert and get operations are necessary to handle basic DynAny objects&#xA;    * but are also helpful to handle constructed DynAny objects.&#xA;    * Inserting a basic data type value into a constructed DynAny object&#xA;    * implies initializing the current component of the constructed data value&#xA;    * associated with the DynAny object. For example, invoking insert_boolean on a&#xA;    * DynStruct implies inserting a boolean data value at the current position&#xA;    * of the associated struct data value.&#xA;    * A type is consistent for inserting or extracting a value if its TypeCode is equivalent to&#xA;    * the TypeCode contained in the DynAny or, if the DynAny has components, is equivalent to the TypeCode&#xA;    * of the DynAny at the current position.&#xA;    * &lt;P>DynAny and DynAnyFactory objects are intended to be local to the process in which they are&#xA;    * created and used. This means that references to DynAny and DynAnyFactory objects cannot be exported&#xA;    * to other processes, or externalized with ORB.object_to_string().&#xA;    * If any attempt is made to do so, the offending operation will raise a MARSHAL system exception.&#xA;    * Since their interfaces are specified in IDL, DynAny objects export operations defined in the standard&#xA;    * org.omg.CORBA.Object interface. However, any attempt to invoke operations exported through the Object&#xA;    * interface may raise the standard NO_IMPLEMENT exception.&#xA;    * An attempt to use a DynAny object with the DII may raise the NO_IMPLEMENT exception.&#xA;    */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
