<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/types ../../../java.ecore#/16" name="DynAny.java">
  <namespaces>org</namespaces>
  <namespaces>omg</namespaces>
  <namespaces>DynamicAny</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="DynAny">
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xD;&#xA;* org/omg/DynamicAny/DynAny.java .&#xD;&#xA;* Generated by the IDL-to-Java compiler (portable), version &quot;3.2&quot;&#xD;&#xA;* from ../../../../src/share/classes/org/omg/DynamicAny/DynamicAny.idl&#xD;&#xA;* Wednesday, May 28, 2008 8:37:43 AM GMT&#xD;&#xA;*/</comments>
      <comments>/**&#xA;    * Any values can be dynamically interpreted (traversed) and constructed through DynAny objects.&#xA;    * A DynAny object is associated with a data value which corresponds to a copy of the value&#xA;    * inserted into an any.&#xA;    * &lt;P>A DynAny object may be viewed as an ordered collection of component DynAnys.&#xA;    * For DynAnys representing a basic type, such as long, or a type without components,&#xA;    * such as an empty exception, the ordered collection of components is empty.&#xA;    * Each DynAny object maintains the notion of a current position into its collection&#xA;    * of component DynAnys. The current position is identified by an index value that runs&#xA;    * from 0 to n-1, where n is the number of components.&#xA;    * The special index value -1 indicates a current position that points nowhere.&#xA;    * For values that cannot have a current position (such as an empty exception),&#xA;    * the index value is fixed at -1.&#xA;    * If a DynAny is initialized with a value that has components, the index is initialized to 0.&#xA;    * After creation of an uninitialized DynAny (that is, a DynAny that has no value but a TypeCode&#xA;    * that permits components), the current position depends on the type of value represented by&#xA;    * the DynAny. (The current position is set to 0 or -1, depending on whether the new DynAny&#xA;    * gets default values for its components.)&#xA;    * &lt;P>The iteration operations rewind, seek, and next can be used to change the current position&#xA;    * and the current_component operation returns the component at the current position.&#xA;    * The component_count operation returns the number of components of a DynAny.&#xA;    * Collectively, these operations enable iteration over the components of a DynAny, for example,&#xA;    * to (recursively) examine its contents.&#xA;    * &lt;P>A constructed DynAny object is a DynAny object associated with a constructed type.&#xA;    * There is a different interface, inheriting from the DynAny interface, associated with&#xA;    * each kind of constructed type in IDL (fixed, enum, struct, sequence, union, array,&#xA;    * exception, and value type).&#xA;    * &lt;P>A constructed DynAny object exports operations that enable the creation of new DynAny objects,&#xA;    * each of them associated with a component of the constructed data value.&#xA;    * As an example, a DynStruct is associated with a struct value. This means that the DynStruct&#xA;    * may be seen as owning an ordered collection of components, one for each structure member.&#xA;    * The DynStruct object exports operations that enable the creation of new DynAny objects,&#xA;    * each of them associated with a member of the struct.&#xA;    * &lt;P>If a DynAny object has been obtained from another (constructed) DynAny object,&#xA;    * such as a DynAny representing a structure member that was created from a DynStruct,&#xA;    * the member DynAny is logically contained in the DynStruct.&#xA;    * Calling an insert or get operation leaves the current position unchanged.&#xA;    * Destroying a top-level DynAny object (one that was not obtained as a component of another DynAny)&#xA;    * also destroys any component DynAny objects obtained from it.&#xA;    * Destroying a non-top level DynAny object does nothing.&#xA;    * Invoking operations on a destroyed top-level DynAny or any of its descendants raises OBJECT_NOT_EXIST.&#xA;    * If the programmer wants to destroy a DynAny object but still wants to manipulate some component&#xA;    * of the data value associated with it, then he or she should first create a DynAny for the component&#xA;    * and, after that, make a copy of the created DynAny object.&#xA;    * &lt;P>The behavior of DynAny objects has been defined in order to enable efficient implementations&#xA;    * in terms of allocated memory space and speed of access. DynAny objects are intended to be used&#xA;    * for traversing values extracted from anys or constructing values of anys at runtime.&#xA;    * Their use for other purposes is not recommended.&#xA;    * &lt;P>Insert and get operations are necessary to handle basic DynAny objects&#xA;    * but are also helpful to handle constructed DynAny objects.&#xA;    * Inserting a basic data type value into a constructed DynAny object&#xA;    * implies initializing the current component of the constructed data value&#xA;    * associated with the DynAny object. For example, invoking insert_boolean on a&#xA;    * DynStruct implies inserting a boolean data value at the current position&#xA;    * of the associated struct data value.&#xA;    * A type is consistent for inserting or extracting a value if its TypeCode is equivalent to&#xA;    * the TypeCode contained in the DynAny or, if the DynAny has components, is equivalent to the TypeCode&#xA;    * of the DynAny at the current position.&#xA;    * &lt;P>DynAny and DynAnyFactory objects are intended to be local to the process in which they are&#xA;    * created and used. This means that references to DynAny and DynAnyFactory objects cannot be exported&#xA;    * to other processes, or externalized with ORB.object_to_string().&#xA;    * If any attempt is made to do so, the offending operation will raise a MARSHAL system exception.&#xA;    * Since their interfaces are specified in IDL, DynAny objects export operations defined in the standard&#xA;    * org.omg.CORBA.Object interface. However, any attempt to invoke operations exported through the Object&#xA;    * interface may raise the standard NO_IMPLEMENT exception.&#xA;    * An attempt to use a DynAny object with the DII may raise the NO_IMPLEMENT exception.&#xA;    */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="DynAnyOperations.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
    <extends xsi:type="types:NamespaceClassifierReference">
      <namespaces>org</namespaces>
      <namespaces>omg</namespaces>
      <namespaces>CORBA</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../CORBA/Object.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
    <extends xsi:type="types:NamespaceClassifierReference">
      <namespaces>org</namespaces>
      <namespaces>omg</namespaces>
      <namespaces>CORBA</namespaces>
      <namespaces>portable</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../CORBA/portable/IDLEntity.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
