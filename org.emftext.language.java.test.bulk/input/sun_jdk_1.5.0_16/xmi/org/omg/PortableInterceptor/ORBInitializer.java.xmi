<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/types ../../../java.ecore#/16" name="ORBInitializer.java">
  <namespaces>org</namespaces>
  <namespaces>omg</namespaces>
  <namespaces>PortableInterceptor</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="ORBInitializer">
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xD;&#xA;* org/omg/PortableInterceptor/ORBInitializer.java .&#xD;&#xA;* Generated by the IDL-to-Java compiler (portable), version &quot;3.2&quot;&#xD;&#xA;* from ../../../../src/share/classes/org/omg/PortableInterceptor/Interceptors.idl&#xD;&#xA;* Wednesday, May 28, 2008 8:37:40 AM GMT&#xD;&#xA;*/</comments>
      <comments>/**&#xA;   * Facilitates interceptor registration and ORB initialization.&#xA;   * &lt;p>&#xA;   * Interceptors are intended to be a means by which ORB services gain &#xA;   * access to ORB processing, effectively becoming part of the ORB. &#xA;   * Since Interceptors are part of the ORB, when &lt;code>ORB.init&lt;/code> &#xA;   * returns an ORB, the Interceptors shall have been registered. &#xA;   * Interceptors cannot be registered on an ORB after it has been &#xA;   * returned by a call to &lt;code>ORB.init&lt;/code>.&#xA;   * &lt;p>&#xA;   * An Interceptor is registered by registering an associated &#xA;   * &lt;code>ORBInitializer&lt;/code> object which implements the &#xA;   * &lt;code>ORBInitializer&lt;/code> interface. When an ORB is initializing, &#xA;   * it shall call each registered &lt;code>ORBInitializer&lt;/code>, passing it &#xA;   * an &lt;code>ORBInitInfo&lt;/code> object which is used to register its &#xA;   * Interceptor.&#xA;   * &lt;p>&#xA;   * &lt;b>Registering ORB Initializers in Java&lt;/b>&#xA;   * &lt;p>&#xA;   * ORBInitializers are registered via Java ORB properties.&#xA;   * &lt;p>&#xA;   * The property names are of the form: &#xA;   *   &lt;blockquote>&lt;code>&#xA;   *     org.omg.PortableInterceptor.ORBInitializerClass.&amp;lt;Service&amp;gt;&#xA;   *   &lt;/code>&lt;/blockquote>&#xA;   * where &lt;code>&amp;lt;Service&amp;gt;&lt;/code> is the string name of a class &#xA;   * which implements &#xA;   *   &lt;blockquote>&lt;code>&#xA;   *     org.omg.PortableInterceptor.ORBInitializer&#xA;   *   &lt;/code>&lt;/blockquote>&#xA;   * To avoid name collisions, the reverse DNS name convention should be &#xA;   * used. For example, if company X has three initializers, it could define &#xA;   * the following properties: &#xA;   * &lt;ul>&#xA;   *   &lt;li>&lt;code>&#xA;   *     org.omg.PortableInterceptor.ORBInitializerClass.com.x.Init1&#xA;   *   &lt;/code>&lt;/li>&#xA;   *   &lt;li>&lt;code>&#xA;   *     org.omg.PortableInterceptor.ORBInitializerClass.com.x.Init2&#xA;   *   &lt;/code>&lt;/li>&#xA;   *   &lt;li>&lt;code>&#xA;   *     org.omg.PortableInterceptor.ORBInitializerClass.com.x.Init3&#xA;   *   &lt;/code>&lt;/li>&#xA;   * &lt;/ul>&#xA;   * During ORB.init, these ORB properties which begin with &#xA;   * &lt;code>org.omg.PortableInterceptor.ORBInitializerClass&lt;/code> shall be &#xA;   * collected, the &lt;code>&amp;lt;Service&amp;gt;&lt;/code> portion of each property &#xA;   * shall be extracted, an object shall be instantiated with the &#xA;   * &lt;code>&amp;lt;Service&amp;gt;&lt;/code> string as its class name, and the &#xA;   * &lt;code>pre_init&lt;/code> and &lt;code>post_init&lt;/code> methods shall be &#xA;   * called on that object. If there are any exceptions, the ORB shall &#xA;   * ignore them and proceed. &#xA;   * &lt;p>&#xA;   * &lt;b>&lt;i>Example&lt;/i>&lt;/b>&#xA;   * &lt;p>&#xA;   * A client-side logging service written by company X, for example, may &#xA;   * have the following ORBInitializer implementation: &#xA;   * &lt;code>&lt;pre>&#xA;   * package com.x.logging;&#xA;   * &#xA;   * import org.omg.PortableInterceptor.Interceptor; &#xA;   * import org.omg.PortableInterceptor.ORBInitializer; &#xA;   * import org.omg.PortableInterceptor.ORBInitInfo; &#xA;   * &#xA;   * public class LoggingService implements ORBInitializer { &#xA;   *     void pre_init( ORBInitInfo info ) { &#xA;   *         // Instantiate the Logging Service s Interceptor. &#xA;   *         Interceptor interceptor = new LoggingInterceptor(); &#xA;   *&#xA;   *         // Register the Logging Service s Interceptor. &#xA;   *         info.add_client_request_interceptor( interceptor ); &#xA;   *     } &#xA;   * &#xA;   *     void post_init( ORBInitInfo info ) { &#xA;   *         // This service does not need two init points. &#xA;   *     } &#xA;   * } &#xA;   * &lt;/pre>&lt;/code>&#xA;   * To run a program called &lt;code>MyApp&lt;/code> using this logging &#xA;   * service, the user could type: &#xA;   *   &lt;blockquote>&lt;code>&#xA;   *     java &#xA;   *-Dorg.omg.PortableInterceptor.ORBInitializerClass.com.x.Logging.LoggingService &#xA;   *     MyApp&#xA;   *   &lt;/code>&lt;/blockquote>&#xA;   * &lt;p>&#xA;   * &lt;b>Notes about Registering Interceptors&lt;/b>&#xA;   * &lt;p>&#xA;   * Request Interceptors are registered on a per-ORB basis. &#xA;   * &lt;p>&#xA;   * To achieve virtual per-object Interceptors, query the policies on the &#xA;   * target from within the interception points to determine whether they &#xA;   * should do any work. &#xA;   * &lt;p>&#xA;   * To achieve virtual per-POA Interceptors, instantiate each POA with a &#xA;   * different ORB. While Interceptors may be ordered administratively, &#xA;   * there is no concept of order with respect to the registration of &#xA;   * Interceptors. Request Interceptors are concerned with service contexts. &#xA;   * Service contexts have no order, so there is no purpose for request &#xA;   * Interceptors to have an order. IOR Interceptors are concerned with &#xA;   * tagged components. Tagged components also have no order, so there &#xA;   * is no purpose for IOR Interceptors to have an order. &#xA;   * &lt;p>&#xA;   * Registration code should avoid using the ORB (i.e., calling &#xA;   * &lt;code>ORB.init&lt;/code> with the provided &lt;code>orb_id&lt;/code>). Since &#xA;   * registration occurs during ORB initialization, results of invocations &#xA;   * on this ORB while it is in this state are undefined. &#xA;   * &#xA;   * @see ORBInitInfo&#xA;   */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="ORBInitializerOperations.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
    <extends xsi:type="types:NamespaceClassifierReference">
      <namespaces>org</namespaces>
      <namespaces>omg</namespaces>
      <namespaces>CORBA</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../CORBA/Object.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
    <extends xsi:type="types:NamespaceClassifierReference">
      <namespaces>org</namespaces>
      <namespaces>omg</namespaces>
      <namespaces>CORBA</namespaces>
      <namespaces>portable</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../CORBA/portable/IDLEntity.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
