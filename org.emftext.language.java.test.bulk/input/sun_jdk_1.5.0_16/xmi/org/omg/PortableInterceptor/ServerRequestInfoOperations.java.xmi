<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="ServerRequestInfoOperations.java">
  <namespaces>org</namespaces>
  <namespaces>omg</namespaces>
  <namespaces>PortableInterceptor</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="ServerRequestInfoOperations">
    <members xsi:type="members:InterfaceMethod" name="sending_exception">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Returns an any which contains the exception to be returned to &#xA;     * the client. &#xA;     * &lt;p>&#xA;     * If the exception is a user exception which cannot be inserted into &#xA;     * an any (e.g., it is unknown or the bindings don't provide the &#xA;     * &lt;code>TypeCode&lt;/code>), then this attribute will be an any &#xA;     * containing the system exception &lt;code>UNKNOWN&lt;/code> with a &#xA;     * standard minor code of 1.&#xA;     *&#xA;     * @see &lt;a href=&quot;package-summary.html#unimpl&quot;>&#xA;     *     &lt;code>PortableInterceptor&lt;/code> package comments for &#xA;     *     limitations / unimplemented features&lt;/a>&#xA;     */</comments>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>CORBA</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../CORBA/Any.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="object_id">
      <typeReference xsi:type="types:Byte">
        <comments>/**&#xA;     * Returns the opaque &lt;code>object_id&lt;/code> describing the target of &#xA;     * the operation invocation.&#xA;     */</comments>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="adapter_id">
      <typeReference xsi:type="types:Byte">
        <comments>/** &#xA;     * Returns the opaque identifier for the object adapter.&#xA;     */</comments>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="server_id">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns the server ID that was specified on ORB::init using the -ORBServerId&#xA;     * argument.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="orb_id">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/** &#xA;     * Returns the ID that was used to create the ORB.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="adapter_name">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/** &#xA;     * Returns the sequence of strings that identifies the object&#xA;     * adapter instance that is handling this request.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="target_most_derived_interface">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns the repository id for the most derived interface of the &#xA;     * servant.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_server_policy">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Returns the policy in effect for this operation for the given &#xA;     * policy type. The returned &lt;code>CORBA.Policy&lt;/code> object shall &#xA;     * only be a policy whose type was registered via &#xA;     * &lt;code>register_policy_factory&lt;/code>. &#xA;     * &#xA;     * @param type The &lt;code>CORBA.PolicyType&lt;/code> which specifies the &#xA;     *     policy to be returned. &#xA;     * @return The &lt;code>CORBA.Policy&lt;/code> obtained with the given &#xA;     *     policy type.&#xA;     * @exception INV_POLICY thrown, with a standard minor code of 2, if&#xA;     *     a policy for the given type was not registered via &#xA;     *     &lt;code>register_policy_factory&lt;/code>.&#xA;     * @see ORBInitInfo#register_policy_factory&#xA;     */</comments>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>CORBA</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../CORBA/Policy.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="set_slot">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Allows an Interceptor to set a slot in the &#xA;     * &lt;code>PortableInterceptor.Current&lt;/code> that is in the scope of &#xA;     * the request. If data already exists in that slot, it will be &#xA;     * overwritten. &#xA;     * &#xA;     * @param id The id of the slot. &#xA;     * @param data The data, in the form of an any, to store in that slot.&#xA;     * @exception InvalidSlot thrown if the ID does not define an allocated &#xA;     *     slot. &#xA;     * @see Current&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="id">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>omg</namespaces>
          <namespaces>CORBA</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../CORBA/Any.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>PortableInterceptor</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidSlot.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="target_is_a">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns true if the servant is the given repository id, &#xA;     * false if it is not. &#xA;     *&#xA;     * @param id The caller wants to know if the servant is this &#xA;     *     repository id. &#xA;     * @return Is the servant the given RepositoryId?&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="id">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="add_reply_service_context">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Allows Interceptors to add service contexts to the request. &#xA;     * &lt;p>&#xA;     * There is no declaration of the order of the service contexts. &#xA;     * They may or may not appear in the order that they are added. &#xA;     *&#xA;     * @param service_context The &lt;code>IOP.ServiceContext&lt;/code> to add to &#xA;     *     the reply. &#xA;     * @param replace Indicates the behavior of this operation when a &#xA;     *     service context already exists with the given ID. If false, &#xA;     *     then &lt;code>BAD_INV_ORDER&lt;/code> with a standard minor code of 15 &#xA;     *     is thrown. If true, then the existing service context is &#xA;     *     replaced by the new one.&#xA;     * @exception BAD_INV_ORDER thrown, with a standard minor code of 15, if&#xA;     *     replace is false and a service context already exists with the&#xA;     *     given ID.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="service_context">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>omg</namespaces>
          <namespaces>IOP</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../IOP/ServiceContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="replace">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xD;&#xA;* org/omg/PortableInterceptor/ServerRequestInfoOperations.java .&#xD;&#xA;* Generated by the IDL-to-Java compiler (portable), version &quot;3.2&quot;&#xD;&#xA;* from ../../../../src/share/classes/org/omg/PortableInterceptor/Interceptors.idl&#xD;&#xA;* Wednesday, May 28, 2008 8:37:40 AM GMT&#xD;&#xA;*/</comments>
      <comments>/**&#xA;   * Request Information, accessible to server-side request interceptors.&#xA;   * &lt;p>&#xA;   * Some attributes and operations on &lt;code>ServerRequestInfo&lt;/code> are not &#xA;   * valid at all interception points.  The following table shows the validity &#xA;   * of each attribute or operation.  If it is not valid, attempting to access &#xA;   * it will result in a &lt;code>BAD_INV_ORDER&lt;/code> being thrown with a &#xA;   * standard minor code of 14.&#xA;   * &lt;p>&#xA;   *&#xA;   *&#xA;   * &lt;table border=1 summary=&quot;Shows the validity of each attribute or operation&quot;>&#xA;   *   &lt;thead>&#xA;   *     &lt;tr>&#xA;   *       &lt;th>&amp;nbsp;&lt;/th>&#xA;   *       &lt;th id=&quot;rec_req_ser_con&quot; valign=&quot;bottom&quot;>receive_request_&lt;br>service_contexts&lt;/th>&#xA;   *       &lt;th id=&quot;rec_req&quot;  valign=&quot;bottom&quot;>receive_request&lt;/th>&#xA;   *       &lt;th id=&quot;send_rep&quot; valign=&quot;bottom&quot;>send_reply&lt;/th>&#xA;   *       &lt;th id=&quot;send_exc&quot; valign=&quot;bottom&quot;>send_exception&lt;/th>&#xA;   *       &lt;th id=&quot;send_oth&quot; valign=&quot;bottom&quot;>send_other&lt;/th>&#xA;   *     &lt;/tr>&#xA;   *   &lt;/thead>&#xA;   *  &lt;tbody>&#xA;   *&#xA;   *&#xA;   * &lt;tr>&#xA;   *   &lt;td id=&quot;ri&quot; colspan=6>&lt;i>Inherited from RequestInfo:&lt;/i>&lt;/td>&#xA;   * &lt;/tr>&#xA;   *&#xA;   * &lt;tr>&lt;th id=&quot;req_id&quot;>&lt;p align=&quot;left&quot;>request_id&lt;/p>&lt;/th>&#xA;   * &lt;td headers=&quot;ri req_id rec_req_ser_con&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri req_id rec_req&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri req_id send_rep&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri req_id send_exc&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri req_id send_oth&quot;>yes&lt;/td>&lt;/tr>&#xA;   *&#xA;   * &lt;tr>&lt;th id=&quot;op&quot;>&lt;p align=&quot;left&quot;>operation&lt;/p>&lt;/th>&#xA;   * &lt;td headers=&quot;ri op rec_req_ser_con&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri op rec_req&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri op send_rep&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri op send_exc&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri op send_oth&quot;>yes&lt;/td>&lt;/tr>&#xA;   *&#xA;   * &lt;tr>&lt;th id=&quot;args&quot;>&lt;p align=&quot;left&quot;>arguments&lt;/p>&lt;/th>&#xA;   * &lt;td headers=&quot;ri args rec_req_ser_con&quot;>no &lt;/td> &#xA;   * &lt;td headers=&quot;ri args rec_req&quot;>yes&lt;sub>1&lt;/sub>&lt;/td>&#xA;   * &lt;td headers=&quot;ri args send_rep&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri args send_exc&quot;>no&lt;sub>2&lt;/sub>&lt;/td>&#xA;   * &lt;td headers=&quot;ri args send_oth&quot;>no&lt;sub>2&lt;/sub>&#xA;   * &lt;/td>&lt;/tr>&#xA;   *&#xA;   * &lt;tr>&lt;th id=&quot;exps&quot;>&lt;p align=&quot;left&quot;>exceptions&lt;/p>&lt;/th>&#xA;   * &lt;td headers=&quot;ri exps rec_req_ser_con&quot;>no &lt;/td> &#xA;   * &lt;td headers=&quot;ri exps rec_req&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri exps send_rep&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri exps send_exc&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri exps send_oth&quot;>yes&lt;/td>&lt;/tr>&#xA;   *&#xA;   * &lt;tr>&lt;th id=&quot;contexts&quot;>&lt;p align=&quot;left&quot;>contexts&lt;/p>&lt;/th>&#xA;   * &lt;td headers=&quot;ri contexts rec_req_ser_con&quot;>no &lt;/td> &#xA;   * &lt;td headers=&quot;ri contexts rec_req&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri contexts send_rep&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri contexts send_exc&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri contexts send_oth&quot;>yes&lt;/td>&lt;/tr>&#xA;   *&#xA;   * &lt;tr>&lt;th id=&quot;op_con&quot;>&lt;p align=&quot;left&quot;>operation_context&lt;/p>&lt;/th>&#xA;   * &lt;td headers=&quot;ri op_con rec_req_ser_con&quot;>no &lt;/td> &#xA;   * &lt;td headers=&quot;ri op_con rec_req&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri op_con send_rep&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri op_con send_exc&quot;>no &lt;/td> &#xA;   * &lt;td headers=&quot;ri op_con send_oth&quot;>no &lt;/td>&#xA;   * &lt;/tr>&#xA;   * &#xA;   * &lt;tr>&lt;th id=&quot;result&quot;>&lt;p align=&quot;left&quot;>result&lt;/p>&lt;/th>&#xA;   * &lt;td headers=&quot;ri result rec_req_ser_con&quot;>no &lt;/td> &#xA;   * &lt;td headers=&quot;ri result rec_req&quot;>no &lt;/td> &#xA;   * &lt;td headers=&quot;ri result send_rep&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri result send_exc&quot;>no &lt;/td> &#xA;   * &lt;td headers=&quot;ri result send_oth&quot;>no &lt;/td>&#xA;   * &lt;/tr>&#xA;   *&#xA;   * &lt;tr>&lt;th id=&quot;res_ex&quot;>&lt;p align=&quot;left&quot;>response_expected&lt;/p>&lt;/th>&#xA;   * &lt;td headers=&quot;ri res_ex rec_req_ser_con&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri res_ex rec_req&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri res_ex send_rep&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri res_ex send_exc&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri res_ex send_oth&quot;>yes&lt;/td>&lt;/tr>&#xA;   *&#xA;   * &lt;tr>&lt;th id=&quot;syn_scp&quot;>&lt;p align=&quot;left&quot;>sync_scope&lt;/p>&lt;/th>&#xA;   * &lt;td headers=&quot;ri syn_scp rec_req_ser_con&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri syn_scp rec_req&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri syn_scp send_rep&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri syn_scp send_exc&quot;>yes&lt;/td> &#xA;   * &lt;td headers=&quot;ri syn_scp send_oth&quot;>yes&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>request_id&lt;/b>&lt;/td>&#xA;   *    &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>operation&lt;/b>&lt;/td>&#xA;   *    &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>arguments&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>yes&lt;sub>1&lt;/sub&lt;/td> &#xA;   *                              &lt;td>yes&lt;/td> &lt;td>no&lt;sub>2&lt;/sub>&lt;/td> &#xA;   *                                                        &lt;td>no&lt;sub>2&lt;/sub>&#xA;   *                                                        &lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>exceptions&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>contexts&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>operation_context&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>no &lt;/td> &lt;td>no &lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>result&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>no &lt;/td> &lt;td>no &lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>response_expected&lt;/b>&lt;/td>&#xA;   *    &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>sync_scope&lt;/b>&lt;/td>&#xA;   *    &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>reply_status&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>forward_reference&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>no &lt;/td> &lt;td>no &lt;/td> &lt;td>no &lt;/td> &lt;td>yes&lt;sub>2&lt;/sub>&#xA;   * &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>get_slot&lt;/b>&lt;/td>&#xA;   *    &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>get_request_service_context&lt;/b>&lt;/td>&#xA;   *    &lt;td>yes&lt;/td> &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>get_reply_service_context&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&#xA;   *      &lt;td colspan=6>&lt;i>ServerRequestInfo-specific:&lt;/i>&lt;/td>&#xA;   *    &lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>sending_exception&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>no &lt;/td> &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>no &lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>object_id&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;sub>3&lt;/sub>&lt;/td> &#xA;   * &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;       &lt;td>yes&lt;sub>3&lt;/sub>&#xA;   * &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                &lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>adapter_id&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;sub>3&lt;/sub>&lt;/td> &#xA;   * &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;       &lt;td>yes&lt;sub>3&lt;/sub>&#xA;   * &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>server_id&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   *&#xA;   *    &lt;tr>&lt;td>&lt;b>orb_id&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   *&#xA;   *    &lt;tr>&lt;td>&lt;b>adapter_name&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   *&#xA;   *    &lt;tr>&lt;td>&lt;b>target_most_derived_interface&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>no&lt;sub>4&lt;/sub>&lt;/td> &#xA;   * &#x9;&#x9;&#x9;&#x9;&#x9;  &lt;td>no&lt;sub>4&lt;/sub>&lt;/td> &#xA;   * &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;       &lt;td>no&lt;sub>4&lt;/sub>&#xA;   * &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;       &lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>get_server_policy&lt;/b>&lt;/td>&#xA;   *    &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>set_slot&lt;/b>&lt;/td>&#xA;   *    &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>target_is_a&lt;/b>&lt;/td>&#xA;   *    &lt;td>no &lt;/td> &lt;td>yes&lt;/td> &lt;td>no&lt;sub>4&lt;/sub>&lt;/td> &#xA;   * &#x9;&#x9;&#x9;&#x9;&#x9;  &lt;td>no&lt;sub>4&lt;/sub>&lt;/td> &#xA;   * &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;       &lt;td>no&lt;sub>4&lt;/sub>&#xA;   * &#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;       &lt;/td>&lt;/tr>&#xA;   * &#xA;   *    &lt;tr>&lt;td>&lt;b>add_reply_service_context&lt;/b>&lt;/td>&#xA;   *    &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td> &lt;td>yes&lt;/td>&lt;/tr>&#xA;   *   &lt;/tbody>&#xA;   * &lt;/table>&#xA;   *&#xA;   * &lt;ol>&#xA;   *   &lt;li>When &lt;code>ServerRequestInfo&lt;/code> is passed to &#xA;   *       &lt;code>receive_request&lt;/code>, there is an entry in the list for &#xA;   *       every argument, whether in, inout, or out. But only the in and &#xA;   *       inout arguments will be available.&lt;/li>&#xA;   *   &lt;li>If the &lt;code>reply_status&lt;/code> attribute is not &#xA;   *       &lt;code>LOCATION_FORWARD&lt;/code>, accessing this attribute will throw&#xA;   *       &lt;code>BAD_INV_ORDER&lt;/code> with a standard minor code of 14.&lt;/li>&#xA;   *   &lt;li>If the servant locator caused a location forward, or thrown an &#xA;   *       exception, this attribute/operation may not be available in this &#xA;   *       interception point. &lt;code>NO_RESOURCES&lt;/code> with a standard minor &#xA;   *       code of 1 will be thrown if it is not available.&lt;/li>&#xA;   *   &lt;li>The operation is not available in this interception point because &#xA;   *       the necessary information requires access to the target object's &#xA;   *       servant, which may no longer be available to the ORB. For example, &#xA;   *       if the object's adapter is a POA that uses a &#xA;   *       &lt;code>ServantLocator&lt;/code>, then the ORB invokes the interception &#xA;   *       point after it calls &lt;code>ServantLocator.postinvoke()&lt;/code>&lt;/li>.&#xA;   * &lt;/ol>&#xA;   *&#xA;   * @see ServerRequestInterceptor&#xA;   */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <namespaces>org</namespaces>
      <namespaces>omg</namespaces>
      <namespaces>PortableInterceptor</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="RequestInfoOperations.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
