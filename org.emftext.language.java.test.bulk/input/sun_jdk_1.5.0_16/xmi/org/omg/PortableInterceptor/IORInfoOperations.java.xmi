<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="IORInfoOperations.java">
  <namespaces>org</namespaces>
  <namespaces>omg</namespaces>
  <namespaces>PortableInterceptor</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="IORInfoOperations">
    <members xsi:type="members:InterfaceMethod" name="get_effective_policy">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Allows an ORB service implementation to determine what server side &#xA;     * policy of a particular type is in effect for an IOR being &#xA;     * constructed.  When the IOR being constructed is for an object &#xA;     * implemented using a POA, all Policy objects passed to the &#xA;     * &lt;code>PortableServer.POA.create_POA&lt;/code> call that created that &#xA;     * POA are accessable via &lt;code>get_effective_policy&lt;/code>. &#xA;     * &lt;p>&#xA;     * If a policy for the given type is not known to the ORB, then this &#xA;     * operation will throw &lt;code>INV_POLICY&lt;/code> with a standard minor &#xA;     * code of 2. &#xA;     * &#xA;     * @param type an int specifying the type of policy to return. &#xA;     * @return The effective &lt;code>CORBA.Policy&lt;/code> object of the &#xA;     *     requested type. If the given policy type is known, but no policy &#xA;     *     of that type is in effect, then this operation will return a &#xA;     *     nil object reference.&#xA;     */</comments>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>CORBA</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../CORBA/Policy.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="add_ior_component">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * A portable ORB service implementation calls &#xA;     * &lt;code>add_ior_component&lt;/code> from its implementation of &#xA;     * &lt;code>establish_components&lt;/code> to add a tagged component to the &#xA;     * set which will be included when constructing IORs. The components in &#xA;     * this set will be included in all profiles. &#xA;     * &lt;p>&#xA;     * Any number of components may exist with the same component ID. &#xA;     * &#xA;     * @param a_component The IOP.TaggedComponent to add.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tagged_component">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>omg</namespaces>
          <namespaces>IOP</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../IOP/TaggedComponent.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="add_ior_component_to_profile">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * A portable ORB service implementation calls &#xA;     * &lt;code>add_ior_component_to_profile&lt;/code> from its implementation of &#xA;     * &lt;code>establish_components&lt;/code> to add a tagged component to the &#xA;     * set which will be included when constructing IORs. The components in &#xA;     * this set will be included in the specified profile. &#xA;     * &lt;p>&#xA;     * Any number of components may exist with the same component ID. &#xA;     * &#xA;     * @param a_component The &lt;code>IOP.TaggedComponent&lt;/code> to add. &#xA;     * @param profile_id The profile id of the profile to &#xA;     *     which this component will be added.&#xA;     * @exception BAD_PARAM thrown, with a standard minor code of 29, if the &#xA;     *     given profile ID does not define a known profile or it is &#xA;     *     impossible to add components to that profile.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tagged_component">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>omg</namespaces>
          <namespaces>IOP</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../IOP/TaggedComponent.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="profile_id">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="manager_id">
      <typeReference xsi:type="types:Int">
        <comments>/** Return the adapter manager id of the object adapter&#xA;     * that was just created and is running IOR interceptors.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="state">
      <typeReference xsi:type="types:Short">
        <comments>/** Return the adapter state of the object adapter&#xA;     * that was just created and is running IOR interceptors.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="adapter_template">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/** Return the object reference template of the object adapter&#xA;     * that was just created and is running IOR interceptors.&#xA;     */</comments>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>PortableInterceptor</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="ObjectReferenceTemplate.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="current_factory">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/** On read, returns the current factory that will be used to create&#xA;     * object references for the object adapter that was just created&#xA;     * and is running IOR interceptors.  By default, this factory is the same&#xA;     * as the value of the adapter_template attribute.  The current_factory &#xA;     * may also be set to another object reference template inside an&#xA;     * IORInterceptor_3_0.&#xA;     */</comments>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>PortableInterceptor</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="ObjectReferenceFactory.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="current_factory">
      <typeReference xsi:type="types:Void">
        <comments>/** On read, returns the current factory that will be used to create&#xA;     * object references for the object adapter that was just created&#xA;     * and is running IOR interceptors.  By default, this factory is the same&#xA;     * as the value of the adapter_template attribute.  The current_factory &#xA;     * may also be set to another object reference template inside an&#xA;     * IORInterceptor_3_0.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newCurrent_factory">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>omg</namespaces>
          <namespaces>PortableInterceptor</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="ObjectReferenceFactory.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xD;&#xA;* org/omg/PortableInterceptor/IORInfoOperations.java .&#xD;&#xA;* Generated by the IDL-to-Java compiler (portable), version &quot;3.2&quot;&#xD;&#xA;* from ../../../../src/share/classes/org/omg/PortableInterceptor/Interceptors.idl&#xD;&#xA;* Wednesday, May 28, 2008 8:37:40 AM GMT&#xD;&#xA;*/</comments>
      <comments>/**&#xA;   * Provides the server-side ORB service with access to the applicable &#xA;   * policies during IOR construction and the ability to add components. &#xA;   * The ORB passes an instance of its implementation of this interface as &#xA;   * a parameter to &lt;code>IORInterceptor.establish_components&lt;/code>.&#xA;   *&#xA;   * @see IORInterceptor&#xA;   */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
