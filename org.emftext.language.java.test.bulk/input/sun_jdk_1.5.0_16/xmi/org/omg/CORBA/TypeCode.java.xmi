<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="TypeCode.java">
  <comments>/*&#xA; * @(#)TypeCode.java&#x9;1.51 03/01/23&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>org</namespaces>
  <namespaces>omg</namespaces>
  <namespaces>CORBA</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>org</namespaces>
    <namespaces>omg</namespaces>
    <namespaces>CORBA</namespaces>
    <namespaces>TypeCodePackage</namespaces>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>omg</namespaces>
    <namespaces>CORBA</namespaces>
    <namespaces>portable</namespaces>
    <classifier xsi:type="classifiers:Interface" href="portable/IDLEntity.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="TypeCode">
    <members xsi:type="members:InterfaceMethod" name="equal">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares this &lt;code>TypeCode&lt;/code> object with the given one,&#xA;     * testing for equality. &lt;code>TypeCode&lt;/code> objects are equal if&#xA;     * they are interchangeable and give identical results when&#xA;     * &lt;code>TypeCode&lt;/code> operations are applied to them.&#xA;     *&#xA;     * @param tc &#x9;&#x9;the &lt;code>TypeCode&lt;/code> object to compare against&#xA;     * @return &#x9;&#x9;&lt;code>true&lt;/code> if the type codes are equal;&#xA;     *                &lt;code>false&lt;/code> otherwise&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="equivalent">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Tests to see if the given &lt;code>TypeCode&lt;/code> object is &#xA;&#x9; * equivalent to this &lt;code>TypeCode&lt;/code> object.&#xA;&#x9; * &lt;P>&#xA;&#x9; * &#xA;&#x9; *&#xA;&#x9; * @param tc the typecode to compare with this typecode&#xA;&#x9; *&#xA;&#x9; * @return &lt;code>true&lt;/code> if the given typecode is equivalent to&#xA;&#x9; *         this typecode; &lt;code>false&lt;/code> otherwise&#xA;     * &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get_compact_typecode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Strips out all optional name and member name fields,&#xA;     * but leaves all alias typecodes intact.&#xA;&#x9; * @return a &lt;code>TypeCode&lt;/code> object with optional name and &#xA;&#x9; *         member name fields stripped out, except for alias typecodes,&#xA;&#x9; *         which are left intact&#xA;     * @see &lt;a href=&quot;package-summary.html#unimpl&quot;>&lt;code>CORBA&lt;/code> package&#xA;     *      comments for unimplemented features&lt;/a>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="kind">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TCKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the kind of this &lt;code>TypeCode&lt;/code> object.&#xA;     * The kind of a type code determines which &lt;code>TypeCode&lt;/code>&#xA;     * methods may legally be invoked on it.&#xA;     * &lt;P>&#xA;     * The method &lt;code>kind&lt;/code> may be invoked on any&#xA;     * &lt;code>TypeCode&lt;/code> object.&#xA;     *&#xA;     * @return&#x9;the &lt;code>TCKind&lt;/code> instance indicating the&#xA;     *            value of the &lt;code>kind&lt;/code> field of this&#xA;     * &#x9;&#x9;&#x9;&lt;code>TypeCode&lt;/code> object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="id">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the RepositoryId globally identifying the type&#xA;     * of this &lt;code>TypeCode&lt;/code> object.&#xA;     * &lt;P>&#xA;     * The method &lt;code>id&lt;/code> can be invoked on object reference,&#xA;     * structure, union, enumeration, alias, exception, valuetype,&#xA;     * boxed valuetype, native, and abstract interface type codes.&#xA;     * Object reference, exception, valuetype, boxed valuetype,&#xA;     * native, and abstract interface &lt;code>TypeCode&lt;/code> objects&#xA;     * always have a RepositoryId.&#xA;     * Structure, union, enumeration, and alias &lt;code>TypeCode&lt;/code> objects&#xA;     * obtained from the Interface Repository or the method&#xA;     * &lt;code>ORB.create_operation_list&lt;/code>&#xA;     * also always have a RepositoryId. If there is no RepositoryId, the&#xA;     * method can return an empty string.&#xA;     *&#xA;     * @return&#x9;&#x9;the RepositoryId for this &lt;code>TypeCode&lt;/code> object&#xA;     *                or an empty string if there is no RepositoryID&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if the method&#xA;     *           is invoked on an inappropriate kind of&lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="name">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the simple name identifying this &lt;code>TypeCode&lt;/code>&#xA;     * object within its&#xA;     * enclosing scope. Since names are local to a Repository, the&#xA;     * name returned from a &lt;code>TypeCode&lt;/code> object&#xA;     * may not match the name of the&#xA;     * type in any particular Repository, and may even be an empty&#xA;     * string.&#xA;     * &lt;P>&#xA;     * The method &lt;code>name&lt;/code> can be invoked on object reference,&#xA;     * structure, union, enumeration, alias, exception, valuetype,&#xA;     * boxed valuetype, native, and abstract interface&#xA;     * &lt;code>TypeCode&lt;/code> objects.&#xA;     *&#xA;     * @return&#x9;&#x9;the name identifying this &lt;code>TypeCode&lt;/code> object&#xA;     *                or an empty string&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if the method&#xA;     *           is invoked on an inappropriate kind of&lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="member_count">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the number of members in the type described by&#xA;     * this &lt;code>TypeCode&lt;/code> object.&#xA;     * &lt;P>&#xA;     * The method &lt;code>member_count&lt;/code> can be invoked on&#xA;     * structure, union, and enumeration &lt;code>TypeCode&lt;/code> objects.&#xA;     * Java IDL extends the CORBA specification to allow this method to&#xA;     * operate on exceptions as well.&#xA;     *&#xA;     * @return&#x9;&#x9;the number of members constituting the type described&#xA;     *                by this &lt;code>TypeCode&lt;/code> object&#xA;     *&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if the method&#xA;     *           is invoked on an inappropriate kind of &lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="member_name">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>CORBA</namespaces>
        <namespaces>TypeCodePackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/Bounds.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the simple name of the member identified by&#xA;     * the given index. Since names are local to a&#xA;     * Repository, the name returned from a &lt;code>TypeCode&lt;/code> object&#xA;     * may not match the name of the member in any particular&#xA;     * Repository, and may even be an empty string.&#xA;     * &lt;P>&#xA;     * The  method &lt;code>member_name&lt;/code> can be invoked on structure, union,&#xA;     * and enumeration &lt;code>TypeCode&lt;/code> objects.&#xA;     * Java IDL extends the CORBA specification to allow this method to&#xA;     * operate on exceptions as well.&#xA;     *&#xA;     * @param index&#x9;index of the member for which a name is being reqested&#xA;     * @return&#x9;&#x9;simple name of the member identified by the&#xA;     *&#x9;&#x9;&#x9;index or an empty string&#xA;     * @throws org.omg.CORBA.TypeCodePackage.Bounds if the index is equal&#xA;     *            to or greater than&#xA;     *&#x9;&#x9;&#x9;the number of members constituting the type&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if the method&#xA;     *           is invoked on an inappropriate kind of &lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="member_type">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>CORBA</namespaces>
        <namespaces>TypeCodePackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/Bounds.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the &lt;code>TypeCode&lt;/code> object describing the type&#xA;     * of the member identified by the given index.&#xA;     * &lt;P>&#xA;     * The method &lt;code>member_type&lt;/code> can be invoked on structure&#xA;     * and union &lt;code>TypeCode&lt;/code> objects.&#xA;     * Java IDL extends the CORBA specification to allow this method to&#xA;     * operate on exceptions as well.&#xA;     *&#xA;     * @param index&#x9;index of the member for which type information&#xA;     *                is begin requested&#xA;     * @return&#x9;&#x9;the &lt;code>TypeCode&lt;/code> object describing the&#xA;     *                member at the given index&#xA;     * @throws org.omg.CORBA.TypeCodePackage.Bounds if the index is&#xA;     *                equal to or greater than&#xA;     *&#x9;&#x9;&#x9;    the number of members constituting the type&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if the method&#xA;     *           is invoked on an inappropriate kind of &lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="member_label">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Any.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>CORBA</namespaces>
        <namespaces>TypeCodePackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/Bounds.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the label of the union member&#xA;     * identified by the given index. For the default member,&#xA;     * the label is the zero octet.&#xA;     *&lt;P>&#xA;     * The method &lt;code>member_label&lt;/code> can only be invoked on union&#xA;     * &lt;code>TypeCode&lt;/code> objects.&#xA;     *&#xA;     * @param index&#x9;index of the union member for which the&#xA;     *                label is being requested&#xA;     * @return&#x9;&#x9;an &lt;code>Any&lt;/code> object describing the label of&#xA;     *                the requested union member or the zero octet for&#xA;     *                the default member&#xA;     * @throws org.omg.CORBA.TypeCodePackage.Bounds if the index is&#xA;     *                equal to or greater than&#xA;     *&#x9;&#x9;&#x9;    the number of members constituting the union&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if the method&#xA;     *           is invoked on a non-union &lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="discriminator_type">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>TypeCode&lt;/code> object describing&#xA;     * all non-default member labels.&#xA;     * The method &lt;code>discriminator_type&lt;/code> can be invoked only&#xA;     * on union &lt;code>TypeCode&lt;/code> objects.&#xA;     *&#xA;     * @return&#x9;&#x9;the &lt;code>TypeCode&lt;/code> object describing&#xA;     *                the non-default member labels&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if the method&#xA;     *           is invoked on a non-union &lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="default_index">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index of the&#xA;     * default member, or -1 if there is no default member.&#xA;     * &lt;P>&#xA;     * The method &lt;code>default_index&lt;/code> can be invoked only on union&#xA;     * &lt;code>TypeCode&lt;/code> objects.&#xA;     *&#xA;     * @return&#x9;&#x9;the index of the default member, or -1 if&#xA;     *&#x9;&#x9;&#x9;there is no default member&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if the method&#xA;     *           is invoked on a non-union &lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="length">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the number of elements in the type described by&#xA;     * this &lt;code>TypeCode&lt;/code> object.&#xA;     * For strings and sequences, it returns the&#xA;     * bound, with zero indicating an unbounded string or sequence.&#xA;     * For arrays, it returns the number of elements in the array.&#xA;     * &lt;P>&#xA;     * The method &lt;code>length&lt;/code> can be invoked on string, sequence, and&#xA;     * array &lt;code>TypeCode&lt;/code> objects.&#xA;     *&#xA;     * @return&#x9;&#x9;the bound for strings and sequences, or the&#xA;     *&#x9;&#x9;&#x9;    number of elements for arrays&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if the method&#xA;     *           is invoked on an inappropriate kind of &lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="content_type">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>TypeCode&lt;/code> object representing the&#xA;     * IDL type for the members of the object described by this&#xA;     * &lt;code>TypeCode&lt;/code> object.&#xA;     * For sequences and arrays, it returns the&#xA;     * element type. For aliases, it returns the original type. Note&#xA;     * that multidimensional arrays are represented by nesting&#xA;     * &lt;code>TypeCode&lt;/code> objects, one per dimension.&#xA;     * For boxed valuetypes, it returns the boxed type.&#xA;     *&lt;P>&#xA;     * The method &lt;code>content_type&lt;/code> can be invoked on sequence, array,&#xA;     * alias, and boxed valuetype &lt;code>TypeCode&lt;/code> objects.&#xA;     *&#xA;     * @return&#x9;a &lt;code>TypeCode&lt;/code> object representing&#xA;     *            the element type for sequences and arrays, the&#xA;     *&#x9;&#x9;original type for aliases, or the&#xA;     *            boxed type for boxed valuetypes.&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if the method&#xA;     *           is invoked on an inappropriate kind of &lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="fixed_digits">
      <typeReference xsi:type="types:Short"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Returns the number of digits in the fixed type described by this&#xA;&#x9; * &lt;code>TypeCode&lt;/code> object. For example, the typecode for&#xA;&#x9; * the number 3000.275d could be &lt;code>fixed&lt;7,3>&lt;/code>, where&#xA;&#x9; * 7 is the precision and 3 is the scale.&#xA;&#x9; *&#xA;&#x9; * @return the total number of digits&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if this method&#xA;     *           is invoked on an inappropriate kind of &lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;&#x9; *&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="fixed_scale">
      <typeReference xsi:type="types:Short"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Returns the scale of the fixed type described by this &#xA;&#x9; * &lt;code>TypeCode&lt;/code> object. A positive number indicates the&#xA;&#x9; * number of digits to the right of the decimal point. &#xA;&#x9; * For example, the number 3000d could have the&#xA;&#x9; * typecode &lt;code>fixed&lt;4,0>&lt;/code>, where the first number is&#xA;&#x9; * the precision and the second number is the scale.&#xA;&#x9; * A negative number is also possible and adds zeroes to the&#xA;&#x9; * left of the decimal point.  In this case, &lt;code>fixed&lt;1,-3>&lt;/code>,&#xA;&#x9; * could be the typecode for the number 3000d.&#xA;&#x9; *&#xA;&#x9; * @return the scale of the fixed type that this&#xA;&#x9; *         &lt;code>TypeCode&lt;/code> object describes&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if this method&#xA;     *           is invoked on an inappropriate kind of &lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="member_visibility">
      <typeReference xsi:type="types:Short"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>omg</namespaces>
        <namespaces>CORBA</namespaces>
        <namespaces>TypeCodePackage</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/Bounds.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Returns the constant that indicates the visibility of the member&#xA;     * at the given index.&#xA;     *&#xA;     * This operation can only be invoked on non-boxed value&#xA;     * &lt;code>TypeCode&lt;/code> objects.&#xA;     *&#xA;     * @param index an &lt;code>int&lt;/code> indicating the index into the&#xA;     *               value&#xA;     * @return either &lt;code>PRIVATE_MEMBER.value&lt;/code> or&#xA;     *          &lt;code>PUBLIC_MEMBER.value&lt;/code>&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if this method&#xA;     *           is invoked on a non-value type &lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;     * @throws org.omg.CORBA.TypeCodePackage.Bounds&#xA;     *           if the given index is out of bounds &#xA;     * @see &lt;a href=&quot;package-summary.html#unimpl&quot;>&lt;code>CORBA&lt;/code> package&#xA;     *      comments for unimplemented features&lt;/a>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="type_modifier">
      <typeReference xsi:type="types:Short"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Returns a constant indicating the modifier of the value type&#xA;     * that this &lt;code>TypeCode&lt;/code> object describes.  The constant&#xA;     * returned must be one of the following: &lt;code>VM_NONE.value&lt;/code>,&#xA;     * &lt;code>VM_ABSTRACT.value&lt;/code>, &lt;code>VM_CUSTOM.value&lt;/code>,&#xA;     * or &lt;code>VM_TRUNCATABLE.value&lt;/code>,&#xA;     *&#xA;     * @return a constant describing the value type&#xA;     *         that this &lt;code>TypeCode&lt;/code> object describes&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind&#xA;     *           if this method&#xA;     *           is invoked on a non-value type &lt;code>TypeCode&lt;/code>&#xA;     *           object&#xA;     * @see &lt;a href=&quot;package-summary.html#unimpl&quot;>&lt;code>CORBA&lt;/code> package&#xA;     *      comments for unimplemented features&lt;/a>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="concrete_base_type">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TypeCodePackage/BadKind.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Returns the &lt;code>TypeCode&lt;/code> object that describes the concrete base type&#xA;     * of the value type that this &lt;code>TypeCode&lt;/code> object describes.&#xA;     * Returns null if it doesn't have a concrete base type.&#xA;     *&#xA;     * @return the &lt;code>TypeCode&lt;/code> object that describes the&#xA;     * concrete base type of the value type&#xA;     * that this &lt;code>TypeCode&lt;/code> object describes&#xA;     * @throws org.omg.CORBA.TypeCodePackage.BadKind if this method&#xA;     *           is invoked on a non-boxed value type &lt;code>TypeCode&lt;/code> object&#xA;     * @see &lt;a href=&quot;package-summary.html#unimpl&quot;>&lt;code>CORBA&lt;/code> package&#xA;     *      comments for unimplemented features&lt;/a>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A container for information about a specific CORBA data&#xA; * type.&#xA; *&lt;P>&#xA; * &lt;code>TypeCode&lt;/code> objects are used:&#xA; * &lt;UL>&#xA; * &lt;LI>in the Dynamic Invocation Interface -- to indicate the types&#xA; * of the actual arguments or the type of the return value.  &lt;BR>&#xA; * &lt;code>NamedValue&lt;/code> objects are used to represent arguments and&#xA; * return values.  One of their components is an &lt;code>Any&lt;/code>&#xA; * object, which in turn has as one of its components a&#xA; * &lt;code>TypeCode&lt;/code> object.&#xA; * &lt;LI>by an Interface Repository to represent the type specifications&#xA; * that are part of many OMG IDL declarations&#xA; * &lt;/UL>&#xA; * &lt;P>&#xA; * The representation of a &lt;code>TypeCode&lt;/code> object is opaque,&#xA; * but abstractly, a &lt;code>TypeCode&lt;/code> object consists of:&#xA; * &lt;UL>&#xA; * &lt;LI>a &lt;code>kind&lt;/code> field, which is set to an instance&#xA; * of the class &lt;code>TCKind&lt;/code>&#xA; * &lt;LI>zero or more additional fields appropriate&#xA; * for the particular kind. For example, the&#xA; * &lt;code>TypeCode&lt;/code> object&#xA; * describing the OMG IDL type &lt;code>1ong&lt;/code> has kind&#xA; * &lt;code>TCKind.tk_long&lt;/code> and no additional fields.&#xA; * The &lt;code>TypeCode&lt;/code> describing OMG IDL type&#xA; * &lt;code>sequence&amp;lt;boolean, 10&amp;gt;&lt;/code> has a &lt;code>kind&lt;/code> field&#xA; * with the value&#xA; * &lt;code>TCKind.tk_sequence&lt;/code> and also fields with the values&#xA; * &lt;code>boolean&lt;/code> and &lt;code>10&lt;/code> for the&#xA; * type of sequence elements and the length of the sequence. &lt;p>&#xA; * &lt;/UL>&#xA; *&#xA; * &lt;code>TypeCode&lt;/code> objects can be obtained in various ways:&#xA; * &lt;OL>&#xA; * &lt;LI>from a call to the method &lt;code>Any.insert_X&lt;/code>, where X is&#xA; * a basic IDL type.  This method creates a &lt;code>TypeCode&lt;/code> object&#xA; * for type X and assigns it to the &lt;code>Any&lt;/code> object's&#xA; * &lt;code>type&lt;/code> field.&#xA; * &lt;LI>from invocations of methods in the ORB class&#xA; * &lt;P>For example, the following creates a &lt;code>TypeCode&lt;/code>&#xA; * object for a &lt;code>string&lt;/code> with a maximum of 30 characters:&#xA; * &lt;PRE>&#xA; *   org.omg.CORBA.TypeCode tcString = orb.create_string_tc(30);&#xA; * &lt;/PRE>&#xA; * &lt;P> The following creates a &lt;code>TypeCode&lt;/code>&#xA; * object for an &lt;code>array&lt;/code> of five &lt;code>string&lt;/code>s:&#xA; * &lt;PRE>&#xA; *   org.omg.CORBA.TypeCode tcArray = orb.create_array_tc(&#xA; *                                       5, TCKind.tk_string);&#xA; * &lt;/PRE>&#xA; * &lt;P> The following creates a &lt;code>TypeCode&lt;/code>&#xA; * object for an interface named &quot;Account&quot;:&#xA; * &lt;PRE>&#xA; *   org.omg.CORBA.TypeCode tcInterface = orb.create_interface_tc(&#xA; *                                                 &quot;thisId&quot;, &quot;Account&quot;);&#xA; * &lt;/PRE>&#xA; * &lt;LI>as the return value from the &lt;code>_type&lt;/code> method&#xA; * in &lt;code>Holder&lt;/code> classes for user-defined&#xA; * IDL types.  These &lt;code>Holder&lt;/code> classes are generated&#xA; * by the &lt;code>idltojava&lt;/code> compiler.&#xA; * &lt;LI>from a CORBA Interface Repository&#xA; * &lt;/OL>&#xA; * &lt;P>&#xA; * Most of the methods in the class &lt;code>TypeCode&lt;/code>&#xA; * are accessors, and the information contained in a &lt;code>TypeCode&lt;/code>&#xA; * object is specific to a particular type.  Therefore, methods&#xA; * must be invoked&#xA; * only on the kind of type codes to which they apply.  If an&#xA; * accessor method&#xA; * tries to access information from an inappropriate kind of&#xA; * type code, it will throw&#xA; * the exception &lt;code>TypeCodePackage.BadKind&lt;/code>.  For example,&#xA; * if the method &lt;code>discriminator_type&lt;/code> is called on anything&#xA; * other than a &lt;code>union&lt;/code>, it will throw &lt;code>BadKind&lt;/code>&#xA; * because only &lt;code>union&lt;/code>s have a discriminator.&#xA; * The following list shows which methods apply to which kinds of&#xA; * type codes:&#xA; * &lt;P>&#xA; * These methods may be invoked on all &lt;code>TypeCode&lt;/code> kinds:&#xA; * &lt;UL>&#xA; * &lt;LI>&lt;code>equal&lt;/code>&#xA; * &lt;LI>&lt;code>kind&lt;/code>&#xA; * &lt;/UL>&#xA; * &lt;P>&#xA; * These methods may be invoked on &lt;code>objref&lt;/code>, &lt;code>struct&lt;/code>,&#xA; * &lt;code>union&lt;/code>, &lt;code>enum&lt;/code>,&#xA; * &lt;code>alias&lt;/code>, &lt;code>exception&lt;/code>, &lt;code>value&lt;/code>,&#xA; * &lt;code>value_box&lt;/code>, &lt;code>native&lt;/code>, &#xA; * and &lt;code>abstract_interface&lt;/code>:&#xA; * &lt;UL>&#xA; * &lt;LI>&lt;code>id&lt;/code>&#xA; * &lt;LI>&lt;code>name&lt;/code>&#xA; * &lt;/UL>&#xA; * &lt;P>&#xA; * These methods may be invoked on &lt;code>struct&lt;/code>,&#xA; * &lt;code>union&lt;/code>, &lt;code>enum&lt;/code>,&#xA; * and &lt;code>exception&lt;/code>:&#xA; * &lt;UL>&#xA; * &lt;LI>&lt;code>member_count&lt;/code>&#xA; * &lt;LI>&lt;code>member_name&lt;/code>&#xA; * &lt;/UL>&#xA; * &lt;P>&#xA; * These methods may be invoked on &lt;code>struct&lt;/code>,&#xA; * &lt;code>union&lt;/code>, and &lt;code>exception&lt;/code>:&#xA; * &lt;UL>&#xA; * &lt;LI>&lt;code>member_type(int index)&lt;/code>&#xA; * &lt;/UL>&#xA; * &lt;P>&#xA; * These methods may be invoked on &lt;code>union&lt;/code>:&#xA; * &lt;UL>&#xA; * &lt;LI>&lt;code>member_label&lt;/code>&#xA; * &lt;LI>&lt;code>discriminator_type&lt;/code>&#xA; * &lt;LI>&lt;code>default_index&lt;/code>&#xA; * &lt;/UL>&#xA; * &lt;P>&#xA; * These methods may be invoked on &lt;code>string&lt;/code>,&#xA; * &lt;code>sequence&lt;/code>, and &lt;code>array&lt;/code>:&#xA; * &lt;UL>&#xA; * &lt;LI>&lt;code>length&lt;/code>&#xA; * &lt;/UL>&#xA; * &lt;P>&#xA; * These methods may be invoked on &lt;code>alias&lt;/code>,&#xA; * &lt;code>sequence&lt;/code>, &lt;code>array&lt;/code>, and &lt;code>value_box&lt;/code>:&#xA; * &lt;UL>&#xA; * &lt;LI>&lt;code>content_type&lt;/code>&#xA; * &lt;/UL>&#xA; * &lt;P>&#xA; * Unlike other CORBA pseudo-objects, &lt;code>TypeCode&lt;/code>&#xA; * objects can be passed as general IDL parameters. &lt;p>&#xA; * The methods &lt;code>parameter&lt;/code> and &lt;code>param_count&lt;/code>,&#xA; * which are deprecated, are not mapped.  &lt;p>&#xA; *&#xA; * Java IDL extends the CORBA specification to allow all operations permitted&#xA; * on a &lt;code>struct&lt;/code> &lt;code>TypeCode&lt;/code> to be permitted&#xA; * on an &lt;code>exception&lt;/code> &lt;code>TypeCode&lt;/code> as well. &lt;p>&#xA; *&#xA; * @version 1.25 09/09/97&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="portable/IDLEntity.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
