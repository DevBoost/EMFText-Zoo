<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/types ../../../java.ecore#/16" name="GSSContext.java">
  <comments>/*&#xA; * @(#)GSSContext.java&#x9;1.9 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>org</namespaces>
  <namespaces>ietf</namespaces>
  <namespaces>jgss</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>sun</namespaces>
    <namespaces>security</namespaces>
    <namespaces>jgss</namespaces>
    <namespaces>spi</namespaces>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/io/InputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../java/io/OutputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="GSSContext">
    <members xsi:type="members:Field" name="DEFAULT_LIFETIME">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A lifetime constant representing the default context lifetime.  This&#xA;     * value is set to 0.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="INDEFINITE_LIFETIME">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="../../../java/lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
        </next>
        <target xsi:type="classifiers:Class" href="../../../java/lang/Integer.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**   &#xA;     * A lifetime constant representing indefinite context lifetime.&#xA;     * This value must is set to the maximum integer value in Java -&#xA;     * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="initSecContext">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inputBuf">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**    &#xA;     * Called by the context initiator to start the context creation&#xA;     * phase and process any tokens generated&#xA;     * by the peer's &lt;code>acceptSecContext&lt;/code> method.&#xA;     * This method may return an output token which the application will need&#xA;     * to send to the peer for processing by its &lt;code>acceptSecContext&lt;/code>&#xA;     * method. The application can call {@link #isEstablished()&#xA;     * isEstablished} to determine if the context establishment phase is&#xA;     * complete on this side of the context.  A return value of&#xA;     * &lt;code>false&lt;/code> from &lt;code>isEstablished&lt;/code> indicates that&#xA;     * more tokens are expected to be supplied to&#xA;     * &lt;code>initSecContext&lt;/code>.  Upon completion of the context&#xA;     * establishment, the available context options may be queried through&#xA;     * the get methods.&lt;p>&#xA;     *&#xA;     * Note that it is possible that the &lt;code>initSecContext&lt;/code> method&#xA;     * return a token for the peer, and &lt;code>isEstablished&lt;/code> return&#xA;     * &lt;code>true&lt;/code> also. This indicates that the token needs to be sent&#xA;     * to the peer, but the local end of the context is now fully&#xA;     * established.&lt;p>&#xA;     *&#xA;     * Some mechanism providers might require that the caller be granted&#xA;     * permission to initiate a security context. A failed permission check &#xA;     * might cause a {@link java.lang.SecurityException SecurityException}&#xA;     * to be thrown from this method.&lt;p>&#xA;     *&#xA;     * @return a byte[] containing the token to be sent to the&#xA;     * peer. &lt;code>null&lt;/code> indicates that no token is generated.&#xA;     * @param inputBuf token generated by the peer. This parameter is ignored&#xA;     * on the first call since no token has been received from the peer.&#xA;     * @param offset the offset within the inputBuf where the token begins.&#xA;     * @param len the length of the token.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},&#xA;     *   {@link GSSException#BAD_MIC GSSException.BAD_MIC},&#xA;     *   {@link GSSException#NO_CRED GSSException.NO_CRED},&#xA;     *   {@link GSSException#CREDENTIALS_EXPIRED &#xA;     *                                  GSSException.CREDENTIALS_EXPIRED},&#xA;     *   {@link GSSException#BAD_BINDINGS GSSException.BAD_BINDINGS},&#xA;     *   {@link GSSException#OLD_TOKEN GSSException.OLD_TOKEN},&#xA;     *   {@link GSSException#DUPLICATE_TOKEN GSSException.DUPLICATE_TOKEN},&#xA;     *   {@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},&#xA;     *   {@link GSSException#BAD_MECH GSSException.BAD_MECH},&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="initSecContext">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="outStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**    &#xA;     * Called by the context initiator to start the context creation&#xA;     * phase and process any tokens generated&#xA;     * by the peer's &lt;code>acceptSecContext&lt;/code> method using&#xA;     * streams. This method may write an output token to the&#xA;     * &lt;code>OutpuStream&lt;/code>, which the application will&#xA;     * need to send to the peer for processing by its&#xA;     * &lt;code>acceptSecContext&lt;/code> call. Typically, the application would&#xA;     * ensure this by calling the  {@link java.io.OutputStream#flush() flush}&#xA;     * method on an &lt;code>OutputStream&lt;/code> that encapsulates the&#xA;     * connection between the two peers. The application can&#xA;     * determine if a token is written to the OutputStream from the return&#xA;     * value of this method. A return value of &lt;code>0&lt;/code> indicates that&#xA;     * no token was written. The application can call&#xA;     * {@link #isEstablished() isEstablished} to determine if the context &#xA;     * establishment phase is complete on this side of the context. A&#xA;     * return  value of &lt;code>false&lt;/code> from &lt;code>isEstablished&lt;/code>&#xA;     * indicates that more tokens are expected to be supplied to&#xA;     * &lt;code>initSecContext&lt;/code>.&#xA;     * Upon completion of the context establishment, the available context&#xA;     * options may be queried through the get methods.&lt;p>&#xA;     *&#xA;     * Note that it is possible that the &lt;code>initSecContext&lt;/code> method&#xA;     * return a token for the peer, and &lt;code>isEstablished&lt;/code> return&#xA;     * &lt;code>true&lt;/code> also. This indicates that the token needs to be sent&#xA;     * to the peer, but the local end of the context is now fully&#xA;     * established.&lt;p>&#xA;     *&#xA;     * The GSS-API authentication tokens contain a definitive start and&#xA;     * end. This method will attempt to read one of these tokens per&#xA;     * invocation, and may block on the stream if only part of the token is&#xA;     * available.  In all other respects this method is equivalent to the&#xA;     * byte array based {@link #initSecContext(byte[], int, int)&#xA;     * initSecContext}.&lt;p>&#xA;     *&#xA;     * Some mechanism providers might require that the caller be granted&#xA;     * permission to initiate a security context. A failed permission check &#xA;     * might cause a {@link java.lang.SecurityException SecurityException}&#xA;     * to be thrown from this method.&lt;p>&#xA;     *&#xA;     * The following example code demonstrates how this method might be&#xA;     * used:&lt;p>&#xA;     * &lt;pre>&#xA;     *     InputStream is ...&#xA;     *     OutputStream os ...&#xA;     *     GSSContext context ...&#xA;     *&#xA;     *     // Loop while there is still a token to be processed&#xA;     *&#xA;     *     while (!context.isEstablished()) {&#xA;     *&#xA;     *         context.initSecContext(is, os);&#xA;     *&#xA;     *         // send output token if generated&#xA;     *         os.flush();&#xA;     *     }&#xA;     * &lt;/pre>&#xA;     * &#xA;     *&#xA;     * @return the number of bytes written to the OutputStream as part of the &#xA;     * token to be sent to the peer. A value of 0 indicates that no token&#xA;     * needs to be sent.&#xA;     * @param inStream an InputStream that contains the token generated by&#xA;     * the peer. This parameter is ignored on the first call since no token&#xA;     * has been or will be received from the peer at that point.&#xA;     * @param outStream an OutputStream where the output token will be&#xA;     * written. During the final stage of context establishment, there may be&#xA;     * no bytes written.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},&#xA;     *   {@link GSSException#BAD_MIC GSSException.BAD_MIC},&#xA;     *   {@link GSSException#NO_CRED GSSException.NO_CRED},&#xA;     *   {@link GSSException#CREDENTIALS_EXPIRED GSSException.CREDENTIALS_EXPIRED},&#xA;     *   {@link GSSException#BAD_BINDINGS GSSException.BAD_BINDINGS},&#xA;     *   {@link GSSException#OLD_TOKEN GSSException.OLD_TOKEN},&#xA;     *   {@link GSSException#DUPLICATE_TOKEN GSSException.DUPLICATE_TOKEN},&#xA;     *   {@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},&#xA;     *   {@link GSSException#BAD_MECH GSSException.BAD_MECH},&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="acceptSecContext">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inToken">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**    &#xA;     * Called by the context acceptor upon receiving a token from the&#xA;     * peer. This method may return an output token which the application&#xA;     * will need to send to the peer for further processing by its&#xA;     * &lt;code>initSecContext&lt;/code> call.&lt;p>&#xA;     *&#xA;     * The application can call {@link #isEstablished() isEstablished} to&#xA;     * determine if the context establishment phase is complete for this&#xA;     * peer.  A return value of &lt;code>false&lt;/code> from&#xA;     * &lt;code>isEstablished&lt;/code> indicates that more tokens are expected to&#xA;     * be supplied to this method.    Upon completion of the context&#xA;     * establishment, the available context options may be queried through&#xA;     * the get methods.&lt;p>&#xA;     *&#xA;     * Note that it is possible that &lt;code>acceptSecContext&lt;/code> return a&#xA;     * token for the peer, and &lt;code>isEstablished&lt;/code> return&#xA;     * &lt;code>true&lt;/code> also.  This indicates that the token needs to be&#xA;     * sent to the peer, but the local end of the context is now fully&#xA;     * established.&lt;p>&#xA;     *&#xA;     * Some mechanism providers might require that the caller be granted&#xA;     * permission to accept a security context. A failed permission check &#xA;     * might cause a {@link java.lang.SecurityException SecurityException}&#xA;     * to be thrown from this method.&lt;p>&#xA;     *&#xA;     * The following example code demonstrates how this method might be&#xA;     * used:&lt;p>&#xA;     * &lt;pre>&#xA;     *     byte[] inToken;&#xA;     *     byte[] outToken;&#xA;     *     GSSContext context ...&#xA;     *&#xA;     *     // Loop while there is still a token to be processed&#xA;     *&#xA;     *     while (!context.isEstablished()) {&#xA;     *         inToken = readToken();&#xA;     *         outToken = context.acceptSecContext(inToken, 0,&#xA;     *                                             inToken.length);&#xA;     *         // send output token if generated&#xA;     *         if (outToken != null)&#xA;     *             sendToken(outToken);&#xA;     *     }&#xA;     * &lt;/pre>&#xA;     * &#xA;     *&#xA;     * @return a byte[] containing the token to be sent to the&#xA;     * peer. &lt;code>null&lt;/code> indicates that no token is generated.&#xA;     * @param inToken token generated by the peer.&#xA;     * @param offset the offset within the inToken where the token begins.&#xA;     * @param len the length of the token.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},&#xA;     *   {@link GSSException#BAD_MIC GSSException.BAD_MIC},&#xA;     *   {@link GSSException#NO_CRED GSSException.NO_CRED},&#xA;     *   {@link GSSException#CREDENTIALS_EXPIRED &#xA;     *                               GSSException.CREDENTIALS_EXPIRED},&#xA;     *   {@link GSSException#BAD_BINDINGS GSSException.BAD_BINDINGS},&#xA;     *   {@link GSSException#OLD_TOKEN GSSException.OLD_TOKEN},&#xA;     *   {@link GSSException#DUPLICATE_TOKEN GSSException.DUPLICATE_TOKEN},&#xA;     *   {@link GSSException#BAD_MECH GSSException.BAD_MECH},&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="acceptSecContext">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="outStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**    &#xA;     * Called by the context acceptor to process a token from the peer using&#xA;     * streams.   It may write an output token to the&#xA;     * &lt;code>OutputStream&lt;/code>, which the application&#xA;     * will need to send to the peer for processing by its&#xA;     * &lt;code>initSecContext&lt;/code> method.  Typically, the application would&#xA;     * ensure this by calling the  {@link java.io.OutputStream#flush() flush}&#xA;     * method on an &lt;code>OutputStream&lt;/code> that encapsulates the&#xA;     * connection between the two peers. The application can call&#xA;     * {@link #isEstablished() isEstablished} to determine if the context&#xA;     * establishment phase is complete on this side of the context. A&#xA;     * return  value of &lt;code>false&lt;/code> from &lt;code>isEstablished&lt;/code>&#xA;     * indicates that more tokens are expected to be supplied to&#xA;     * &lt;code>acceptSecContext&lt;/code>. &#xA;     * Upon completion of the context establishment, the available context&#xA;     * options may be queried through the get methods.&lt;p>&#xA;     *&#xA;     * Note that it is possible that &lt;code>acceptSecContext&lt;/code> return a&#xA;     * token for the peer, and &lt;code>isEstablished&lt;/code> return&#xA;     * &lt;code>true&lt;/code> also.  This indicates that the token needs to be&#xA;     * sent to the peer, but the local end of the context is now fully&#xA;     * established.&lt;p>&#xA;     *&#xA;     * The GSS-API authentication tokens contain a definitive start and&#xA;     * end. This method will attempt to read one of these tokens per&#xA;     * invocation, and may block on the stream if only part of the token is&#xA;     * available. In all other respects this method is equivalent to the byte&#xA;     * array based {@link #acceptSecContext(byte[], int, int)&#xA;     * acceptSecContext}.&lt;p>&#xA;     *&#xA;     * Some mechanism providers might require that the caller be granted&#xA;     * permission to accept a security context. A failed permission check &#xA;     * might cause a {@link java.lang.SecurityException SecurityException}&#xA;     * to be thrown from this method.&lt;p>&#xA;     *&#xA;     * The following example code demonstrates how this method might be&#xA;     * used:&lt;p>&#xA;     * &lt;pre>&#xA;     *     InputStream is ...&#xA;     *     OutputStream os ...&#xA;     *     GSSContext context ...&#xA;     *&#xA;     *     // Loop while there is still a token to be processed&#xA;     *&#xA;     *     while (!context.isEstablished()) {&#xA;     *&#xA;     *         context.acceptSecContext(is, os);&#xA;     *&#xA;     *         // send output token if generated&#xA;     *         os.flush();&#xA;     *     }&#xA;     * &lt;/pre>&#xA;     * &#xA;     * &#xA;     * @param inStream an InputStream that contains the token generated by&#xA;     * the peer.&#xA;     * @param outStream an OutputStream where the output token will be&#xA;     * written. During the final stage of context establishment, there may be&#xA;     * no bytes written.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},&#xA;     *   {@link GSSException#BAD_MIC GSSException.BAD_MIC},&#xA;     *   {@link GSSException#NO_CRED GSSException.NO_CRED},&#xA;     *   {@link GSSException#CREDENTIALS_EXPIRED &#xA;     *                           GSSException.CREDENTIALS_EXPIRED},&#xA;     *   {@link GSSException#BAD_BINDINGS GSSException.BAD_BINDINGS},&#xA;     *   {@link GSSException#OLD_TOKEN GSSException.OLD_TOKEN},&#xA;     *   {@link GSSException#DUPLICATE_TOKEN GSSException.DUPLICATE_TOKEN},&#xA;     *   {@link GSSException#BAD_MECH GSSException.BAD_MECH},&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}     &#xA;     */</comments>
        <comments>/* Missing return value in RFC. int should have been returned.&#xA;     * -----------------------------------------------------------&#xA;     *&#xA;     * The application can determine if a token is written to the&#xA;     * OutputStream from the return value of this method. A return value of&#xA;     * &lt;code>0&lt;/code> indicates that no token was written.&#xA;     *&#xA;     * @return &lt;strong>the number of bytes written to the&#xA;     * OutputStream as part of the token to be sent to the peer. A value of&#xA;     * 0 indicates that no token  needs to be&#xA;     * sent.&lt;/strong>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isEstablished">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Used during context establishment to determine the state of the&#xA;     * context.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if this is a fully established context on&#xA;     * the caller's side and no more tokens are needed from the peer.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="dispose">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Releases any system resources and cryptographic information stored in &#xA;     * the context object and invalidates the context.&#xA;     *&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getWrapSizeLimit">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="qop">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="confReq">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="maxTokenSize">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**    &#xA;     * Used to determine limits on the size of the message &#xA;     * that can be passed to &lt;code>wrap&lt;/code>. Returns the maximum&#xA;     * message size that, if presented to the &lt;code>wrap&lt;/code> method with&#xA;     * the same &lt;code>confReq&lt;/code> and &lt;code>qop&lt;/code> parameters, will&#xA;     * result in an output token containing no more&#xA;     * than &lt;code>maxTokenSize&lt;/code> bytes.&lt;p>&#xA;     *&#xA;     * This call is intended for use by applications that communicate over&#xA;     * protocols that impose a maximum message size.  It enables the&#xA;     * application to fragment messages prior to applying protection.&lt;p>&#xA;     *&#xA;     * GSS-API implementations are recommended but not required to detect&#xA;     * invalid QOP values when &lt;code>getWrapSizeLimit&lt;/code> is called.&#xA;     * This routine guarantees only a maximum message size, not the&#xA;     * availability of specific QOP values for message protection.&lt;p>&#xA;     *&#xA;     * @param qop the level of protection wrap will be asked to provide.&#xA;     * @param confReq &lt;code>true&lt;/code> if wrap will be asked to provide&#xA;     * privacy, &lt;code>false&lt;/code>  otherwise.&#xA;     * @param maxTokenSize the desired maximum size of the token emitted by&#xA;     * wrap.&#xA;     * @return the maximum size of the input token for the given output&#xA;     * token size&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},&#xA;     *   {@link GSSException#BAD_QOP GSSException.BAD_QOP},&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="wrap">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inBuf">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="msgProp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MessageProp.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Applies per-message security services over the established security&#xA;     * context. The method will return a token with the&#xA;     * application supplied data and a cryptographic MIC over it.&#xA;     * The data may be encrypted if confidentiality (privacy) was&#xA;     * requested.&lt;p>&#xA;     *&#xA;     * The MessageProp object is instantiated by the application and used&#xA;     * to specify a QOP value which selects cryptographic algorithms, and a&#xA;     * privacy service to optionally encrypt the message.  The underlying&#xA;     * mechanism that is used in the call may not be able to provide the&#xA;     * privacy service.  It sets the actual privacy service that it does&#xA;     * provide in this MessageProp object which the caller should then&#xA;     * query upon return.  If the mechanism is not able to provide the&#xA;     * requested QOP, it throws a GSSException with the BAD_QOP code.&lt;p>&#xA;     *&#xA;     * Since some application-level protocols may wish to use tokens&#xA;     * emitted by wrap to provide &quot;secure framing&quot;, implementations should&#xA;     * support the wrapping of zero-length messages.&lt;p>&#xA;     *&#xA;     * The application will be responsible for sending the token to the&#xA;     * peer.&#xA;     *&#xA;     * @param inBuf application data to be protected.&#xA;     * @param offset the offset within the inBuf where the data begins.&#xA;     * @param len the length of the data&#xA;     * @param msgProp instance of MessageProp that is used by the&#xA;     * application to set the desired QOP and privacy state. Set the&#xA;     * desired QOP to 0 to request the default QOP. Upon return from this&#xA;     * method, this object will contain the the actual privacy state that&#xA;     * was applied to the message by the underlying mechanism.&#xA;     * @return a byte[] containing the token to be sent to the peer.&#xA;     *&#xA;     * @throws GSSException containing the following major error codes: &#xA;     *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},&#xA;     *   {@link GSSException#BAD_QOP GSSException.BAD_QOP},&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="wrap">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="outStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="msgProp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MessageProp.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Applies per-message security services over the established security&#xA;     * context using streams. The method will return a&#xA;     * token with the application supplied data and a cryptographic MIC over it.&#xA;     * The data may be encrypted if confidentiality&#xA;     * (privacy) was requested. This method is equivalent to the byte array&#xA;     * based {@link #wrap(byte[], int, int, MessageProp) wrap} method.&lt;p>&#xA;     *&#xA;     * The application will be responsible for sending the token to the&#xA;     * peer.  Typically, the application would&#xA;     * ensure this by calling the  {@link java.io.OutputStream#flush() flush}&#xA;     * method on an &lt;code>OutputStream&lt;/code> that encapsulates the&#xA;     * connection between the two peers.&lt;p>&#xA;     *&#xA;     * The MessageProp object is instantiated by the application and used&#xA;     * to specify a QOP value which selects cryptographic algorithms, and a&#xA;     * privacy service to optionally encrypt the message.  The underlying&#xA;     * mechanism that is used in the call may not be able to provide the&#xA;     * privacy service.  It sets the actual privacy service that it does&#xA;     * provide in this MessageProp object which the caller should then&#xA;     * query upon return.  If the mechanism is not able to provide the&#xA;     * requested QOP, it throws a GSSException with the BAD_QOP code.&lt;p>&#xA;     *&#xA;     * Since some application-level protocols may wish to use tokens&#xA;     * emitted by wrap to provide &quot;secure framing&quot;, implementations should&#xA;     * support the wrapping of zero-length messages.&lt;p>&#xA;     *&#xA;     * @param inStream an InputStream containing the application data to be&#xA;     * protected. All of the data that is available in&#xA;     * inStream is used.&#xA;     * @param outStream an OutputStream to write the protected message&#xA;     * to.&#xA;     * @param msgProp instance of MessageProp that is used by the&#xA;     * application to set the desired QOP and privacy state. Set the&#xA;     * desired QOP to 0 to request the default QOP. Upon return from this&#xA;     * method, this object will contain the the actual privacy state that&#xA;     * was applied to the message by the underlying mechanism.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},&#xA;     *   {@link GSSException#BAD_QOP GSSException.BAD_QOP},&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="unwrap">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inBuf">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="msgProp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MessageProp.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Used to process tokens generated by the &lt;code>wrap&lt;/code> method on&#xA;     * the other side of the context. The method will return the message&#xA;     * supplied by the peer application to its wrap call, while at the same&#xA;     * time verifying the embedded MIC for that message.&lt;p>&#xA;     *&#xA;     * The MessageProp object is instantiated by the application and is&#xA;     * used by the underlying mechanism to return information to the caller&#xA;     * such as the QOP, whether confidentiality was applied to the message,&#xA;     * and other supplementary message state information.&lt;p>&#xA;     *&#xA;     * Since some application-level protocols may wish to use tokens&#xA;     * emitted by wrap to provide &quot;secure framing&quot;, implementations should&#xA;     * support the wrapping and unwrapping of zero-length messages.&lt;p>&#xA;     *&#xA;     * @param inBuf a byte array containing the wrap token received from&#xA;     * peer.&#xA;     * @param offset the offset where the token begins.&#xA;     * @param len the length of the token&#xA;     * @param msgProp upon return from the method, this object will contain&#xA;     * the applied QOP, the privacy state of the message, and supplementary&#xA;     * information stating if the token was a duplicate, old, out of&#xA;     * sequence or arriving after a gap.&#xA;     * @return a byte[] containing the message unwrapped from the input&#xA;     * token.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},&#xA;     *   {@link GSSException#BAD_MIC GSSException.BAD_MIC},&#xA;     *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="unwrap">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="outStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="msgProp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MessageProp.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Uses streams to process tokens generated by the &lt;code>wrap&lt;/code>&#xA;     * method on the other side of the context. The method will return the&#xA;     * message supplied by the peer application to its wrap call, while at&#xA;     * the same time verifying the embedded MIC for that message.&lt;p>&#xA;     * &#xA;     * The MessageProp object is instantiated by the application and is&#xA;     * used by the underlying mechanism to return information to the caller&#xA;     * such as the QOP, whether confidentiality was applied to the message,&#xA;     * and other supplementary message state information.&lt;p>&#xA;     *&#xA;     * Since some application-level protocols may wish to use tokens&#xA;     * emitted by wrap to provide &quot;secure framing&quot;, implementations should&#xA;     * support the wrapping and unwrapping of zero-length messages.&lt;p>&#xA;     *&#xA;     * The format of the input token that this method&#xA;     * reads is defined in the specification for the underlying mechanism that&#xA;     * will be used. This method will attempt to read one of these tokens per&#xA;     * invocation. If the mechanism token contains a definitive start and&#xA;     * end this method may block on the &lt;code>InputStream&lt;/code> if only&#xA;     * part of the token is available. If the start and end of the token&#xA;     * are not definitive then the method will attempt to treat all&#xA;     * available bytes as part of the token.&lt;p>&#xA;     *&#xA;     * Other than the possible blocking behaviour described above, this&#xA;     * method is equivalent to the byte array based {@link #unwrap(byte[],&#xA;     * int, int, MessageProp) unwrap} method.&lt;p>&#xA;     *&#xA;     * @param inStream an InputStream that contains the wrap token generated&#xA;     * by the peer.&#xA;     * @param outStream an OutputStream to write the application message&#xA;     * to.&#xA;     * @param msgProp upon return from the method, this object will contain&#xA;     * the applied QOP, the privacy state of the message, and supplementary&#xA;     * information stating if the token was a duplicate, old, out of&#xA;     * sequence or arriving after a gap.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},&#xA;     *   {@link GSSException#BAD_MIC GSSException.BAD_MIC},&#xA;     *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMIC">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inMsg">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="msgProp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MessageProp.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Returns a token containing a cryptographic Message Integrity Code&#xA;     * (MIC) for the supplied message,  for transfer to the peer&#xA;     * application.  Unlike wrap, which encapsulates the user message in the&#xA;     * returned token, only the message MIC is returned in the output&#xA;     * token.&lt;p> &#xA;     *&#xA;     * Note that privacy can only be applied through the wrap call.&lt;p>&#xA;     *&#xA;     * Since some application-level protocols may wish to use tokens emitted&#xA;     * by getMIC to provide &quot;secure framing&quot;, implementations should support&#xA;     * derivation of MICs from zero-length messages.&#xA;     *&#xA;     * @param inMsg the message to generate the MIC over.&#xA;     * @param offset offset within the inMsg where the message begins.&#xA;     * @param len the length of the message&#xA;     * @param msgProp an instance of &lt;code>MessageProp&lt;/code> that is used&#xA;     * by the application to set the desired QOP.  Set the desired QOP to&#xA;     * &lt;code>0&lt;/code> in &lt;code>msgProp&lt;/code> to request the default&#xA;     * QOP. Alternatively pass in &lt;code>null&lt;/code> for &lt;code>msgProp&lt;/code>&#xA;     * to request the default QOP.&#xA;     * @return a byte[] containing the token to be sent to the peer.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},&#xA;     *   {@link GSSException#BAD_QOP GSSException.BAD_QOP},&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMIC">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="outStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="msgProp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MessageProp.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Uses streams to produce a token containing a cryptographic MIC for&#xA;     * the supplied message, for transfer to the peer application.&#xA;     * Unlike wrap, which encapsulates the user message in the returned&#xA;     * token, only the message MIC is produced in the output token. This&#xA;     * method is equivalent to the byte array based {@link #getMIC(byte[],&#xA;     * int, int, MessageProp) getMIC} method.&#xA;     *&#xA;     * Note that privacy can only be applied through the wrap call.&lt;p>&#xA;     *&#xA;     * Since some application-level protocols may wish to use tokens emitted&#xA;     * by getMIC to provide &quot;secure framing&quot;, implementations should support&#xA;     * derivation of MICs from zero-length messages.&#xA;     *&#xA;     * @param inStream an InputStream containing the message to generate the &#xA;     * MIC over. All of the data that is available in&#xA;     * inStream is used.&#xA;     * @param outStream an OutputStream to write the output token to.&#xA;     * @param msgProp an instance of &lt;code>MessageProp&lt;/code> that is used&#xA;     * by the application to set the desired QOP.  Set the desired QOP to&#xA;     * &lt;code>0&lt;/code> in &lt;code>msgProp&lt;/code> to request the default&#xA;     * QOP. Alternatively pass in &lt;code>null&lt;/code> for &lt;code>msgProp&lt;/code>&#xA;     * to request the default QOP.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},&#xA;     *   {@link GSSException#BAD_QOP GSSException.BAD_QOP},&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="verifyMIC">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inToken">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tokOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tokLen">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inMsg">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="msgOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="msgLen">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="msgProp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MessageProp.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Verifies the cryptographic MIC, contained in the token parameter,&#xA;     * over the supplied message.&lt;p>&#xA;     *&#xA;     * The MessageProp object is instantiated by the application and is used&#xA;     * by the underlying mechanism to return information to the caller such&#xA;     * as the QOP indicating the strength of protection that was applied to&#xA;     * the message and other supplementary message state information.&lt;p>&#xA;     *&#xA;     * Since some application-level protocols may wish to use tokens emitted&#xA;     * by getMIC to provide &quot;secure framing&quot;, implementations should support&#xA;     * the calculation and verification of MICs over zero-length messages.&#xA;     *&#xA;     * @param inToken the token generated by peer's getMIC method.&#xA;     * @param tokOffset the offset within the inToken where the token&#xA;     * begins.&#xA;     * @param tokLen the length of the token.&#xA;     * @param inMsg the application message to verify the cryptographic MIC&#xA;     * over.&#xA;     * @param msgOffset the offset in inMsg where the message begins.&#xA;     * @param msgLen the length of the message.&#xA;     * @param msgProp upon return from the method, this object will contain&#xA;     * the applied QOP and supplementary information stating if the token&#xA;     * was a duplicate, old, out of sequence or arriving after a gap.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN}&#xA;     *   {@link GSSException#BAD_MIC GSSException.BAD_MIC}&#xA;     *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED}&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="verifyMIC">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tokStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="msgStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="msgProp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MessageProp.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Uses streams to verify the cryptographic MIC, contained in the token&#xA;     * parameter, over the supplied message.  This method is equivalent to&#xA;     * the byte array based {@link #verifyMIC(byte[], int, int, byte[], int, &#xA;     * int, MessageProp) verifyMIC} method.&#xA;     *&#xA;     * The MessageProp object is instantiated by the application and is used&#xA;     * by the underlying mechanism to return information to the caller such&#xA;     * as the QOP indicating the strength of protection that was applied to&#xA;     * the message and other supplementary message state information.&lt;p>&#xA;     *&#xA;     * Since some application-level protocols may wish to use tokens emitted&#xA;     * by getMIC to provide &quot;secure framing&quot;, implementations should support&#xA;     * the calculation and verification of MICs over zero-length messages.&lt;p>&#xA;     *&#xA;     * The format of the input token that this method&#xA;     * reads is defined in the specification for the underlying mechanism that&#xA;     * will be used. This method will attempt to read one of these tokens per&#xA;     * invocation. If the mechanism token contains a definitive start and&#xA;     * end this method may block on the &lt;code>InputStream&lt;/code> if only&#xA;     * part of the token is available. If the start and end of the token&#xA;     * are not definitive then the method will attempt to treat all&#xA;     * available bytes as part of the token.&lt;p>&#xA;     *&#xA;     * Other than the possible blocking behaviour described above, this&#xA;     * method is equivalent to the byte array based {@link #verifyMIC(byte[],&#xA;     * int, int, byte[], int, int, MessageProp) verifyMIC} method.&lt;p>&#xA;     *&#xA;     * @param tokStream an InputStream containing the token generated by the &#xA;     * peer's getMIC method.&#xA;     * @param msgStream an InputStream containing the application message to&#xA;     * verify the cryptographic MIC over. All of the data&#xA;     * that is available in msgStream is used.&#xA;     * @param msgProp upon return from the method, this object will contain&#xA;     * the applied QOP and supplementary information stating if the token&#xA;     * was a duplicate, old, out of sequence or arriving after a gap.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN}&#xA;     *   {@link GSSException#BAD_MIC GSSException.BAD_MIC}&#xA;     *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED}&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="export">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Exports this context so that another process may&#xA;     * import it.. Provided to support the sharing of work between&#xA;     * multiple processes. This routine will typically be used by the&#xA;     * context-acceptor, in an application where a single process receives&#xA;     * incoming connection requests and accepts security contexts over&#xA;     * them, then passes the established context to one or more other&#xA;     * processes for message exchange.&lt;p>&#xA;     *&#xA;     * This method deactivates the security context and creates an&#xA;     * interprocess token which, when passed to {@link&#xA;     * GSSManager#createContext(byte[]) GSSManager.createContext} in&#xA;     * another process, will re-activate the context in the second process.&#xA;     * Only a single instantiation of a given context may be active at any&#xA;     * one time; a subsequent attempt by a context exporter to access the&#xA;     * exported security context will fail.&lt;p>&#xA;     *&#xA;     * The implementation may constrain the set of processes by which the&#xA;     * interprocess token may be imported, either as a function of local&#xA;     * security policy, or as a result of implementation decisions.  For&#xA;     * example, some implementations may constrain contexts to be passed&#xA;     * only between processes that run under the same account, or which are&#xA;     * part of the same process group.&lt;p>&#xA;     *&#xA;     * The interprocess token may contain security-sensitive information&#xA;     * (for example cryptographic keys).  While mechanisms are encouraged&#xA;     * to either avoid placing such sensitive information within&#xA;     * interprocess tokens, or to encrypt the token before returning it to&#xA;     * the application, in a typical GSS-API implementation this may not be&#xA;     * possible.  Thus the application must take care to protect the&#xA;     * interprocess token, and ensure that any process to which the token&#xA;     * is transferred is trustworthy. &lt;p>&#xA;     *&#xA;     * Implementations are not required to support the inter-process&#xA;     * transfer of security contexts.  Calling the {@link #isTransferable()&#xA;     * isTransferable} method will indicate if the context object is&#xA;     * transferable.&lt;p>&#xA;     *&#xA;     * Calling this method on a context that &#xA;     * is not exportable will result in this exception being thrown with&#xA;     * the error code {@link GSSException#UNAVAILABLE&#xA;     * GSSException.UNAVAILABLE}. &#xA;     *&#xA;     * @return a byte[] containing the exported context&#xA;     * @see GSSManager#createContext(byte[])&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#UNAVAILABLE GSSException.UNAVAILABLE},&#xA;     *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},&#xA;     *   {@link GSSException#NO_CONTEXT GSSException.NO_CONTEXT},&#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="requestMutualAuth">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="state">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Requests that mutual authentication be done during&#xA;     * context establishment. This request can only be made on the context&#xA;     * initiator's side and it has to be done prior to the first call to&#xA;     * &lt;code>initSecContext&lt;/code>.&lt;p>&#xA;     *&#xA;     * Not all mechanisms support mutual authentication and some mechanisms&#xA;     * might require mutual authentication even if the application&#xA;     * doesn't. Therefore, the application should check to see if the&#xA;     * request was honored with the {@link #getMutualAuthState()&#xA;     * getMutualAuthState} method.&lt;p>&#xA;     *&#xA;     * @param state a boolean value indicating whether mutual&#xA;     * authentication shouls be used or not.&#xA;     * @see #getMutualAuthState()&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="requestReplayDet">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="state">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Requests that replay detection be enabled for the&#xA;     * per-message security services after context establishemnt. This&#xA;     * request can only be made on the context initiator's side and it has&#xA;     * to be done prior to the first call to&#xA;     * &lt;code>initSecContext&lt;/code>. During context establishment replay&#xA;     * detection is not an option and is a function of the underlying&#xA;     * mechanism's capabilities.&lt;p>&#xA;     *&#xA;     * Not all mechanisms support replay detection and some mechanisms&#xA;     * might require replay detection even if the application&#xA;     * doesn't. Therefore, the application should check to see if the&#xA;     * request was honored with the {@link #getReplayDetState()&#xA;     * getReplayDetState} method. If replay detection is enabled then the&#xA;     * {@link MessageProp#isDuplicateToken() MessageProp.isDuplicateToken} and {@link&#xA;     * MessageProp#isOldToken() MessageProp.isOldToken} methods will return &#xA;     * valid results for the &lt;code>MessageProp&lt;/code> object that is passed&#xA;     * in to the &lt;code>unwrap&lt;/code> method or the &lt;code>verifyMIC&lt;/code>&#xA;     * method.&lt;p>&#xA;     *&#xA;     * @param state a boolean value indicating whether replay detection&#xA;     * should be enabled over the established context or not.&#xA;     * @see #getReplayDetState()&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="requestSequenceDet">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="state">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Requests that sequence checking be enabled for the&#xA;     * per-message security services after context establishemnt. This&#xA;     * request can only be made on the context initiator's side and it has&#xA;     * to be done prior to the first call to&#xA;     * &lt;code>initSecContext&lt;/code>. During context establishment sequence&#xA;     * checking is not an option and is a function of the underlying&#xA;     * mechanism's capabilities.&lt;p>&#xA;     *&#xA;     * Not all mechanisms support sequence checking and some mechanisms&#xA;     * might require sequence checking even if the application&#xA;     * doesn't. Therefore, the application should check to see if the&#xA;     * request was honored with the {@link #getSequenceDetState()&#xA;     * getSequenceDetState} method. If sequence checking is enabled then the&#xA;     * {@link MessageProp#isDuplicateToken() MessageProp.isDuplicateToken}, &#xA;     * {@link MessageProp#isOldToken() MessageProp.isOldToken},&#xA;     * {@link MessageProp#isUnseqToken() MessageProp.isUnseqToken}, and&#xA;     * {@link MessageProp#isGapToken() MessageProp.isGapToken} methods will return&#xA;     * valid results for the &lt;code>MessageProp&lt;/code> object that is passed&#xA;     * in to the &lt;code>unwrap&lt;/code> method or the &lt;code>verifyMIC&lt;/code>&#xA;     * method.&lt;p>&#xA;     *&#xA;     * @param state a boolean value indicating whether sequence checking&#xA;     * should be enabled over the established context or not.&#xA;     * @see #getSequenceDetState()&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="requestCredDeleg">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="state">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Requests that the initiator's credentials be&#xA;     * delegated to the acceptor during context establishment. This&#xA;     * request can only be made on the context initiator's side and it has&#xA;     * to be done prior to the first call to&#xA;     * &lt;code>initSecContext&lt;/code>.&#xA;     *&#xA;     * Not all mechanisms support credential delegation. Therefore, an&#xA;     * application that desires delegation should check to see if the&#xA;     * request was honored with the {@link #getCredDelegState()&#xA;     * getCredDelegState} method. If the application indicates that&#xA;     * delegation must not be used, then the mechanism will honor the&#xA;     * request and delegation will not occur. This is an exception&#xA;     * to the general rule that a mechanism may enable a service even if it &#xA;     * is not requested.&lt;p>&#xA;     *&#xA;     * @param state a boolean value indicating whether the credentials&#xA;     * should be delegated or not.&#xA;     * @see #getCredDelegState()&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="requestAnonymity">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="state">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Requests that the initiator's identity not be&#xA;     * disclosed to the acceptor. This request can only be made on the&#xA;     * context initiator's side and it has to be done prior to the first&#xA;     * call to &lt;code>initSecContext&lt;/code>.&#xA;     *&#xA;     * Not all mechanisms support anonymity for the initiator. Therefore, the&#xA;     * application should check to see if the request was honored with the&#xA;     * {@link #getAnonymityState() getAnonymityState} method.&lt;p>&#xA;     *&#xA;     * @param state a boolean value indicating if the initiator should &#xA;     * be authenticated to the acceptor as an anonymous principal.&#xA;     * @see #getAnonymityState&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="requestConf">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="state">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Requests that data confidentiality be enabled&#xA;     * for the &lt;code>wrap&lt;/code> method. This request can only be made on&#xA;     * the context initiator's side and it has to be done prior to the&#xA;     * first call to &lt;code>initSecContext&lt;/code>.&#xA;     *&#xA;     * Not all mechanisms support confidentiality and other mechanisms&#xA;     * might enable it even if the application doesn't request&#xA;     * it. The application may check to see if the request was honored with&#xA;     * the {@link #getConfState() getConfState} method. If confidentiality&#xA;     * is enabled, only then will the mechanism honor a request for privacy &#xA;     * in the {@link MessageProp#MessageProp(int, boolean) MessageProp}&#xA;     * object that is passed in to the &lt;code>wrap&lt;/code> method.&lt;p>&#xA;     *&#xA;     * Enabling confidentiality will also automatically enable&#xA;     * integrity.&lt;p>&#xA;     *&#xA;     * @param state a boolean value indicating whether confidentiality&#xA;     * should be enabled or not.&#xA;     * @see #getConfState()&#xA;     * @see #getIntegState()&#xA;     * @see #requestInteg(boolean)&#xA;     * @see MessageProp&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="requestInteg">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="state">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Requests that data integrity be enabled&#xA;     * for the &lt;code>wrap&lt;/code> and &lt;code>getMIC&lt;/code>methods. This&#xA;     * request can only be made on the context initiator's side and it has&#xA;     * to be done prior to the first call to &lt;code>initSecContext&lt;/code>.&#xA;     *&#xA;     * Not all mechanisms support integrity and other mechanisms&#xA;     * might enable it even if the application doesn't request&#xA;     * it. The application may check to see if the request was honored with&#xA;     * the {@link #getIntegState() getIntegState} method.&lt;p>&#xA;     *&#xA;     * Disabling integrity will also automatically disable&#xA;     * confidentiality.&lt;p>&#xA;     *&#xA;     * @param state a boolean value indicating whether integrity&#xA;     * should be enabled or not.&#xA;     * @see #getIntegState()&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="requestLifetime">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lifetime">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Requests a lifetime in seconds for the&#xA;     * context. This method can only be called on the context initiator's&#xA;     * side  and it has to be done prior to the first call to&#xA;     * &lt;code>initSecContext&lt;/code>.&lt;p>&#xA;     *&#xA;     * The actual lifetime of the context will depend on the capabilites of &#xA;     * the underlying mechanism and the application should call the {@link&#xA;     * #getLifetime() getLifetime} method to determine this.&lt;p>&#xA;     *&#xA;     * @param lifetime the desired context lifetime in seconds. Use&#xA;     * &lt;code>INDEFINITE_LIFETIME&lt;/code> to request an indefinite lifetime&#xA;     * and &lt;code>DEFAULT_LIFETIME&lt;/code> to request a default lifetime.&#xA;     * @see #getLifetime()&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setChannelBinding">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cb">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ChannelBinding.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Sets the channel bindings to be used during context&#xA;     * establishment. This method can be called on both&#xA;     * the context initiator's and the context acceptor's side, but it must &#xA;     * be called before context establishment begins. This means that an&#xA;     * initiator must call it before the first call to&#xA;     * &lt;code>initSecContext&lt;/code> and the acceptor must call it before the &#xA;     * first call to &lt;code>acceptSecContext&lt;/code>.&#xA;     *&#xA;     * @param cb the channel bindings to use.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCredDelegState">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if credential delegation is enabled on&#xA;     * this context. It can be called by both the context initiator and the &#xA;     * context acceptor. For a definitive answer this method must be&#xA;     * called only after context establishment is complete. Note that if an &#xA;     * initiator requests that delegation not be allowed the {@link&#xA;     * #requestCredDeleg(boolean) requestCredDeleg} method will honor that&#xA;     * request and this method will return &lt;code>false&lt;/code> on the &#xA;     * initiator's side from that point onwards. &lt;p>&#xA;     *&#xA;     * @return true if delegation is enabled, false otherwise.&#xA;     * @see #requestCredDeleg(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMutualAuthState">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Determines if mutual authentication is enabled on&#xA;     * this context. It can be called by both the context initiator and the &#xA;     * context acceptor. For a definitive answer this method must be&#xA;     * called only after context establishment is complete. An initiator&#xA;     * that requests mutual authentication can call this method after&#xA;     * context completion and dispose the context if its request was not&#xA;     * honored.&lt;p>&#xA;     *&#xA;     * @return true if mutual authentication is enabled, false otherwise.&#xA;     * @see #requestMutualAuth(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getReplayDetState">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Determines if replay detection is enabled for the&#xA;     * per-message security services from this context. It can be called by&#xA;     * both the context initiator and the context acceptor. For a&#xA;     * definitive answer this method must be called only after context&#xA;     * establishment is complete. An initiator that requests replay&#xA;     * detection can call this method after context completion and&#xA;     * dispose the context if its request was not honored.&lt;p>&#xA;     *&#xA;     * @return true if replay detection is enabled, false otherwise.&#xA;     * @see #requestReplayDet(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSequenceDetState">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Determines if sequence checking is enabled for the&#xA;     * per-message security services from this context. It can be called by&#xA;     * both the context initiator and the context acceptor. For a&#xA;     * definitive answer this method must be called only after context&#xA;     * establishment is complete. An initiator that requests sequence&#xA;     * checking can call this method after context completion and&#xA;     * dispose the context if its request was not honored.&lt;p>&#xA;     *&#xA;     * @return true if sequence checking is enabled, false otherwise.&#xA;     * @see #requestSequenceDet(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAnonymityState">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Determines if the context initiator is&#xA;     * anonymously authenticated to the context acceptor. It can be called by&#xA;     * both the context initiator and the context acceptor, and at any&#xA;     * time. &lt;strong>On the initiator side, a call to this method determines&#xA;     * if the identity of the initiator has been disclosed in any of the&#xA;     * context establishment tokens that might have been generated thus far &#xA;     * by &lt;code>initSecContext&lt;/code>. An initiator that absolutely must be&#xA;     * authenticated anonymously should call this method after each call to &#xA;     * &lt;code>initSecContext&lt;/code> to determine if the generated token&#xA;     * should be sent to the peer or the context aborted.&lt;/strong> On the&#xA;     * acceptor side, a call to this method determines if any of the tokens &#xA;     * processed by &lt;code>acceptSecContext&lt;/code> thus far have divulged&#xA;     * the identity of the initiator.&lt;p>&#xA;     *&#xA;     * @return true if the context initiator is still anonymous, false&#xA;     * otherwise.&#xA;     * @see #requestAnonymity(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isTransferable">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Determines if the context is transferable to other processes&#xA;     * through the use of the {@link #export() export} method.  This call&#xA;     * is only valid on fully established contexts.&#xA;     *&#xA;     * @return true if this context can be exported, false otherwise.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isProtReady">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Determines if the context is ready for per message operations to be&#xA;     * used over it.  Some mechanisms may allow the usage of the&#xA;     * per-message operations before the context is fully established.&#xA;     *&#xA;     * @return true if methods like &lt;code>wrap&lt;/code>, &lt;code>unwrap&lt;/code>, &#xA;     * &lt;code>getMIC&lt;/code>, and &lt;code>verifyMIC&lt;/code> can be used with&#xA;     * this context at the current stage of context establishment, false&#xA;     * otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getConfState">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Determines if data confidentiality is available&#xA;     * over the context. This method can be called by both the context&#xA;     * initiator and the context acceptor, but only after one of {@link&#xA;     * #isProtReady() isProtReady} or {@link #isEstablished()&#xA;     * isEstablished} return &lt;code>true&lt;/code>. If this method returns&#xA;     * &lt;code>true&lt;/code>, so will {@link #getIntegState()&#xA;     * getIntegState}&lt;p>&#xA;     *&#xA;     * @return true if confidentiality services are available, false&#xA;     * otherwise.&#xA;     * @see #requestConf(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getIntegState">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Determines if data integrity is available&#xA;     * over the context. This method can be called by both the context&#xA;     * initiator and the context acceptor, but only after one of {@link&#xA;     * #isProtReady() isProtReady} or {@link #isEstablished()&#xA;     * isEstablished} return &lt;code>true&lt;/code>. This method will always&#xA;     * return &lt;code>true&lt;/code> if {@link #getConfState() getConfState}&#xA;     * returns true.&lt;p>&#xA;     *&#xA;     * @return true if integrity services are available, false otherwise.&#xA;     * @see #requestInteg(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLifetime">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Determines what the remaining lifetime for this&#xA;     * context is. It can be called by both the context initiator and the&#xA;     * context acceptor, but for a definitive answer it should be called&#xA;     * only after {@link #isEstablished() isEstablished} returns&#xA;     * true.&lt;p>&#xA;     *&#xA;     * @return the remaining lifetime in seconds&#xA;     * @see #requestLifetime(int)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSrcName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="GSSName.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the name of the context initiator. This call is valid only&#xA;     * after one of {@link #isProtReady() isProtReady} or {@link&#xA;     * #isEstablished() isEstablished} return &lt;code>true&lt;/code>.&#xA;     *&#xA;     * @return a GSSName that is an MN containing the name of the context&#xA;     * initiator.&#xA;     * @see GSSName&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTargName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="GSSName.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the name of the context acceptor. This call is valid only&#xA;     * after one of {@link #isProtReady() isProtReady} or {@link&#xA;     * #isEstablished() isEstablished} return &lt;code>true&lt;/code>.&#xA;     *&#xA;     * @return a GSSName that is an MN containing the name of the context&#xA;     * acceptor.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMech">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Oid.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines what mechanism is being used for this&#xA;     * context. This method may be called before the context is fully&#xA;     * established, but the mechanism returned may change on successive&#xA;     * calls in the negotiated mechanism case.&#xA;     *&#xA;     * @return the Oid of the mechanism being used&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDelegCred">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="GSSCredential.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtains the credentials delegated by the context&#xA;     * initiator to the context acceptor. It should be called only on the&#xA;     * context acceptor's side, and once the context is fully&#xA;     * established. The caller can use the method {@link&#xA;     * #getCredDelegState() getCredDelegState} to determine if there are&#xA;     * any delegated credentials. &#xA;     *&#xA;     * @return a GSSCredential containing the initiator's delegated&#xA;     * credentials, or &lt;code>null&lt;/code> is no credentials&#xA;     * were delegated.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isInitiator">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GSSException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**     &#xA;     * Determines if this is the context initiator. This&#xA;     * can be called on both the context initiator's and context acceptor's&#xA;     * side.&#xA;     *&#xA;     * @return true if this is the context initiator, false if it is the&#xA;     * context acceptor.&#xA;     *&#xA;     * @throws GSSException containing the following &#xA;     * major error codes: &#xA;     *   {@link GSSException#FAILURE GSSException.FAILURE}     &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**  &#xA; * This interface encapsulates the GSS-API security context and provides&#xA; * the security services that are available over the context.  Security&#xA; * contexts are established between peers using locally acquired&#xA; * credentials.  Multiple contexts may exist simultaneously between a pair&#xA; * of peers, using the same or different set of credentials.  GSS-API&#xA; * functions in a manner independent of the underlying transport protocol&#xA; * and depends on its calling application to transport the tokens that are&#xA; * generated by the security context between the peers.&lt;p>&#xA; *&#xA; * If the caller instantiates the context using the default&#xA; * &lt;code>GSSManager&lt;/code> instance, then the Kerberos v5 GSS-API mechanism&#xA; * is guaranteed to be available for context establishment. This mechanism&#xA; * is identified by the Oid &quot;1.2.840.113554.1.2.2&quot; and is defined in RFC&#xA; * 1964.&lt;p>&#xA; *&#xA; * Before the context establishment phase is initiated, the context&#xA; * initiator may request specific characteristics desired of the&#xA; * established context. Not all underlying mechanisms support all&#xA; * characteristics that a caller might desire. After the context is&#xA; * established, the caller can check the actual characteristics and services&#xA; * offered by that context by means of various query methods. When using&#xA; * the Kerberos v5 GSS-API mechanism offered by the default&#xA; * &lt;code>GSSManager&lt;/code> instance, all optional services will be&#xA; * available locally. They are mutual authentication, credential&#xA; * delegation, confidentiality and integrity protection, and per-message&#xA; * replay detection and sequencing. Note that in the GSS-API, message integrity&#xA; * is a prerequisite for message confidentiality.&lt;p>&#xA; *&#xA; * The context establishment occurs in a loop where the&#xA; * initiator calls {@link #initSecContext(byte[], int, int) initSecContext}&#xA; * and the acceptor calls {@link #acceptSecContext(byte[], int, int)&#xA; * acceptSecContext} until the context is established. While in this loop&#xA; * the &lt;code>initSecContext&lt;/code> and &lt;code>acceptSecContext&lt;/code>&#xA; * methods produce tokens that the application sends over to the peer. The&#xA; * peer passes any such token as input to its &lt;code>acceptSecContext&lt;/code>&#xA; * or &lt;code>initSecContext&lt;/code> as the case may be.&lt;p>&#xA; *&#xA; * During the context establishment phase, the {@link&#xA; * #isProtReady() isProtReady} method may be called to determine if the&#xA; * context can be used for the per-message operations of {@link&#xA; * #wrap(byte[], int, int, MessageProp) wrap} and {@link #getMIC(byte[],&#xA; * int, int, MessageProp) getMIC}.  This allows applications to use&#xA; * per-message operations on contexts which aren't yet fully&#xA; * established.&lt;p>&#xA; *&#xA; * After the context has been established or the &lt;code>isProtReady&lt;/code>&#xA; * method returns &lt;code>true&lt;/code>, the query routines can be invoked to&#xA; * determine the actual characteristics and services of the established&#xA; * context.  The application can also start using the per-message methods&#xA; * of {@link #wrap(byte[], int, int, MessageProp) wrap} and&#xA; * {@link #getMIC(byte[], int, int, MessageProp) getMIC} to obtain&#xA; * cryptographic operations on application supplied data.&lt;p>&#xA; *&#xA; * When the context is no longer needed, the application should call&#xA; * {@link #dispose() dispose} to release any system resources the context&#xA; * may be using.&lt;p>&#xA; *&#xA; * A security context typically maintains sequencing and replay detection&#xA; * information about the tokens it processes. Therefore, the sequence in&#xA; * which any tokens are presented to this context for processing can be&#xA; * important. Also note that none of the methods in this interface are&#xA; * synchronized. Therefore, it is not advisable to share a&#xA; * &lt;code>GSSContext&lt;/code> among several threads unless some application&#xA; * level synchronization is in place.&lt;p>&#xA; *&#xA; * Finally, different mechanism providers might place different security&#xA; * restrictions on using GSS-API contexts. These will be documented by the&#xA; * mechanism provider. The application will need to ensure that it has the&#xA; * appropriate permissions if such checks are made in the mechanism layer.&lt;p>&#xA; *&#xA; * The example code presented below demonstrates the usage of the&#xA; * &lt;code>GSSContext&lt;/code> interface for the initiating peer.  Different&#xA; * operations on the &lt;code>GSSContext&lt;/code> object are presented,&#xA; * including: object instantiation, setting of desired flags, context&#xA; * establishment, query of actual context flags, per-message operations on&#xA; * application data, and finally context deletion.&lt;p>&#xA; *&#xA; * &lt;pre>&#xA; *    // Create a context using default credentials &#xA; *    // and the implementation specific default mechanism&#xA; *    GSSManager manager ...&#xA; *    GSSName targetName ...&#xA; *    GSSContext context = manager.createContext(targetName, null, null,&#xA; *                                           GSSContext.INDEFINITE_LIFETIME);&#xA; * &#xA; *    // set desired context options prior to context establishment&#xA; *    context.requestConf(true);&#xA; *    context.requestMutualAuth(true);&#xA; *    context.requestReplayDet(true);&#xA; *    context.requestSequenceDet(true);&#xA; *    &#xA; *    // establish a context between peers&#xA; *&#xA; *    byte []inToken = new byte[0];&#xA; *&#xA; *    // Loop while there still is a token to be processed&#xA; *&#xA; *    while (!context.isEstablished()) {&#xA; *&#xA; *        byte[] outToken &#xA; *            = context.initSecContext(inToken, 0, inToken.length);&#xA; *        &#xA; *        // send the output token if generated&#xA; *        if (outToken != null)&#xA; *            sendToken(outToken);&#xA; *  &#xA; *        if (!context.isEstablished()) {&#xA; *            inToken = readToken();&#xA; *    }&#xA; *    &#xA; *     // display context information&#xA; *     System.out.println(&quot;Remaining lifetime in seconds = &quot; &#xA; *                                          + context.getLifetime());&#xA; *     System.out.println(&quot;Context mechanism = &quot; + context.getMech());&#xA; *     System.out.println(&quot;Initiator = &quot; + context.getSrcName());&#xA; *     System.out.println(&quot;Acceptor = &quot; + context.getTargName());&#xA; *  &#xA; *     if (context.getConfState())&#xA; *             System.out.println(&quot;Confidentiality (i.e., privacy) is available&quot;);&#xA; *  &#xA; *     if (context.getIntegState())&#xA; *             System.out.println(&quot;Integrity is available&quot;);&#xA; *  &#xA; *     // perform wrap on an application supplied message, appMsg,&#xA; *     // using QOP = 0, and requesting privacy service&#xA; *     byte [] appMsg ...&#xA; *  &#xA; *     MessageProp mProp = new MessageProp(0, true);&#xA; *  &#xA; *     byte []tok = context.wrap(appMsg, 0, appMsg.length, mProp);&#xA; *  &#xA; *     sendToken(tok);&#xA; *  &#xA; *     // release the local-end of the context&#xA; *     context.dispose();&#xA; *&#xA; * &lt;/pre>&#xA; *&#xA; * @author Mayank Upadhyay&#xA; * @version 1.9, 12/19/03&#xA; * @since 1.4&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
