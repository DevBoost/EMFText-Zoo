<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/types ../../../java.ecore#/16" name="Type.java">
  <comments>/*&#xA; * @(#)Type.java&#x9;1.18 04/04/30&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>com</namespaces>
  <namespaces>sun</namespaces>
  <namespaces>javadoc</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Type">
    <members xsi:type="members:InterfaceMethod" name="typeName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return unqualified name of type excluding any dimension information.&#xA;     * &lt;p>&#xA;     * For example, a two dimensional array of String returns&#xA;     * &quot;&lt;code>String&lt;/code>&quot;.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="qualifiedTypeName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return qualified name of type excluding any dimension information.&#xA;     *&lt;p>&#xA;     * For example, a two dimensional array of String&#xA;     * returns &quot;&lt;code>java.lang.String&lt;/code>&quot;.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="simpleTypeName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return the simple name of this type excluding any dimension information.&#xA;     * This is the unqualified name of the type, except that for nested types&#xA;     * only the identifier of the innermost type is included.&#xA;     * &lt;p>&#xA;     * For example, the class {@code Outer.Inner} returns&#xA;     * &quot;&lt;code>Inner&lt;/code>&quot;.&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="dimension">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return the type's dimension information, as a string.&#xA;     * &lt;p>&#xA;     * For example, a two dimensional array of String returns&#xA;     * &quot;&lt;code>[][]&lt;/code>&quot;.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return a string representation of the type.&#xA;     * This includes any dimension information and type arguments.&#xA;     * &lt;p>&#xA;     * For example, a two dimensional array of String may return&#xA;     * &quot;&lt;code>java.lang.String[][]&lt;/code>&quot;,&#xA;     * and the parameterized type {@code List&lt;Integer>} may return&#xA;     * &quot;{@code java.util.List&lt;java.lang.Integer>}&quot;.&#xA;     *&#xA;     * @return a string representation of the type.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isPrimitive">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Return true if this type represents a primitive type.&#xA;     *&#xA;     * @return true if this type represents a primitive type.&#xA;     * @since 1.5&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asClassDoc">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return this type as a &lt;code>ClassDoc&lt;/code> if it represents a class&#xA;     * or interface.  Array dimensions are ignored.&#xA;     * If this type is a &lt;code>ParameterizedType&lt;/code>,&#xA;     * &lt;code>TypeVariable&lt;/code>, or &lt;code>WildcardType&lt;/code>, return&#xA;     * the &lt;code>ClassDoc&lt;/code> of the type's erasure.  If this is an&#xA;     * &lt;code>AnnotationTypeDoc&lt;/code>, return this as a &lt;code>ClassDoc&lt;/code>&#xA;     * (but see {@link #asAnnotationTypeDoc()}).&#xA;     * If this is a primitive type, return null.&#xA;     *&#xA;     * @return the &lt;code>ClassDoc&lt;/code> of this type,&#xA;     *         or null if it is a primitive type.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ClassDoc.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asParameterizedType">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return this type as a &lt;code>ParameterizedType&lt;/code> if it represents&#xA;     * an invocation of a generic class or interface.  Array dimensions&#xA;     * are ignored.&#xA;     *&#xA;     * @return a &lt;code>ParameterizedType&lt;/code> if the type is an&#xA;     *         invocation of a generic type, or null if it is not.&#xA;     * @since 1.5&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ParameterizedType.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asTypeVariable">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return this type as a &lt;code>TypeVariable&lt;/code> if it represents&#xA;     * a type variable.  Array dimensions are ignored.&#xA;     *&#xA;     * @return a &lt;code>TypeVariable&lt;/code> if the type is a type variable,&#xA;     *         or null if it is not.&#xA;     * @since 1.5&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="TypeVariable.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asWildcardType">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return this type as a &lt;code>WildcardType&lt;/code> if it represents&#xA;     * a wildcard type.&#xA;     *&#xA;     * @return a &lt;code>WildcardType&lt;/code> if the type is a wildcard type,&#xA;     *         or null if it is not.&#xA;     * @since 1.5&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="WildcardType.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asAnnotationTypeDoc">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return this type as an &lt;code>AnnotationTypeDoc&lt;/code> if it represents&#xA;     * an annotation type.  Array dimensions are ignored.&#xA;     *&#xA;     * @return an &lt;code>AnnotationTypeDoc&lt;/code> if the type is an annotation&#xA;     *         type, or null if it is not.&#xA;     * @since 1.5&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="AnnotationTypeDoc.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Represents a type.  A type can be a class or interface, an&#xA; * invocation (like {@code List&lt;String>}) of a generic class or interface,&#xA; * a type variable, a wildcard type (&quot;&lt;code>?&lt;/code>&quot;),&#xA; * or a primitive data type (like &lt;code>char&lt;/code>).&#xA; *&#xA; * @since JDK1.2&#xA; * @author Kaiyang Liu (original)&#xA; * @author Robert Field (rewrite)&#xA; * @author Scott Seligman (generics)&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
