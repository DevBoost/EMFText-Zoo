<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:annotations="http://www.emftext.org/java/annotations" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/annotations ../../../java.ecore#/0 http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="ClassDoc.java">
  <comments>/*&#xA; * @(#)ClassDoc.java&#x9;1.15 02/10/06&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>com</namespaces>
  <namespaces>sun</namespaces>
  <namespaces>javadoc</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="ClassDoc">
    <members xsi:type="members:InterfaceMethod" name="isAbstract">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Return true if this class is abstract.  Return true&#xA;     * for all interfaces.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isSerializable">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Return true if this class implements or interface extends&#xA;     * &lt;code>java.io.Serializable&lt;/code>.&#xA;     *&#xA;     * Since &lt;code>java.io.Externalizable&lt;/code> extends&#xA;     * &lt;code>java.io.Serializable&lt;/code>,&#xA;     * Externalizable objects are also Serializable.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isExternalizable">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Return true if this class implements or interface extends&#xA;     * &lt;code>java.io.Externalizable&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="serializationMethods">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return the serialization methods for this class or&#xA;     * interface.&#xA;     *&#xA;     * @return an array of MethodDoc objects that represents&#xA;     *         the serialization methods for this class or interface.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="MethodDoc.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="serializableFields">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return the Serializable fields of this class or interface.&#xA;     * &lt;p>&#xA;     * Return either a list of default fields documented by&#xA;     * &lt;code>serial&lt;/code> tag&lt;br>&#xA;     * or return a single &lt;code>FieldDoc&lt;/code> for&#xA;     * &lt;code>serialPersistentField&lt;/code> member.&#xA;     * There should be a &lt;code>serialField&lt;/code> tag for&#xA;     * each Serializable field defined by an &lt;code>ObjectStreamField&lt;/code>&#xA;     * array component of &lt;code>serialPersistentField&lt;/code>.&#xA;     *&#xA;     * @return an array of &lt;code>FieldDoc&lt;/code> objects for the Serializable &#xA;     *         fields of this class or interface.&#xA;     *&#xA;     * @see #definesSerializableFields()&#xA;     * @see SerialFieldTag&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="FieldDoc.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="definesSerializableFields">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     *  Return true if Serializable fields are explicitly defined with&#xA;     *  the special class member &lt;code>serialPersistentFields&lt;/code>.&#xA;     *&#xA;     * @see #serializableFields()&#xA;     * @see SerialFieldTag&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="superclass">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0">
          <comments>/**&#xA;     * Return the superclass of this class.  Return null if this is an&#xA;     * interface.&#xA;     *&#xA;     * &lt;p> &lt;i>This method cannot accommodate certain generic type constructs.&#xA;     * The &lt;code>superclassType&lt;/code> method should be used instead.&lt;/i>&#xA;     *&#xA;     * @return the ClassDoc for the superclass of this class, null if&#xA;     *         there is no superclass.&#xA;     * @see #superclassType&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="superclassType">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return the superclass of this class.  Return null if this is an&#xA;     * interface.  A superclass is represented by either a&#xA;     * &lt;code>ClassDoc&lt;/code> or a &lt;code>ParametrizedType&lt;/code>.&#xA;     *&#xA;     * @return the superclass of this class, or null if there is no superclass.&#xA;     * @since 1.5&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="Type.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="subclassOf">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Test whether this class is a subclass of the specified class.&#xA;     * If this is an interface, return false for all classes except &#xA;     * &lt;code>java.lang.Object&lt;/code> (we must keep this unexpected&#xA;     * behavior for compatibility reasons).&#xA;     *&#xA;     * @param cd the candidate superclass.&#xA;     * @return true if cd is a superclass of this class.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cd">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="interfaces">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0">
          <comments>/**&#xA;     * Return interfaces implemented by this class or interfaces extended&#xA;     * by this interface. Includes only directly-declared interfaces, not&#xA;     * inherited interfaces.&#xA;     * Return an empty array if there are no interfaces.&#xA;     *&#xA;     * &lt;p> &lt;i>This method cannot accommodate certain generic type constructs.&#xA;     * The &lt;code>interfaceTypes&lt;/code> method should be used instead.&lt;/i>&#xA;     *&#xA;     * @return an array of ClassDoc objects representing the interfaces.&#xA;     * @see #interfaceTypes&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="interfaceTypes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return interfaces implemented by this class or interfaces extended&#xA;     * by this interface. Includes only directly-declared interfaces, not&#xA;     * inherited interfaces.&#xA;     * Return an empty array if there are no interfaces.&#xA;     *&#xA;     * @return an array of interfaces, each represented by a&#xA;     *&#x9;       &lt;code>ClassDoc&lt;/code> or a &lt;code>ParametrizedType&lt;/code>.&#xA;     * @since 1.5&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="Type.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="typeParameters">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return the formal type parameters of this class or interface.&#xA;     * Return an empty array if there are none.&#xA;     *&#xA;     * @return the formal type parameters of this class or interface.&#xA;     * @since 1.5&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="TypeVariable.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="typeParamTags">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return the type parameter tags of this class or interface.&#xA;     * Return an empty array if there are none.&#xA;     *&#xA;     * @return the type parameter tags of this class or interface.&#xA;     * @since 1.5&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ParamTag.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="fields">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return&#xA;     * &lt;a href=&quot;{@docRoot}/com/sun/javadoc/package-summary.html#included&quot;>included&lt;/a>&#xA;     * fields in this class or interface.&#xA;     * Excludes enum constants if this is an enum type.&#xA;     *&#xA;     * @return an array of FieldDoc objects representing the included&#xA;     *         fields in this class or interface.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="FieldDoc.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="fields">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return fields in this class or interface, filtered to the specified&#xA;     * &lt;a href=&quot;{@docRoot}/com/sun/javadoc/package-summary.html#included&quot;>access &#xA;     * modifier option&lt;/a>.&#xA;     * Excludes enum constants if this is an enum type.&#xA;     *&#xA;     * @param filter Specify true to filter according to the specified access&#xA;     *               modifier option.&#xA;     *               Specify false to include all fields regardless of&#xA;     *               access modifier option.&#xA;     * @return       an array of FieldDoc objects representing the included&#xA;     *               fields in this class or interface.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="FieldDoc.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filter">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="enumConstants">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return the enum constants if this is an enum type.&#xA;     * Return an empty array if there are no enum constants, or if&#xA;     * this is not an enum type.&#xA;     *&#xA;     * @return the enum constants if this is an enum type.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="FieldDoc.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="methods">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return &#xA;     * &lt;a href=&quot;{@docRoot}/com/sun/javadoc/package-summary.html#included&quot;>included&lt;/a>&#xA;     * methods in this class or interface.&#xA;     * Same as &lt;code>methods(true)&lt;/code>.&#xA;     *&#xA;     * @return an array of MethodDoc objects representing the included&#xA;     *         methods in this class or interface.  Does not include&#xA;     *&#x9;       constructors or annotation type elements.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="MethodDoc.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="methods">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return methods in this class or interface, filtered to the specified&#xA;     * &lt;a href=&quot;{@docRoot}/com/sun/javadoc/package-summary.html#included&quot;>access &#xA;     * modifier option&lt;/a>.  Does not include constructors or annotation&#xA;     *&#x9;&#x9;type elements.&#xA;     *&#xA;     * @param filter Specify true to filter according to the specified access&#xA;     *               modifier option.&#xA;     *               Specify false to include all methods regardless of&#xA;     *               access modifier option.&#xA;     * @return       an array of MethodDoc objects representing the included&#xA;     *               methods in this class or interface.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="MethodDoc.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filter">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="constructors">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return&#xA;     * &lt;a href=&quot;{@docRoot}/com/sun/javadoc/package-summary.html#included&quot;>included&lt;/a>&#xA;     * constructors in this class.  An array containing the default&#xA;     * no-arg constructor is returned if no other constructors exist.&#xA;     * Return empty array if this is an interface.&#xA;     *&#xA;     * @return an array of ConstructorDoc objects representing the included&#xA;     *         constructors in this class.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ConstructorDoc.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="constructors">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return constructors in this class, filtered to the specified&#xA;     * &lt;a href=&quot;{@docRoot}/com/sun/javadoc/package-summary.html#included&quot;>access &#xA;     * modifier option&lt;/a>.  Return an array containing the default&#xA;     * no-arg constructor if no other constructors exist.&#xA;     *&#xA;     * @param filter Specify true to filter according to the specified access&#xA;     *               modifier option.&#xA;     *               Specify false to include all constructors regardless of&#xA;     *               access modifier option.&#xA;     * @return       an array of ConstructorDoc objects representing the included&#xA;     *               constructors in this class.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ConstructorDoc.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filter">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="innerClasses">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0">
          <comments>/**&#xA;     * Return &#xA;     * &lt;a href=&quot;{@docRoot}/com/sun/javadoc/package-summary.html#included&quot;>included&lt;/a>&#xA;     * nested classes and interfaces within this class or interface.&#xA;     * This includes both static and non-static nested classes.&#xA;     * (This method should have been named &lt;code>nestedClasses()&lt;/code>, &#xA;     * as inner classes are technically non-static.)  Anonymous and local classes&#xA;     * or interfaces are not included.&#xA;     *&#xA;     * @return an array of ClassDoc objects representing the included classes&#xA;     *         and interfaces defined in this class or interface. &#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="innerClasses">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0">
          <comments>/**&#xA;     * Return nested classes and interfaces within this class or interface&#xA;     * filtered to the specified &#xA;     * &lt;a href=&quot;{@docRoot}/com/sun/javadoc/package-summary.html#included&quot;>access &#xA;     * modifier option&lt;/a>.&#xA;     * This includes both static and non-static nested classes.&#xA;     * Anonymous and local classes are not included.&#xA;     *&#xA;     * @param filter Specify true to filter according to the specified access&#xA;     *               modifier option.&#xA;     *               Specify false to include all nested classes regardless of&#xA;     *               access modifier option.&#xA;     * @return       a filtered array of ClassDoc objects representing the included&#xA;     *               classes and interfaces defined in this class or interface.&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filter">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="findClass">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0">
          <comments>/**&#xA;     * Find the specified class or interface within the context of this class doc.&#xA;     * Search order: 1) qualified name, 2) nested in this class or interface,&#xA;     * 3) in this package, 4) in the class imports, 5) in the package imports.&#xA;     * Return the ClassDoc if found, null if not found.&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="className">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="importedClasses">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Get the list of classes and interfaces declared as imported.&#xA;     * These are called &quot;single-type-import declarations&quot; in the &#xA;     * Java Language Specification.&#xA;     *&#xA;     * @return an array of ClassDoc representing the imported classes.&#xA;     *&#xA;     * @deprecated  Import declarations are implementation details that&#xA;     *&#x9;&#x9;should not be exposed here.  In addition, not all imported&#xA;     *&#x9;&#x9;classes are imported through single-type-import declarations.&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="../../../java/lang/Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="importedPackages">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="PackageDoc.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Get the list of packages declared as imported.&#xA;     * These are called &quot;type-import-on-demand declarations&quot; in the &#xA;     * Java Language Specification.&#xA;     *&#xA;     * @return an array of PackageDoc representing the imported packages.&#xA;     *&#xA;     * @deprecated  Import declarations are implementation details that&#xA;     *&#x9;&#x9;should not be exposed here.  In addition, this method's&#xA;     *&#x9;&#x9;return type does not allow for all type-import-on-demand&#xA;     *&#x9;&#x9;declarations to be returned.&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="../../../java/lang/Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Represents a java class or interface and provides access to &#xA; * information about the class, the class's comment and tags, and the&#xA; * members of the class.  A ClassDoc only exists if it was&#xA; * processed in this run of javadoc.  References to classes&#xA; * which may or may not have been processed in this run are&#xA; * referred to using Type (which can be converted to ClassDoc,&#xA; * if possible).&#xA; *&#xA; * @see Type&#xA; *&#xA; * @since JDK1.2&#xA; * @author Kaiyang Liu (original)&#xA; * @author Robert Field (rewrite)&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="ProgramElementDoc.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Type.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
