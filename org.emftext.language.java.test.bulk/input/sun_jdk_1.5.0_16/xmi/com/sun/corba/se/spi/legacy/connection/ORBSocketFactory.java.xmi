<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../../../../../java.ecore#/7 http://www.emftext.org/java/members ../../../../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../../../../../java.ecore#/13 http://www.emftext.org/java/references ../../../../../../../java.ecore#/14 http://www.emftext.org/java/types ../../../../../../../java.ecore#/16" name="ORBSocketFactory.java">
  <comments>/*&#xA; * @(#)ORBSocketFactory.java&#x9;1.14 04/06/21&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>com</namespaces>
  <namespaces>sun</namespaces>
  <namespaces>corba</namespaces>
  <namespaces>se</namespaces>
  <namespaces>spi</namespaces>
  <namespaces>legacy</namespaces>
  <namespaces>connection</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>net</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../../../../java/net/ServerSocket.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>net</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../../../../java/net/Socket.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../../../../java/io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>com</namespaces>
    <namespaces>sun</namespaces>
    <namespaces>corba</namespaces>
    <namespaces>se</namespaces>
    <namespaces>spi</namespaces>
    <namespaces>ior</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../ior/IOR.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>com</namespaces>
    <namespaces>sun</namespaces>
    <namespaces>corba</namespaces>
    <namespaces>se</namespaces>
    <namespaces>spi</namespaces>
    <namespaces>transport</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../transport/SocketInfo.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="ORBSocketFactory">
    <members xsi:type="members:Field" name="IIOP_CLEAR_TEXT">
      <initialValue xsi:type="references:StringReference" value="IIOP_CLEAR_TEXT"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * DEPRECATED.  DEPRECATED. DEPRECATED. DEPRECATED. &lt;p>&#xA;     *&#xA;     * A server ORB always creates an &quot;IIOP_CLEAR_TEXT&quot; listening port.&#xA;     * That port is put into IOP profiles of object references exported&#xA;     * by an ORB. &lt;p>&#xA;     *&#xA;     * If &#xA;     *&#xA;     *     &lt;code>createServerSocket(String type, int port)&lt;/code> &#xA;     *&#xA;     * is passed &lt;code>IIOP_CLEAR_TEXT&lt;/code> as a &lt;code>type&lt;/code>&#xA;     * argument it should then call and return &#xA;     *&#xA;     *     &lt;code>new java.net.ServerSocket(int port)&lt;/code> &lt;p>&#xA;     *&#xA;     * If&#xA;     *&#xA;     *     &lt;code>createSocket(SocketInfo socketInfo)&lt;/code>&#xA;     *&#xA;     * is passed &lt;code>IIOP_CLEAR_TEXT&lt;/code> in&#xA;     * &lt;code>socketInfo.getType()&lt;/code> it should&#xA;     * then call and return&#xA;     *&#xA;     * &lt;pre>&#xA;     *     new java.net.Socket(socketInfo.getHost(),&#xA;     *                         socketInfo.getPort())&#xA;     * &lt;/pre>&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createServerSocket">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../java/net/ServerSocket.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="port">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * DEPRECATED.  DEPRECATED. DEPRECATED. DEPRECATED. &lt;p>&#xA;     *&#xA;     * This method is used by a server side ORB. &lt;p>&#xA;     *&#xA;     * When an ORB needs to create a listen socket on which connection&#xA;     * requests are accepted it calls&#xA;     *&#xA;     *     &lt;code>createServerSocket(String type, int port)&lt;/code>. &#xA;     *&#xA;     * The type argument says which type of socket should be created. &lt;p>&#xA;     *&#xA;     * The interpretation of the type argument is the responsibility of&#xA;     * an instance of &lt;code>ORBSocketFactory&lt;/code>, except in the case&#xA;     * of &lt;code>IIOP_CLEAR_TEXT&lt;/code>, in which case a standard server&#xA;     * socket should be created. &lt;p>&#xA;     * &#xA;     *&#xA;     * Multiple Server Port API: &lt;p>&#xA;     *&#xA;     * In addition to the IIOP_CLEAR_TEXT listening port, it is possible&#xA;     * to specify that an ORB listen on additional port of specific types. &lt;p>&#xA;     *&#xA;     * This API allows one to specify that an ORB should create an X,&#xA;     * or an X and a Y listen socket. &lt;p>&#xA;     *&#xA;     * If X, to the user, means SSL, then one just plugs in an SSL&#xA;     * socket factory. &lt;p>&#xA;     *&#xA;     * Or, another example, if X and Y, to the user, means SSL without&#xA;     * authentication and SSL with authentication respectively, then they&#xA;     * plug in a factory which will either create an X or a Y socket&#xA;     * depending on the type given to&#xA;     *&#xA;     *     &lt;code>createServerSocket(String type, int port)&lt;/code>. &lt;p>&#xA;     *&#xA;     * One specifies multiple listening ports (in addition to the&#xA;     * default IIOP_CLEAR_TEXT port) using the&#xA;     *&#xA;     *     &lt;code>ORBConstants.LISTEN_SOCKET_PROPERTY&lt;/code>&#xA;     *&#xA;     * property. &lt;p>&#xA;     *&#xA;     * Example usage:&lt;p>&#xA;     *&#xA;     * &lt;pre>&#xA;     *    ... \ &#xA;     *    -Dcom.sun.CORBA.connection.ORBSocketFactoryClass=com.my.MySockFact \&#xA;     *    -Dcom.sun.CORBA.connection.ORBListenSocket=SSL:0,foo:1 \&#xA;     *    ... &#xA;     * &lt;/pre>&#xA;     *&#xA;     * The meaning of the &quot;type&quot; (SSL and foo above) is controlled &#xA;     * by the user. &lt;p>&#xA;     *&#xA;     * ORBListenSocket is only meaningful for servers. &lt;p>&#xA;     *&#xA;     * The property value is interpreted as follows.  For each&#xA;     * type/number pair: &lt;p>&#xA;     *&#xA;     * If number is 0 then use an emphemeral port for the listener of&#xA;     * the associated type. &lt;p>&#xA;     *&#xA;     * If number is greater then 0 use that port number. &lt;p>&#xA;     * &#xA;     * An ORB creates a listener socket for each type&#xA;     * specified by the user by calling&#xA;     *&#xA;     *    &lt;code>createServerSocket(String type, int port)&lt;/code>&#xA;     *&#xA;     * with the type specified by the user. &lt;p>&#xA;     *&#xA;     * After an ORB is initialized and the RootPOA has been resolved,&#xA;     * it is then listening on&#xA;     * all the end points which were specified.  It may be necessary&#xA;     * to add this additional end point information to object references&#xA;     * exported by this ORB.  &lt;p>&#xA;     * &#xA;     * Each object reference will contain the ORB's default IIOP_CLEAR_TEXT&#xA;     * end point in its IOP profile.  To add additional end point information&#xA;     * (i.e., an SSL port) to an IOR (i.e., an object reference) one needs&#xA;     * to intercept IOR creation using&#xA;     * an &lt;code>PortableInterceptor::IORInterceptor&lt;/code>. &lt;p>&#xA;     * &#xA;     * Using PortableInterceptors (with a non-standard extension): &lt;p>&#xA;     *&#xA;     * Register an &lt;code>IORInterceptor&lt;/code>.  Inside its&#xA;     * &lt;code>establish_components&lt;/code> operation:&#xA;     *&#xA;     * &lt;pre>&#xA;     *&#xA;     * com.sun.corba.se.spi.legacy.interceptor.IORInfoExt ext;&#xA;     * ext = (com.sun.corba.se.spi.legacy.interceptor.IORInfoExt)info;&#xA;     *&#xA;     * int port = ext.getServerPort(&quot;myType&quot;);&#xA;     *&#xA;     * &lt;/pre>&#xA;     * &#xA;     * Once you have the port you may add information to references&#xA;     * created by the associated adapter by calling&#xA;     *&#xA;     *    &lt;code>IORInfo::add_ior_component&lt;/code>&lt;p> &lt;p>&#xA;     * &#xA;     *&#xA;     * Note: if one is using a POA and the lifespan policy of that&#xA;     * POA is persistent then the port number returned &#xA;     * by &lt;code>getServerPort&lt;/code> &lt;em>may&lt;/em>&#xA;     * be the corresponding ORBD port, depending on whether the POA/ORBD&#xA;     * protocol is the present port exchange or if, in the future,&#xA;     * the protocol is based on object reference template exchange.&#xA;     * In either&#xA;     * case, the port returned will be correct for the protocol.&#xA;     * (In more detail, if the port exchange protocol is used then&#xA;     * getServerPort will return the ORBD's port since the port&#xA;     * exchange happens before, at ORB initialization.&#xA;     * If object reference&#xA;     * exchange is used then the server's transient port will be returned&#xA;     * since the templates are exchanged after adding components.) &lt;p>&#xA;     * &#xA;     *&#xA;     * Persistent object reference support: &lt;p>&#xA;     *&#xA;     * When creating persistent object references with alternate&#xA;     * type/port info, ones needs to configure the ORBD to also support&#xA;     * this alternate info.  This is done as follows: &lt;p>&#xA;     *&#xA;     * - Give the ORBD the same socket factory you gave to the client&#xA;     * and server. &lt;p>&#xA;     *&#xA;     * - specify ORBListenSocket ports of the same types that your&#xA;     * servers support.  You should probably specify explicit port&#xA;     * numbers for ORBD if you embed these numbers inside IORs. &lt;p>&#xA;     *&#xA;     * Note: when using the port exchange protocol&#xA;     * the ORBD and servers will exchange port&#xA;     * numbers for each given type so they know about each other. &#xA;     * When using object reference template exchange the server's&#xA;     * transient ports are contained in the template. &lt;p>&#xA;     *&#xA;     *&#xA;     * - specify your &lt;code>BadServerIdHandler&lt;/code> (discussed below)&#xA;     * using the&#xA;     *&#xA;     *    &lt;code>ORBConstants.BAD_SERVER_ID_HANDLER_CLASS_PROPERTY&lt;/code> &lt;p>&#xA;     *&#xA;     * Example: &lt;p>&#xA;     *&#xA;     * &lt;pre>&#xA;     *&#xA;     * -Dcom.sun.CORBA.POA.ORBBadServerIdHandlerClass=corba.socketPersistent.MyBadServerIdHandler&#xA;     *&#xA;     * &lt;/pre>&#xA;     * &#xA;     * The &lt;code>BadServerIdHandler&lt;/code> ...&lt;p>&#xA;     *&#xA;     * See &lt;code>com.sun.corba.se.impl.activation.ServerManagerImpl.handle&lt;/code>&#xA;     * for example code on writing a bad server id handler.  NOTE:  This&#xA;     * is an unsupported internal API.  It will not exist in future releases. &#xA;     * &lt;p>&#xA;     *&#xA;     *&#xA;     * Secure connections to other services: &lt;p>&#xA;     *&#xA;     * If one wants secure connections to other services such as&#xA;     * Naming then one should configure them with the same&#xA;     *&#xA;     *     &lt;code>SOCKET_FACTORY_CLASS_PROPERTY&lt;/code> and&#xA;     *     &lt;code>LISTEN_SOCKET_PROPERTY&lt;/code>&#xA;     *&#xA;     * as used by other clients and servers in your distributed system. &lt;p>&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getEndPointInfo">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../transport/SocketInfo.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="orb">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>omg</namespaces>
          <namespaces>CORBA</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../org/omg/CORBA/ORB.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ior">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../ior/IOR.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="socketInfo">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../transport/SocketInfo.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * DEPRECATED.  DEPRECATED. DEPRECATED. DEPRECATED. &lt;p>&#xA;     *&#xA;     * This method is used by a client side ORB. &lt;p>&#xA;     *&#xA;     * Each time a client invokes on an object reference, the reference's&#xA;     * associated ORB will call&#xA;     *&#xA;     * &lt;pre>&#xA;     *    getEndPointInfo(ORB orb, &#xA;     *                    IOR ior,&#xA;     *                    SocketInfo socketInfo)&#xA;     * &lt;/pre>&#xA;     *&#xA;     * NOTE: The type of the &lt;code>ior&lt;/code> argument is an internal&#xA;     * representation for efficiency.  If the &lt;code>ORBSocketFactory&lt;/code>&#xA;     * interface ever becomes standardized then the &lt;code>ior&lt;/code> will&#xA;     * most likely change to a standard type (e.g., a stringified ior,&#xA;     * an &lt;code>org.omg.IOP.IOR&lt;/code>, or ...). &lt;p>&#xA;     *&#xA;     * Typically, this method will look at tagged components in the&#xA;     * given &lt;code>ior&lt;/code> to determine what type of socket to create. &lt;p>&#xA;     *&#xA;     * Typically, the &lt;code>ior&lt;/code> will contain a tagged component&#xA;     * specifying an alternate port type and number.  &lt;p>&#xA;     *&#xA;     * This method should return an &lt;code>SocketInfo&lt;/code> object&#xA;     * containing the type/host/port to be used for the connection.&#xA;     *&#xA;     * If there are no appropriate tagged components then this method&#xA;     * should return an &lt;code>SocketInfo&lt;/code> object with the type&#xA;     * &lt;code>IIOP_CLEAR_TEXT&lt;/code> and host/port from the ior's IOP&#xA;     * profile. &lt;p>&#xA;     *&#xA;     * If the ORB already has an existing connection to the returned&#xA;     * type/host/port, then that connection is used.  Otherwise the ORB calls&#xA;     *&#xA;     *    &lt;code>createSocket(SocketInfo socketInfo)&lt;/code> &lt;p>&#xA;     *&#xA;     * The &lt;code>orb&lt;/code> argument is useful for handling&#xA;     * the &lt;code>ior&lt;/code> argument. &lt;p>&#xA;     *&#xA;     * The &lt;code>SocketInfo&lt;/code> given to &lt;code>getEndPointInfo&lt;/code>&#xA;     * is either null or an object obtained&#xA;     * from &lt;code>GetEndPointInfoAgainException&lt;/code> &lt;p>&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createSocket">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../java/net/Socket.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="socketInfo">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../transport/SocketInfo.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../java/io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GetEndPointInfoAgainException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * DEPRECATED.  DEPRECATED. DEPRECATED. DEPRECATED. &lt;p&#xA;     *&#xA;     * This method is used by a client side ORB. &lt;p>&#xA;     *&#xA;     * This method should return a client socket of the given&#xA;     * type/host/port. &lt;p>&#xA;     *&#xA;     * Note: the &lt;code>SocketInfo&lt;/code> is the same instance as was&#xA;     * returned by &lt;code>getSocketInfo&lt;/code> so extra cookie info may&#xA;     * be attached. &lt;p>&#xA;     * &#xA;     * If this method throws GetEndPointInfoAgainException then the&#xA;     * ORB calls &lt;code>getEndPointInfo&lt;/code> again, passing it the&#xA;     * &lt;code>SocketInfo&lt;/code> object contained in the exception. &lt;p>&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &#xA; * DEPRECATED.  DEPRECATED. DEPRECATED. DEPRECATED. &lt;p>&#xA; * DEPRECATED.  DEPRECATED. DEPRECATED. DEPRECATED. &lt;p>&#xA; *&#xA; * This interface gives one the ability to plug in their own socket&#xA; * factory class to an ORB. &lt;p>&#xA; *&#xA; * Usage: &lt;p>&#xA; *&#xA; * One specifies a class which implements this interface via the &#xA; *&#xA; *     &lt;code>ORBConstants.SOCKET_FACTORY_CLASS_PROPERTY&lt;/code>&#xA; *&#xA; * property. &lt;p>&#xA; * &#xA; * Example: &lt;p>&#xA;&#xA; * &lt;pre>&#xA; *   -Dcom.sun.CORBA.connection.ORBSocketFactoryClass=MySocketFactory&#xA; * &lt;/pre> &lt;p>&#xA; *&#xA; * Typically one would use the same socket factory class on both the&#xA; * server side and the client side (but this is not required). &lt;p>&#xA; *&#xA; * A &lt;code>ORBSocketFactory&lt;/code> class should have a public default&#xA; * constructor which is called once per instantiating ORB.init call. &#xA; * That ORB then calls the methods of that &lt;code>ORBSocketFactory&lt;/code>&#xA; * to obtain client and server sockets. &lt;p>&#xA; *&#xA; * This interface also supports multiple server end points.  See the&#xA; * documentation on &lt;code>createServerSocket&lt;/code> below. &#xA; *&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
