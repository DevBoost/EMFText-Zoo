<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../../../../../java.ecore#/5 http://www.emftext.org/java/literals ../../../../../../../java.ecore#/9 http://www.emftext.org/java/members ../../../../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../../../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../../../../../java.ecore#/13 http://www.emftext.org/java/references ../../../../../../../java.ecore#/14 http://www.emftext.org/java/types ../../../../../../../java.ecore#/16" name="Sync.java">
  <comments>/*&#xA;  File: Sync.java&#xA;&#xA;  Originally written by Doug Lea and released into the public domain.&#xA;  This may be used for any purposes whatsoever without acknowledgment.&#xA;  Thanks for the assistance and support of Sun Microsystems Labs,&#xA;  and everyone contributing, testing, and using this code.&#xA;&#xA;  History:&#xA;  Date       Who                What&#xA;  11Jun1998  dl               Create public version&#xA;   5Aug1998  dl               Added some convenient time constants&#xA;*/</comments>
  <namespaces>com</namespaces>
  <namespaces>sun</namespaces>
  <namespaces>corba</namespaces>
  <namespaces>se</namespaces>
  <namespaces>impl</namespaces>
  <namespaces>orbutil</namespaces>
  <namespaces>concurrent</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Sync">
    <members xsi:type="members:InterfaceMethod" name="acquire">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../java/lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;   *  Wait (possibly forever) until successful passage.&#xA;   *  Fail only upon interuption. Interruptions always result in&#xA;   *  `clean' failures. On failure,  you can be sure that it has not &#xA;   *  been acquired, and that no &#xA;   *  corresponding release should be performed. Conversely,&#xA;   *  a normal return guarantees that the acquire was successful.&#xA;  **/</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="attempt">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="msecs">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../java/lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;   * Wait at most msecs to pass; report whether passed.&#xA;   * &lt;p>&#xA;   * The method has best-effort semantics:&#xA;   * The msecs bound cannot&#xA;   * be guaranteed to be a precise upper bound on wait time in Java.&#xA;   * Implementations generally can only attempt to return as soon as possible&#xA;   * after the specified bound. Also, timers in Java do not stop during garbage&#xA;   * collection, so timeouts can occur just because a GC intervened.&#xA;   * So, msecs arguments should be used in&#xA;   * a coarse-grained manner. Further,&#xA;   * implementations cannot always guarantee that this method&#xA;   * will return at all without blocking indefinitely when used in&#xA;   * unintended ways. For example, deadlocks may be encountered&#xA;   * when called in an unintended context.&#xA;   * &lt;p>&#xA;   * @param msecs the number of milleseconds to wait.&#xA;   * An argument less than or equal to zero means not to wait at all. &#xA;   * However, this may still require&#xA;   * access to a synchronization lock, which can impose unbounded&#xA;   * delay if there is a lot of contention among threads.&#xA;   * @return true if acquired&#xA;  **/</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="release">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;   * Potentially enable others to pass.&#xA;   * &lt;p>&#xA;   * Because release does not raise exceptions, &#xA;   * it can be used in `finally' clauses without requiring extra&#xA;   * embedded try/catch blocks. But keep in mind that&#xA;   * as with any java method, implementations may &#xA;   * still throw unchecked exceptions such as Error or NullPointerException&#xA;   * when faced with uncontinuable errors. However, these should normally&#xA;   * only be caught by higher-level error handlers.&#xA;  **/</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="ONE_SECOND">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1000"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**  One second, in milliseconds; convenient as a time-out value **/</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ONE_MINUTE">
      <initialValue xsi:type="expressions:MultiplicativeExpression">
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="60"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
        <multiplicativeOperators xsi:type="operators:Multiplication"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**  One minute, in milliseconds; convenient as a time-out value **/</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ONE_HOUR">
      <initialValue xsi:type="expressions:MultiplicativeExpression">
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="60"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
        <multiplicativeOperators xsi:type="operators:Multiplication"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**  One hour, in milliseconds; convenient as a time-out value **/</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ONE_DAY">
      <initialValue xsi:type="expressions:MultiplicativeExpression">
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="24"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
        <multiplicativeOperators xsi:type="operators:Multiplication"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**  One day, in milliseconds; convenient as a time-out value **/</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ONE_WEEK">
      <initialValue xsi:type="expressions:MultiplicativeExpression">
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        <multiplicativeOperators xsi:type="operators:Multiplication"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**  One week, in milliseconds; convenient as a time-out value **/</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ONE_YEAR">
      <initialValue xsi:type="expressions:CastExpression">
        <typeReference xsi:type="types:Long"/>
        <child xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="365.2425"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
            <multiplicativeOperators xsi:type="operators:Multiplication"/>
          </expression>
        </child>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**  One year in milliseconds; convenient as a time-out value  **/</comments>
        <comments>// Not that it matters, but there is some variation across</comments>
        <comments>// standard sources about value at msec precision.</comments>
        <comments>// The value used is the same as in java.util.GregorianCalendar</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ONE_CENTURY">
      <initialValue xsi:type="expressions:MultiplicativeExpression">
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="100"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
        <multiplicativeOperators xsi:type="operators:Multiplication"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**  One century in milliseconds; convenient as a time-out value **/</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Main interface for locks, gates, and conditions.&#xA; * &lt;p>&#xA; * Sync objects isolate waiting and notification for particular&#xA; * logical states, resource availability, events, and the like that are&#xA; * shared across multiple threads. Use of Syncs sometimes&#xA; * (but by no means always) adds flexibility and efficiency&#xA; * compared to the use of plain java monitor methods&#xA; * and locking, and are sometimes (but by no means always)&#xA; * simpler to program with.&#xA; * &lt;p>&#xA; *&#xA; * Most Syncs are intended to be used primarily (although&#xA; * not exclusively) in  before/after constructions such as:&#xA; * &lt;pre>&#xA; * class X {&#xA; *   Sync gate;&#xA; *   // ...&#xA; *&#xA; *   public void m() { &#xA; *     try {&#xA; *       gate.acquire();  // block until condition holds&#xA; *       try {&#xA; *         // ... method body&#xA; *       }&#xA; *       finally {&#xA; *         gate.release()&#xA; *       }&#xA; *     }&#xA; *     catch (InterruptedException ex) {&#xA; *       // ... evasive action&#xA; *     }&#xA; *   }&#xA; *&#xA; *   public void m2(Sync cond) { // use supplied condition&#xA; *     try {&#xA; *       if (cond.attempt(10)) {         // try the condition for 10 ms&#xA; *         try {&#xA; *           // ... method body&#xA; *         }&#xA; *         finally {&#xA; *           cond.release()&#xA; *         }&#xA; *       }&#xA; *     }&#xA; *     catch (InterruptedException ex) {&#xA; *       // ... evasive action&#xA; *     }&#xA; *   }&#xA; * }&#xA; * &lt;/pre>&#xA; * Syncs may be used in somewhat tedious but more flexible replacements&#xA; * for built-in Java synchronized blocks. For example:&#xA; * &lt;pre>&#xA; * class HandSynched {          &#xA; *   private double state_ = 0.0; &#xA; *   private final Sync lock;  // use lock type supplied in constructor&#xA; *   public HandSynched(Sync l) { lock = l; } &#xA; *&#xA; *   public void changeState(double d) {&#xA; *     try {&#xA; *       lock.acquire(); &#xA; *       try     { state_ = updateFunction(d); } &#xA; *       finally { lock.release(); }&#xA; *     } &#xA; *     catch(InterruptedException ex) { }&#xA; *   }&#xA; *&#xA; *   public double getState() {&#xA; *     double d = 0.0;&#xA; *     try {&#xA; *       lock.acquire(); &#xA; *       try     { d = accessFunction(state_); }&#xA; *       finally { lock.release(); }&#xA; *     } &#xA; *     catch(InterruptedException ex){}&#xA; *     return d;&#xA; *   }&#xA; *   private double updateFunction(double d) { ... }&#xA; *   private double accessFunction(double d) { ... }&#xA; * }&#xA; * &lt;/pre>&#xA; * If you have a lot of such methods, and they take a common&#xA; * form, you can standardize this using wrappers. Some of these&#xA; * wrappers are standardized in LockedExecutor, but you can make others.&#xA; * For example:&#xA; * &lt;pre>&#xA; * class HandSynchedV2 {          &#xA; *   private double state_ = 0.0; &#xA; *   private final Sync lock;  // use lock type supplied in constructor&#xA; *   public HandSynchedV2(Sync l) { lock = l; } &#xA; *&#xA; *   protected void runSafely(Runnable r) {&#xA; *     try {&#xA; *       lock.acquire();&#xA; *       try { r.run(); }&#xA; *       finally { lock.release(); }&#xA; *     }&#xA; *     catch (InterruptedException ex) { // propagate without throwing&#xA; *       Thread.currentThread().interrupt();&#xA; *     }&#xA; *   }&#xA; *&#xA; *   public void changeState(double d) {&#xA; *     runSafely(new Runnable() {&#xA; *       public void run() { state_ = updateFunction(d); } &#xA; *     });&#xA; *   }&#xA; *   // ...&#xA; * }&#xA; * &lt;/pre>&#xA; * &lt;p>&#xA; * One reason to bother with such constructions is to use deadlock-&#xA; * avoiding back-offs when dealing with locks involving multiple objects.&#xA; * For example, here is a Cell class that uses attempt to back-off&#xA; * and retry if two Cells are trying to swap values with each other &#xA; * at the same time.&#xA; * &lt;pre>&#xA; * class Cell {&#xA; *   long value;&#xA; *   Sync lock = ... // some sync implementation class&#xA; *   void swapValue(Cell other) {&#xA; *     for (;;) { &#xA; *       try {&#xA; *         lock.acquire();&#xA; *         try {&#xA; *           if (other.lock.attempt(100)) {&#xA; *             try { &#xA; *               long t = value; &#xA; *               value = other.value;&#xA; *               other.value = t;&#xA; *               return;&#xA; *             }&#xA; *             finally { other.lock.release(); }&#xA; *           }&#xA; *         }&#xA; *         finally { lock.release(); }&#xA; *       } &#xA; *       catch (InterruptedException ex) { return; }&#xA; *     }&#xA; *   }&#xA; * }&#xA; *&lt;/pre>&#xA; * &lt;p>&#xA; * Here is an even fancier version, that uses lock re-ordering&#xA; * upon conflict:&#xA; * &lt;pre>&#xA; * class Cell { &#xA; *   long value;&#xA; *   Sync lock = ...;&#xA; *   private static boolean trySwap(Cell a, Cell b) {&#xA; *     a.lock.acquire();&#xA; *     try {&#xA; *       if (!b.lock.attempt(0)) &#xA; *         return false;&#xA; *       try { &#xA; *         long t = a.value;&#xA; *         a.value = b.value;&#xA; *         b.value = t;&#xA; *         return true;&#xA; *       }&#xA; *       finally { other.lock.release(); }&#xA; *     }&#xA; *     finally { lock.release(); }&#xA; *     return false;&#xA; *   }&#xA; *&#xA; *  void swapValue(Cell other) {&#xA; *    try {&#xA; *      while (!trySwap(this, other) &amp;&amp;&#xA; *            !tryswap(other, this)) &#xA; *        Thread.sleep(1);&#xA; *    }&#xA; *    catch (InterruptedException ex) { return; }&#xA; *  }&#xA; *}&#xA; *&lt;/pre>&#xA; * &lt;p>&#xA; * Interruptions are in general handled as early as possible.&#xA; * Normally, InterruptionExceptions are thrown&#xA; * in acquire and attempt(msec) if interruption&#xA; * is detected upon entry to the method, as well as in any&#xA; * later context surrounding waits. &#xA; * However, interruption status is ignored in release();&#xA; * &lt;p>&#xA; * Timed versions of attempt report failure via return value.&#xA; * If so desired, you can transform such constructions to use exception&#xA; * throws via &#xA; * &lt;pre>&#xA; *   if (!c.attempt(timeval)) throw new TimeoutException(timeval);&#xA; * &lt;/pre>&#xA; * &lt;p>&#xA; * The TimoutSync wrapper class can be used to automate such usages.&#xA; * &lt;p>&#xA; * All time values are expressed in milliseconds as longs, which have a maximum&#xA; * value of Long.MAX_VALUE, or almost 300,000 centuries. It is not&#xA; * known whether JVMs actually deal correctly with such extreme values. &#xA; * For convenience, some useful time values are defined as static constants.&#xA; * &lt;p>&#xA; * All implementations of the three Sync methods guarantee to&#xA; * somehow employ Java &lt;code>synchronized&lt;/code> methods or blocks,&#xA; * and so entail the memory operations described in JLS&#xA; * chapter 17 which ensure that variables are loaded and flushed&#xA; * within before/after constructions.&#xA; * &lt;p>&#xA; * Syncs may also be used in spinlock constructions. Although&#xA; * it is normally best to just use acquire(), various forms&#xA; * of busy waits can be implemented. For a simple example &#xA; * (but one that would probably never be preferable to using acquire()):&#xA; * &lt;pre>&#xA; * class X {&#xA; *   Sync lock = ...&#xA; *   void spinUntilAcquired() throws InterruptedException {&#xA; *     // Two phase. &#xA; *     // First spin without pausing.&#xA; *     int purespins = 10; &#xA; *     for (int i = 0; i &lt; purespins; ++i) {&#xA; *       if (lock.attempt(0))&#xA; *         return true;&#xA; *     }&#xA; *     // Second phase - use timed waits&#xA; *     long waitTime = 1; // 1 millisecond&#xA; *     for (;;) {&#xA; *       if (lock.attempt(waitTime))&#xA; *         return true;&#xA; *       else &#xA; *         waitTime = waitTime * 3 / 2 + 1; // increase 50% &#xA; *     }&#xA; *   }&#xA; * }&#xA; * &lt;/pre>&#xA; * &lt;p>&#xA; * In addition pure synchronization control, Syncs&#xA; * may be useful in any context requiring before/after methods.&#xA; * For example, you can use an ObservableSync&#xA; * (perhaps as part of a LayeredSync) in order to obtain callbacks&#xA; * before and after each method invocation for a given class.&#xA; * &lt;p>&#xA;&#xA; * &lt;p>[&lt;a href=&quot;http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html&quot;> Introduction to this package. &lt;/a>]&#xA;**/</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
