<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../../java.ecore#/4 http://www.emftext.org/java/members ../../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../../../java.ecore#/13 http://www.emftext.org/java/types ../../../../../java.ecore#/16" name="JPEGEncodeParam.java">
  <comments>/*&#xA; * @(#)JPEGEncodeParam.java&#x9;1.8 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/**********************************************************************&#xA; **********************************************************************&#xA; **********************************************************************&#xA; *** COPYRIGHT (c) 1997-1998 Eastman Kodak Company.                 ***&#xA; *** As  an unpublished  work pursuant to Title 17 of the United    ***&#xA; *** States Code.  All rights reserved.                             ***&#xA; **********************************************************************&#xA; **********************************************************************&#xA; **********************************************************************/</comments>
  <namespaces>com</namespaces>
  <namespaces>sun</namespaces>
  <namespaces>image</namespaces>
  <namespaces>codec</namespaces>
  <namespaces>jpeg</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="JPEGEncodeParam">
    <members xsi:type="members:InterfaceMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../java/lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setHorizontalSubsampling">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="component">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="subsample">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Set the horizontal subsample factor for the given component.&#xA;&#x9; * Note that the subsample factor is the number of input pixels&#xA;&#x9; * that contribute to each output pixel (ussually 2 for YCC).&#xA;&#x9; * @param component The component being specified.&#xA;&#x9; * @param subsample The subsampling factor being specified.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setVerticalSubsampling">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="component">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="subsample">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Set the vertical subsample factor for the given component.  Note that&#xA;&#x9; * the subsample factor is the number of input pixels that&#xA;&#x9; * contribute to each output pixel (ussually 2 for YCC).&#xA;&#x9; * @param component The component being specified.&#xA;&#x9; * @param subsample The subsampling factor being specified.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setQTable">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tableNum">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="qTable">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="JPEGQTable.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;&#x9; * Sets the coefficient quantization tables at index&#xA;&#x9; * passed. tableNum must range in value from 0 - 3.&#xA;&#x9; * @param qtable that will be used.&#xA;&#x9; * @param tableNum the index of the table to be set.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setDCHuffmanTable">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tableNum">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="huffTable">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="JPEGHuffmanTable.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Sets the DC Huffman coding table at index to the table provided. &#xA;&#x9; * @param huffTable JPEGHuffmanTable that will be assigned&#xA;&#x9; * to index tableNum.&#xA;&#x9; * @param tableNum - the index of the table to be set.&#xA;&#x9; * @exception IllegalArgumentException - thrown if the tableNum&#xA;&#x9; * is out of range.  Index must range in value from 0 - 3.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setACHuffmanTable">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tableNum">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="huffTable">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="JPEGHuffmanTable.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Sets the AC Huffman coding table at index to the table provided. &#xA;&#x9; * @param huffTable JPEGHuffmanTable that will be assigned&#xA;&#x9; * to index tableNum.&#xA;&#x9; * @param tableNum - the index of the table to be set.&#xA;&#x9; * @exception IllegalArgumentException - thrown if the tableNum&#xA;&#x9; * is out of range.  Index must range in value from 0 - 3.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setDCHuffmanComponentMapping">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="component">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="table">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Sets the mapping between a component and it's DC Huffman Table.&#xA;&#x9; * @param component The component to set the mapping for&#xA;&#x9; * @param table The DC Huffman table to use for component&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setACHuffmanComponentMapping">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="component">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="table">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Sets the mapping between a component and it's AC Huffman Table.&#xA;&#x9; * @param component The component to set the mapping for&#xA;&#x9; * @param table The AC Huffman table to use for component&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setQTableComponentMapping">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="component">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="table">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Sets the mapping between a component and it's Quantization Table.&#xA;&#x9; * @param component The component to set the mapping for&#xA;&#x9; * @param table The Quantization Table to use for component&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setImageInfoValid">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="flag">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Set the flag indicating the validity of the table information&#xA;&#x9; * in the ParamBlock.  This is used to indicate if tables should&#xA;&#x9; * be included when encoding.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setTableInfoValid">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="flag">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;&#x9; * Set the flag indicating the validity of the image information&#xA;&#x9; * in the ParamBlock.  This is used to indicates if image data&#xA;&#x9; * should be written when encoding.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setMarkerData">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="marker">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Sets the marker data to be written to the output data stream.&#xA;&#x9; * This removes any existing marker data in the JPEParm object.&#xA;&#x9; * This can be used to remove the default APP0 marker by calling&#xA;&#x9; * it with data set to null.&#xA;&#x9; * @param marker The marker to set the data for.&#xA;&#x9; * @param data the new set of data to be written.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addMarkerData">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="marker">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Appends 'data' to the array of byte[] associated with&#xA;&#x9; * marker. This will result in additional instance of the marker&#xA;&#x9; * being written (one for each byte[] in the array.).&#xA;&#x9; * @param marker The marker to add and instance of.&#xA;&#x9; * @param data the data to be written.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setRestartInterval">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="restartInterval">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * Set the MCUs per restart, or 0 for no restart markers.&#xA;&#x9; * @param restartInterval number MCUs per restart marker.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setDensityUnit">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="unit">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;&#x9; * Set the pixel size units This value is copied into the APP0&#xA;&#x9; * marker (if that marker is written). This value isn't used by&#xA;&#x9; * the JPEG code.&#xA;&#x9; * @param unit One of the DENSITY_UNIT_* values.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setXDensity">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="density">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;&#x9; * Set the horizontal pixel density This value is written into the&#xA;&#x9; * APP0 marker. It isn't used by the JPEG code.&#xA;&#x9; * @param density the horizontal pixel density, in units&#xA;&#x9; * described by @see JPEGParam.getDensityUnit.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setYDensity">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="density">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;&#x9; * Set the vertical pixel density.  This value is copied into&#xA;&#x9; * the JFIF APP0 marker. It isn't used by the JPEG code.&#xA;&#x9; * @param density The verticle pixel density, in units&#xA;&#x9; * described by @see JPEGParam.getDensityUnit.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setQuality">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="quality">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="forceBaseline">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;&#x9; * This creates new Quantization tables that replace the currently&#xA;&#x9; * installed Quantization tables.  It also updates the Component&#xA;&#x9; * QTable mapping to the default for the current encoded COLOR_ID.&#xA;&#xA;&#x9; * The Created Quantization table varies from very high&#xA;&#x9; * compression, very low quality, (0.0) to low compression, very&#xA;&#x9; * high quality (1.0) based on the quality parameter.&lt;P>&#xA;&#x9; &#xA;&#x9; * At a quality level of 1.0 the table will be all 1's which will&#xA;&#x9; * lead to no loss of data due to quantization (however chrominace&#xA;&#x9; * subsampling, if used, and roundoff error in the DCT will still&#xA;&#x9; * degrade the image some what).&lt;P>&#xA;&#xA;&#x9; * This is a linear manipulation of the standard Chrominance&#xA;&#x9; * Q-Table.&lt;P>&#xA;&#xA;&#x9; * &lt;pre>Some guidelines: 0.75 high quality&#xA;&#x9; *                 0.5  medium quality&#xA;&#x9; *                 0.25 low quality&#xA;&#x9; * &lt;/pre>&#xA;&#x9; * @param quality 0.0-1.0 setting of desired quality level.&#xA;&#x9; * @param forceBaseline force baseline quantization table&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/** &#xA; * JPEGEncodeParam encapsulates tables and options necessary to&#xA; * control encoding of JPEG data streams.  Parameters are either set&#xA; * explicitly by the application for encoding, or read from another&#xA; * JPEG header.&lt;p>&#xA;&#xA; * When working with BufferedImages, the codec will attempt to match&#xA; * the encoded JPEG COLOR_ID with the ColorModel in the BufferedImage.&#xA; * This is not always possible (the default mappings are listed&#xA; * below).  In cases where unsupported conversions are required (or&#xA; * odd image colorspaces are in use) the user must either convert the&#xA; * image data to a known ColorSpace or encode the data from a raster.&#xA; * When encoding rasters no colorspace adjustments are made, so the&#xA; * user must do any conversions required to get to the encoded&#xA; * COLOR_ID.&#xA; &#xA; * The COLOR_ID for the encoded images is used to control the JPEG&#xA; * codec's inital values for Huffman and Quantization Tables as well&#xA; * as subsampling factors. It is also used to determine what color&#xA; * conversion should be performed to obtain the best encoding.&lt;p>&#xA;&#xA; * Note: The color ids described herein are simply enumerated values&#xA; * that influence data processing by the JPEG codec.  JPEG compression&#xA; * is, by definition, color blind.  These values are used as hints when&#xA; * compressing JPEG data.  Through these values the JPEG codec can&#xA; * perform some default rotation of data into spaces that will aid in&#xA; * getting better compression ratios.&lt;P>&#xA;&#xA; * Example behaviour is described below.  Since these mappings are&#xA; * likely to change in the future it is strongly recommended that you&#xA; * make use of the @see JPEGImageEncoder.getDefaultParamBlock calls&#xA; * and check the encodedColorID for your particular BufferedImage.&#xA;&#xA; * In extreme cases is may be necessary for the user to convert the&#xA; * image to the desired colorspace, and encode it from a Raster.  In&#xA; * this case the API programmer must specify the colorID of the data&#xA; * in the Raster and no color conversion will take place.&#xA; &lt;pre>&#xA; ENCODING:&#xA; &#xA; BufferedImage Type/Instance        JPEG (Encoded) Color ID&#xA; ========================       =======================&#xA; TYPE_GRAY                      COLOR_ID_GRAYSCALE&#xA; TYPE_RGB                       COLOR_ID_YCbCr&#xA; TYPE_YCbCr                     COLOR_ID_YCbCr&#xA; TYPE_YCbCr/CS_PYCC             COLOR_ID_PYCC&#xA; TYPE_CMYK                      COLOR_ID_CMYK&#xA; TYPE_RGB   (w/ alpha)          COLOR_ID_YCbCrA&#xA; TYPE_YCbCr (w/ alpha)          COLOR_ID_YCbCrA&#xA; TYPE_YCbCr/CS_PYCC (w/ alpha)  COLOR_ID_PYCCA&#xA; ** Any Other **                COLOR_ID_UNKNOWN&#xA; &lt;/pre> &#xA;&#xA; * When the user wants more control than the BufferedImage conversions&#xA; * provide, the user must encode the data from a Raster. In this case&#xA; * the data undergoes no color conversion at all. It is the user's&#xA; * responsiblity to perform the desired conversions.&lt;P>&#xA; &#xA; * If you intend to write a JFIF image (by including the APP0_MARKER)&#xA; * the encoded COLOR_ID must be one of: COLOR_ID_UNKNOWN,&#xA; * COLOR_ID_GRAYSCALE, COLOR_ID_YCbCr, or COLOR_ID_CMYK. In all other&#xA; * instances an ImageformatException will be thrown.&lt;P>&#xA;&#xA; * &lt;B>IMPORTANT:&lt;/B> an Alpha RGB BufferedImage will not map to a&#xA; * valid JFIF stream, you must strip off the alpha prior to encoding&#xA; * if you want a JFIF file.  If the APP0 marker is set and you do not&#xA; * strip off the Alpha, an ImageFormatException will be thrown.&#xA; * &lt;p>&#xA; * Note that the classes in the com.sun.image.codec.jpeg package are not&#xA; * part of the core Java APIs.  They are a part of Sun's JDK and JRE&#xA; * distributions.  Although other licensees may choose to distribute these&#xA; * classes, developers cannot depend on their availability in non-Sun&#xA; * implementations.  We expect that equivalent functionality will eventually&#xA; * be available in a core API or standard extension.&#xA; * &lt;p>&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../../../../java/lang/Cloneable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="JPEGDecodeParam.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
