<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../../../../../../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../../../../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../../../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../../../../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../../../../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../../../../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../../../../../../java.ecore#/9 http://www.emftext.org/java/members ../../../../../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../../../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../../../../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../../../../../../java.ecore#/13 http://www.emftext.org/java/references ../../../../../../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../../../../../../java.ecore#/15 http://www.emftext.org/java/types ../../../../../../../../java.ecore#/16 http://www.emftext.org/java/variables ../../../../../../../../java.ecore#/17" name="DTMDocumentImpl.java">
  <comments>/*&#xA; * Copyright 1999-2004 The Apache Software Foundation.&#xA; *&#xA; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);&#xA; * you may not use this file except in compliance with the License.&#xA; * You may obtain a copy of the License at&#xA; *&#xA; *     http://www.apache.org/licenses/LICENSE-2.0&#xA; *&#xA; * Unless required by applicable law or agreed to in writing, software&#xA; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&#xA; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA; * See the License for the specific language governing permissions and&#xA; * limitations under the License.&#xA; */</comments>
  <comments>/*&#xA; * $Id: DTMDocumentImpl.java,v 1.13 2004/02/16 23:06:11 minchau Exp $&#xA; */</comments>
  <namespaces>com</namespaces>
  <namespaces>sun</namespaces>
  <namespaces>org</namespaces>
  <namespaces>apache</namespaces>
  <namespaces>xml</namespaces>
  <namespaces>internal</namespaces>
  <namespaces>dtm</namespaces>
  <namespaces>ref</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>transform</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../../../../../../javax/xml/transform/SourceLocator.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>com</namespaces>
    <namespaces>sun</namespaces>
    <namespaces>org</namespaces>
    <namespaces>apache</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>internal</namespaces>
    <namespaces>dtm</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../DTM.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>com</namespaces>
    <namespaces>sun</namespaces>
    <namespaces>org</namespaces>
    <namespaces>apache</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>internal</namespaces>
    <namespaces>dtm</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../DTMAxisIterator.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>com</namespaces>
    <namespaces>sun</namespaces>
    <namespaces>org</namespaces>
    <namespaces>apache</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>internal</namespaces>
    <namespaces>dtm</namespaces>
    <classifier xsi:type="classifiers:Class" href="../DTMAxisTraverser.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>com</namespaces>
    <namespaces>sun</namespaces>
    <namespaces>org</namespaces>
    <namespaces>apache</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>internal</namespaces>
    <namespaces>dtm</namespaces>
    <classifier xsi:type="classifiers:Class" href="../DTMManager.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>com</namespaces>
    <namespaces>sun</namespaces>
    <namespaces>org</namespaces>
    <namespaces>apache</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>internal</namespaces>
    <namespaces>dtm</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../DTMWSFilter.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>com</namespaces>
    <namespaces>sun</namespaces>
    <namespaces>org</namespaces>
    <namespaces>apache</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>internal</namespaces>
    <namespaces>utils</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../utils/FastStringBuffer.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>com</namespaces>
    <namespaces>sun</namespaces>
    <namespaces>org</namespaces>
    <namespaces>apache</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>internal</namespaces>
    <namespaces>utils</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../utils/XMLString.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>com</namespaces>
    <namespaces>sun</namespaces>
    <namespaces>org</namespaces>
    <namespaces>apache</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>internal</namespaces>
    <namespaces>utils</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../utils/XMLStringFactory.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>sax</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/Attributes.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>sax</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/ContentHandler.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>sax</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/Locator.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>org</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>sax</namespaces>
    <namespaces>ext</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/ext/LexicalHandler.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="DTMDocumentImpl">
    <members xsi:type="members:Field" name="DOCHANDLE_SHIFT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="22"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>// Number of lower bits used to represent node index.</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="NODEHANDLE_MASK">
      <initialValue xsi:type="expressions:AdditiveExpression">
        <children xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ShiftExpression">
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </expression>
            </children>
            <shiftOperators xsi:type="operators:LeftShift"/>
          </expression>
        </children>
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        <additiveOperators xsi:type="operators:Subtraction"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>// Masks the lower order of node handle.</comments>
        <comments>// Same as {@link DTMConstructor.IDENT_NODE_DEFAULT}</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DOCHANDLE_MASK">
      <initialValue xsi:type="expressions:AdditiveExpression">
        <children xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </children>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        <additiveOperators xsi:type="operators:Subtraction"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>// Masks the higher order Document handle</comments>
        <comments>// Same as {@link DTMConstructor.IDENT_DOC_DEFAULT}</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="m_docHandle">
      <initialValue xsi:type="references:IdentifierReference">
        <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
    </members>
    <members xsi:type="members:Field" name="m_docElement">
      <initialValue xsi:type="references:IdentifierReference">
        <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
      </initialValue>
      <typeReference xsi:type="types:Int">
        <comments>// masked document handle for this dtm document</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="currentParent">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int">
        <comments>// nodeHandle to the root of the actual dtm doc content</comments>
        <comments>// Context for parse-and-append operations</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="previousSibling">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int">
        <comments>// current parent - default is document root</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="m_currentNode">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>// previous sibling - no previous sibling</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="previousSiblingWasParent">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// current node</comments>
        <comments>// The tree under construction can itself be used as</comments>
        <comments>// the element stack, so m_elemStack isn't needed.</comments>
        <comments>//protected Stack m_elemStack = new Stack();&#x9; // element stack</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="gotslot">
      <initialValue xsi:type="arrays:ArrayInstantiationBySize">
        <typeReference xsi:type="types:Int"/>
        <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      </initialValue>
      <typeReference xsi:type="types:Int">
        <comments>// Local cache for record-at-a-time fetch</comments>
      </typeReference>
      <arrayDimensionsAfter/>
    </members>
    <members xsi:type="members:Field" name="done">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// endDocument recieved?</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="m_isError">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
    </members>
    <members xsi:type="members:Field" name="DEBUG">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="m_documentBaseURI">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/** The document base URI. */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="m_incrSAXSource">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="IncrementalSAXSource.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** If we're building the model incrementally on demand, we need to&#xA;   * be able to tell the source when to send us more data.&#xA;   *&#xA;   * Note that if this has not been set, and you attempt to read ahead&#xA;   * of the current build point, we'll probably throw a null-pointer&#xA;   * exception. We could try to wait-and-retry instead, as a very poor&#xA;   * fallback, but that has all the known problems with multithreading&#xA;   * on multiprocessors and we Don't Want to Go There.&#xA;   *&#xA;   * @see setIncrementalSAXSource&#xA;   */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="nodes">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ChunkedIntArray.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>// ========= DTM data structure declarations. ==============</comments>
          <comments>// nodes array: integer array blocks to hold the first level reference of the nodes,</comments>
          <comments>// each reference slot is addressed by a nodeHandle index value.</comments>
          <comments>// Assumes indices are not larger than {@link NODEHANDLE_MASK}</comments>
          <comments>// ({@link DOCHANDLE_SHIFT} bits).</comments>
          <target xsi:type="classifiers:Class" href="ChunkedIntArray.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="m_char">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../utils/FastStringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../utils/FastStringBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// text/comment table: string buffer to hold the text string values of the document,</comments>
        <comments>// each of which is addressed by the absolute offset and length in the buffer</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="m_char_current_start">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Start of string currently being accumulated into m_char;</comments>
        <comments>// needed because the string may be appended in several chunks.</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="m_localNames">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DTMStringPool.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DTMStringPool.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// %TBD% INITIALIZATION/STARTUP ISSUES</comments>
        <comments>// -- Should we really be creating these, or should they be</comments>
        <comments>// passed in from outside? Scott want to be able to share</comments>
        <comments>// pools across multiple documents, so setting them here is</comments>
        <comments>// probably not the right default.</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="m_nsNames">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DTMStringPool.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DTMStringPool.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="m_prefixNames">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DTMStringPool.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DTMStringPool.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="m_expandedNames">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ExpandedNameTable.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ExpandedNameTable.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// %TBD% If we use the current ExpandedNameTable mapper, it</comments>
        <comments>// needs to be bound to the NS and local name pools. Which</comments>
        <comments>// means it needs to attach to them AFTER we've resolved their</comments>
        <comments>// startup. Or it needs to attach to this document and</comments>
        <comments>// retrieve them each time. Or this needs to be</comments>
        <comments>// an interface _implemented_ by this class... which might be simplest!</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="m_xsf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../utils/XMLStringFactory.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Constructor" name="DTMDocumentImpl">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.62">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22">
            <comments>// clear nodes and document handle</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.3"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mgr">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../DTMManager.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="documentNumber">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="whiteSpaceFilter">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../DTMWSFilter.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="xstringfactory">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../utils/XMLStringFactory.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Construct a DTM.&#xA;         *&#xA;         * @param documentNumber the ID number assigned to this document.&#xA;         * It will be shifted up into the high bits and returned as part of&#xA;         * all node ID numbers, so those IDs indicate which document they&#xA;         * came from as well as a location within the document. It is the&#xA;         * DTMManager's responsibility to assign a unique number to each&#xA;         * document.&#xA;         */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="setIncrementalSAXSource">
      <comments>// Are the following really needed? IncrementalSAXSource doesn't yet</comments>
      <comments>// support them, and they're mostly no-ops here...</comments>
      <comments>//source.setErrorHandler(this);</comments>
      <comments>//source.setDTDHandler(this);</comments>
      <comments>//source.setDeclHandler(this);</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="IncrementalSAXSource.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Bind a IncrementalSAXSource to this DTM. If we discover we need nodes&#xA;   * that have not yet been built, we will ask this object to send us more&#xA;   * events, and it will manage interactions with its data sources.&#xA;   *&#xA;   * Note that we do not actually build the IncrementalSAXSource, since we don't&#xA;   * know what source it's reading from, what thread that source will run in,&#xA;   * or when it will run.&#xA;   *&#xA;   * @param source The IncrementalSAXSource that we want to recieve events from&#xA;   * on demand.&#xA;   */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0">
          <comments>// Establish SAX-stream link so we can receive the requested data</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="IncrementalSAXSource.class.xmi#//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="IncrementalSAXSource.class.xmi#//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendNode">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w0">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w2">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w3">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;         * Wrapper for ChunkedIntArray.append, to automatically update the&#xA;         * previous sibling's &quot;next&quot; reference (if necessary) and periodically&#xA;         * wake a reader who may have encountered incomplete data and entered&#xA;         * a wait state.&#xA;         * @param w0 int As in ChunkedIntArray.append&#xA;         * @param w1 int As in ChunkedIntArray.append&#xA;         * @param w2 int As in ChunkedIntArray.append&#xA;         * @param w3 int As in ChunkedIntArray.append&#xA;         * @return int As in ChunkedIntArray.append&#xA;         * @see ChunkedIntArray.append&#xA;         */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="slotnumber">
          <typeReference xsi:type="types:Int">
            <comments>// A decent compiler may inline this.</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.8"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.3"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../../../../../../java/io/PrintStream.class.xmi#//@classifiers.0/@members.42"/>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable"/>
                  <children xsi:type="references:StringReference" value=": "/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
                  <children xsi:type="references:StringReference" value=" "/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
                  <children xsi:type="references:StringReference" value=" "/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
                  <children xsi:type="references:StringReference" value=" "/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.3"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
              </next>
              <target xsi:type="members:Field" href="../../../../../../../../java/lang/System.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/System.class.xmi#//@classifiers.0"/>
          </expression>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12"/>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.13"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable"/>
            </next>
          </expression>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// Set the default; endElement overrides</comments>
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setFeature">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="featureId">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="state">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// ========= DTM Implementation Control Functions. ==============</comments>
        <comments>/**&#xA;         * Set an implementation dependent feature.&#xA;         * &lt;p>&#xA;         * %REVIEW% Do we really expect to set features on DTMs?&#xA;         *&#xA;         * @param featureId A feature URL.&#xA;         * @param state true if this feature should be on, false otherwise.&#xA;         */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:EmptyMember"/>
    <members xsi:type="members:ClassMethod" name="setLocalNameTable">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="poolRef">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DTMStringPool.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Set a reference pointer to the element name symbol table.&#xA;         * %REVIEW% Should this really be Public? Changing it while&#xA;         * DTM is in use would be a disaster.&#xA;         *&#xA;         * @param poolRef DTMStringPool reference to an instance of table.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLocalNameTable">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DTMStringPool.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Get a reference pointer to the element name symbol table.&#xA;         *&#xA;         * @return DTMStringPool reference to an instance of table.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setNsNameTable">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="poolRef">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DTMStringPool.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Set a reference pointer to the namespace URI symbol table.&#xA;         * %REVIEW% Should this really be Public? Changing it while&#xA;         * DTM is in use would be a disaster.&#xA;         *&#xA;         * @param poolRef DTMStringPool reference to an instance of table.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNsNameTable">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DTMStringPool.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Get a reference pointer to the namespace URI symbol table.&#xA;         *&#xA;         * @return DTMStringPool reference to an instance of table.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setPrefixNameTable">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="poolRef">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DTMStringPool.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Set a reference pointer to the prefix name symbol table.&#xA;         * %REVIEW% Should this really be Public? Changing it while&#xA;         * DTM is in use would be a disaster.&#xA;         *&#xA;         * @param poolRef DTMStringPool reference to an instance of table.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPrefixNameTable">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DTMStringPool.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Get a reference pointer to the prefix name symbol table.&#xA;         *&#xA;         * @return DTMStringPool reference to an instance of table.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setContentBuffer">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;          * Set a reference pointer to the content-text repository&#xA;          *&#xA;          * @param bufferRef FastStringBuffer reference to an instance of&#xA;          * buffer&#xA;          */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buffer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../utils/FastStringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getContentBuffer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;          * Get a reference pointer to the content-text repository&#xA;          *&#xA;          * @return FastStringBuffer reference to an instance of buffer&#xA;          */</comments>
          <target xsi:type="classifiers:Class" href="../../utils/FastStringBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getContentHandler">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/ContentHandler.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** getContentHandler returns &quot;our SAX builder&quot; -- the thing that&#xA;   * someone else should send SAX events to in order to extend this&#xA;   * DTM model.&#xA;   *&#xA;   * @return null if this model doesn't respond to SAX events,&#xA;   * &quot;this&quot; if the DTM object has a built-in SAX ContentHandler,&#xA;   * the IncrementalSAXSource if we're bound to one and should receive&#xA;   * the SAX stream via it for incremental build purposes...&#xA;   * */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/ContentHandler.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="IncrementalSAXSource_Filter.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </condition>
        <elseStatement xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </returnValue>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLexicalHandler">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/ext/LexicalHandler.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;   * Return this DTM's lexical handler.&#xA;   *&#xA;   * %REVIEW% Should this return null if constrution already done/begun?&#xA;   *&#xA;   * @return null if this model doesn't respond to lexical SAX events,&#xA;   * &quot;this&quot; if the DTM object has a built-in SAX ContentHandler,&#xA;   * the IncrementalSAXSource if we're bound to one and should receive&#xA;   * the SAX stream via it for incremental build purposes...&#xA;   */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/ext/LexicalHandler.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="IncrementalSAXSource_Filter.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </condition>
        <elseStatement xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </returnValue>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getEntityResolver">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/EntityResolver.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;   * Return this DTM's EntityResolver.&#xA;   *&#xA;   * @return null if this model doesn't respond to SAX entity ref events.&#xA;   */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDTDHandler">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/DTDHandler.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;   * Return this DTM's DTDHandler.&#xA;   *&#xA;   * @return null if this model doesn't respond to SAX dtd events.&#xA;   */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getErrorHandler">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/ErrorHandler.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;   * Return this DTM's ErrorHandler.&#xA;   *&#xA;   * @return null if this model doesn't respond to SAX error events.&#xA;   */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDeclHandler">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <namespaces>ext</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/ext/DeclHandler.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;   * Return this DTM's DeclHandler.&#xA;   *&#xA;   * @return null if this model doesn't respond to SAX Decl events.&#xA;   */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="needsTwoThreads">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** @return true iff we're building this model incrementally (eg&#xA;   * we're partnered with a IncrementalSAXSource) and thus require that the&#xA;   * transformation and the parse run simultaneously. Guidance to the&#xA;   * DTMManager.&#xA;   * */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="literals:NullLiteral"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="characters">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>//================================================================</comments>
        <comments>// ========= SAX2 ContentHandler methods =========</comments>
        <comments>// Accept SAX events, use them to build/extend the DTM tree.</comments>
        <comments>// Replaces the deprecated DocumentHandler interface.</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
          <comments>// Actually creating the text node is handled by</comments>
          <comments>// processAccumulatedText(); here we just accumulate the</comments>
          <comments>// characters into the buffer.</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../utils/FastStringBuffer.class.xmi#//@classifiers.0/@members.29"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.2"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="processAccumulatedText">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Flush string accumulation into a text node</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../utils/FastStringBuffer.class.xmi#//@classifiers.0/@members.21"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.119">
              <comments>// The FastStringBuffer has been previously agreed upon</comments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.0/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </arguments>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="endDocument">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.129">
          <comments>// May need to tell the low-level builder code to pop up a level.</comments>
          <comments>// There _should't_ be any significant pending text at this point.</comments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="endElement">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespaceURI">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="localName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="qName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.44"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.127">
          <comments>// No args but we do need to tell the low-level builder code to</comments>
          <comments>// pop up a level.</comments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="endPrefixMapping">
      <comments>// No-op</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="ignorableWhitespace">
      <comments>// %TBD% I believe ignorable text isn't part of the DTM model...?</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="processingInstruction">
      <comments>// %TBD% Which pools do target and data go into?</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="target">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.44"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setDocumentLocator">
      <comments>// No-op for DTM</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="locator">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/Locator.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="skippedEntity">
      <comments>//%TBD%</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.44"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="startDocument">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.128"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="startElement">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespaceURI">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="localName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="qName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="atts">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/Attributes.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.44"/>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="prefix">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// %TBD% Split prefix off qname</comments>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="colon">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.45"/>
              <arguments xsi:type="literals:CharacterLiteral" value="58"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.56"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.2/@variable"/>
              </next>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.2/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <comments>// %TBD% Where do we pool expandedName, or is it just the union, or...</comments>
          <comments>/**/</comments>
          <next xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../../../../../../java/io/PrintStream.class.xmi#//@classifiers.0/@members.42"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Prefix="/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable"/>
                <children xsi:type="references:StringReference" value=" index="/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable"/>
                  </next>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </next>
            <target xsi:type="members:Field" href="../../../../../../../../java/lang/System.class.xmi#//@classifiers.0/@members.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.121">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.1"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable"/>
            </next>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="nAtts">
          <typeReference xsi:type="types:Int">
            <comments>/////// %TBD%</comments>
            <comments>// %TBD% I'm assuming that DTM will require resequencing of</comments>
            <comments>// NS decls before other attrs, hence two passes are taken.</comments>
            <comments>// %TBD% Is there an easier way to test for NSDecl?</comments>
          </typeReference>
          <initialValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.3"/>
                <children xsi:type="literals:NullLiteral"/>
              </expression>
            </child>
            <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.3">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../../../../../../../../org/xml/sax/Attributes.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </expressionElse>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <comments>// %TBD% Countdown is more efficient if nobody cares about sequence.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.3">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../../../../../../../../org/xml/sax/Attributes.class.xmi#//@classifiers.0/@members.3"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.7/@init"/>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:NullLiteral"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.2/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.45"/>
                      <arguments xsi:type="literals:CharacterLiteral" value="58"/>
                    </next>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.56"/>
                          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.2/@variable"/>
                        </next>
                      </value>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.2/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </condition>
                <elseStatement xsi:type="statements:Block">
                  <comments>// Default prefix</comments>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable">
                        <comments>// %REVEIW% Null or &quot;&quot;?</comments>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="literals:NullLiteral"/>
                    </expression>
                  </statements>
                </elseStatement>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.122">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable"/>
                    </next>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.3">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:InterfaceMethod" href="../../../../../../../../org/xml/sax/Attributes.class.xmi#//@classifiers.0/@members.5"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.7/@init"/>
                        </next>
                      </arguments>
                    </next>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.3">
                    <next xsi:type="references:MethodCall">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.36"/>
                        <arguments xsi:type="references:StringReference" value="ID"/>
                      </next>
                      <target xsi:type="members:InterfaceMethod" href="../../../../../../../../org/xml/sax/Attributes.class.xmi#//@classifiers.0/@members.4"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.7/@init"/>
                    </next>
                  </arguments>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.42"/>
                  <arguments xsi:type="references:StringReference" value="xmlns:"/>
                </next>
              </children>
              <children xsi:type="references:StringReference" value="xmlns">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.33"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2"/>
                </next>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.7/@init"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.6/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </init>
        <updates xsi:type="expressions:PrefixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.7/@init"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.3">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../../../../../../../../org/xml/sax/Attributes.class.xmi#//@classifiers.0/@members.3"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.8/@init"/>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable">
                    <comments>// %TBD% I hate having to extract the prefix into a new</comments>
                    <comments>// string when we may never use it. Consider pooling whole</comments>
                    <comments>// qNames, which are already strings?</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:NullLiteral"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.2/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.45"/>
                      <arguments xsi:type="literals:CharacterLiteral" value="58"/>
                    </next>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.56"/>
                          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.2/@variable"/>
                        </next>
                      </value>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.1"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.55"/>
                          <arguments xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.2/@variable"/>
                            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                          </arguments>
                        </next>
                      </value>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.2/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </condition>
                <elseStatement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:StringReference" value=""/>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.1">
                        <comments>// Default prefix</comments>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2"/>
                    </expression>
                  </statements>
                </elseStatement>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../utils/FastStringBuffer.class.xmi#//@classifiers.0/@members.27"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.3">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:InterfaceMethod" href="../../../../../../../../org/xml/sax/Attributes.class.xmi#//@classifiers.0/@members.5"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.8/@init"/>
                      </next>
                    </arguments>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="contentEnd">
                  <typeReference xsi:type="types:Int">
                    <comments>// Single-string value</comments>
                  </typeReference>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../utils/FastStringBuffer.class.xmi#//@classifiers.0/@members.21"/>
                    </next>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.123">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.3">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:InterfaceMethod" href="../../../../../../../../org/xml/sax/Attributes.class.xmi#//@classifiers.0/@members.1"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.8/@init"/>
                          </next>
                        </arguments>
                      </next>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.1"/>
                      </next>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable"/>
                      </next>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.3">
                      <next xsi:type="references:MethodCall">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.36"/>
                          <arguments xsi:type="references:StringReference" value="ID"/>
                        </next>
                        <target xsi:type="members:InterfaceMethod" href="../../../../../../../../org/xml/sax/Attributes.class.xmi#//@classifiers.0/@members.4"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.8/@init"/>
                      </next>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.8/@statement/@statements.1/@statement/@statements.4/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </arguments>
                  </expression>
                </statement>
                <condition xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Negate"/>
                  <child xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:ConditionalOrExpression">
                      <children xsi:type="references:StringReference" value="xmlns">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.33"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable"/>
                        </next>
                      </children>
                      <children xsi:type="references:StringReference" value="xmlns">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.33"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2"/>
                        </next>
                      </children>
                    </expression>
                  </child>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.8/@statement/@statements.1/@statement/@statements.4/@variable"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ConditionalOrExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.42"/>
                      <arguments xsi:type="references:StringReference" value="xmlns:"/>
                    </next>
                  </children>
                  <children xsi:type="references:StringReference" value="xmlns">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.33"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2"/>
                    </next>
                  </children>
                </expression>
              </child>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.8/@init"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.6/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </init>
        <updates xsi:type="expressions:PrefixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.8/@init"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="startPrefixMapping">
      <comments>// No-op in DTM, handled during element/attr processing?</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="uri">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="comment">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>//</comments>
        <comments>// LexicalHandler support. Not all SAX2 parsers support these events</comments>
        <comments>// but we may want to pass them through when they exist...</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.44"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../utils/FastStringBuffer.class.xmi#//@classifiers.0/@members.29"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.2"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.120">
          <comments>// Single-string value</comments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.2"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="endCDATA">
      <comments>// No-op in DTM</comments>
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="endDTD">
      <comments>// No-op in DTM</comments>
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="endEntity">
      <comments>// No-op in DTM</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="startCDATA">
      <comments>// No-op in DTM</comments>
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="startDTD">
      <comments>// No-op in DTM</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="publicId">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="systemId">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="startEntity">
      <comments>// No-op in DTM</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>lang</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="initDocument">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="documentNumber">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>//================================================================</comments>
        <comments>// ========= Document Handler Functions =========</comments>
        <comments>// %REVIEW% jjk -- DocumentHandler is  SAX Level 1, and deprecated....</comments>
        <comments>// and this wasn't a fully compliant or declared implementation of that API</comments>
        <comments>// in any case. Phase out in favor of SAX2 ContentHandler/LexicalHandler</comments>
        <comments>/**&#xA;         * Reset a dtm document to its initial (empty) state.&#xA;         *&#xA;         * The DTMManager will invoke this method when the dtm is created.&#xA;         *&#xA;         * @param docHandle int the handle for the DTM document.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
            <comments>// save masked DTM document handle</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:ShiftExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <shiftOperators xsi:type="operators:LeftShift"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
          <comments>// Initialize the doc -- no parent, no next-sib</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.10"/>
            </arguments>
            <arguments xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arguments>
            <arguments xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10">
            <comments>// wait for the first startElement to create the doc root node</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hasChildNodes">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// &#x9;/**</comments>
        <comments>// &#x9; * Receive hint of the end of a document.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * &lt;p>The content handler will invoke this method only once, and it will</comments>
        <comments>// &#x9; * be the last method invoked during the parse.  The handler shall not</comments>
        <comments>// &#x9; * not invoke this method until it has either abandoned parsing</comments>
        <comments>// &#x9; * (because of an unrecoverable error) or reached the end of</comments>
        <comments>// &#x9; * input.&lt;/p></comments>
        <comments>// &#x9; */</comments>
        <comments>// &#x9;public void documentEnd()</comments>
        <comments>// &#x9;{</comments>
        <comments>// &#x9;&#x9;done = true;</comments>
        <comments>// &#x9;&#x9;// %TBD% may need to notice the last slot number and slot count to avoid</comments>
        <comments>// &#x9;&#x9;// residual data from provious use of this DTM</comments>
        <comments>// &#x9;}</comments>
        <comments>// &#x9;/**</comments>
        <comments>// &#x9; * Receive notification of the beginning of a document.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * &lt;p>The SAX parser will invoke this method only once, before any</comments>
        <comments>// &#x9; * other methods in this interface.&lt;/p></comments>
        <comments>// &#x9; */</comments>
        <comments>// &#x9;public void reset()</comments>
        <comments>// &#x9;{</comments>
        <comments>// &#x9;&#x9;// %TBD% reset slot 0 to indicate ChunkedIntArray reuse or wait for</comments>
        <comments>// &#x9;&#x9;//       the next initDocument().</comments>
        <comments>// &#x9;&#x9;m_docElement = NULL;&#x9; // reset nodeHandle to the root of the actual dtm doc content</comments>
        <comments>// &#x9;&#x9;initDocument(0);</comments>
        <comments>// &#x9;}</comments>
        <comments>// &#x9;/**</comments>
        <comments>// &#x9; * Factory method; creates an Element node in this document.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * The node created will be chained according to its natural order of request</comments>
        <comments>// &#x9; * received.  %TBD% It can be rechained later via the optional DTM writable interface.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * &lt;p>The XML content handler will invoke endElement() method after all</comments>
        <comments>// &#x9; * of the element's content are processed in order to give DTM the indication</comments>
        <comments>// &#x9; * to prepare and patch up parent and sibling node pointers.&lt;/p></comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * &lt;p>The following interface for createElement will use an index value corresponds</comments>
        <comments>// &#x9; * to the symbol entry in the DTMDStringPool based symbol tables.&lt;/p></comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * @param nsIndex The namespace of the node</comments>
        <comments>// &#x9; * @param nameIndex The element name.</comments>
        <comments>// &#x9; * @see #endElement</comments>
        <comments>// &#x9; * @see org.xml.sax.Attributes</comments>
        <comments>// &#x9; * @return nodeHandle int of the element created</comments>
        <comments>// &#x9; */</comments>
        <comments>// &#x9;public int createElement(int nsIndex, int nameIndex, Attributes atts)</comments>
        <comments>// &#x9;{</comments>
        <comments>// &#x9;&#x9;// do document root node creation here on the first element, create nodes for</comments>
        <comments>// &#x9;&#x9;// this element and its attributes, store the element, namespace, and attritute</comments>
        <comments>// &#x9;&#x9;// name indexes to the nodes array, keep track of the current node and parent</comments>
        <comments>// &#x9;&#x9;// element used</comments>
        <comments>// &#x9;&#x9;// W0  High:  Namespace  Low:  Node Type</comments>
        <comments>// &#x9;&#x9;int w0 = (nsIndex &lt;&lt; 16) | ELEMENT_NODE;</comments>
        <comments>// &#x9;&#x9;// W1: Parent</comments>
        <comments>// &#x9;&#x9;int w1 = currentParent;</comments>
        <comments>// &#x9;&#x9;// W2: Next  (initialized as 0)</comments>
        <comments>// &#x9;&#x9;int w2 = 0;</comments>
        <comments>// &#x9;&#x9;// W3: Tagname</comments>
        <comments>// &#x9;&#x9;int w3 = nameIndex;</comments>
        <comments>// &#x9;&#x9;//int ourslot = nodes.appendSlot(w0, w1, w2, w3);</comments>
        <comments>// &#x9;&#x9;int ourslot = appendNode(w0, w1, w2, w3);</comments>
        <comments>// &#x9;&#x9;currentParent = ourslot;</comments>
        <comments>// &#x9;&#x9;previousSibling = 0;</comments>
        <comments>// &#x9;&#x9;setAttributes(atts);</comments>
        <comments>// &#x9;&#x9;// set the root element pointer when creating the first element node</comments>
        <comments>// &#x9;&#x9;if (m_docElement == NULL)</comments>
        <comments>// &#x9;&#x9;&#x9;m_docElement = ourslot;</comments>
        <comments>// &#x9;&#x9;return (m_docHandle | ourslot);</comments>
        <comments>// &#x9;}</comments>
        <comments>// &#x9;// Factory method to create an Element node not associated with a given name space</comments>
        <comments>// &#x9;// using String value parameters passed in from a content handler or application</comments>
        <comments>// &#x9;/**</comments>
        <comments>// &#x9; * Factory method; creates an Element node not associated with a given name space in this document.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * The node created will be chained according to its natural order of request</comments>
        <comments>// &#x9; * received.  %TBD% It can be rechained later via the optional DTM writable interface.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * &lt;p>The XML content handler or application will invoke endElement() method after all</comments>
        <comments>// &#x9; * of the element's content are processed in order to give DTM the indication</comments>
        <comments>// &#x9; * to prepare and patch up parent and sibling node pointers.&lt;/p></comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * &lt;p>The following parameters for createElement contains raw string values for name</comments>
        <comments>// &#x9; * symbols used in an Element node.&lt;/p></comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * @param name String the element name, including the prefix if any.</comments>
        <comments>// &#x9; * @param atts The attributes attached to the element, if any.</comments>
        <comments>// &#x9; * @see #endElement</comments>
        <comments>// &#x9; * @see org.xml.sax.Attributes</comments>
        <comments>// &#x9; */</comments>
        <comments>// &#x9;public int createElement(String name, Attributes atts)</comments>
        <comments>// &#x9;{</comments>
        <comments>// &#x9;&#x9;// This method wraps around the index valued interface of the createElement interface.</comments>
        <comments>// &#x9;&#x9;// The raw string values are stored into the current DTM name symbol tables.  The method</comments>
        <comments>// &#x9;&#x9;// method will then use the index values returned to invoke the other createElement()</comments>
        <comments>// &#x9;&#x9;// onverted to index values modified to match a</comments>
        <comments>// &#x9;&#x9;// method.</comments>
        <comments>// &#x9;&#x9;int nsIndex = NULL;</comments>
        <comments>// &#x9;&#x9;int nameIndex = m_localNames.stringToIndex(name);</comments>
        <comments>// &#x9;&#x9;// note - there should be no prefix separator in the name because it is not associated</comments>
        <comments>// &#x9;&#x9;// with a name space</comments>
        <comments>// &#x9;&#x9;return createElement(nsIndex, nameIndex, atts);</comments>
        <comments>// &#x9;}</comments>
        <comments>// &#x9;// Factory method to create an Element node associated with a given name space</comments>
        <comments>// &#x9;// using String value parameters passed in from a content handler or application</comments>
        <comments>// &#x9;/**</comments>
        <comments>// &#x9; * Factory method; creates an Element node associated with a given name space in this document.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * The node created will be chained according to its natural order of request</comments>
        <comments>// &#x9; * received.  %TBD% It can be rechained later via the optional DTM writable interface.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * &lt;p>The XML content handler or application will invoke endElement() method after all</comments>
        <comments>// &#x9; * of the element's content are processed in order to give DTM the indication</comments>
        <comments>// &#x9; * to prepare and patch up parent and sibling node pointers.&lt;/p></comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * &lt;p>The following parameters for createElementNS contains raw string values for name</comments>
        <comments>// &#x9; * symbols used in an Element node.&lt;/p></comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * @param ns String the namespace of the node</comments>
        <comments>// &#x9; * @param name String the element name, including the prefix if any.</comments>
        <comments>// &#x9; * @param atts The attributes attached to the element, if any.</comments>
        <comments>// &#x9; * @see #endElement</comments>
        <comments>// &#x9; * @see org.xml.sax.Attributes</comments>
        <comments>// &#x9; */</comments>
        <comments>// &#x9;public int createElementNS(String ns, String name, Attributes atts)</comments>
        <comments>// &#x9;{</comments>
        <comments>// &#x9;&#x9;// This method wraps around the index valued interface of the createElement interface.</comments>
        <comments>// &#x9;&#x9;// The raw string values are stored into the current DTM name symbol tables.  The method</comments>
        <comments>// &#x9;&#x9;// method will then use the index values returned to invoke the other createElement()</comments>
        <comments>// &#x9;&#x9;// onverted to index values modified to match a</comments>
        <comments>// &#x9;&#x9;// method.</comments>
        <comments>// &#x9;&#x9;int nsIndex = m_nsNames.stringToIndex(ns);</comments>
        <comments>// &#x9;&#x9;int nameIndex = m_localNames.stringToIndex(name);</comments>
        <comments>// &#x9;&#x9;// The prefixIndex is not needed by the indexed interface of the createElement method</comments>
        <comments>// &#x9;&#x9;int prefixSep = name.indexOf(&quot;:&quot;);</comments>
        <comments>// &#x9;&#x9;int prefixIndex = m_prefixNames.stringToIndex(name.substring(0, prefixSep));</comments>
        <comments>// &#x9;&#x9;return createElement(nsIndex, nameIndex, atts);</comments>
        <comments>// &#x9;}</comments>
        <comments>// &#x9;/**</comments>
        <comments>// &#x9; * Receive an indication for the end of an element.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * &lt;p>The XML content handler will invoke this method at the end of every</comments>
        <comments>// &#x9; * element in the XML document to give hint its time to pop up the current</comments>
        <comments>// &#x9; * element and parent and patch up parent and sibling pointers if necessary</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * &lt;p>%tbd% The following interface may need to be modified to match a</comments>
        <comments>// &#x9; * coordinated access to the DTMDStringPool based symbol tables.&lt;/p></comments>
        <comments>// &#x9;&#x9; *</comments>
        <comments>// &#x9; * @param ns the namespace of the element</comments>
        <comments>// &#x9; * @param localName The local part of the qualified name of the element</comments>
        <comments>// &#x9; * @param name The element name</comments>
        <comments>// &#x9; */</comments>
        <comments>// &#x9;public void endElement(String ns, String name)</comments>
        <comments>// &#x9;{</comments>
        <comments>// &#x9;&#x9;// pop up the stacks</comments>
        <comments>// &#x9;&#x9;//</comments>
        <comments>// &#x9;&#x9;if (previousSiblingWasParent)</comments>
        <comments>// &#x9;&#x9;&#x9;nodes.writeEntry(previousSibling, 2, NULL);</comments>
        <comments>// &#x9;&#x9;// Pop parentage</comments>
        <comments>// &#x9;&#x9;previousSibling = currentParent;</comments>
        <comments>// &#x9;&#x9;nodes.readSlot(currentParent, gotslot);</comments>
        <comments>// &#x9;&#x9;currentParent = gotslot[1] &amp; 0xFFFF;</comments>
        <comments>// &#x9;&#x9;// The element just being finished will be</comments>
        <comments>// &#x9;&#x9;// the previous sibling for the next operation</comments>
        <comments>// &#x9;&#x9;previousSiblingWasParent = true;</comments>
        <comments>// &#x9;&#x9;// Pop a level of namespace table</comments>
        <comments>// &#x9;&#x9;// namespaceTable.removeLastElem();</comments>
        <comments>// &#x9;}</comments>
        <comments>// &#x9;/**</comments>
        <comments>// &#x9; * Creates attributes for the current node.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * @param atts Attributes to be created.</comments>
        <comments>// &#x9; */</comments>
        <comments>// &#x9;void setAttributes(Attributes atts) {</comments>
        <comments>// &#x9;&#x9;int atLength = (null == atts) ? 0 : atts.getLength();</comments>
        <comments>// &#x9;&#x9;for (int i=0; i &lt; atLength; i++) {</comments>
        <comments>// &#x9;&#x9;&#x9;String qname = atts.getQName(i);</comments>
        <comments>// &#x9;&#x9;&#x9;createAttribute(atts.getQName(i), atts.getValue(i));</comments>
        <comments>// &#x9;&#x9;}</comments>
        <comments>// &#x9;}</comments>
        <comments>// &#x9;/**</comments>
        <comments>// &#x9; * Appends an attribute to the document.</comments>
        <comments>// &#x9; * @param qname Qualified Name of the attribute</comments>
        <comments>// &#x9; * @param value Value of the attribute</comments>
        <comments>// &#x9; * @return Handle of node</comments>
        <comments>// &#x9; */</comments>
        <comments>// &#x9;public int createAttribute(String qname, String value) {</comments>
        <comments>// &#x9;&#x9;int colonpos = qname.indexOf(&quot;:&quot;);</comments>
        <comments>// &#x9;&#x9;String attName = qname.substring(colonpos+1);</comments>
        <comments>// &#x9;&#x9;int w0 = 0;</comments>
        <comments>// &#x9;&#x9;if (colonpos > 0) {</comments>
        <comments>// &#x9;&#x9;&#x9;String prefix = qname.substring(0, colonpos);</comments>
        <comments>// &#x9;&#x9;&#x9;if (prefix.equals(&quot;xml&quot;)) {</comments>
        <comments>// &#x9;&#x9;&#x9;&#x9;//w0 = ATTRIBUTE_NODE |</comments>
        <comments>// &#x9;&#x9;&#x9;&#x9;//&#x9;(com.sun.org.apache.xalan.internal.templates.Constants.S_XMLNAMESPACEURI &lt;&lt; 16);</comments>
        <comments>// &#x9;&#x9;&#x9;} else {</comments>
        <comments>// &#x9;&#x9;&#x9;&#x9;//w0 = ATTRIBUTE_NODE |</comments>
        <comments>// &#x9;&#x9;&#x9;}</comments>
        <comments>// &#x9;&#x9;} else {</comments>
        <comments>// &#x9;&#x9;&#x9;w0 = ATTRIBUTE_NODE;</comments>
        <comments>// &#x9;&#x9;}</comments>
        <comments>// &#x9;&#x9;// W1:  Parent</comments>
        <comments>// &#x9;&#x9;int w1 = currentParent;</comments>
        <comments>// &#x9;&#x9;// W2:  Next (not yet resolved)</comments>
        <comments>// &#x9;&#x9;int w2 = 0;</comments>
        <comments>// &#x9;&#x9;// W3:  Tag name</comments>
        <comments>// &#x9;&#x9;int w3 = m_localNames.stringToIndex(attName);</comments>
        <comments>// &#x9;&#x9;// Add node</comments>
        <comments>// &#x9;&#x9;int ourslot = appendNode(w0, w1, w2, w3);</comments>
        <comments>// &#x9;&#x9;previousSibling = ourslot;&#x9;// Should attributes be previous siblings</comments>
        <comments>// &#x9;&#x9;// W0: Node Type</comments>
        <comments>// &#x9;&#x9;w0 = TEXT_NODE;</comments>
        <comments>// &#x9;&#x9;// W1: Parent</comments>
        <comments>// &#x9;&#x9;w1 = ourslot;</comments>
        <comments>// &#x9;&#x9;// W2: Start Position within buffer</comments>
        <comments>// &#x9;&#x9;w2 = m_char.length();</comments>
        <comments>// &#x9;&#x9;m_char.append(value);</comments>
        <comments>// &#x9;&#x9;// W3: Length</comments>
        <comments>// &#x9;&#x9;w3 = m_char.length() - w2;</comments>
        <comments>// &#x9;&#x9;appendNode(w0, w1, w2, w3);</comments>
        <comments>// &#x9;&#x9;charStringStart=m_char.length();</comments>
        <comments>// &#x9;&#x9;charStringLength = 0;</comments>
        <comments>// &#x9;&#x9;//previousSibling = ourslot;</comments>
        <comments>// &#x9;&#x9;// Attrs are Parents</comments>
        <comments>// &#x9;&#x9;previousSiblingWasParent = true;</comments>
        <comments>// &#x9;&#x9;return (m_docHandle | ourslot);</comments>
        <comments>// &#x9;}</comments>
        <comments>// &#x9;/**</comments>
        <comments>// &#x9; * Factory method; creates a Text node in this document.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * The node created will be chained according to its natural order of request</comments>
        <comments>// &#x9; * received.  %TBD% It can be rechained later via the optional DTM writable interface.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * @param text String The characters text string from the XML document.</comments>
        <comments>// &#x9; * @return int DTM node-number of the text node created</comments>
        <comments>// &#x9; */</comments>
        <comments>// &#x9;public int createTextNode(String text)</comments>
        <comments>// &#x9;throws DTMException</comments>
        <comments>// &#x9;{</comments>
        <comments>// &#x9;&#x9;// wraps around the index value based createTextNode method</comments>
        <comments>// &#x9;&#x9;return createTextNode(text.toCharArray(), 0, text.length());</comments>
        <comments>// &#x9;}</comments>
        <comments>// &#x9;/**</comments>
        <comments>// &#x9; * Factory method; creates a Text node in this document.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * The node created will be chained according to its natural order of request</comments>
        <comments>// &#x9; * received.  %TBD% It can be rechained later via the optional DTM writable interface.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * %REVIEW% for text normalization issues, unless we are willing to</comments>
        <comments>// &#x9; * insist that all adjacent text must be merged before this method</comments>
        <comments>// &#x9; * is called.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * @param ch The characters from the XML document.</comments>
        <comments>// &#x9; * @param start The start position in the array.</comments>
        <comments>// &#x9; * @param length The number of characters to read from the array.</comments>
        <comments>// &#x9; */</comments>
        <comments>// &#x9;public int createTextNode(char ch[], int start, int length)</comments>
        <comments>// &#x9;throws DTMException</comments>
        <comments>// &#x9;{</comments>
        <comments>// &#x9;&#x9;m_char.append(ch, start, length);&#x9;&#x9;// store the chunk to the text/comment string table</comments>
        <comments>// &#x9;&#x9;// create a Text Node</comments>
        <comments>// &#x9;&#x9;// %TBD% may be possible to combine with appendNode()to replace the next chunk of code</comments>
        <comments>// &#x9;&#x9;int w0 = TEXT_NODE;</comments>
        <comments>// &#x9;&#x9;// W1: Parent</comments>
        <comments>// &#x9;&#x9;int w1 = currentParent;</comments>
        <comments>// &#x9;&#x9;// W2: Start position within m_char</comments>
        <comments>// &#x9;&#x9;int w2 = charStringStart;</comments>
        <comments>// &#x9;&#x9;// W3: Length of the full string</comments>
        <comments>// &#x9;&#x9;int w3 = length;</comments>
        <comments>// &#x9;&#x9;int ourslot = appendNode(w0, w1, w2, w3);</comments>
        <comments>// &#x9;&#x9;previousSibling = ourslot;</comments>
        <comments>// &#x9;&#x9;charStringStart=m_char.length();</comments>
        <comments>// &#x9;&#x9;charStringLength = 0;</comments>
        <comments>// &#x9;&#x9;return (m_docHandle | ourslot);</comments>
        <comments>// &#x9;}</comments>
        <comments>// &#x9;/**</comments>
        <comments>// &#x9; * Factory method; creates a Comment node in this document.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * The node created will be chained according to its natural order of request</comments>
        <comments>// &#x9; * received.  %TBD% It can be rechained later via the optional DTM writable interface.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * @param text String The characters text string from the XML document.</comments>
        <comments>// &#x9; * @return int DTM node-number of the text node created</comments>
        <comments>// &#x9; */</comments>
        <comments>// &#x9;public int createComment(String text)</comments>
        <comments>// &#x9;throws DTMException</comments>
        <comments>// &#x9;{</comments>
        <comments>// &#x9;&#x9;// wraps around the index value based createTextNode method</comments>
        <comments>// &#x9;&#x9;return createComment(text.toCharArray(), 0, text.length());</comments>
        <comments>// &#x9;}</comments>
        <comments>// &#x9;/**</comments>
        <comments>// &#x9; * Factory method; creates a Comment node in this document.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * The node created will be chained according to its natural order of request</comments>
        <comments>// &#x9; * received.  %TBD% It can be rechained later via the optional DTM writable interface.</comments>
        <comments>// &#x9; *</comments>
        <comments>// &#x9; * @param ch An array holding the characters in the comment.</comments>
        <comments>// &#x9; * @param start The starting position in the array.</comments>
        <comments>// &#x9; * @param length The number of characters to use from the array.</comments>
        <comments>// &#x9; * @see DTMException</comments>
        <comments>// &#x9; */</comments>
        <comments>// &#x9;public int createComment(char ch[], int start, int length)</comments>
        <comments>// &#x9;throws DTMException</comments>
        <comments>// &#x9;{</comments>
        <comments>// &#x9;&#x9;m_char.append(ch, start, length);&#x9;&#x9;// store the comment string to the text/comment string table</comments>
        <comments>// &#x9;&#x9;// create a Comment Node</comments>
        <comments>// &#x9;&#x9;// %TBD% may be possible to combine with appendNode()to replace the next chunk of code</comments>
        <comments>// &#x9;&#x9;int w0 = COMMENT_NODE;</comments>
        <comments>// &#x9;&#x9;// W1: Parent</comments>
        <comments>// &#x9;&#x9;int w1 = currentParent;</comments>
        <comments>// &#x9;&#x9;// W2: Start position within m_char</comments>
        <comments>// &#x9;&#x9;int w2 = charStringStart;</comments>
        <comments>// &#x9;&#x9;// W3: Length of the full string</comments>
        <comments>// &#x9;&#x9;int w3 = length;</comments>
        <comments>// &#x9;&#x9;int ourslot = appendNode(w0, w1, w2, w3);</comments>
        <comments>// &#x9;&#x9;previousSibling = ourslot;</comments>
        <comments>// &#x9;&#x9;charStringStart=m_char.length();</comments>
        <comments>// &#x9;&#x9;charStringLength = 0;</comments>
        <comments>// &#x9;&#x9;return (m_docHandle | ourslot);</comments>
        <comments>// &#x9;}</comments>
        <comments>// &#x9;// Counters to keep track of the current text string being accumulated with respect</comments>
        <comments>// &#x9;// to the text/comment string table: charStringStart should point to the starting</comments>
        <comments>// &#x9;// offset of the string in the table and charStringLength the acccumulated length when</comments>
        <comments>// &#x9;// appendAccumulatedText starts, and reset to the end of the table and 0 at the end</comments>
        <comments>// &#x9;// of appendAccumulatedText for the next set of characters receives</comments>
        <comments>// &#x9;int charStringStart=0,charStringLength=0;</comments>
        <comments>// ========= Document Navigation Functions =========</comments>
        <comments>/** Given a node handle, test if it has child nodes.&#xA;         * &lt;p> %REVIEW% This is obviously useful at the DOM layer, where it&#xA;         * would permit testing this without having to create a proxy&#xA;         * node. It's less useful in the DTM API, where&#xA;         * (dtm.getFirstChild(nodeHandle)!=DTM.NULL) is just as fast and&#xA;         * almost as self-evident. But it's a convenience, and eases porting&#xA;         * of DOM code to DTM.  &lt;/p>&#xA;         *&#xA;         * @param nodeHandle int Handle of the node.&#xA;         * @return int true if the given node has child nodes.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.64">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0"/>
            </children>
            <children xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
            </children>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getFirstChild">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, get the handle of the node's first child.&#xA;         * If not yet resolved, waits for more nodes to be added to the document and&#xA;         * tries again.&#xA;         *&#xA;         * @param nodeHandle int Handle of the node.&#xA;         * @return int DTM node-number of first child, or DTM.NULL to indicate none exists.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.0">
            <comments>// ###shs worry about tracing/debug later</comments>
          </child>
          <assignmentOperator xsi:type="operators:AssignmentAnd"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
          <comments>// Read node into variable</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="type">
          <typeReference xsi:type="types:Short">
            <comments>// type is the last half of first slot</comments>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Short"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                  <arraySelectors>
                    <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </arraySelectors>
                </children>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
              </expression>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Check to see if Element or Document node</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="kid">
              <typeReference xsi:type="types:Int">
                <comments>// In case when Document root is given</comments>
                <comments>//&#x9;if (nodeHandle == 0) nodeHandle = 1;</comments>
                <comments>// %TBD% Probably was a mistake.</comments>
                <comments>// If someone explicitly asks for first child</comments>
                <comments>// of Document, I would expect them to want</comments>
                <comments>// that and only that.</comments>
              </typeReference>
              <initialValue xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.3/@statement/@statements.0/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:WhileLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.3/@statement/@statements.0/@variable">
                    <comments>// points to next sibling</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                    </arraySelectors>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <comments>// Return NULL if node has only attributes</comments>
                <statement xsi:type="statements:Return">
                  <returnValue xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
                  </returnValue>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.3/@statement/@statements.0/@variable"/>
                  <children xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
                  </children>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.3/@statement/@statements.0/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.3"/>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AndExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    </arraySelectors>
                  </children>
                  <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// If parent slot matches given parent, return kid</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="firstChild">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="expressions:InclusiveOrExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.3/@statement/@statements.0/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.3/@statement/@statements.3/@statement/@statements.0/@variable"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.0"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.2"/>
              </children>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.10"/>
              </children>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.6"/>
              </children>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// No child found</comments>
        <returnValue xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLastChild">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;        * Given a node handle, advance to its last child.&#xA;        * If not yet resolved, waits for more nodes to be added to the document and&#xA;        * tries again.&#xA;        *&#xA;        * @param nodeHandle int Handle of the node.&#xA;        * @return int Node-number of last child,&#xA;        * or DTM.NULL to indicate none exists.&#xA;        */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@parameters.0">
            <comments>// ###shs put trace/debug later</comments>
          </child>
          <assignmentOperator xsi:type="operators:AssignmentAnd"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lastChild">
          <typeReference xsi:type="types:Int">
            <comments>// do not need to test node type since getFirstChild does that</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@statements.2/@init"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
          </children>
        </condition>
        <init xsi:type="variables:LocalVariable" name="nextkid">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.64">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@parameters.0"/>
          </initialValue>
        </init>
        <updates xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@statements.2/@init"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.69">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@statements.2/@init"/>
          </value>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:InclusiveOrExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@statements.1/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAttributeNode">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespaceURI">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Retrieves an attribute node by by qualified name and namespace URI.&#xA;         *&#xA;         * @param nodeHandle int Handle of the node upon which to look up this attribute.&#xA;         * @param namespaceURI The namespace URI of the attribute to&#xA;         *   retrieve, or null.&#xA;         * @param name The local name of the attribute to&#xA;         *   retrieve.&#xA;         * @return The attribute node handle with the specified name (&#xA;         *   &lt;code>nodeName&lt;/code>) or &lt;code>DTM.NULL&lt;/code> if there is no such&#xA;         *   attribute.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="nsIndex">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.1"/>
            </next>
          </initialValue>
          <additionalLocalVariables name="nameIndex">
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.2"/>
              </next>
            </initialValue>
          </additionalLocalVariables>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.0"/>
          <assignmentOperator xsi:type="operators:AssignmentAnd"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="type">
          <typeReference xsi:type="types:Short"/>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Short"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                  <arraySelectors>
                    <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </arraySelectors>
                </children>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
              </expression>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// If nodeHandle points to element next slot would be first attribute</comments>
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.0"/>
            <operator xsi:type="operators:PlusPlus"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.3/@variable"/>
          <children xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.2"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>// Iterate through Attribute Nodes</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="expressions:InclusiveOrExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.0/@variable"/>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:ShiftExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                        <arraySelectors>
                          <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        </arraySelectors>
                      </children>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                      <shiftOperators xsi:type="operators:LeftShift"/>
                    </expression>
                  </children>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                    </arraySelectors>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.0/@variable/@additionalLocalVariables.0"/>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.0">
                <comments>// Goto next sibling</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                </arraySelectors>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.3/@variable"/>
          <children xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.3"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getFirstAttribute">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, get the index of the node's first attribute.&#xA;         *&#xA;         * @param nodeHandle int Handle of the Element node.&#xA;         * @return Handle of first attribute, or DTM.NULL to indicate none exists.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@parameters.0"/>
          <assignmentOperator xsi:type="operators:AssignmentAnd"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// %REVIEW% jjk: Just a quick observation: If you're going to</comments>
        <comments>// call readEntry repeatedly on the same node, it may be</comments>
        <comments>// more efficiently to do a readSlot to get the data locally,</comments>
        <comments>// reducing the addressing and call-and-return overhead.</comments>
        <comments>// Should we check if handle is element (do we want sanity checks?)</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.2"/>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AndExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.9"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@parameters.0"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </next>
              </children>
              <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@parameters.0">
            <comments>// First Attribute (if any) should be at next position in table</comments>
          </child>
          <operator xsi:type="operators:PlusPlus"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.3"/>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AndExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.9"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@parameters.0"/>
                      <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    </next>
                  </children>
                  <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
                </expression>
              </children>
            </expression>
          </child>
          <expressionIf xsi:type="expressions:InclusiveOrExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          </expressionIf>
          <expressionElse xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getFirstNamespaceNode">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inScope">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, get the index of the node's first child.&#xA;         * If not yet resolved, waits for more nodes to be added to the document and&#xA;         * tries again&#xA;         *&#xA;         * @param nodeHandle handle to node, which should probably be an element&#xA;         *                   node, but need not be.&#xA;         *&#xA;         * @param inScope    true if all namespaces in scope should be returned,&#xA;         *                   false if only the namespace declarations should be&#xA;         *                   returned.&#xA;         * @return handle of first namespace, or DTM.NULL to indicate none exists.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNextSibling">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, advance to its next sibling.&#xA;         *&#xA;         * %TBD% This currently uses the DTM-internal definition of&#xA;         * sibling; eg, the last attr's next sib is the first&#xA;         * child. In the old DTM, the DOM proxy layer provided the&#xA;         * additional logic for the public view.  If we're rewriting&#xA;         * for XPath emulation, that test must be done here.&#xA;         *&#xA;         * %TBD% CODE INTERACTION WITH INCREMENTAL PARSE - If not yet&#xA;         * resolved, should wait for more nodes to be added to the document&#xA;         * and tries again.&#xA;         *&#xA;         * @param nodeHandle int Handle of the node.&#xA;         * @return int Node-number of next sibling,&#xA;         * or DTM.NULL to indicate none exists.&#xA;         * */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.0"/>
          <assignmentOperator xsi:type="operators:AssignmentAnd"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Document root has no next sibling</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="type">
          <typeReference xsi:type="types:Short"/>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Short"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.9"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.0"/>
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </next>
                </children>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
              </expression>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <comments>// ###shs should cycle/wait if nextSib is 0? Working on threading next</comments>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="nextSib">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.9"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.0"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.3/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:InclusiveOrExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.3/@statement/@statements.0/@variable"/>
                </expression>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.3/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.2"/>
              </children>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.3"/>
              </children>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.6"/>
              </children>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="thisParent">
          <typeReference xsi:type="types:Int">
            <comments>// Next Sibling is in the next position if it shares the same parent</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.0"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InclusiveOrExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.0"/>
            </expression>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="expressions:PrefixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.0"/>
                <operator xsi:type="operators:PlusPlus"/>
              </arguments>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.4/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPreviousSibling">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, find its preceeding sibling.&#xA;         * WARNING: DTM is asymmetric; this operation is resolved by search, and is&#xA;         * relatively expensive.&#xA;         *&#xA;         * @param nodeHandle the id of the node.&#xA;         * @return int Node-number of the previous sib,&#xA;         * or DTM.NULL to indicate none exists.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0"/>
          <assignmentOperator xsi:type="operators:AssignmentAnd"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Document root has no previous sibling</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="parent">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="kid">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.4/@init"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.4/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="nextkid">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.64">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.2/@variable"/>
          </initialValue>
        </init>
        <updates xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.4/@init"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.69">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.4/@init"/>
          </value>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:InclusiveOrExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNextAttribute">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, advance to the next attribute. If an&#xA;         * element, we advance to its first attribute; if an attr, we advance to&#xA;         * the next attr on the same node.&#xA;         *&#xA;         * @param nodeHandle int Handle of the node.&#xA;         * @return int DTM node-number of the resolved attr,&#xA;         * or DTM.NULL to indicate none exists.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0"/>
          <assignmentOperator xsi:type="operators:AssignmentAnd"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="type">
          <typeReference xsi:type="types:Short">
            <comments>//%REVIEW% Why are we using short here? There's no storage</comments>
            <comments>//reduction for an automatic variable, especially one used</comments>
            <comments>//so briefly, and it typically costs more cycles to process</comments>
            <comments>//than an int would.</comments>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Short"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                  <arraySelectors>
                    <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </arraySelectors>
                </children>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
              </expression>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.67">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@statements.2/@variable"/>
          <children xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.2"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:InclusiveOrExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                      <arraySelectors>
                        <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                      </arraySelectors>
                    </children>
                  </expression>
                </returnValue>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                  <arraySelectors>
                    <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                  </arraySelectors>
                </children>
                <children xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
                </children>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@statements.2/@variable"/>
            <children xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.3"/>
            </children>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNextNamespaceNode">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="baseHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespaceHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inScope">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a namespace handle, advance to the next namespace.&#xA;         *&#xA;         * %TBD% THIS METHOD DOES NOT MATCH THE CURRENT SIGNATURE IN&#xA;         * THE DTM INTERFACE.  FIX IT, OR JUSTIFY CHANGING THE DTM&#xA;         * API.&#xA;         *&#xA;         * @param namespaceHandle handle to node which must be of type NAMESPACE_NODE.&#xA;         * @return handle of next namespace, or DTM.NULL to indicate none exists.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// ###shs need to work on namespace</comments>
        <returnValue xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNextDescendant">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="subtreeRootHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, advance to its next descendant.&#xA;         * If not yet resolved, waits for more nodes to be added to the document and&#xA;         * tries again.&#xA;         *&#xA;         * @param subtreeRootNodeHandle&#xA;         * @param nodeHandle int Handle of the node.&#xA;         * @return handle of next descendant,&#xA;         * or DTM.NULL to indicate none exists.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.0"/>
          <assignmentOperator xsi:type="operators:AssignmentAnd"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.1"/>
          <assignmentOperator xsi:type="operators:AssignmentAnd"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Document root [Document Node? -- jjk] - no next-sib</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>// Document done and node out of bounds</comments>
            <statement xsi:type="statements:Break"/>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.1"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.11"/>
                    </next>
                  </children>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.1"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="type">
                      <typeReference xsi:type="types:Short"/>
                      <initialValue xsi:type="expressions:CastExpression">
                        <typeReference xsi:type="types:Short"/>
                        <child xsi:type="expressions:NestedExpression">
                          <expression xsi:type="expressions:AndExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                              <arraySelectors>
                                <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                              </arraySelectors>
                            </children>
                            <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
                          </expression>
                        </child>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.1"/>
                          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@statement/@statements.1/@statement/@statements.1/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.3"/>
                      </children>
                    </condition>
                    <elseStatement xsi:type="statements:Block">
                      <statements xsi:type="statements:LocalVariableStatement">
                        <variable name="nextParentPos">
                          <typeReference xsi:type="types:Int"/>
                          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                            <arraySelectors>
                              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                            </arraySelectors>
                          </initialValue>
                        </variable>
                      </statements>
                      <statements xsi:type="statements:Condition">
                        <statement xsi:type="statements:Return">
                          <returnValue xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:InclusiveOrExpression">
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                              <children xsi:type="expressions:NestedExpression">
                                <expression xsi:type="expressions:AdditiveExpression">
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.1"/>
                                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                                  <additiveOperators xsi:type="operators:Addition"/>
                                </expression>
                              </children>
                            </expression>
                          </returnValue>
                        </statement>
                        <condition xsi:type="expressions:RelationExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@statement/@statements.1/@statement/@statements.1/@statement/@statements.1/@elseStatement/@statements.0/@variable"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.0"/>
                          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                        </condition>
                        <elseStatement xsi:type="statements:Break"/>
                      </statements>
                    </elseStatement>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                    </arraySelectors>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </condition>
                <elseStatement xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <comments>// Add wait logic here</comments>
                  </statement>
                  <condition xsi:type="expressions:UnaryExpression">
                    <operators xsi:type="operators:Negate"/>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
                  </condition>
                  <elseStatement xsi:type="statements:Break"/>
                </elseStatement>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.0"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.1"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </expression>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// Probably should throw error here like original instead of returning</comments>
        <returnValue xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNextFollowing">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="axisContextHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, advance to the next node on the following axis.&#xA;         *&#xA;         * @param axisContextHandle the start of the axis that is being traversed.&#xA;         * @param nodeHandle&#xA;         * @return handle of next sibling,&#xA;         * or DTM.NULL to indicate none exists.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>//###shs still working on</comments>
        <returnValue xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNextPreceding">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="axisContextHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, advance to the next node on the preceding axis.&#xA;         *&#xA;         * @param axisContextHandle the start of the axis that is being traversed.&#xA;         * @param nodeHandle the id of the node.&#xA;         * @return int Node-number of preceding sibling,&#xA;         * or DTM.NULL to indicate none exists.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.1">
            <comments>// ###shs copied from Xalan 1, what is this suppose to do?</comments>
          </child>
          <assignmentOperator xsi:type="operators:AssignmentAnd"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.1"/>
              <operator xsi:type="operators:MinusMinus"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Continue"/>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.3"/>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AndExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.9"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.1"/>
                      <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    </next>
                  </children>
                  <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Return">
            <comments>// if nodeHandle is _not_ an ancestor of</comments>
            <comments>// axisContextHandle, specialFind will return it.</comments>
            <comments>// If it _is_ an ancestor, specialFind will return -1</comments>
            <comments>// %REVIEW% unconditional return defeats the</comments>
            <comments>// purpose of the while loop -- does this</comments>
            <comments>// logic make any sense?</comments>
            <returnValue xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:InclusiveOrExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.10"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.1"/>
                  </next>
                </children>
              </expression>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getParent">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, find its parent node.&#xA;         *&#xA;         * @param nodeHandle the id of the node.&#xA;         * @return int Node-number of parent,&#xA;         * or DTM.NULL to indicate none exists.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// Should check to see within range?</comments>
        <comments>// Document Root should not have to be handled differently</comments>
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:InclusiveOrExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.9"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.0"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </next>
            </children>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDocumentRoot">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Returns the root element of the document.&#xA;         * @return nodeHandle to the Document Root.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:InclusiveOrExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDocument">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;                * Given a node handle, find the owning document node.&#xA;                *&#xA;                * @param nodeHandle the id of the node.&#xA;                * @return int Node handle of document, which should always be valid.&#xA;                */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getOwnerDocument">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, find the owning document node.  This has the exact&#xA;         * same semantics as the DOM Document method of the same name, in that if&#xA;         * the nodeHandle is a document node, it will return NULL.&#xA;         *&#xA;         * &lt;p>%REVIEW% Since this is DOM-specific, it may belong at the DOM&#xA;         * binding layer. Included here as a convenience function and to&#xA;         * aid porting of DOM code to DTM.&lt;/p>&#xA;         *&#xA;         * @param nodeHandle the id of the node.&#xA;         * @return int Node handle of owning document, or NULL if the nodeHandle is&#xA;         *             a document.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// Assumption that Document Node is always in 0 slot</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AndExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:AndExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDocumentRoot">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, find the owning document node.  This has the DTM&#xA;         * semantics; a Document node is its own owner.&#xA;         *&#xA;         * &lt;p>%REVIEW% Since this is DOM-specific, it may belong at the DOM&#xA;         * binding layer. Included here as a convenience function and to&#xA;         * aid porting of DOM code to DTM.&lt;/p>&#xA;         *&#xA;         * @param nodeHandle the id of the node.&#xA;         * @return int Node handle of owning document, or NULL if the nodeHandle is&#xA;         *             a document.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// Assumption that Document Node is always in 0 slot</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AndExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:AndExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getStringValue">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../utils/XMLString.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Get the string-value of a node as a String object&#xA;         * (see http://www.w3.org/TR/xpath#data-model&#xA;         * for the definition of a node's string-value).&#xA;         *&#xA;         * @param nodeHandle The node ID.&#xA;         *&#xA;         * @return A string object that represents the string-value of the given node.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
          <comments>// ###zaj - researching</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="nodetype">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AndExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
              <arraySelectors>
                <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </arraySelectors>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="value">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Switch">
        <cases xsi:type="statements:NormalSwitchCase">
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.4"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.9"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../utils/FastStringBuffer.class.xmi#//@classifiers.0/@members.32"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                    </arraySelectors>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                    </arraySelectors>
                  </arguments>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Break"/>
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.5"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.8"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.3"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.2"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.6"/>
          </condition>
        </cases>
        <cases xsi:type="statements:DefaultSwitchCase">
          <statements xsi:type="statements:Break"/>
        </cases>
        <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.1/@variable"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../utils/XMLStringFactory.class.xmi#//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.2/@variable"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getStringValueChunkCount">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Get number of character array chunks in&#xA;         * the string-value of a node.&#xA;         * (see http://www.w3.org/TR/xpath#data-model&#xA;         * for the definition of a node's string-value).&#xA;         * Note that a single text node may have multiple text chunks.&#xA;         *&#xA;         * EXPLANATION: This method is an artifact of the fact that the&#xA;         * underlying m_chars object may not store characters in a&#xA;         * single contiguous array -- for example,the current&#xA;         * FastStringBuffer may split a single node's text across&#xA;         * multiple allocation units.  This call tells us how many&#xA;         * separate accesses will be required to retrieve the entire&#xA;         * content. PLEASE NOTE that this may not be the same as the&#xA;         * number of SAX characters() events that caused the text node&#xA;         * to be built in the first place, since m_chars buffering may&#xA;         * be on different boundaries than the parser's buffers.&#xA;         *&#xA;         * @param nodeHandle The node ID.&#xA;         *&#xA;         * @return number of character array chunks in&#xA;         *         the string-value of a node.&#xA;         * */</comments>
        <comments>//###zaj - tbd</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>//###zaj    return value</comments>
        <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getStringValueChunk">
      <typeReference xsi:type="types:Char"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="chunkIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="startAndLen">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Get a character array chunk in the string-value of a node.&#xA;         * (see http://www.w3.org/TR/xpath#data-model&#xA;         * for the definition of a node's string-value).&#xA;         * Note that a single text node may have multiple text chunks.&#xA;         *&#xA;         * EXPLANATION: This method is an artifact of the fact that&#xA;         * the underlying m_chars object may not store characters in a&#xA;         * single contiguous array -- for example,the current&#xA;         * FastStringBuffer may split a single node's text across&#xA;         * multiple allocation units.  This call retrieves a single&#xA;         * contiguous portion of the text -- as much as m-chars was&#xA;         * able to store in a single allocation unit.  PLEASE NOTE&#xA;         * that this may not be the same granularityas the SAX&#xA;         * characters() events that caused the text node to be built&#xA;         * in the first place, since m_chars buffering may be on&#xA;         * different boundaries than the parser's buffers.&#xA;         *&#xA;         * @param nodeHandle The node ID.&#xA;         * @param chunkIndex Which chunk to get.&#xA;         * @param startAndLen An array of 2 where the start position and length of&#xA;         *                    the chunk will be returned.&#xA;         *&#xA;         * @return The character array reference where the chunk occurs.  */</comments>
        <comments>//###zaj - tbd</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="arrays:ArrayInstantiationBySize">
          <typeReference xsi:type="types:Char"/>
          <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getExpandedTypeID">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, return an ID that represents the node's expanded name.&#xA;         *&#xA;         * @param nodeHandle The handle to the node in question.&#xA;         *&#xA;         * @return the expanded-name id of the node.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="qName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.8"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                </arraySelectors>
              </arguments>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="colonpos">
          <typeReference xsi:type="types:Int">
            <comments>// Remove prefix from qName</comments>
            <comments>// %TBD% jjk This is assuming the elementName is the qName.</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.49"/>
              <arguments xsi:type="references:StringReference" value=":"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="localName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.55"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@statements.2/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="namespace">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Get NS</comments>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.8"/>
              <arguments xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                  <arraySelectors>
                    <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </arraySelectors>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                <shiftOperators xsi:type="operators:LeftShift"/>
              </arguments>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="expandedName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Create expanded name</comments>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@statements.4/@variable"/>
            <children xsi:type="references:StringReference" value=":"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@statements.3/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="expandedNameID">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@statements.5/@variable"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@statements.6/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getExpandedTypeID">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespace">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="localName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given an expanded name, return an ID.  If the expanded-name does not&#xA;         * exist in the internal tables, the entry will be created, and the ID will&#xA;         * be returned.  Any additional nodes that are created that have this&#xA;         * expanded name will use this ID.&#xA;         *&#xA;         * @param nodeHandle The handle to the node in question.&#xA;         *&#xA;         * @return the expanded-name id of the node.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="expandedName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Create expanded name</comments>
              <comments>// %TBD% jjk Expanded name is bitfield-encoded as</comments>
              <comments>// typeID[6]nsuriID[10]localID[16]. Switch to that form, and to</comments>
              <comments>// accessing the ns/local via their tables rather than confusing</comments>
              <comments>// nsnames and expandednames.</comments>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85/@parameters.0"/>
            <children xsi:type="references:StringReference" value=":"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85/@parameters.1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="expandedNameID">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85/@statements.0/@variable"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLocalNameFromExpandedNameID">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ExpandedNameID">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given an expanded-name ID, return the local name part.&#xA;         *&#xA;         * @param ExpandedNameID an ID that represents an expanded-name.&#xA;         * @return String Local name of this node.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="expandedName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Get expanded name</comments>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.8"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="colonpos">
          <typeReference xsi:type="types:Int">
            <comments>// Remove prefix from expanded name</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.49"/>
              <arguments xsi:type="references:StringReference" value=":"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="localName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.55"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@statements.1/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNamespaceFromExpandedNameID">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ExpandedNameID">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given an expanded-name ID, return the namespace URI part.&#xA;         *&#xA;         * @param ExpandedNameID an ID that represents an expanded-name.&#xA;         * @return String URI value of this node's namespace, or null if no&#xA;         * namespace was resolved.&#xA;        */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="expandedName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.8"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.87/@parameters.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="colonpos">
          <typeReference xsi:type="types:Int">
            <comments>// Remove local name from expanded name</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.87/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.49"/>
              <arguments xsi:type="references:StringReference" value=":"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="nsName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.87/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.56"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.87/@statements.1/@variable"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.87/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:Field" name="fixednames">
      <initialValue xsi:type="arrays:ArrayInstantiationByValues">
        <arrayInitializer>
          <initialValues xsi:type="literals:NullLiteral"/>
          <initialValues xsi:type="literals:NullLiteral"/>
          <initialValues xsi:type="literals:NullLiteral">
            <comments>// nothing, Element</comments>
          </initialValues>
          <initialValues xsi:type="references:StringReference" value="#text"/>
          <initialValues xsi:type="references:StringReference" value="#cdata_section">
            <comments>// Attr, Text</comments>
          </initialValues>
          <initialValues xsi:type="literals:NullLiteral"/>
          <initialValues xsi:type="literals:NullLiteral">
            <comments>// CDATA, EntityReference</comments>
          </initialValues>
          <initialValues xsi:type="literals:NullLiteral"/>
          <initialValues xsi:type="references:StringReference" value="#comment">
            <comments>// Entity, PI</comments>
          </initialValues>
          <initialValues xsi:type="references:StringReference" value="#document"/>
          <initialValues xsi:type="literals:NullLiteral">
            <comments>// Comment, Document</comments>
          </initialValues>
          <initialValues xsi:type="references:StringReference" value="#document-fragment"/>
          <initialValues xsi:type="literals:NullLiteral">
            <comments>// Doctype, DocumentFragment</comments>
          </initialValues>
        </arrayInitializer>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;         * fixednames&#xA;        */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getNodeName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Notation</comments>
        <comments>/**&#xA;         * Given a node handle, return its DOM-style node name. This will&#xA;         * include names such as #text or #document.&#xA;         *&#xA;         * @param nodeHandle the id of the node.&#xA;         * @return String Name of this node, which may be an empty string.&#xA;         * %REVIEW% Document when empty string is possible...&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="type">
          <typeReference xsi:type="types:Short"/>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Short"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                  <arraySelectors>
                    <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </arraySelectors>
                </children>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
              </expression>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="name">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.1/@variable"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                </arraySelectors>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <comments>/**/</comments>
              <next xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../../../../../../java/io/PrintStream.class.xmi#//@classifiers.0/@members.42"/>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value="got i="/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.3/@statement/@statements.0/@variable"/>
                    <children xsi:type="references:StringReference" value=" "/>
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:ShiftExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.3/@statement/@statements.0/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                        <shiftOperators xsi:type="operators:RightShift"/>
                      </expression>
                    </children>
                    <children xsi:type="references:StringReference" value="/"/>
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:AndExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.3/@statement/@statements.0/@variable"/>
                        <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
                      </expression>
                    </children>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </next>
                <target xsi:type="members:Field" href="../../../../../../../../java/lang/System.class.xmi#//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/System.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.8"/>
                  <arguments xsi:type="expressions:AndExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.3/@statement/@statements.0/@variable"/>
                    <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
                  </arguments>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="prefix">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.8"/>
                  <arguments xsi:type="expressions:ShiftExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.3/@statement/@statements.0/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                    <shiftOperators xsi:type="operators:RightShift"/>
                  </arguments>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.2/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.3/@statement/@statements.3/@variable"/>
                  <children xsi:type="references:StringReference" value=":"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.2/@variable"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </value>
              </expression>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.3/@statement/@statements.3/@variable"/>
                <children xsi:type="literals:NullLiteral"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.3/@statement/@statements.3/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0/@members.22"/>
                  </next>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="literals:NullLiteral"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.2/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNodeNameX">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, return the XPath node name.  This should be&#xA;         * the name as described by the XPath data model, NOT the DOM-style&#xA;         * name.&#xA;         *&#xA;         * @param nodeHandle the id of the node.&#xA;         * @return String Name of this node.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLocalName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, return its DOM-style localname.&#xA;         * (As defined in Namespaces, this is the portion of the name after any&#xA;         * colon character)&#xA;         *&#xA;         * %REVIEW% What's the local name of something other than Element/Attr?&#xA;         * Should this be DOM-style (undefined unless namespaced), or other?&#xA;         *&#xA;         * @param nodeHandle the id of the node.&#xA;         * @return String Local name of this node.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="type">
          <typeReference xsi:type="types:Short"/>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Short"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                  <arraySelectors>
                    <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </arraySelectors>
                </children>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
              </expression>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="name">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:StringReference" value=""/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                </arraySelectors>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.8"/>
                  <arguments xsi:type="expressions:AndExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91/@statements.3/@statement/@statements.0/@variable"/>
                    <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
                  </arguments>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91/@statements.2/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:StringReference" value=""/>
              </expression>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91/@statements.2/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.2"/>
              </children>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.3"/>
              </children>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPrefix">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a namespace handle, return the prefix that the namespace decl is&#xA;         * mapping.&#xA;         * Given a node handle, return the prefix used to map to the namespace.&#xA;         *&#xA;         * &lt;p> %REVIEW% Are you sure you want &quot;&quot; for no prefix?  &lt;/p>&#xA;         *&#xA;         * %REVIEW%  Should this be DOM-style (undefined unless namespaced),&#xA;         * or other?&#xA;         *&#xA;         * @param nodeHandle the id of the node.&#xA;         * @return String prefix of this node's name, or &quot;&quot; if no explicit&#xA;         * namespace prefix was given.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="type">
          <typeReference xsi:type="types:Short"/>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Short"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                  <arraySelectors>
                    <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </arraySelectors>
                </children>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
              </expression>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="name">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:StringReference" value=""/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                </arraySelectors>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.8"/>
                  <arguments xsi:type="expressions:ShiftExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@statements.3/@statement/@statements.0/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                    <shiftOperators xsi:type="operators:RightShift"/>
                  </arguments>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@statements.2/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:StringReference" value=""/>
              </expression>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@statements.2/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.2"/>
              </children>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.3"/>
              </children>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNamespaceURI">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, return its DOM-style namespace URI&#xA;         * (As defined in Namespaces, this is the declared URI which this node's&#xA;         * prefix -- or default in lieu thereof -- was mapped to.)&#xA;         *&#xA;         * @param nodeHandle the id of the node.&#xA;         * @return String URI value of this node's namespace, or null if no&#xA;         * namespace was resolved.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNodeValue">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, return its node value. This is mostly&#xA;         * as defined by the DOM, but may ignore some conveniences.&#xA;         * &lt;p>&#xA;         *&#xA;         * @param nodeHandle The node id.&#xA;         * @return String Value of this node, or null if not&#xA;         * meaningful for this node type.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="nodetype">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AndExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
              <arraySelectors>
                <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </arraySelectors>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="value">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// ###zaj use mask to get node type</comments>
              <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Switch">
        <cases xsi:type="statements:NormalSwitchCase">
          <comments>// ###zaj todo - document nodetypes</comments>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
              </next>
            </expression>
          </statements>
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.3"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.4"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.9"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../utils/FastStringBuffer.class.xmi#//@classifiers.0/@members.32"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                    </arraySelectors>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                    </arraySelectors>
                  </arguments>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Break">
            <comments>//###zaj</comments>
          </statements>
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.5"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.8"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.2"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <condition xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.6"/>
          </condition>
        </cases>
        <cases xsi:type="statements:DefaultSwitchCase">
          <statements xsi:type="statements:Break"/>
        </cases>
        <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@statements.1/@variable"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNodeType">
      <typeReference xsi:type="types:Short"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Given a node handle, return its DOM-style node type.&#xA;         * &lt;p>&#xA;         * %REVIEW% Generally, returning short is false economy. Return int?&#xA;         *&#xA;         * @param nodeHandle The node id.&#xA;         * @return int Node type, as per the DOM's Node._NODE constants.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Short"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AndExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.9"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95/@parameters.0"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </next>
              </children>
              <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
            </expression>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLevel">
      <typeReference xsi:type="types:Short"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Get the depth level of this node in the tree (equals 1 for&#xA;         * a parentless node).&#xA;         *&#xA;         * @param nodeHandle The node id.&#xA;         * @return the number of ancestors, plus one&#xA;         * @xsl.usage internal&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="count">
          <typeReference xsi:type="types:Short"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@statements.0/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@parameters.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.9"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@parameters.0"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isSupported">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="feature">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="version">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// ============== Document query functions ==============</comments>
        <comments>/**&#xA;         * Tests whether DTM DOM implementation implements a specific feature and&#xA;         * that feature is supported by this node.&#xA;         *&#xA;         * @param feature The name of the feature to test.&#xA;         * @param versionThis is the version number of the feature to test.&#xA;         *   If the version is not&#xA;         *   specified, supporting any version of the feature will cause the&#xA;         *   method to return &lt;code>true&lt;/code>.&#xA;         * @return Returns &lt;code>true&lt;/code> if the specified feature is&#xA;         *   supported on this node, &lt;code>false&lt;/code> otherwise.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDocumentBaseURI">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Return the base URI of the document entity. If it is not known&#xA;         * (because the document was parsed from a socket connection or from&#xA;         * standard input, for example), the value of this property is unknown.&#xA;         *&#xA;         * @return the document base URI String object or null if unknown.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setDocumentBaseURI">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="baseURI">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Set the base URI of the document entity.&#xA;         *&#xA;         * @param baseURI the document base URI String object or null if unknown.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDocumentSystemIdentifier">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Return the system identifier of the document entity. If&#xA;         * it is not known, the value of this property is unknown.&#xA;         *&#xA;         * @param nodeHandle The node id, which can be any valid node handle.&#xA;         * @return the system identifier String object or null if unknown.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDocumentEncoding">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Return the name of the character encoding scheme&#xA;         *        in which the document entity is expressed.&#xA;         *&#xA;         * @param nodeHandle The node id, which can be any valid node handle.&#xA;         * @return the document encoding String object.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDocumentStandalone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Return an indication of the standalone status of the document,&#xA;         *        either &quot;yes&quot; or &quot;no&quot;. This property is derived from the optional&#xA;         *        standalone document declaration in the XML declaration at the&#xA;         *        beginning of the document entity, and has no value if there is no&#xA;         *        standalone document declaration.&#xA;         *&#xA;         * @param nodeHandle The node id, which can be any valid node handle.&#xA;         * @return the document standalone String object, either &quot;yes&quot;, &quot;no&quot;, or null.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDocumentVersion">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="documentHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Return a string representing the XML version of the document. This&#xA;         * property is derived from the XML declaration optionally present at the&#xA;         * beginning of the document entity, and has no value if there is no XML&#xA;         * declaration.&#xA;         *&#xA;         * @param the document handle&#xA;         *&#xA;         * @return the document version String object&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDocumentAllDeclarationsProcessed">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Return an indication of&#xA;         * whether the processor has read the complete DTD. Its value is a&#xA;         * boolean. If it is false, then certain properties (indicated in their&#xA;         * descriptions below) may be unknown. If it is true, those properties&#xA;         * are never unknown.&#xA;         *&#xA;         * @return &lt;code>true&lt;/code> if all declarations were processed {};&#xA;         *         &lt;code>false&lt;/code> otherwise.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDocumentTypeDeclarationSystemIdentifier">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         *   A document type declaration information item has the following properties:&#xA;         *&#xA;         *     1. [system identifier] The system identifier of the external subset, if&#xA;         *        it exists. Otherwise this property has no value.&#xA;         *&#xA;         * @return the system identifier String object, or null if there is none.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDocumentTypeDeclarationPublicIdentifier">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Return the public identifier of the external subset,&#xA;         * normalized as described in 4.2.2 External Entities [XML]. If there is&#xA;         * no external subset or if it has no public identifier, this property&#xA;         * has no value.&#xA;         *&#xA;         * @param the document type declaration handle&#xA;         *&#xA;         * @return the public identifier String object, or null if there is none.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getElementById">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="elementId">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Returns the &lt;code>Element&lt;/code> whose &lt;code>ID&lt;/code> is given by&#xA;         * &lt;code>elementId&lt;/code>. If no such element exists, returns&#xA;         * &lt;code>DTM.NULL&lt;/code>. Behavior is not defined if more than one element&#xA;         * has this &lt;code>ID&lt;/code>. Attributes (including those&#xA;         * with the name &quot;ID&quot;) are not of type ID unless so defined by DTD/Schema&#xA;         * information available to the DTM implementation.&#xA;         * Implementations that do not know whether attributes are of type ID or&#xA;         * not are expected to return &lt;code>DTM.NULL&lt;/code>.&#xA;         *&#xA;         * &lt;p>%REVIEW% Presumably IDs are still scoped to a single document,&#xA;         * and this operation searches only within a single document, right?&#xA;         * Wouldn't want collisions between DTMs in the same process.&lt;/p>&#xA;         *&#xA;         * @param elementId The unique &lt;code>id&lt;/code> value for an element.&#xA;         * @return The handle of the matching element.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getUnparsedEntityURI">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * The getUnparsedEntityURI function returns the URI of the unparsed&#xA;         * entity with the specified name in the same document as the context&#xA;         * node (see [3.3 Unparsed Entities]). It returns the empty string if&#xA;         * there is no such entity.&#xA;         * &lt;p>&#xA;         * XML processors may choose to use the System Identifier (if one&#xA;         * is provided) to resolve the entity, rather than the URI in the&#xA;         * Public Identifier. The details are dependent on the processor, and&#xA;         * we would have to support some form of plug-in resolver to handle&#xA;         * this properly. Currently, we simply return the System Identifier if&#xA;         * present, and hope that it a usable URI or that our caller can&#xA;         * map it to one.&#xA;         * TODO: Resolve Public Identifiers... or consider changing function name.&#xA;         * &lt;p>&#xA;         * If we find a relative URI&#xA;         * reference, XML expects it to be resolved in terms of the base URI&#xA;         * of the document. The DOM doesn't do that for us, and it isn't&#xA;         * entirely clear whether that should be done here; currently that's&#xA;         * pushed up to a higher level of our application. (Note that DOM Level&#xA;         * 1 didn't store the document's base URI.)&#xA;         * TODO: Consider resolving Relative URIs.&#xA;         * &lt;p>&#xA;         * (The DOM's statement that &quot;An XML processor may choose to&#xA;         * completely expand entities before the structure model is passed&#xA;         * to the DOM&quot; refers only to parsed entities, not unparsed, and hence&#xA;         * doesn't affect this function.)&#xA;         *&#xA;         * @param name A string containing the Entity Name of the unparsed&#xA;         * entity.&#xA;         *&#xA;         * @return String containing the URI of the Unparsed Entity, or an&#xA;         * empty string if no such entity exists.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="supportsPreStripping">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// ============== Boolean methods ================</comments>
        <comments>/**&#xA;         * Return true if the xsl:strip-space or xsl:preserve-space was processed&#xA;         * during construction of the DTM document.&#xA;         *&#xA;         * &lt;p>%REVEIW% Presumes a 1:1 mapping from DTM to Document, since&#xA;         * we aren't saying which Document to query...?&lt;/p>&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isNodeAfter">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle2">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Figure out whether nodeHandle2 should be considered as being later&#xA;         * in the document than nodeHandle1, in Document Order as defined&#xA;         * by the XPath model. This may not agree with the ordering defined&#xA;         * by other XML applications.&#xA;         * &lt;p>&#xA;         * There are some cases where ordering isn't defined, and neither are&#xA;         * the results of this function -- though we'll generally return true.&#xA;         *&#xA;         * TODO: Make sure this does the right thing with attribute nodes!!!&#xA;         *&#xA;         * @param node1 DOM Node to perform position comparison on.&#xA;         * @param node2 DOM Node to perform position comparison on .&#xA;         *&#xA;         * @return false if node2 comes before node1, otherwise return true.&#xA;         * You can think of this as&#xA;         * &lt;code>(node1.documentOrderPosition &amp;lt;= node2.documentOrderPosition)&lt;/code>.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isCharacterElementContentWhitespace">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         *     2. [element content whitespace] A boolean indicating whether the&#xA;         *        character is white space appearing within element content (see [XML],&#xA;         *        2.10 &quot;White Space Handling&quot;). Note that validating XML processors are&#xA;         *        required by XML 1.0 to provide this information. If there is no&#xA;         *        declaration for the containing element, this property has no value for&#xA;         *        white space characters. If no declaration has been read, but the [all&#xA;         *        declarations processed] property of the document information item is&#xA;         *        false (so there may be an unread declaration), then the value of this&#xA;         *        property is unknown for white space characters. It is always false for&#xA;         *        characters that are not white space.&#xA;         *&#xA;         * @param nodeHandle the node ID.&#xA;         * @return &lt;code>true&lt;/code> if the character data is whitespace;&#xA;         *         &lt;code>false&lt;/code> otherwise.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isDocumentAllDeclarationsProcessed">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="documentHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         *    10. [all declarations processed] This property is not strictly speaking&#xA;         *        part of the infoset of the document. Rather it is an indication of&#xA;         *        whether the processor has read the complete DTD. Its value is a&#xA;         *        boolean. If it is false, then certain properties (indicated in their&#xA;         *        descriptions below) may be unknown. If it is true, those properties&#xA;         *        are never unknown.&#xA;         *&#xA;         * @param the document handle&#xA;         *&#xA;         * @param documentHandle A node handle that must identify a document.&#xA;         * @return &lt;code>true&lt;/code> if all declarations were processed;&#xA;         *         &lt;code>false&lt;/code> otherwise.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isAttributeSpecified">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attributeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         *     5. [specified] A flag indicating whether this attribute was actually&#xA;         *        specified in the start-tag of its element, or was defaulted from the&#xA;         *        DTD.&#xA;         *&#xA;         * @param the attribute handle&#xA;         *&#xA;         * NEEDSDOC @param attributeHandle&#xA;         * @return &lt;code>true&lt;/code> if the attribute was specified;&#xA;         *         &lt;code>false&lt;/code> if it was defaulted.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="dispatchCharactersEvents">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>xml</namespaces>
          <namespaces>sax</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/ContentHandler.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="normalize">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// ========== Direct SAX Dispatch, for optimization purposes ========</comments>
        <comments>/**&#xA;         * Directly call the&#xA;         * characters method on the passed ContentHandler for the&#xA;         * string-value of the given node (see http://www.w3.org/TR/xpath#data-model&#xA;         * for the definition of a node's string-value). Multiple calls to the&#xA;         * ContentHandler's characters methods may well occur for a single call to&#xA;         * this method.&#xA;         *&#xA;         * @param nodeHandle The node ID.&#xA;         * @param ch A non-null reference to a ContentHandler.&#xA;         *&#xA;         * @throws org.xml.sax.SAXException&#xA;         */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="dispatchToEvents">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>org</namespaces>
          <namespaces>xml</namespaces>
          <namespaces>sax</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/ContentHandler.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>org</namespaces>
        <namespaces>xml</namespaces>
        <namespaces>sax</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../org/xml/sax/SAXException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Directly create SAX parser events from a subtree.&#xA;         *&#xA;         * @param nodeHandle The node ID.&#xA;         * @param ch A non-null reference to a ContentHandler.&#xA;         *&#xA;         * @throws org.xml.sax.SAXException&#xA;         */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getNode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <namespaces>org</namespaces>
        <namespaces>w3c</namespaces>
        <namespaces>dom</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../../../../../../org/w3c/dom/Node.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeHandle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Return an DOM node for the given node.&#xA;         *&#xA;         * @param nodeHandle The node ID.&#xA;         *&#xA;         * @return A node representation of the DTM node.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendChild">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newChild">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="clone">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cloneDepth">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// ==== Construction methods (may not be supported by some implementations!) =====</comments>
        <comments>// %REVIEW% jjk: These probably aren't the right API. At the very least</comments>
        <comments>// they need to deal with current-insertion-location and end-element</comments>
        <comments>// issues.</comments>
        <comments>/**&#xA;         * Append a child to the end of the child list of the current node. Please note that the node&#xA;         * is always cloned if it is owned by another document.&#xA;         *&#xA;         * &lt;p>%REVIEW% &quot;End of the document&quot; needs to be defined more clearly.&#xA;         * Does it become the last child of the Document? Of the root element?&lt;/p>&#xA;         *&#xA;         * @param newChild Must be a valid new node handle.&#xA;         * @param clone true if the child should be cloned into the document.&#xA;         * @param cloneDepth if the clone argument is true, specifies that the&#xA;         *                   clone should include all it's children.&#xA;         */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sameDoc">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AndExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117/@parameters.0"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                </expression>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block"/>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117/@parameters.1"/>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117/@statements.0/@variable"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendTextChild">
      <comments>// ###shs Think more about how this differs from createTextNode</comments>
      <comments>//%TBD%</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;         * Append a text node child that will be constructed from a string,&#xA;         * to the end of the document.&#xA;         *&#xA;         * &lt;p>%REVIEW% &quot;End of the document&quot; needs to be defined more clearly.&#xA;         * Does it become the last child of the Document? Of the root element?&lt;/p>&#xA;         *&#xA;         * @param str Non-null reference to a string.&#xA;         */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="appendTextChild">
      <typeReference xsi:type="types:Void">
        <comments>//================================================================</comments>
        <comments>// ==== BUILDER methods ====</comments>
        <comments>// %TBD% jjk: SHOULD PROBABLY BE INLINED, unless we want to support</comments>
        <comments>// both SAX1 and SAX2 and share this logic between them.</comments>
        <comments>/** Append a text child at the current insertion point. Assumes that the&#xA;   * actual content of the text has previously been appended to the m_char&#xA;   * buffer (shared with the builder).&#xA;   *&#xA;   * @param m_char_current_start int Starting offset of node's content in m_char.&#xA;   * @param contentLength int Length of node's content in m_char.&#xA;   * */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="m_char_current_start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="contentLength">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w0">
          <typeReference xsi:type="types:Int">
            <comments>// create a Text Node</comments>
            <comments>// %TBD% may be possible to combine with appendNode()to replace the next chunk of code</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.4"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w1">
          <typeReference xsi:type="types:Int">
            <comments>// W1: Parent</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w2">
          <typeReference xsi:type="types:Int">
            <comments>// W2: Start position within m_char</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@parameters.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w3">
          <typeReference xsi:type="types:Int">
            <comments>// W3: Length of the full string</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@parameters.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ourslot">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@statements.1/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@statements.2/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@statements.3/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@statements.4/@variable"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendComment">
      <typeReference xsi:type="types:Void">
        <comments>/** Append a comment child at the current insertion point. Assumes that the&#xA;   * actual content of the comment has previously been appended to the m_char&#xA;   * buffer (shared with the builder).&#xA;   *&#xA;   * @param m_char_current_start int Starting offset of node's content in m_char.&#xA;   * @param contentLength int Length of node's content in m_char.&#xA;   * */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="m_char_current_start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="contentLength">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w0">
          <typeReference xsi:type="types:Int">
            <comments>// create a Comment Node</comments>
            <comments>// %TBD% may be possible to combine with appendNode()to replace the next chunk of code</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.9"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w1">
          <typeReference xsi:type="types:Int">
            <comments>// W1: Parent</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w2">
          <typeReference xsi:type="types:Int">
            <comments>// W2: Start position within m_char</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w3">
          <typeReference xsi:type="types:Int">
            <comments>// W3: Length of the full string</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ourslot">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.1/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.2/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.3/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.4/@variable"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendStartElement">
      <typeReference xsi:type="types:Void">
        <comments>/** Append an Element child at the current insertion point. This&#xA;   * Element then _becomes_ the insertion point; subsequent appends&#xA;   * become its lastChild until an appendEndElement() call is made.&#xA;   *&#xA;   * Assumes that the symbols (local name, namespace URI and prefix)&#xA;   * have already been added to the pools&#xA;   *&#xA;   * Note that this _only_ handles the Element node itself. Attrs and&#xA;   * namespace nodes are unbundled in the ContentHandler layer&#xA;   * and appended separately.&#xA;   *&#xA;   * @param namespaceIndex: Index within the namespaceURI string pool&#xA;   * @param localNameIndex Index within the local name string pool&#xA;   * @param prefixIndex: Index within the prefix string pool&#xA;   * */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespaceIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="localNameIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefixIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w0">
          <typeReference xsi:type="types:Int">
            <comments>// do document root node creation here on the first element, create nodes for</comments>
            <comments>// this element and its attributes, store the element, namespace, and attritute</comments>
            <comments>// name indexes to the nodes array, keep track of the current node and parent</comments>
            <comments>// element used</comments>
            <comments>// W0  High:  Namespace  Low:  Node Type</comments>
          </typeReference>
          <initialValue xsi:type="expressions:InclusiveOrExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                <shiftOperators xsi:type="operators:LeftShift"/>
              </expression>
            </children>
            <children xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.2"/>
            </children>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w1">
          <typeReference xsi:type="types:Int">
            <comments>// W1: Parent</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w2">
          <typeReference xsi:type="types:Int">
            <comments>// W2: Next  (initialized as 0)</comments>
          </typeReference>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w3">
          <typeReference xsi:type="types:Int">
            <comments>// W3: Tagname high: prefix Low: local name</comments>
          </typeReference>
          <initialValue xsi:type="expressions:InclusiveOrExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@parameters.1"/>
            <children xsi:type="expressions:ShiftExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@parameters.2"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              <shiftOperators xsi:type="operators:LeftShift"/>
            </children>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <comments>/**/</comments>
          <next xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../../../../../../java/io/PrintStream.class.xmi#//@classifiers.0/@members.42"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="set w3="/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@statements.3/@variable"/>
                <children xsi:type="references:StringReference" value=" "/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ShiftExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@statements.3/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                    <shiftOperators xsi:type="operators:RightShift"/>
                  </expression>
                </children>
                <children xsi:type="references:StringReference" value="/"/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AndExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@statements.3/@variable"/>
                    <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
                  </expression>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </next>
            <target xsi:type="members:Field" href="../../../../../../../../java/lang/System.class.xmi#//@classifiers.0/@members.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ourslot">
          <typeReference xsi:type="types:Int">
            <comments>//int ourslot = nodes.appendSlot(w0, w1, w2, w3);</comments>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@statements.1/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@statements.2/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@statements.3/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@statements.5/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// set the root element pointer when creating the first element node</comments>
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@statements.5/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          <children xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
          </children>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendNSDeclaration">
      <comments>//(m_docHandle | ourslot);</comments>
      <typeReference xsi:type="types:Void">
        <comments>/** Append a Namespace Declaration child at the current insertion point.&#xA;   * Assumes that the symbols (namespace URI and prefix) have already been&#xA;   * added to the pools&#xA;   *&#xA;   * @param prefixIndex: Index within the prefix string pool&#xA;   * @param namespaceIndex: Index within the namespaceURI string pool&#xA;   * @param isID: If someone really insists on writing a bad DTD, it is&#xA;   * theoretically possible for a namespace declaration to also be declared&#xA;   * as being a node ID. I don't really want to support that stupidity,&#xA;   * but I'm not sure we can refuse to accept it.&#xA;   * */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefixIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespaceIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="isID">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="namespaceForNamespaces">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="references:StringReference" value="http://www.w3.org/2000/xmlns/"/>
            </next>
          </initialValue>
          <annotationsAndModifiers xsi:type="modifiers:Final">
            <comments>// %REVIEW% I'm assigning this node the &quot;namespace for namespaces&quot;</comments>
            <comments>// which the DOM defined. It is expected that the Namespace spec will</comments>
            <comments>// adopt this as official. It isn't strictly needed since it's implied</comments>
            <comments>// by the nodetype, but for now...</comments>
            <comments>// %REVIEW% Prefix need not be recorded; it's implied too. But</comments>
            <comments>// recording it might simplify the design.</comments>
            <comments>// %TBD% isID is not currently honored.</comments>
          </annotationsAndModifiers>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w0">
          <typeReference xsi:type="types:Int">
            <comments>// W0  High:  Namespace  Low:  Node Type</comments>
          </typeReference>
          <initialValue xsi:type="expressions:InclusiveOrExpression">
            <children xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.14"/>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="DTMStringPool.class.xmi#//@classifiers.0/@members.9"/>
                    <arguments xsi:type="references:StringReference" value="http://www.w3.org/2000/xmlns/"/>
                  </next>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                <shiftOperators xsi:type="operators:LeftShift"/>
              </expression>
            </children>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w1">
          <typeReference xsi:type="types:Int">
            <comments>// W1:  Parent</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w2">
          <typeReference xsi:type="types:Int">
            <comments>// W2:  CURRENTLY UNUSED -- It's next-sib in attrs, but we have no kids.</comments>
          </typeReference>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w3">
          <typeReference xsi:type="types:Int">
            <comments>// W3:  namespace name</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ourslot">
          <typeReference xsi:type="types:Int">
            <comments>// Add node</comments>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.1/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.2/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.3/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.4/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.5/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
            <comments>// Should attributes be previous siblings</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return"/>
    </members>
    <members xsi:type="members:ClassMethod" name="appendAttribute">
      <comments>//(m_docHandle | ourslot);</comments>
      <typeReference xsi:type="types:Void">
        <comments>/** Append an Attribute child at the current insertion&#xA;   * point.  Assumes that the symbols (namespace URI, local name, and&#xA;   * prefix) have already been added to the pools, and that the content has&#xA;   * already been appended to m_char. Note that the attribute's content has&#xA;   * been flattened into a single string; DTM does _NOT_ attempt to model&#xA;   * the details of entity references within attribute values.&#xA;   *&#xA;   * @param namespaceIndex int Index within the namespaceURI string pool&#xA;   * @param localNameIndex int Index within the local name string pool&#xA;   * @param prefixIndex int Index within the prefix string pool&#xA;   * @param isID boolean True if this attribute was declared as an ID&#xA;   * (for use in supporting getElementByID).&#xA;   * @param m_char_current_start int Starting offset of node's content in m_char.&#xA;   * @param contentLength int Length of node's content in m_char.&#xA;   * */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="namespaceIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="localNameIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefixIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="isID">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="m_char_current_start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="contentLength">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w0">
          <typeReference xsi:type="types:Int">
            <comments>// %TBD% isID is not currently honored.</comments>
            <comments>// W0  High:  Namespace  Low:  Node Type</comments>
          </typeReference>
          <initialValue xsi:type="expressions:InclusiveOrExpression">
            <children xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.3"/>
            </children>
            <children xsi:type="expressions:ShiftExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              <shiftOperators xsi:type="operators:LeftShift"/>
            </children>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w1">
          <typeReference xsi:type="types:Int">
            <comments>// W1:  Parent</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w2">
          <typeReference xsi:type="types:Int">
            <comments>// W2:  Next (not yet resolved)</comments>
          </typeReference>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w3">
          <typeReference xsi:type="types:Int">
            <comments>// W3:  Tagname high: prefix Low: local name</comments>
          </typeReference>
          <initialValue xsi:type="expressions:InclusiveOrExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@parameters.1"/>
            <children xsi:type="expressions:ShiftExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@parameters.2"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              <shiftOperators xsi:type="operators:LeftShift"/>
            </children>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <comments>/**/</comments>
          <next xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../../../../../../java/io/PrintStream.class.xmi#//@classifiers.0/@members.42"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="set w3="/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.3/@variable"/>
                <children xsi:type="references:StringReference" value=" "/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ShiftExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.3/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                    <shiftOperators xsi:type="operators:RightShift"/>
                  </expression>
                </children>
                <children xsi:type="references:StringReference" value="/"/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AndExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.3/@variable"/>
                    <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
                  </expression>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </next>
            <target xsi:type="members:Field" href="../../../../../../../../java/lang/System.class.xmi#//@classifiers.0/@members.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ourslot">
          <typeReference xsi:type="types:Int">
            <comments>// Add node</comments>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.1/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.2/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.3/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.5/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.0/@variable">
            <comments>// Should attributes be previous siblings</comments>
            <comments>// Attribute's content is currently appended as a Text Node</comments>
            <comments>// W0: Node Type</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.4"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.1/@variable">
            <comments>// W1: Parent</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.5/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.2/@variable">
            <comments>// W2: Start Position within buffer</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@parameters.4"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.3/@variable">
            <comments>// W3: Length</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@parameters.5"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.0/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.1/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.2/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@statements.3/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
            <comments>// Attrs are Parents</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getAxisTraverser">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../DTMAxisTraverser.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="axis">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;   * This returns a stateless &quot;traverser&quot;, that can navigate over an&#xA;   * XPath axis, though not in document order.&#xA;   *&#xA;   * @param axis One of Axes.ANCESTORORSELF, etc.&#xA;   *&#xA;   * @return A DTMAxisIterator, or null if the given axis isn't supported.&#xA;   */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAxisIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../DTMAxisIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="axis">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;   * This is a shortcut to the iterators that implement the&#xA;   * supported XPath axes (only namespace::) is not supported.&#xA;   * Returns a bare-bones iterator that must be initialized&#xA;   * with a start node (using iterator.setStartNode()).&#xA;   *&#xA;   * @param axis One of Axes.ANCESTORORSELF, etc.&#xA;   *&#xA;   * @return A DTMAxisIterator, or null if the given axis isn't supported.&#xA;   */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// %TBD%</comments>
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getTypedAxisIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../DTMAxisIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="axis">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;   * Get an iterator that can navigate over an XPath Axis, predicated by&#xA;   * the extended type ID.&#xA;   *&#xA;   *&#xA;   * @param axis&#xA;   * @param type An extended type ID.&#xA;   *&#xA;   * @return A DTMAxisIterator, or null if the given axis isn't supported.&#xA;   */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// %TBD%</comments>
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendEndElement">
      <comments>// Pop a level of namespace table</comments>
      <comments>// namespaceTable.removeLastElem();</comments>
      <typeReference xsi:type="types:Void">
        <comments>/** Terminate the element currently acting as an insertion point. Subsequent&#xA;   * insertions will occur as the last child of this element's parent.&#xA;   * */</comments>
      </typeReference>
      <statements xsi:type="statements:Condition">
        <comments>// pop up the stacks</comments>
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.13"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              <arguments xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
              </arguments>
            </next>
          </expression>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6">
            <comments>// Pop parentage</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ChunkedIntArray.class.xmi#//@classifiers.0/@members.15"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:AndExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
              <arraySelectors>
                <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </arraySelectors>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
            <comments>// The element just being finished will be</comments>
            <comments>// the previous sibling for the next operation</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendStartDocument">
      <typeReference xsi:type="types:Void">
        <comments>/**  Starting a new document. Perform any resets/initialization&#xA;   * not already handled.&#xA;   * */</comments>
      </typeReference>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4">
            <comments>// %TBD% reset slot 0 to indicate ChunkedIntArray reuse or wait for</comments>
            <comments>//       the next initDocument().</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="../DTM.class.xmi#//@classifiers.0/@members.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.62">
          <comments>// reset nodeHandle to the root of the actual dtm doc content</comments>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendEndDocument">
      <comments>// %TBD% may need to notice the last slot number and slot count to avoid</comments>
      <comments>// residual data from provious use of this DTM</comments>
      <typeReference xsi:type="types:Void">
        <comments>/**  All appends to this document have finished; do whatever final&#xA;   * cleanup is needed.&#xA;   * */</comments>
      </typeReference>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setProperty">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="property">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;   * For the moment all the run time properties are ignored by this&#xA;   * class.&#xA;   *&#xA;   * @param property a &lt;code>String&lt;/code> value&#xA;   * @param value an &lt;code>Object&lt;/code> value&#xA;   */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getSourceLocatorFor">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../../../../../../javax/xml/transform/SourceLocator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="node">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;   * Source information is not handled yet, so return&#xA;   * &lt;code>null&lt;/code> here.&#xA;   *&#xA;   * @param node an &lt;code>int&lt;/code> value&#xA;   * @return null&#xA;   */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="documentRegistration">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;   * A dummy routine to satisify the abstract interface. If the DTM&#xA;   * implememtation that extends the default base requires notification&#xA;   * of registration, they can override this method.&#xA;   */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="documentRelease">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;   * A dummy routine to satisify the abstract interface. If the DTM&#xA;   * implememtation that extends the default base requires notification&#xA;   * when the document is being released, they can override this method&#xA;   */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="migrateTo">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="manager">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../DTMManager.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Migrate a DTM built with an old DTMManager to a new DTMManager.&#xA;    * After the migration, the new DTMManager will treat the DTM as&#xA;    * one that is built by itself.&#xA;    * This is used to support DTM sharing between multiple transformations.&#xA;    * @param manager the DTMManager&#xA;    */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This is the implementation of the DTM document interface.  It receives&#xA; * requests from an XML content handler similar to that of an XML DOM or SAX parser&#xA; * to store information from the xml document in an array based&#xA; * dtm table structure.  This informtion is used later for document navigation,&#xA; * query, and SAX event dispatch functions. The DTM can also be used directly as a&#xA; * document composition model for an application.  The requests received are:&#xA; * &lt;ul>&#xA; * &lt;li>initiating DTM to set the doc handle&lt;/li>&#xA; * &lt;li>resetting DTM for data structure reuse&lt;/li>&#xA; * &lt;li>hinting the end of document to adjust the end of data structure pointers&lt;/li>&#xA; * &lt;li>createnodes (element, comment, text, attribute, ....)&lt;/li>&#xA; * &lt;li>hinting the end of an element to patch parent and siblings&lt;li>&#xA; * &lt;li>setting application provided symbol name stringpool data structures&lt;/li>&#xA; * &lt;/ul>&#xA; * &lt;p>State: In progress!!&lt;/p>&#xA; *&#xA; * %REVIEW% I _think_ the SAX convention is that &quot;no namespace&quot; is expressed&#xA; * as &quot;&quot; rather than as null (which is the DOM's convention). What should&#xA; * DTM expect? What should it do with the other?&#xA; *&#xA; * &lt;p>Origin: the implemention is a composite logic based on the DTM of XalanJ1 and&#xA; *     DocImpl, DocumentImpl, ElementImpl, TextImpl, etc. of XalanJ2&lt;/p>&#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../DTM.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <namespaces>org</namespaces>
      <namespaces>xml</namespaces>
      <namespaces>sax</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/ContentHandler.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <namespaces>org</namespaces>
      <namespaces>xml</namespaces>
      <namespaces>sax</namespaces>
      <namespaces>ext</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../../../../../../../org/xml/sax/ext/LexicalHandler.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
