<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../../../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../../../../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../../../../../../java.ecore#/8 http://www.emftext.org/java/members ../../../../../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../../../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../../../../../../java.ecore#/13 http://www.emftext.org/java/references ../../../../../../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../../../../../../java.ecore#/15 http://www.emftext.org/java/types ../../../../../../../../java.ecore#/16" name="DatatypeFactoryImpl.java">
  <comments>// $Id: DatatypeFactoryImpl.java,v 1.4 2004/04/30 01:40:53 jsuttor Exp $</comments>
  <comments>/*&#xA; * @(#)DatatypeFactoryImpl.java&#x9;1.2 04/07/26&#xA; * &#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>com</namespaces>
  <namespaces>sun</namespaces>
  <namespaces>org</namespaces>
  <namespaces>apache</namespaces>
  <namespaces>xerces</namespaces>
  <namespaces>internal</namespaces>
  <namespaces>jaxp</namespaces>
  <namespaces>datatype</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>math</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../../../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>math</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../../../../../java/math/BigDecimal.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../../../../../java/util/GregorianCalendar.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>datatype</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../../../../../javax/xml/datatype/DatatypeConstants.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>datatype</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../../../../../javax/xml/datatype/DatatypeFactory.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>datatype</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../../../../../javax/xml/datatype/Duration.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>xml</namespaces>
    <namespaces>datatype</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../../../../../../javax/xml/datatype/XMLGregorianCalendar.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="DatatypeFactoryImpl">
    <members xsi:type="members:Constructor" name="DatatypeFactoryImpl">
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Public constructor is empty..&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>Use {@link DatatypeFactory#newInstance()} to create a &lt;code>DatatypeFactory&lt;code>.&lt;/p>&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="newDuration">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../javax/xml/datatype/Duration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lexicalRepresentation">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Obtain a new instance of a &lt;code>Duration&lt;/code>&#xA;&#x9; * specifying the &lt;code>Duration&lt;/code> as its string representation, &quot;PnYnMnDTnHnMnS&quot;,&#xA;&#x9; * as defined in XML Schema 1.0 section 3.2.6.1.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>XML Schema Part 2: Datatypes, 3.2.6 duration, defines &lt;code>duration&lt;/code> as:&lt;/p>&#xA;&#x9; * &lt;blockquote>&#xA;&#x9; * duration represents a duration of time.&#xA;&#x9; * The value space of duration is a six-dimensional space where the coordinates designate the&#xA;&#x9; * Gregorian year, month, day, hour, minute, and second components defined in Section 5.5.3.2 of [ISO 8601], respectively.&#xA;&#x9; * These components are ordered in their significance by their order of appearance i.e. as&#xA;&#x9; * year, month, day, hour, minute, and second. &#xA;&#x9; * &lt;/blockquote>&#xA;     * &lt;p>All six values are set and availabe from the created {@link Duration}&lt;/p>&#xA;&#x9; * &#xA;     * &lt;p>The XML Schema specification states that values can be of an arbitrary size.&#xA;     * Implementations may chose not to or be incapable of supporting arbitrarily large and/or small values.&#xA;     * An {@link UnsupportedOperationException} will be thrown with a message indicating implementation limits&#xA;     * if implementation capacities are exceeded.&lt;/p>&#xA;     * &#xA;&#x9; * @param lexicalRepresentation &lt;code>String&lt;/code> representation of a &lt;code>Duration&lt;/code>.&#xA;&#x9; * &#xA;&#x9; * @return New &lt;code>Duration&lt;/code> created from parsing the &lt;code>lexicalRepresentation&lt;/code>.&#xA;&#x9; * &#xA;&#x9; * @throws IllegalArgumentException If &lt;code>lexicalRepresentation&lt;/code> is not a valid representation of a &lt;code>Duration&lt;/code>.&#xA;&#x9; * @throws UnsupportedOperationException If implementation cannot support requested values.&#xA;&#x9; * @throws NullPointerException if &lt;code>lexicalRepresentation&lt;/code> is &lt;code>null&lt;/code>.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="DurationImpl.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newDuration">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../javax/xml/datatype/Duration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="durationInMilliseconds">
        <typeReference xsi:type="types:Long"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Obtain a new instance of a &lt;code>Duration&lt;/code>&#xA;&#x9; * specifying the &lt;code>Duration&lt;/code> as milliseconds.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>XML Schema Part 2: Datatypes, 3.2.6 duration, defines &lt;code>duration&lt;/code> as:&lt;/p>&#xA;&#x9; * &lt;blockquote>&#xA;&#x9; * duration represents a duration of time.&#xA;&#x9; * The value space of duration is a six-dimensional space where the coordinates designate the&#xA;&#x9; * Gregorian year, month, day, hour, minute, and second components defined in Section 5.5.3.2 of [ISO 8601], respectively.&#xA;&#x9; * These components are ordered in their significance by their order of appearance i.e. as&#xA;&#x9; * year, month, day, hour, minute, and second. &#xA;&#x9; * &lt;/blockquote>&#xA;     * &lt;p>All six values are set by computing their values from the specified milliseconds&#xA;     * and are availabe using the &lt;code>get&lt;/code> methods of  the created {@link Duration}.&#xA;     * The values conform to and are defined by:&lt;/p>&#xA;     * &lt;ul>&#xA;     *   &lt;li>ISO 8601:2000(E) Section 5.5.3.2 Alternative format&lt;/li>&#xA;     *   &lt;li>&lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#isoformats&quot;>&#xA;     *     W3C XML Schema 1.0 Part 2, Appendix D, ISO 8601 Date and Time Formats&lt;/a>&#xA;     *   &lt;/li>&#xA;     *   &lt;li>{@link XMLGregorianCalendar}  Date/Time Datatype Field Mapping Between XML Schema 1.0 and Java Representation&lt;/li>&#xA;     * &lt;/ul>&#xA;&#x9; * &#xA;&#x9; * &lt;p>The default start instance is defined by {@link GregorianCalendar}'s use of the start of the epoch: i.e.,&#xA;&#x9; * {@link java.util.Calendar#YEAR} = 1970,&#xA;&#x9; * {@link java.util.Calendar#MONTH} = {@link java.util.Calendar#JANUARY},&#xA;&#x9; * {@link java.util.Calendar#DATE} = 1, etc.&#xA;&#x9; * This is important as there are variations in the Gregorian Calendar,&#xA;&#x9; * e.g. leap years have different days in the month = {@link java.util.Calendar#FEBRUARY}&#xA;&#x9; * so the result of {@link Duration#getMonths()} and {@link Duration#getDays()} can be influenced.&lt;/p> &#xA;&#x9; * &#xA;&#x9; * @param durationInMilliseconds Duration in milliseconds to create.&#xA;&#x9; * &#xA;&#x9; * @return New &lt;code>Duration&lt;/code> representing &lt;code>durationInMilliseconds&lt;/code>.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="DurationImpl.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newDuration">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../javax/xml/datatype/Duration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="isPositive">
        <typeReference xsi:type="types:Boolean"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="years">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="months">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="days">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hours">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="minutes">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="seconds">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/math/BigDecimal.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Obtain a new instance of a &lt;code>Duration&lt;/code>&#xA;&#x9; * specifying the &lt;code>Duration&lt;/code> as isPositive, years, months, days, hours, minutes, seconds.&lt;/p>&#xA;&#x9; * &#xA;     * &lt;p>The XML Schema specification states that values can be of an arbitrary size.&#xA;     * Implementations may chose not to or be incapable of supporting arbitrarily large and/or small values.&#xA;     * An {@link UnsupportedOperationException} will be thrown with a message indicating implementation limits&#xA;     * if implementation capacities are exceeded.&lt;/p>&#xA;     * &#xA;&#x9; * @param isPositive Set to &lt;code>false&lt;/code> to create a negative duration. When the length&#xA;&#x9; *   of the duration is zero, this parameter will be ignored.&#xA;&#x9; * @param years of this &lt;code>Duration&lt;/code>&#xA;&#x9; * @param months of this &lt;code>Duration&lt;/code>&#xA;&#x9; * @param days of this &lt;code>Duration&lt;/code>&#xA;&#x9; * @param hours of this &lt;code>Duration&lt;/code>&#xA;&#x9; * @param minutes of this &lt;code>Duration&lt;/code>&#xA;&#x9; * @param seconds of this &lt;code>Duration&lt;/code>&#xA;&#x9; * &#xA;&#x9; * @return New &lt;code>Duration&lt;/code> created from the specified values.&#xA;&#x9; * &#xA;&#x9; * @throws IllegalArgumentException If values are not a valid representation of a &lt;code>Duration&lt;/code>.&#xA;&#x9; * @throws UnsupportedOperationException If implementation cannot support requested values.&#xA;&#x9; * @throws NullPointerException If any values are &lt;code>null&lt;/code>.&#xA;&#x9; * &#xA;&#x9; * @see #newDuration(boolean isPositive, BigInteger years, BigInteger months, BigInteger days,&#xA;&#x9; *   BigInteger hours, BigInteger minutes, BigDecimal seconds)&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="DurationImpl.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.3"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.4"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.5"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.6"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newXMLGregorianCalendar">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../javax/xml/datatype/XMLGregorianCalendar.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Create a new instance of an &lt;code>XMLGregorianCalendar&lt;/code>.&lt;/p>&#xA;&#x9; * &#xA;     * &lt;p>All date/time datatype fields set to {@link DatatypeConstants#FIELD_UNDEFINED} or null.&lt;/p>&#xA;     * &#xA;     * @return New &lt;code>XMLGregorianCalendar&lt;/code> with all date/time datatype fields set to&#xA;     *   {@link DatatypeConstants#FIELD_UNDEFINED} or null.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="XMLGregorianCalendarImpl.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newXMLGregorianCalendar">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../javax/xml/datatype/XMLGregorianCalendar.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lexicalRepresentation">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Create a new XMLGregorianCalendar by parsing the String as a lexical representation.&lt;/p>&#xA;&#x9; * &#xA;     * &lt;p>Parsing the lexical string representation is defined in &#xA;     * &lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#dateTime-order&quot;>XML Schema 1.0 Part 2, Section 3.2.[7-14].1,&#xA;     * &lt;em>Lexical Representation&lt;/em>.&lt;/a>&lt;/p>&#xA;     * &#xA;     * &lt;p>The string representation may not have any leading and trailing whitespaces.&lt;/p>&#xA;     * &#xA;     * &lt;p>The parsing is done field by field so that&#xA;     * the following holds for any lexically correct String x:&lt;/p>&#xA;     * &lt;pre>&#xA;     * newXMLGregorianCalendar(x).toXMLFormat().equals(x)&#xA;     * &lt;/pre>&#xA;     * &lt;p>Except for the noted lexical/canonical representation mismatches&#xA;     * listed in &lt;a href=&quot;http://www.w3.org/2001/05/xmlschema-errata#e2-45&quot;>&#xA;     * XML Schema 1.0 errata, Section 3.2.7.2&lt;/a>.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * @param lexicalRepresentation Lexical representation of one the eight XML Schema date/time datatypes.&#xA;&#x9; * &#xA;&#x9; * @return &lt;code>XMLGregorianCalendar&lt;/code> created from the &lt;code>lexicalRepresentation&lt;/code>.&#xA;&#x9; * &#xA;&#x9; * @throws IllegalArgumentException If the &lt;code>lexicalRepresentation&lt;/code> is not a valid &lt;code>XMLGregorianCalendar&lt;/code>.&#xA;&#x9; * @throws NullPointerException If &lt;code>lexicalRepresentation&lt;/code> is &lt;code>null&lt;/code>.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="XMLGregorianCalendarImpl.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newXMLGregorianCalendar">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../javax/xml/datatype/XMLGregorianCalendar.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/util/GregorianCalendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Create an &lt;code>XMLGregorianCalendar&lt;/code> from a {@link GregorianCalendar}.&lt;/p> &#xA;&#x9; *&#xA;&#x9; * &lt;table border=&quot;2&quot; rules=&quot;all&quot; cellpadding=&quot;2&quot;>&#xA;&#x9; *   &lt;thead>&#xA;&#x9; *     &lt;tr>&#xA;&#x9; *       &lt;th align=&quot;center&quot; colspan=&quot;2&quot;>&#xA;&#x9; *          Field by Field Conversion from&#xA;&#x9; *          {@link GregorianCalendar} to an {@link XMLGregorianCalendar} &#xA;&#x9; *       &lt;/th>&#xA;&#x9; *     &lt;/tr>&#xA;&#x9; *     &lt;tr>&#xA;&#x9; *        &lt;th>&lt;code>java.util.GregorianCalendar&lt;/code> field&lt;/th>&#xA;&#x9; *        &lt;th>&lt;code>javax.xml.datatype.XMLGregorianCalendar&lt;/code> field&lt;/th>&#xA;&#x9; *     &lt;/tr>&#xA;&#x9; *   &lt;/thead>&#xA;&#x9; *   &lt;tbody>&#xA;&#x9; *     &lt;tr>&#xA;&#x9; *       &lt;td>&lt;code>ERA == GregorianCalendar.BC ? -YEAR : YEAR&lt;/code>&lt;/td>&#xA;&#x9; *       &lt;td>{@link XMLGregorianCalendar#setYear(int year)}&lt;/td>&#xA;&#x9; *     &lt;/tr>&#xA;&#x9; *     &lt;tr>&#xA;&#x9; *       &lt;td>&lt;code>MONTH + 1&lt;/code>&lt;/td>&#xA;&#x9; *       &lt;td>{@link XMLGregorianCalendar#setMonth(int month)}&lt;/td>&#xA;&#x9; *     &lt;/tr>&#xA;&#x9; *     &lt;tr>&#xA;&#x9; *       &lt;td>&lt;code>DAY_OF_MONTH&lt;/code>&lt;/td>&#xA;&#x9; *       &lt;td>{@link XMLGregorianCalendar#setDay(int day)}&lt;/td>&#xA;&#x9; *     &lt;/tr>&#xA;&#x9; *     &lt;tr>&#xA;&#x9; *       &lt;td>&lt;code>HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND&lt;/code>&lt;/td>&#xA;&#x9; *       &lt;td>{@link XMLGregorianCalendar#setTime(int hour, int minute, int second, BigDecimal fractional)}&lt;/td>&#xA;&#x9; *     &lt;/tr>&#xA;&#x9; *     &lt;tr>&#xA;&#x9; *       &lt;td>&#xA;&#x9; *         &lt;code>(ZONE_OFFSET + DST_OFFSET) / (60*1000)&lt;/code>&lt;br/>&#xA;&#x9; *         &lt;em>(in minutes)&lt;/em>&#xA;&#x9; *       &lt;/td>&#xA;&#x9; *       &lt;td>{@link XMLGregorianCalendar#setTimezone(int offset)}&lt;sup>&lt;em>*&lt;/em>&lt;/sup>&#xA;&#x9; *       &lt;/td>&#xA;&#x9; *     &lt;/tr>&#xA;&#x9; *   &lt;/tbody>&#xA;&#x9; * &lt;/table>&#xA;&#x9; * &lt;p>&lt;em>*&lt;/em>conversion loss of information. It is not possible to represent &#xA;&#x9; * a &lt;code>java.util.GregorianCalendar&lt;/code> daylight savings timezone id in the &#xA;&#x9; * XML Schema 1.0 date/time datatype representation.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * &lt;p>To compute the return value's &lt;code>TimeZone&lt;/code> field,&#xA;&#x9; * &lt;ul>&#xA;&#x9; * &lt;li>when &lt;code>this.getTimezone() != FIELD_UNDEFINED&lt;/code>,&#xA;&#x9; * create a &lt;code>java.util.TimeZone&lt;/code> with a custom timezone id &#xA;&#x9; * using the &lt;code>this.getTimezone()&lt;/code>.&lt;/li>&#xA;&#x9; * &lt;li>else use the &lt;code>GregorianCalendar&lt;/code> default timezone value &#xA;&#x9; * for the host is defined as specified by &#xA;&#x9; * &lt;code>java.util.TimeZone.getDefault()&lt;/code>.&lt;/li>&lt;/p>     &#xA;&#x9; *&#xA;&#x9; * @param cal &lt;code>java.util.GregorianCalendar&lt;/code> used to create &lt;code>XMLGregorianCalendar&lt;/code>&#xA;&#x9; * &#xA;&#x9; * @return &lt;code>XMLGregorianCalendar&lt;/code> created from &lt;code>java.util.GregorianCalendar&lt;/code>&#xA;&#x9; *  &#xA;&#x9; * @throws NullPointerException If &lt;code>cal&lt;/code> is &lt;code>null&lt;/code>.&#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="XMLGregorianCalendarImpl.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newXMLGregorianCalendar">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../../../../../../javax/xml/datatype/XMLGregorianCalendar.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="year">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/math/BigInteger.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="month">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="day">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hour">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="minute">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="second">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fractionalSecond">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../../java/math/BigDecimal.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timezone">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#x9; * &lt;p>Constructor allowing for complete value spaces allowed by &#xA;&#x9; * W3C XML Schema 1.0 recommendation for xsd:dateTime and related &#xA;&#x9; * builtin datatypes. Note that &lt;code>year&lt;/code> parameter supports&#xA;&#x9; * arbitrarily large numbers and fractionalSecond has infinite &#xA;&#x9; * precision.&lt;/p>&#xA;&#x9; * &#xA;&#x9; * @param year of &lt;code>XMLGregorianCalendar&lt;/code> to be created.&#xA;&#x9; * @param month of &lt;code>XMLGregorianCalendar&lt;/code> to be created.&#xA;&#x9; * @param day of &lt;code>XMLGregorianCalendar&lt;/code> to be created.&#xA;&#x9; * @param hour of &lt;code>XMLGregorianCalendar&lt;/code> to be created.&#xA;&#x9; * @param minute of &lt;code>XMLGregorianCalendar&lt;/code> to be created.&#xA;&#x9; * @param second of &lt;code>XMLGregorianCalendar&lt;/code> to be created.&#xA;&#x9; * @param fractionalSecond of &lt;code>XMLGregorianCalendar&lt;/code> to be created.&#xA;&#x9; * @param timezone of &lt;code>XMLGregorianCalendar&lt;/code> to be created.&#xA;&#x9; * &#xA;&#x9; * @return &lt;code>XMLGregorianCalendar&lt;/code> created from specified values.&#xA;&#x9; * &#xA;&#x9; * @throws IllegalArgumentException If any individual parameter's value is outside the maximum value constraint for the field&#xA;&#x9; *   as determined by the Date/Time Data Mapping table in {@link XMLGregorianCalendar}&#xA;&#x9; *   or if the composite values constitute an invalid &lt;code>XMLGregorianCalendar&lt;/code> instance&#xA;&#x9; *   as determined by {@link XMLGregorianCalendar#isValid()}.&#xA;&#x9; * @throws NullPointerException If any parameters are &lt;code>null&lt;/code>.&#xA;&#x9; * &#xA;&#x9; */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="XMLGregorianCalendarImpl.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.3"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.4"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.5"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.6"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.7"/>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;p>Factory that creates new &lt;code>javax.xml.datatype&lt;/code> &lt;code>Object&lt;/code>s that map XML to/from Java &lt;code>Object&lt;/code>s.&lt;/p>&#xA; * &#xA; * &lt;p id=&quot;DatatypeFactory.newInstance&quot;>{@link #newInstance()} is used to create a new &lt;code>DatatypeFactory&lt;/code>.&#xA; * The following implementation resolution mechanisms are used in the following order:&lt;/p>&#xA; * &lt;ol>&#xA; *    &lt;li>&#xA; *      If the system property specified by {@link #DATATYPEFACTORY_PROPERTY}, &quot;&lt;code>javax.xml.datatype.DatatypeFactory&lt;/code>&quot;,&#xA; *      exists, a class with the name of the property's value is instantiated.&#xA; *      Any Exception thrown during the instantiation process is wrapped as a {@link DatatypeConfigurationException}.&#xA; *    &lt;/li>&#xA; *    &lt;li>&#xA; *      If the file ${JAVA_HOME}/lib/jaxp.properties exists, it is loaded in a {@link java.util.Properties} &lt;code>Object&lt;/code>.&#xA; *      The &lt;code>Properties&lt;/code> &lt;code>Object &lt;/code> is then queried for the property as documented in the prior step&#xA; *      and processed as documented in the prior step.&#xA; *    &lt;/li>&#xA; *    &lt;li>&#xA; *      The services resolution mechanism is used, e.g. &lt;code>META-INF/services/java.xml.datatype.DatatypeFactory&lt;/code>.&#xA; *      Any Exception thrown during the instantiation process is wrapped as a {@link DatatypeConfigurationException}.&#xA; *    &lt;/li>&#xA; *    &lt;li>&#xA; *      The final mechanism is to attempt to instantiate the &lt;code>Class&lt;/code> specified by&#xA; *      {@link #DATATYPEFACTORY_IMPLEMENTATION_CLASS}, &quot;&lt;code>javax.xml.datatype.DatatypeFactoryImpl&lt;/code>&quot;.&#xA; *      Any Exception thrown during the instantiation process is wrapped as a {@link DatatypeConfigurationException}.&#xA; *    &lt;/li>&#xA; * &lt;/ol> &#xA; * &#xA; * @author &lt;a href=&quot;mailto:Joseph.Fialli@Sun.COM&quot;>Joseph Fialli&lt;/a>&#xA; * @author &lt;a href=&quot;mailto:Jeff.Suttor@Sun.com&quot;>Jeff Suttor&lt;/a>&#xA; * @version $Revision: 1.4 $, $Date: 2004/04/30 01:40:53 $&#xA; * @since 1.5&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="../../../../../../../../javax/xml/datatype/DatatypeFactory.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
