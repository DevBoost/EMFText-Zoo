<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../../../../../java.ecore#/5 http://www.emftext.org/java/instantiations ../../../../../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../../../../../java.ecore#/9 http://www.emftext.org/java/members ../../../../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../../../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../../../../../java.ecore#/13 http://www.emftext.org/java/references ../../../../../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../../../../../java.ecore#/15 http://www.emftext.org/java/types ../../../../../../../java.ecore#/16" name="ElemContext.java">
  <comments>/*&#xA; * Copyright 2003-2004 The Apache Software Foundation.&#xA; *&#xA; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);&#xA; * you may not use this file except in compliance with the License.&#xA; * You may obtain a copy of the License at&#xA; *&#xA; *     http://www.apache.org/licenses/LICENSE-2.0&#xA; *&#xA; * Unless required by applicable law or agreed to in writing, software&#xA; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&#xA; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA; * See the License for the specific language governing permissions and&#xA; * limitations under the License.&#xA; */</comments>
  <comments>/*&#xA; * $Id: ElemContext.java,v 1.2 2004/02/17 04:18:19 minchau Exp $&#xA; */</comments>
  <namespaces>com</namespaces>
  <namespaces>sun</namespaces>
  <namespaces>org</namespaces>
  <namespaces>apache</namespaces>
  <namespaces>xml</namespaces>
  <namespaces>internal</namespaces>
  <namespaces>serializer</namespaces>
  <classifiers xsi:type="classifiers:Class" name="ElemContext">
    <comments>/**&#xA; * This class is a stack frame that consists of &#xA; * information about the element currently being processed &#xA; * by a serializer. Consider this example:&#xA; * &lt;pre>&#xA; *   &lt;A>&#xA; *     &lt;B1>&#xA; *     &lt;/B1>&#xA; *     &lt;B2>&#xA; *     &lt;/B2>&#xA; *   &lt;A>&#xA; * &lt;/pre> &#xA; * &#xA; * A stack frame will be pushed for &quot;A&quot; at depth 1, &#xA; * then another one for &quot;B1&quot; at depth 2.&#xA; * Then &quot;B1&quot; stackframe is popped.  When the stack frame for &quot;B2&quot; is &#xA; * pushed, this implementation re-uses the old stack fram object used&#xA; * by &quot;B1&quot; to be efficient at not creating too many of these object.&#xA; * &#xA; * This is by no means a public class, and neither are its fields or methods,&#xA; * they are all helper fields for a serializer.&#xA; * &#xA; * The purpose of this class is to be more consistent with pushing information&#xA; * when a new element is being serialized and more quickly restoring the old&#xA; * information about the parent element with a simple pop() when the&#xA; * child element is done.  Previously there was some redundant and error-prone&#xA; * calculations going on to retore information.&#xA; * &#xA; */</comments>
    <members xsi:type="members:Field" name="m_currentElemDepth">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>// Fields that form the context of the element</comments>
        <comments>/**&#xA;     * The nesting depth of the element inside other elements.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="m_elementDesc">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/** HTML field, the element description of the HTML element */</comments>
          <target xsi:type="classifiers:Class" href="ElemDesc.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="m_elementLocalName">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * The local name of the element.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="m_elementName">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * The fully qualified name of the element (with prefix, if any).&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="m_elementURI">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * The URI of the element.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="m_isCdataSection">
      <typeReference xsi:type="types:Boolean">
        <comments>/** If the element is in the cdata-section-names list&#xA;     * then the value is true. If it is true the text children of the element&#xA;     * should be output in CDATA section blocks. &#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="m_isRaw">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean">
        <comments>/** True if the current element has output escaping disabled.&#xA;     * This is true for SCRIPT and STYLE elements. &#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="m_next">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** The next element &quot;stack frame&quot;. This value will only be&#xA;     * set once as deeper stack frames are not deleted when popped off,&#xA;     * but are rather re-used when a push is required.&#xA;     * &#xA;     * This makes for very fast pushing and popping of stack frames &#xA;     * because very few stack frame objects are ever created, they are&#xA;     * mostly re-used.  This re-use saves object creation but it also means&#xA;     * that connections between the frames via m_next and m_prev&#xA;     * never changes either. Just the contents of the frames change&#xA;     * as they are re-used. Only the reference to the current stack frame, which&#xA;     * is held by the serializer is changed via a quick pop() or push().&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="m_prev">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/** The previous element &quot;stack frame&quot;. */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="m_startTagOpen">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Set to true when a start tag is started, or open, but not all the&#xA;     * attributes or namespace information is yet collected.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Constructor" name="ElemContext">
      <comments>/**&#xA;     * Constructor to create the root of the element contexts. &#xA;     *&#xA;     */</comments>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
            <comments>// this assignment means can never pop this context off</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <comments>// depth 0 because it doesn't correspond to any element</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:Constructor" name="ElemContext">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="previous">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Constructor to create the &quot;stack frame&quot; for a given element depth.&#xA;     * &#xA;     * This implementation will re-use the context at each depth. If&#xA;     * a documents deepest element depth is N then there will be (N+1)&#xA;     * such objects created, no more than that.&#xA;     * &#xA;     * @param previous The &quot;stack frame&quot; corresponding to the new&#xA;     * elements parent element.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="pop">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Pop the current &quot;stack frame&quot;.&#xA;     * @return Returns the parent &quot;stack frame&quot; of the one popped.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>/* a very simple pop.  No clean up is done of the deeper&#xA;         * stack frame.  All deeper stack frames are still attached&#xA;         * but dormant, just waiting to be re-used.&#xA;         */</comments>
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="push">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * This method pushes an element &quot;stack frame&quot; &#xA;     * but with no initialization of values in that frame.&#xA;     * This method is used for optimization purposes, like when pushing&#xA;     * a stack frame for an HTML &quot;IMG&quot; tag which has no children and&#xA;     * the stack frame will almost immediately be popped.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="frame">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@variable">
                <comments>/* We have never been at this depth yet, and there is no&#xA;             * stack frame to re-use, so we now make a new one.&#xA;             */</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@variable">
            <comments>/*&#xA;         * We shouldn't need to set this true because we should just&#xA;         * be pushing a dummy stack frame that will be instantly popped.&#xA;         * Yet we need to be ready in case this element does have&#xA;         * unexpected children.&#xA;         */</comments>
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="push">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="uri">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="localName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="qName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../../../../../java/lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Push an element context on the stack. This context keeps track of&#xA;     * information gathered about the element.&#xA;     * @param uri The URI for the namespace for the element name, &#xA;     * can be null if it is not yet known.&#xA;     * @param localName The local name of the element (no prefix),  &#xA;     * can be null.&#xA;     * @param qName The qualified name (with prefix, if any) &#xA;     * of the element, this parameter is required.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="frame">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable">
                <comments>/* We have never been at this depth yet, and there is no&#xA;             * stack frame to re-use, so we now make a new one.&#xA;             */</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable">
            <comments>// Initialize, or reset values in the new or re-used stack frame.</comments>
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// is_Raw is already set in the HTML startElement() method</comments>
        <comments>// frame.m_isRaw = false; </comments>
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable"/>
      </statements>
    </members>
  </classifiers>
</containers:CompilationUnit>
