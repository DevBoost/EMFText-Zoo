<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="CharacterIterator.java">
  <comments>/*&#xA; * @(#)CharacterIterator.java&#x9;1.19 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/*&#xA; * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved&#xA; * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved&#xA; *&#xA; * The original version of this source code and documentation&#xA; * is copyrighted and owned by Taligent, Inc., a wholly-owned&#xA; * subsidiary of IBM. These materials are provided under terms&#xA; * of a License Agreement between Taligent and Sun. This technology&#xA; * is protected by multiple US and International patents.&#xA; *&#xA; * This notice and attribution to Taligent may not be removed.&#xA; * Taligent is a registered trademark of Taligent, Inc.&#xA; *&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>text</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="CharacterIterator">
    <members xsi:type="members:Field" name="DONE">
      <initialValue xsi:type="literals:CharacterLiteral" value="92"/>
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constant that is returned when the iterator has reached either the end&#xA;     * or the beginning of the text. The value is '\\uFFFF', the &quot;not a&#xA;     * character&quot; value which should not occur in any valid Unicode string.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="first">
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the position to getBeginIndex() and returns the character at that&#xA;     * position.&#xA;     * @return the first character in the text, or DONE if the text is empty&#xA;     * @see #getBeginIndex()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="last">
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the position to getEndIndex()-1 (getEndIndex() if the text is empty)&#xA;     * and returns the character at that position.&#xA;     * @return the last character in the text, or DONE if the text is empty&#xA;     * @see #getEndIndex()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="current">
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the character at the current position (as returned by getIndex()).&#xA;     * @return the character at the current position or DONE if the current&#xA;     * position is off the end of the text.&#xA;     * @see #getIndex()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="next">
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Increments the iterator's index by one and returns the character&#xA;     * at the new index.  If the resulting index is greater or equal&#xA;     * to getEndIndex(), the current index is reset to getEndIndex() and&#xA;     * a value of DONE is returned.&#xA;     * @return the character at the new position or DONE if the new&#xA;     * position is off the end of the text range.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="previous">
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Decrements the iterator's index by one and returns the character&#xA;     * at the new index. If the current index is getBeginIndex(), the index&#xA;     * remains at getBeginIndex() and a value of DONE is returned.&#xA;     * @return the character at the new position or DONE if the current&#xA;     * position is equal to getBeginIndex().&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setIndex">
      <typeReference xsi:type="types:Char"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="position">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the position to the specified position in the text and returns that&#xA;     * character.&#xA;     * @param position the position within the text.  Valid values range from&#xA;     * getBeginIndex() to getEndIndex().  An IllegalArgumentException is thrown&#xA;     * if an invalid value is supplied.&#xA;     * @return the character at the specified position or DONE if the specified position is equal to getEndIndex()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBeginIndex">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the start index of the text.&#xA;     * @return the index at which the text begins.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getEndIndex">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the end index of the text.  This index is the index of the first&#xA;     * character following the end of the text.&#xA;     * @return the index after the last character in the text&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getIndex">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current index.&#xA;     * @return the current index.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a copy of this iterator&#xA;     * @return A copy of this&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This interface defines a protocol for bidirectional iteration over text.&#xA; * The iterator iterates over a bounded sequence of characters.  Characters&#xA; * are indexed with values beginning with the value returned by getBeginIndex() and&#xA; * continuing through the value returned by getEndIndex()-1.&#xA; * &lt;p>&#xA; * Iterators maintain a current character index, whose valid range is from&#xA; * getBeginIndex() to getEndIndex(); the value getEndIndex() is included to allow&#xA; * handling of zero-length text ranges and for historical reasons.&#xA; * The current index can be retrieved by calling getIndex() and set directly&#xA; * by calling setIndex(), first(), and last().&#xA; * &lt;p>&#xA; * The methods previous() and next() are used for iteration. They return DONE if&#xA; * they would move outside the range from getBeginIndex() to getEndIndex() -1,&#xA; * signaling that the iterator has reached the end of the sequence. DONE is&#xA; * also returned by other methods to indicate that the current index is&#xA; * outside this range.&#xA; *&#xA; * &lt;P>Examples:&lt;P>&#xA; *&#xA; * Traverse the text from start to finish&#xA; * &lt;pre>&#xA; * public void traverseForward(CharacterIterator iter) {&#xA; *     for(char c = iter.first(); c != CharacterIterator.DONE; c = iter.next()) {&#xA; *         processChar(c);&#xA; *     }&#xA; * }&#xA; * &lt;/pre>&#xA; *&#xA; * Traverse the text backwards, from end to start&#xA; * &lt;pre>&#xA; * public void traverseBackward(CharacterIterator iter) {&#xA; *     for(char c = iter.last(); c != CharacterIterator.DONE; c = iter.previous()) {&#xA; *         processChar(c);&#xA; *     }&#xA; * }&#xA; * &lt;/pre>&#xA; *&#xA; * Traverse both forward and backward from a given position in the text.&#xA; * Calls to notBoundary() in this example represents some&#xA; * additional stopping criteria.&#xA; * &lt;pre>&#xA; * public void traverseOut(CharacterIterator iter, int pos) {&#xA; *     for (char c = iter.setIndex(pos);&#xA; *              c != CharacterIterator.DONE &amp;&amp; notBoundary(c);&#xA; *              c = iter.next()) {&#xA; *     }&#xA; *     int end = iter.getIndex();&#xA; *     for (char c = iter.setIndex(pos);&#xA; *             c != CharacterIterator.DONE &amp;&amp; notBoundary(c);&#xA; *             c = iter.previous()) {&#xA; *     }&#xA; *     int start = iter.getIndex();&#xA; *     processSection(start, end);&#xA; * }&#xA; * &lt;/pre>&#xA; *&#xA; * @see StringCharacterIterator&#xA; * @see AttributedCharacterIterator&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../lang/Cloneable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
