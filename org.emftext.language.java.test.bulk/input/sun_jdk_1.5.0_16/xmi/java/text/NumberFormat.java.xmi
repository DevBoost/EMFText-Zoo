<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="NumberFormat.java">
  <comments>/*&#xA; * @(#)NumberFormat.java&#x9;1.65 04/05/10&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/*&#xA; * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved&#xA; * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved&#xA; *&#xA; *   The original version of this source code and documentation is copyrighted&#xA; * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These&#xA; * materials are provided under terms of a License Agreement between Taligent&#xA; * and Sun. This technology is protected by multiple US and International&#xA; * patents. This notice and attribution to Taligent may not be removed.&#xA; *   Taligent is a registered trademark of Taligent, Inc.&#xA; *&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>text</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/InvalidObjectException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/ObjectInputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>math</namespaces>
    <classifier xsi:type="classifiers:Class" href="../math/BigInteger.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Currency.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/HashMap.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Hashtable.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/ResourceBundle.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>text</namespaces>
    <namespaces>resources</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="NumberFormat">
    <members xsi:type="members:Field" name="INTEGER_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field constant used to construct a FieldPosition object. Signifies that&#xA;     * the position of the integer part of a formatted number should be returned.&#xA;     * @see java.text.FieldPosition&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="FRACTION_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field constant used to construct a FieldPosition object. Signifies that&#xA;     * the position of the fraction part of a formatted number should be returned.&#xA;     * @see java.text.FieldPosition&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="number">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toAppendTo">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="FieldPosition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Formats a number and appends the resulting text to the given string&#xA;     * buffer.&#xA;     * The number can be of any subclass of {@link java.lang.Number}.&#xA;     * &lt;p>&#xA;     * This implementation extracts the number's value using&#xA;     * {@link java.lang.Number#longValue()} for all integral type values that&#xA;     * can be converted to &lt;code>long&lt;/code> without loss of information,&#xA;     * including &lt;code>BigInteger&lt;/code> values with a&#xA;     * {@link java.math.BigInteger#bitLength() bit length} of less than 64,&#xA;     * and {@link java.lang.Number#doubleValue()} for all other types. It&#xA;     * then calls&#xA;     * {@link #format(long,java.lang.StringBuffer,java.text.FieldPosition)}&#xA;     * or {@link #format(double,java.lang.StringBuffer,java.text.FieldPosition)}.&#xA;     * This may result in loss of magnitude information and precision for&#xA;     * &lt;code>BigInteger&lt;/code> and &lt;code>BigDecimal&lt;/code> values.&#xA;     * @param number     the number to format&#xA;     * @param toAppendTo the &lt;code>StringBuffer&lt;/code> to which the formatted&#xA;     *                   text is to be appended&#xA;     * @param pos        On input: an alignment field, if desired.&#xA;     *                   On output: the offsets of the alignment field.&#xA;     * @return           the value passed in as &lt;code>toAppendTo&lt;/code>&#xA;     * @exception        IllegalArgumentException if &lt;code>number&lt;/code> is&#xA;     *                   null or not an instance of &lt;code>Number&lt;/code>.&#xA;     * @exception        NullPointerException if &lt;code>toAppendTo&lt;/code> or&#xA;     *                   &lt;code>pos&lt;/code> is null&#xA;     * @see              java.text.FieldPosition&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
              <arguments xsi:type="expressions:NestedExpression">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Number.class.xmi#//@classifiers.0/@members.3"/>
                </next>
                <expression xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/Number.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
                </expression>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.2"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:InstanceOfExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          </children>
          <children xsi:type="expressions:InstanceOfExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          </children>
          <children xsi:type="expressions:InstanceOfExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Short.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          </children>
          <children xsi:type="expressions:InstanceOfExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Byte.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:InstanceOfExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../math/BigInteger.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:NestedExpression">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../math/BigInteger.class.xmi#//@classifiers.0/@members.100"/>
                  </next>
                  <expression xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../math/BigInteger.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
                  </expression>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="64"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </children>
            </expression>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
                <arguments xsi:type="expressions:NestedExpression">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Number.class.xmi#//@classifiers.0/@members.5"/>
                  </next>
                  <expression xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../lang/Number.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
                  </expression>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.2"/>
              </returnValue>
            </statements>
          </statement>
          <condition xsi:type="expressions:InstanceOfExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Number.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="Cannot format given Object as a Number"/>
              </throwable>
            </statements>
          </elseStatement>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="parseObject">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ParsePosition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Parses text from a string to produce a &lt;code>Number&lt;/code>.&#xA;     * &lt;p>&#xA;     * The method attempts to parse text starting at the index given by&#xA;     * &lt;code>pos&lt;/code>.&#xA;     * If parsing succeeds, then the index of &lt;code>pos&lt;/code> is updated&#xA;     * to the index after the last character used (parsing does not necessarily&#xA;     * use all characters up to the end of the string), and the parsed&#xA;     * number is returned. The updated &lt;code>pos&lt;/code> can be used to&#xA;     * indicate the starting point for the next call to this method.&#xA;     * If an error occurs, then the index of &lt;code>pos&lt;/code> is not&#xA;     * changed, the error index of &lt;code>pos&lt;/code> is set to the index of&#xA;     * the character where the error occurred, and null is returned.&#xA;     * &lt;p>&#xA;     * See the {@link #parse(String, ParsePosition)} method for more information&#xA;     * on number parsing.&#xA;     *&#xA;     * @param source A &lt;code>String&lt;/code>, part of which should be parsed.&#xA;     * @param pos A &lt;code>ParsePosition&lt;/code> object with index and error&#xA;     *            index information as described above.&#xA;     * @return A &lt;code>Number&lt;/code> parsed from the string. In case of&#xA;     *         error, returns null.&#xA;     * @exception NullPointerException if &lt;code>pos&lt;/code> is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.8">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="number">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Specialization of format.&#xA;     * @see java.text.Format#format&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </arguments>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DontCareFieldPosition.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="DontCareFieldPosition.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="number">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Specialization of format.&#xA;     * @see java.text.Format#format&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </arguments>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DontCareFieldPosition.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="DontCareFieldPosition.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="number">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toAppendTo">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="FieldPosition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Specialization of format.&#xA;     * @see java.text.Format#format&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="number">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toAppendTo">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="FieldPosition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Specialization of format.&#xA;     * @see java.text.Format#format&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="parse">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Number.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parsePosition">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ParsePosition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,&#xA;     * Long.MAX_VALUE] and with no decimals), otherwise a Double.&#xA;     * If IntegerOnly is set, will stop at a decimal&#xA;     * point (or equivalent; e.g., for rational numbers &quot;1 2/3&quot;, will stop&#xA;     * after the 1).&#xA;     * Does not throw an exception; if no object can be parsed, index is&#xA;     * unchanged!&#xA;     * @see java.text.NumberFormat#isParseIntegerOnly&#xA;     * @see java.text.Format#parseObject&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="parse">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Number.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ParseException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Parses text from the beginning of the given string to produce a number.&#xA;     * The method may not use the entire text of the given string.&#xA;     * &lt;p>&#xA;     * See the {@link #parse(String, ParsePosition)} method for more information&#xA;     * on number parsing.&#xA;     *&#xA;     * @param source A &lt;code>String&lt;/code> whose beginning should be parsed.&#xA;     * @return A &lt;code>Number&lt;/code> parsed from the string.&#xA;     * @exception ParseException if the beginning of the specified string&#xA;     *            cannot be parsed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="parsePosition">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="ParsePosition.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="ParsePosition.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Number.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.8">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="ParseException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Unparseable number: &quot;"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
                <children xsi:type="references:StringReference" value="&quot;"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="ParsePosition.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="ParsePosition.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isParseIntegerOnly">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns true if this format will parse numbers as integers only.&#xA;     * For example in the English locale, with ParseIntegerOnly true, the&#xA;     * string &quot;1234.&quot; would be parsed as the integer value 1234 and parsing&#xA;     * would stop at the &quot;.&quot; character.  Of course, the exact format accepted&#xA;     * by the parse operation is locale dependant and determined by sub-classes&#xA;     * of NumberFormat.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setParseIntegerOnly">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets whether or not numbers should be parsed as integers only.&#xA;     * @see #isParseIntegerOnly&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>//============== Locale Stuff =====================</comments>
        <comments>/**&#xA;     * Returns a general-purpose number format for the current default locale.&#xA;     * This is the same as calling&#xA;     * {@link #getNumberInstance() getNumberInstance()}.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a general-purpose number format for the specified locale.&#xA;     * This is the same as calling&#xA;     * {@link #getNumberInstance(java.util.Locale) getNumberInstance(inLocale)}.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNumberInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a general-purpose number format for the current default locale.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNumberInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a general-purpose number format for the specified locale.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getIntegerInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an integer number format for the current default locale. The&#xA;     * returned number format is configured to round floating point numbers&#xA;     * to the nearest integer using IEEE half-even rounding (see {@link &#xA;     * java.math.BigDecimal#ROUND_HALF_EVEN ROUND_HALF_EVEN}) for formatting,&#xA;     * and to parse only the integer part of an input string (see {@link&#xA;     * #isParseIntegerOnly isParseIntegerOnly}).&#xA;     *&#xA;     * @return a number format for integer values&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getIntegerInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an integer number format for the specified locale. The&#xA;     * returned number format is configured to round floating point numbers&#xA;     * to the nearest integer using IEEE half-even rounding (see {@link &#xA;     * java.math.BigDecimal#ROUND_HALF_EVEN ROUND_HALF_EVEN}) for formatting,&#xA;     * and to parse only the integer part of an input string (see {@link&#xA;     * #isParseIntegerOnly isParseIntegerOnly}).&#xA;     *&#xA;     * @param inLocale the locale for which a number format is needed&#xA;     * @return a number format for integer values&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCurrencyInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a currency format for the current default locale.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCurrencyInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a currency format for the specified locale.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPercentInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a percentage format for the current default locale.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPercentInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a percentage format for the specified locale.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getScientificInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Returns a scientific format for the current default locale.&#xA;     */</comments>
        <comments>/*public*/</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getScientificInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Returns a scientific format for the specified locale.&#xA;     */</comments>
        <comments>/*public*/</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAvailableLocales">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an array of all locales for which the&#xA;     * &lt;code>get*Instance&lt;/code> methods of this class can return&#xA;     * localized instances.&#xA;     * The array returned must contain at least a &lt;code>Locale&lt;/code>&#xA;     * instance equal to {@link java.util.Locale#US Locale.US}.&#xA;     *&#xA;     * @return An array of locales for which localized&#xA;     *         &lt;code>NumberFormat&lt;/code> instances are available.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0/@members.7"/>
            <arguments xsi:type="references:StringReference" value="NumberPatterns"/>
          </next>
          <target xsi:type="classifiers:Class" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <comments>// just enough fields for a reasonable distribution</comments>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Overrides hashCode&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="37"/>
            <multiplicativeOperators xsi:type="operators:Multiplication"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52"/>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Overrides equals&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="other">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
              </children>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
              </children>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
              </children>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
              </children>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
              </children>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
              </children>
            </children>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Overrides Cloneable&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="other">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Format.class.xmi#//@classifiers.0/@members.7"/>
              </next>
              <self xsi:type="literals:Super"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isGroupingUsed">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns true if grouping is used in this format. For example, in the&#xA;     * English locale, with grouping on, the number 1234567 might be formatted&#xA;     * as &quot;1,234,567&quot;. The grouping separator as well as the size of each group&#xA;     * is locale dependant and is determined by sub-classes of NumberFormat.&#xA;     * @see #setGroupingUsed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setGroupingUsed">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newValue">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set whether or not grouping will be used in this format.&#xA;     * @see #isGroupingUsed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMaximumIntegerDigits">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the maximum number of digits allowed in the integer portion of a&#xA;     * number.&#xA;     * @see #setMaximumIntegerDigits&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setMaximumIntegerDigits">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newValue">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the maximum number of digits allowed in the integer portion of a&#xA;     * number. maximumIntegerDigits must be >= minimumIntegerDigits.  If the&#xA;     * new value for maximumIntegerDigits is less than the current value&#xA;     * of minimumIntegerDigits, then minimumIntegerDigits will also be set to&#xA;     * the new value.&#xA;     * @param newValue the maximum number of integer digits to be shown; if&#xA;     * less than zero, then zero is used. The concrete subclass may enforce an&#xA;     * upper limit to this value appropriate to the numeric type being formatted.&#xA;     * @see #getMaximumIntegerDigits&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMinimumIntegerDigits">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the minimum number of digits allowed in the integer portion of a&#xA;     * number.&#xA;     * @see #setMinimumIntegerDigits&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setMinimumIntegerDigits">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newValue">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the minimum number of digits allowed in the integer portion of a&#xA;     * number. minimumIntegerDigits must be &lt;= maximumIntegerDigits.  If the&#xA;     * new value for minimumIntegerDigits exceeds the current value&#xA;     * of maximumIntegerDigits, then maximumIntegerDigits will also be set to&#xA;     * the new value&#xA;     * @param newValue the minimum number of integer digits to be shown; if&#xA;     * less than zero, then zero is used. The concrete subclass may enforce an&#xA;     * upper limit to this value appropriate to the numeric type being formatted.&#xA;     * @see #getMinimumIntegerDigits&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMaximumFractionDigits">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the maximum number of digits allowed in the fraction portion of a&#xA;     * number.&#xA;     * @see #setMaximumFractionDigits&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setMaximumFractionDigits">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newValue">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the maximum number of digits allowed in the fraction portion of a&#xA;     * number. maximumFractionDigits must be >= minimumFractionDigits.  If the&#xA;     * new value for maximumFractionDigits is less than the current value&#xA;     * of minimumFractionDigits, then minimumFractionDigits will also be set to&#xA;     * the new value.&#xA;     * @param newValue the maximum number of fraction digits to be shown; if&#xA;     * less than zero, then zero is used. The concrete subclass may enforce an&#xA;     * upper limit to this value appropriate to the numeric type being formatted.&#xA;     * @see #getMaximumFractionDigits&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMinimumFractionDigits">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the minimum number of digits allowed in the fraction portion of a&#xA;     * number.&#xA;     * @see #setMinimumFractionDigits&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setMinimumFractionDigits">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newValue">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the minimum number of digits allowed in the fraction portion of a&#xA;     * number. minimumFractionDigits must be &lt;= maximumFractionDigits.  If the&#xA;     * new value for minimumFractionDigits exceeds the current value&#xA;     * of maximumFractionDigits, then maximumIntegerDigits will also be set to&#xA;     * the new value&#xA;     * @param newValue the minimum number of fraction digits to be shown; if&#xA;     * less than zero, then zero is used. The concrete subclass may enforce an&#xA;     * upper limit to this value appropriate to the numeric type being formatted.&#xA;     * @see #getMinimumFractionDigits&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCurrency">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Currency.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the currency used by this number format when formatting&#xA;     * currency values. The initial value is derived in a locale dependent&#xA;     * way. The returned value may be null if no valid&#xA;     * currency could be determined and no currency has been set using&#xA;     * {@link #setCurrency(java.util.Currency) setCurrency}.&#xA;     * &lt;p>&#xA;     * The default implementation throws&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @return the currency used by this number format, or &lt;code>null&lt;/code>&#xA;     * @exception UnsupportedOperationException if the number format class&#xA;     * doesn't implement currency formatting&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setCurrency">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="currency">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Currency.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the currency used by this number format when formatting&#xA;     * currency values. This does not update the minimum or maximum&#xA;     * number of fraction digits used by the number format.&#xA;     * &lt;p>&#xA;     * The default implementation throws&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param currency the new currency to be used by this number format&#xA;     * @exception UnsupportedOperationException if the number format class&#xA;     * doesn't implement currency formatting&#xA;     * @exception NullPointerException if &lt;code>currency&lt;/code> is null&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="desiredLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="choice">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// =======================privates===============================</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="numberPatterns">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>/* try the cache first */</comments>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/Hashtable.class.xmi#//@classifiers.0/@members.25"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
              </next>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="resource">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <comments>/* cache miss */</comments>
                  <target xsi:type="classifiers:Class" href="../util/ResourceBundle.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0/@members.8"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.1/@statement/@statements.0/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../util/ResourceBundle.class.xmi#//@classifiers.0/@members.12"/>
                  <arguments xsi:type="references:StringReference" value="NumberPatterns"/>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
              <comments>/* update cache */</comments>
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/Hashtable.class.xmi#//@classifiers.0/@members.27"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@variable"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="symbols">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="DecimalFormatSymbols.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="DecimalFormatSymbols.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="entry">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48"/>
              </expression>
            </child>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="format">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="DecimalFormat.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="DecimalFormat.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@variable">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.3/@variable"/>
              </arraySelectors>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.2/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.4/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="DecimalFormat.class.xmi#//@classifiers.0/@members.108"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.4/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="DecimalFormat.class.xmi#//@classifiers.0/@members.89"/>
                <arguments xsi:type="literals:BooleanLiteral"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.4/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
                <arguments xsi:type="literals:BooleanLiteral" value="true"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.4/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="DecimalFormat.class.xmi#//@classifiers.0/@members.116"/>
                </next>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.4/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="stream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/ObjectInputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/ClassNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * First, read in the default serializable data.&#xA;     *&#xA;     * Then, if &lt;code>serialVersionOnStream&lt;/code> is less than 1, indicating that&#xA;     * the stream was written by JDK 1.1,&#xA;     * set the &lt;code>int&lt;/code> fields such as &lt;code>maximumIntegerDigits&lt;/code>&#xA;     * to be equal to the &lt;code>byte&lt;/code> fields such as &lt;code>maxIntegerDigits&lt;/code>,&#xA;     * since the &lt;code>int&lt;/code> fields were not present in JDK 1.1.&#xA;     * Finally, set serialVersionOnStream back to the maximum allowed value so that&#xA;     * default serialization will work properly if this object is streamed out again.&#xA;     *&#xA;     * &lt;p>If &lt;code>minimumIntegerDigits&lt;/code> is greater than&#xA;     * &lt;code>maximumIntegerDigits&lt;/code> or &lt;code>minimumFractionDigits&lt;/code>&#xA;     * is greater than &lt;code>maximumFractionDigits&lt;/code>, then the stream data&#xA;     * is invalid and this method throws an &lt;code>InvalidObjectException&lt;/code>.&#xA;     * In addition, if any of these values is negative, then this method throws&#xA;     * an &lt;code>InvalidObjectException&lt;/code>.&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectInputStream.class.xmi#//@classifiers.0/@members.19"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55">
                <comments>// Didn't have additional int fields, reassign to use them.</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../io/InvalidObjectException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Digit count range invalid"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="stream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Write out the default serializable data, after first setting&#xA;     * the &lt;code>byte&lt;/code> fields such as &lt;code>maxIntegerDigits&lt;/code> to be&#xA;     * equal to the &lt;code>int&lt;/code> fields such as &lt;code>maximumIntegerDigits&lt;/code>&#xA;     * (or to &lt;code>Byte.MAX_VALUE&lt;/code>, whichever is smaller), for compatibility&#xA;     * with the JDK 1.1 version of the stream format.&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Byte.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Byte.class.xmi#//@classifiers.0"/>
                </children>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </expression>
            </child>
            <expressionIf xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../lang/Byte.class.xmi#//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Byte.class.xmi#//@classifiers.0"/>
            </expressionIf>
            <expressionElse xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Byte"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
            </expressionElse>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Byte.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Byte.class.xmi#//@classifiers.0"/>
                </children>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </expression>
            </child>
            <expressionIf xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../lang/Byte.class.xmi#//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Byte.class.xmi#//@classifiers.0"/>
            </expressionIf>
            <expressionElse xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Byte"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
            </expressionElse>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Byte.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Byte.class.xmi#//@classifiers.0"/>
                </children>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </expression>
            </child>
            <expressionIf xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../lang/Byte.class.xmi#//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Byte.class.xmi#//@classifiers.0"/>
            </expressionIf>
            <expressionElse xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Byte"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
            </expressionElse>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Byte.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Byte.class.xmi#//@classifiers.0"/>
                </children>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </expression>
            </child>
            <expressionIf xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../lang/Byte.class.xmi#//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Byte.class.xmi#//@classifiers.0"/>
            </expressionIf>
            <expressionElse xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Byte"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
            </expressionElse>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.17"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:Field" name="cachedLocaleData">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Hashtable.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Hashtable.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Cache to hold the NumberPatterns of a Locale.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="NUMBERSTYLE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Constants used by factory methods to specify a style of format.</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="CURRENCYSTYLE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="PERCENTSTYLE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SCIENTIFICSTYLE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="INTEGERSTYLE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="groupingUsed">
      <initialValue xsi:type="literals:BooleanLiteral" value="true"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * True if the the grouping (i.e. thousands) separator is used when&#xA;     * formatting and parsing numbers.&#xA;     *&#xA;     * @serial&#xA;     * @see #isGroupingUsed&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="maxIntegerDigits">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="40"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The maximum number of digits allowed in the integer portion of a&#xA;     * number.  &lt;code>maxIntegerDigits&lt;/code> must be greater than or equal to&#xA;     * &lt;code>minIntegerDigits&lt;/code>.&#xA;     * &lt;p>&#xA;     * &lt;strong>Note:&lt;/strong> This field exists only for serialization&#xA;     * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new&#xA;     * &lt;code>int&lt;/code> field &lt;code>maximumIntegerDigits&lt;/code> is used instead.&#xA;     * When writing to a stream, &lt;code>maxIntegerDigits&lt;/code> is set to&#xA;     * &lt;code>maximumIntegerDigits&lt;/code> or &lt;code>Byte.MAX_VALUE&lt;/code>,&#xA;     * whichever is smaller.  When reading from a stream, this field is used&#xA;     * only if &lt;code>serialVersionOnStream&lt;/code> is less than 1. &#xA;     *&#xA;     * @serial&#xA;     * @see #getMaximumIntegerDigits&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="minIntegerDigits">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The minimum number of digits allowed in the integer portion of a&#xA;     * number.  &lt;code>minimumIntegerDigits&lt;/code> must be less than or equal to&#xA;     * &lt;code>maximumIntegerDigits&lt;/code>.&#xA;     * &lt;p>&#xA;     * &lt;strong>Note:&lt;/strong> This field exists only for serialization&#xA;     * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new&#xA;     * &lt;code>int&lt;/code> field &lt;code>minimumIntegerDigits&lt;/code> is used instead.&#xA;     * When writing to a stream, &lt;code>minIntegerDigits&lt;/code> is set to&#xA;     * &lt;code>minimumIntegerDigits&lt;/code> or &lt;code>Byte.MAX_VALUE&lt;/code>,&#xA;     * whichever is smaller.  When reading from a stream, this field is used&#xA;     * only if &lt;code>serialVersionOnStream&lt;/code> is less than 1. &#xA;     *&#xA;     * @serial&#xA;     * @see #getMinimumIntegerDigits&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="maxFractionDigits">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The maximum number of digits allowed in the fractional portion of a&#xA;     * number.  &lt;code>maximumFractionDigits&lt;/code> must be greater than or equal to&#xA;     * &lt;code>minimumFractionDigits&lt;/code>.&#xA;     * &lt;p>&#xA;     * &lt;strong>Note:&lt;/strong> This field exists only for serialization&#xA;     * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new&#xA;     * &lt;code>int&lt;/code> field &lt;code>maximumFractionDigits&lt;/code> is used instead.&#xA;     * When writing to a stream, &lt;code>maxFractionDigits&lt;/code> is set to&#xA;     * &lt;code>maximumFractionDigits&lt;/code> or &lt;code>Byte.MAX_VALUE&lt;/code>,&#xA;     * whichever is smaller.  When reading from a stream, this field is used&#xA;     * only if &lt;code>serialVersionOnStream&lt;/code> is less than 1. &#xA;     *&#xA;     * @serial&#xA;     * @see #getMaximumFractionDigits&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="minFractionDigits">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// invariant, >= minFractionDigits</comments>
        <comments>/**&#xA;     * The minimum number of digits allowed in the fractional portion of a&#xA;     * number.  &lt;code>minimumFractionDigits&lt;/code> must be less than or equal to&#xA;     * &lt;code>maximumFractionDigits&lt;/code>.&#xA;     * &lt;p>&#xA;     * &lt;strong>Note:&lt;/strong> This field exists only for serialization&#xA;     * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new&#xA;     * &lt;code>int&lt;/code> field &lt;code>minimumFractionDigits&lt;/code> is used instead.&#xA;     * When writing to a stream, &lt;code>minFractionDigits&lt;/code> is set to&#xA;     * &lt;code>minimumFractionDigits&lt;/code> or &lt;code>Byte.MAX_VALUE&lt;/code>,&#xA;     * whichever is smaller.  When reading from a stream, this field is used&#xA;     * only if &lt;code>serialVersionOnStream&lt;/code> is less than 1. &#xA;     *&#xA;     * @serial&#xA;     * @see #getMinimumFractionDigits&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="parseIntegerOnly">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * True if this format will parse numbers as integers only.&#xA;     *&#xA;     * @serial&#xA;     * @see #isParseIntegerOnly&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="maximumIntegerDigits">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="40"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// new fields for 1.2.  byte is too small for integer digits.</comments>
        <comments>/**&#xA;     * The maximum number of digits allowed in the integer portion of a&#xA;     * number.  &lt;code>maximumIntegerDigits&lt;/code> must be greater than or equal to&#xA;     * &lt;code>minimumIntegerDigits&lt;/code>.&#xA;     *&#xA;     * @serial&#xA;     * @since 1.2&#xA;     * @see #getMaximumIntegerDigits&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="minimumIntegerDigits">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The minimum number of digits allowed in the integer portion of a&#xA;     * number.  &lt;code>minimumIntegerDigits&lt;/code> must be less than or equal to&#xA;     * &lt;code>maximumIntegerDigits&lt;/code>.&#xA;     *&#xA;     * @serial&#xA;     * @since 1.2&#xA;     * @see #getMinimumIntegerDigits&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="maximumFractionDigits">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The maximum number of digits allowed in the fractional portion of a&#xA;     * number.  &lt;code>maximumFractionDigits&lt;/code> must be greater than or equal to&#xA;     * &lt;code>minimumFractionDigits&lt;/code>.&#xA;     *&#xA;     * @serial&#xA;     * @since 1.2&#xA;     * @see #getMaximumFractionDigits&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="minimumFractionDigits">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// invariant, >= minFractionDigits</comments>
        <comments>/**&#xA;     * The minimum number of digits allowed in the fractional portion of a&#xA;     * number.  &lt;code>minimumFractionDigits&lt;/code> must be less than or equal to&#xA;     * &lt;code>maximumFractionDigits&lt;/code>.&#xA;     *&#xA;     * @serial&#xA;     * @since 1.2&#xA;     * @see #getMinimumFractionDigits&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="currentSerialVersion">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="serialVersionOnStream">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Describes the version of &lt;code>NumberFormat&lt;/code> present on the stream.&#xA;     * Possible values are:&#xA;     * &lt;ul>&#xA;     * &lt;li>&lt;b>0&lt;/b> (or uninitialized): the JDK 1.1 version of the stream format.&#xA;     *     In this version, the &lt;code>int&lt;/code> fields such as&#xA;     *     &lt;code>maximumIntegerDigits&lt;/code> were not present, and the &lt;code>byte&lt;/code>&#xA;     *     fields such as &lt;code>maxIntegerDigits&lt;/code> are used instead.&#xA;     *&#xA;     * &lt;li>&lt;b>1&lt;/b>: the 1.2 version of the stream format.  The values of the&#xA;     *     &lt;code>byte&lt;/code> fields such as &lt;code>maxIntegerDigits&lt;/code> are ignored,&#xA;     *     and the &lt;code>int&lt;/code> fields such as &lt;code>maximumIntegerDigits&lt;/code>&#xA;     *     are used instead.&#xA;     * &lt;/ul>&#xA;     * When streaming out a &lt;code>NumberFormat&lt;/code>, the most recent format&#xA;     * (corresponding to the highest allowable &lt;code>serialVersionOnStream&lt;/code>)&#xA;     * is always written.&#xA;     *&#xA;     * @serial&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="2308460125733713944"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>// Removed &quot;implements Cloneable&quot; clause.  Needs to update serialization</comments>
        <comments>// ID for backward compatibility.</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="classifiers:Class" name="Field">
      <members xsi:type="members:Field" name="serialVersionUID">
        <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="7494728892700160890"/>
        <typeReference xsi:type="types:Long"/>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Proclaim serial compatibility with 1.4 FCS</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="instanceMap">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../util/HashMap.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// table of all instances in this class, used by readResolve</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Constructor" name="Field">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@members.2/@parameters.0"/>
            <callTarget xsi:type="literals:Super"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@members.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../util/Map.class.xmi#//@classifiers.0/@members.5"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@members.2/@parameters.0"/>
                  <arguments xsi:type="references:SelfReference">
                    <self xsi:type="literals:This"/>
                  </arguments>
                </next>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
              </next>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62">
                <next xsi:type="references:ReflectiveClassReference"/>
              </next>
            </children>
          </condition>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="name">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected">
          <comments>/**&#xA;         * Creates a Field instance with the specified&#xA;         * name.&#xA;         *&#xA;         * @param name Name of the attribute&#xA;         */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:ClassMethod" name="readResolve">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/InvalidObjectException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Protected">
          <comments>/**&#xA;         * Resolves instances being deserialized to the predefined constants.&#xA;         *&#xA;         * @throws InvalidObjectException if the constant could not be resolved.&#xA;         * @return resolved NumberFormat.Field constant&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../io/InvalidObjectException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="subclass didn't correctly implement readResolve"/>
              </throwable>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
              </next>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62">
                <next xsi:type="references:ReflectiveClassReference"/>
              </next>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="instance">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@members.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../util/Map.class.xmi#//@classifiers.0/@members.4"/>
                <arguments xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="AttributedCharacterIterator$Attribute.class.xmi#//@classifiers.0/@members.10"/>
                </arguments>
              </next>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@members.3/@statements.1/@variable"/>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@members.3/@statements.1/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../io/InvalidObjectException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="unknown attribute name"/>
              </throwable>
            </statements>
          </elseStatement>
        </statements>
      </members>
      <members xsi:type="members:Field" name="INTEGER">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.62"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="integer"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.62"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the integer field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="FRACTION">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.62"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="fraction"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.62"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the fraction field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="EXPONENT">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.62"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="exponent"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.62"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the exponent field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="DECIMAL_SEPARATOR">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.62"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="decimal separator"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.62"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the decimal separator field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SIGN">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.62"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="sign"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.62"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the sign field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="GROUPING_SEPARATOR">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.62"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="grouping separator"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.62"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the grouping separator field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="EXPONENT_SYMBOL">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.62"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="exponent symbol"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.62"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the exponent symbol field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="PERCENT">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.62"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="percent"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.62"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the percent field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="PERMILLE">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.62"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="per mille"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.62"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the permille field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CURRENCY">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.62"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="currency"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.62"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the currency field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="EXPONENT_SIGN">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.62"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="exponent sign"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.62"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the exponent sign field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>//</comments>
        <comments>// class for AttributedCharacterIterator attributes</comments>
        <comments>//</comments>
        <comments>/**&#xA;     * Defines constants that are used as attribute keys in the&#xA;     * &lt;code>AttributedCharacterIterator&lt;/code> returned&#xA;     * from &lt;code>NumberFormat.formatToCharacterIterator&lt;/code> and as&#xA;     * field identifiers in &lt;code>FieldPosition&lt;/code>.&#xA;     *&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <namespaces>Format</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Format$Field.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </extends>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;code>NumberFormat&lt;/code> is the abstract base class for all number&#xA; * formats. This class provides the interface for formatting and parsing&#xA; * numbers. &lt;code>NumberFormat&lt;/code> also provides methods for determining&#xA; * which locales have number formats, and what their names are.&#xA; *&#xA; * &lt;p>&#xA; * &lt;code>NumberFormat&lt;/code> helps you to format and parse numbers for any locale.&#xA; * Your code can be completely independent of the locale conventions for&#xA; * decimal points, thousands-separators, or even the particular decimal&#xA; * digits used, or whether the number format is even decimal.&#xA; *&#xA; * &lt;p>&#xA; * To format a number for the current Locale, use one of the factory&#xA; * class methods:&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; *  myString = NumberFormat.getInstance().format(myNumber);&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; * If you are formatting multiple numbers, it is&#xA; * more efficient to get the format and use it multiple times so that&#xA; * the system doesn't have to fetch the information about the local&#xA; * language and country conventions multiple times.&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * NumberFormat nf = NumberFormat.getInstance();&#xA; * for (int i = 0; i &lt; a.length; ++i) {&#xA; *     output.println(nf.format(myNumber[i]) + &quot;; &quot;);&#xA; * }&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; * To format a number for a different Locale, specify it in the&#xA; * call to &lt;code>getInstance&lt;/code>.&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; * You can also use a &lt;code>NumberFormat&lt;/code> to parse numbers:&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * myNumber = nf.parse(myString);&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; * Use &lt;code>getInstance&lt;/code> or &lt;code>getNumberInstance&lt;/code> to get the&#xA; * normal number format. Use &lt;code>getIntegerInstance&lt;/code> to get an&#xA; * integer number format. Use &lt;code>getCurrencyInstance&lt;/code> to get the&#xA; * currency number format. And use &lt;code>getPercentInstance&lt;/code> to get a&#xA; * format for displaying percentages. With this format, a fraction like&#xA; * 0.53 is displayed as 53%.&#xA; *&#xA; * &lt;p>&#xA; * You can also control the display of numbers with such methods as&#xA; * &lt;code>setMinimumFractionDigits&lt;/code>.&#xA; * If you want even more control over the format or parsing,&#xA; * or want to give your users more control,&#xA; * you can try casting the &lt;code>NumberFormat&lt;/code> you get from the factory methods&#xA; * to a &lt;code>DecimalFormat&lt;/code>. This will work for the vast majority&#xA; * of locales; just remember to put it in a &lt;code>try&lt;/code> block in case you&#xA; * encounter an unusual one.&#xA; *&#xA; * &lt;p>&#xA; * NumberFormat and DecimalFormat are designed such that some controls&#xA; * work for formatting and others work for parsing.  The following is&#xA; * the detailed description for each these control methods,&#xA; * &lt;p>&#xA; * setParseIntegerOnly : only affects parsing, e.g.&#xA; * if true,  &quot;3456.78&quot; -> 3456 (and leaves the parse position just after index 6)&#xA; * if false, &quot;3456.78&quot; -> 3456.78 (and leaves the parse position just after index 8)&#xA; * This is independent of formatting.  If you want to not show a decimal point&#xA; * where there might be no digits after the decimal point, use&#xA; * setDecimalSeparatorAlwaysShown.&#xA; * &lt;p>&#xA; * setDecimalSeparatorAlwaysShown : only affects formatting, and only where&#xA; * there might be no digits after the decimal point, such as with a pattern&#xA; * like &quot;#,##0.##&quot;, e.g.,&#xA; * if true,  3456.00 -> &quot;3,456.&quot;&#xA; * if false, 3456.00 -> &quot;3456&quot;&#xA; * This is independent of parsing.  If you want parsing to stop at the decimal&#xA; * point, use setParseIntegerOnly.&#xA; *&#xA; * &lt;p>&#xA; * You can also use forms of the &lt;code>parse&lt;/code> and &lt;code>format&lt;/code>&#xA; * methods with &lt;code>ParsePosition&lt;/code> and &lt;code>FieldPosition&lt;/code> to&#xA; * allow you to:&#xA; * &lt;ul>&#xA; * &lt;li> progressively parse through pieces of a string&#xA; * &lt;li> align the decimal point and other areas&#xA; * &lt;/ul>&#xA; * For example, you can align numbers in two ways:&#xA; * &lt;ol>&#xA; * &lt;li> If you are using a monospaced font with spacing for alignment,&#xA; *      you can pass the &lt;code>FieldPosition&lt;/code> in your format call, with&#xA; *      &lt;code>field&lt;/code> = &lt;code>INTEGER_FIELD&lt;/code>. On output,&#xA; *      &lt;code>getEndIndex&lt;/code> will be set to the offset between the&#xA; *      last character of the integer and the decimal. Add&#xA; *      (desiredSpaceCount - getEndIndex) spaces at the front of the string.&#xA; *&#xA; * &lt;li> If you are using proportional fonts,&#xA; *      instead of padding with spaces, measure the width&#xA; *      of the string in pixels from the start to &lt;code>getEndIndex&lt;/code>.&#xA; *      Then move the pen by&#xA; *      (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.&#xA; *      It also works where there is no decimal, but possibly additional&#xA; *      characters at the end, e.g., with parentheses in negative&#xA; *      numbers: &quot;(12)&quot; for -12.&#xA; * &lt;/ol>&#xA; *&#xA; * &lt;h4>&lt;a name=&quot;synchronization&quot;>Synchronization&lt;/a>&lt;/h4>&#xA; *&#xA; * &lt;p>&#xA; * Number formats are generally not synchronized.&#xA; * It is recommended to create separate format instances for each thread.&#xA; * If multiple threads access a format concurrently, it must be synchronized&#xA; * externally.&#xA; *&#xA; * @see          DecimalFormat&#xA; * @see          ChoiceFormat&#xA; * @version      1.65, 05/10/04&#xA; * @author       Mark Davis&#xA; * @author       Helena Shih&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="Format.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
