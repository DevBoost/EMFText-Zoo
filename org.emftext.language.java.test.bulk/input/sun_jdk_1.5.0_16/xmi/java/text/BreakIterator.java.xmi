<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="BreakIterator.java">
  <comments>/*&#xA; * @(#)BreakIterator.java&#x9;1.35 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/*&#xA; * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved&#xA; * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved&#xA; *&#xA; * The original version of this source code and documentation&#xA; * is copyrighted and owned by Taligent, Inc., a wholly-owned&#xA; * subsidiary of IBM. These materials are provided under terms&#xA; * of a License Agreement between Taligent and Sun. This technology&#xA; * is protected by multiple US and International patents.&#xA; *&#xA; * This notice and attribution to Taligent may not be removed.&#xA; * Taligent is a registered trademark of Taligent, Inc.&#xA; *&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>text</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Vector.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/ResourceBundle.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/MissingResourceException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>text</namespaces>
    <namespaces>resources</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>text</namespaces>
    <classifier xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>text</namespaces>
    <classifier xsi:type="classifiers:Class" href="StringCharacterIterator.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>net</namespaces>
    <classifier xsi:type="classifiers:Class" href="../net/URL.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/InputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <namespaces>ref</namespaces>
    <classifier xsi:type="classifiers:Class" href="../lang/ref/SoftReference.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../security/AccessController.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../security/PrivilegedAction.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="BreakIterator">
    <members xsi:type="members:Constructor" name="BreakIterator">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Constructor. BreakIterator is stateless and has no default behavior.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a copy of this iterator&#xA;     * @return A copy of this&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.5"/>
            </next>
            <self xsi:type="literals:Super"/>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/InternalError.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/CloneNotSupportedException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:Field" name="DONE">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * DONE is returned by previous() and next() after all valid&#xA;     * boundaries have been returned.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="first">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return the first boundary. The iterator's current position is set&#xA;     * to the first boundary.&#xA;     * @return The character index of the first text boundary.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="last">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return the last boundary. The iterator's current position is set&#xA;     * to the last boundary.&#xA;     * @return The character index of the last text boundary.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="next">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return the nth boundary from the current boundary&#xA;     * @param n which boundary to return.  A value of 0&#xA;     * does nothing.  Negative values move to previous boundaries&#xA;     * and positive values move to later boundaries.&#xA;     * @return The index of the nth boundary from the current position.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="next">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return the boundary following the current boundary.&#xA;     * @return The character index of the next text boundary or DONE if all&#xA;     * boundaries have been returned.  Equivalent to next(1).&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="previous">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return the boundary preceding the current boundary.&#xA;     * @return The character index of the previous text boundary or DONE if all&#xA;     * boundaries have been returned.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="following">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return the first boundary following the specified offset.&#xA;     * The value returned is always greater than the offset or&#xA;     * the value BreakIterator.DONE&#xA;     * @param offset the offset to begin scanning. Valid values&#xA;     * are determined by the CharacterIterator passed to&#xA;     * setText().  Invalid values cause&#xA;     * an IllegalArgumentException to be thrown.&#xA;     * @return The first boundary after the specified offset.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="preceding">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return the last boundary preceding the specfied offset.&#xA;     * The value returned is always less than the offset or the value&#xA;     * BreakIterator.DONE.&#xA;     * @param offset the offset to begin scanning.  Valid values are&#xA;     * determined by the CharacterIterator passed to setText().&#xA;     * Invalid values cause an IllegalArgumentException to be thrown.&#xA;     * @return The last boundary before the specified offset.&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="pos">
          <typeReference xsi:type="types:Int">
            <comments>// NOTE:  This implementation is here solely because we can't add new</comments>
            <comments>// abstract methods to an existing class.  There is almost ALWAYS a</comments>
            <comments>// better, faster way to do this.</comments>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.8">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.7"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isBoundary">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return true if the specified position is a boundary position.&#xA;     * @param offset the offset to check.&#xA;     * @return True if &quot;offset&quot; is a boundary position.&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// NOTE: This implementation probably is wrong for most situations</comments>
        <comments>// because it fails to take into account the possibility that a</comments>
        <comments>// CharacterIterator passed to setText() may not have a begin offset</comments>
        <comments>// of 0.  But since the abstract BreakIterator doesn't have that</comments>
        <comments>// knowledge, it assumes the begin offset is 0.  If you subclass</comments>
        <comments>// BreakIterator, copy the SimpleTextBoundary implementation of this</comments>
        <comments>// function into your subclass.  [This should have been abstract at</comments>
        <comments>// this level, but it's too late to fix that now.]</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
        <elseStatement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.8">
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </arguments>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          </returnValue>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="current">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return character index of the text boundary that was most recently&#xA;     * returned by next(), previous(), first(), or last()&#xA;     * @return The boundary most recently returned.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getText">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Get the text being scanned&#xA;     * @return the text being scanned&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="setText">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newText">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set a new text string to be scanned.  The current scan&#xA;     * position is reset to first().&#xA;     * @param newText new text to scan.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringCharacterIterator.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setText">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newText">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set a new text for scanning.  The current scan&#xA;     * position is reset to first().&#xA;     * @param newText new text to scan.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:Field" name="CHARACTER_INDEX">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="WORD_INDEX">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="LINE_INDEX">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SENTENCE_INDEX">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="iterCache">
      <initialValue xsi:type="arrays:ArrayInstantiationBySize">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/ref/SoftReference.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/ref/SoftReference.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getWordInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create BreakIterator for word-breaks using default locale.&#xA;     * Returns an instance of a BreakIterator implementing word breaks.&#xA;     * WordBreak  is usefull for word selection (ex. double click)&#xA;     * @return A BreakIterator for word-breaks&#xA;     * @see java.util.Locale#getDefault&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.21">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getWordInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="where">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create BreakIterator for word-breaks using specified locale.&#xA;     * Returns an instance of a BreakIterator implementing word breaks.&#xA;     * WordBreak is usefull for word selection (ex. double click)&#xA;     * @param where the local.  If a specific WordBreak is not&#xA;     * avaliable for the specified locale, a default WordBreak is returned.&#xA;     * @return A BreakIterator for word-breaks&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
          <arguments xsi:type="references:StringReference" value="WordData"/>
          <arguments xsi:type="references:StringReference" value="WordDictionary"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLineInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create BreakIterator for line-breaks using default locale.&#xA;     * Returns an instance of a BreakIterator implementing line breaks. Line&#xA;     * breaks are logically possible line breaks, actual line breaks are&#xA;     * usually determined based on display width.&#xA;     * LineBreak is useful for word wrapping text.&#xA;     * @return A BreakIterator for line-breaks&#xA;     * @see java.util.Locale#getDefault&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLineInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="where">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create BreakIterator for line-breaks using specified locale.&#xA;     * Returns an instance of a BreakIterator implementing line breaks. Line&#xA;     * breaks are logically possible line breaks, actual line breaks are&#xA;     * usually determined based on display width.&#xA;     * LineBreak is useful for word wrapping text.&#xA;     * @param where the local.  If a specific LineBreak is not&#xA;     * avaliable for the specified locale, a default LineBreak is returned.&#xA;     * @return A BreakIterator for line-breaks&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
          <arguments xsi:type="references:StringReference" value="LineData"/>
          <arguments xsi:type="references:StringReference" value="LineDictionary"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCharacterInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create BreakIterator for character-breaks using default locale&#xA;     * Returns an instance of a BreakIterator implementing character breaks.&#xA;     * Character breaks are boundaries of combining character sequences.&#xA;     * @return A BreakIterator for character-breaks&#xA;     * @see Locale#getDefault&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCharacterInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="where">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create BreakIterator for character-breaks using specified locale&#xA;     * Returns an instance of a BreakIterator implementing character breaks.&#xA;     * Character breaks are boundaries of combining character sequences.&#xA;     * @param where the local.  If a specific character break is not&#xA;     * avaliable for the specified local, a default character break is returned.&#xA;     * @return A BreakIterator for character-breaks&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15"/>
          <arguments xsi:type="references:StringReference" value="CharacterData"/>
          <arguments xsi:type="references:StringReference" value="CharacterDictionary"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSentenceInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create BreakIterator for sentence-breaks using default locale&#xA;     * Returns an instance of a BreakIterator implementing sentence breaks.&#xA;     * @return A BreakIterator for sentence-breaks&#xA;     * @see java.util.Locale#getDefault&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.27">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSentenceInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="where">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create BreakIterator for sentence-breaks using specified locale&#xA;     * Returns an instance of a BreakIterator implementing sentence breaks.&#xA;     * @param where the local.  If a specific SentenceBreak is not&#xA;     * avaliable for the specified local, a default SentenceBreak is returned.&#xA;     * @return A BreakIterator for sentence-breaks&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
          <arguments xsi:type="references:StringReference" value="SentenceData"/>
          <arguments xsi:type="references:StringReference" value="SentenceDictionary"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getBreakInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="where">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dictionaryName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="cache">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.32"/>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@members.32"/>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/ref/SoftReference.class.xmi#//@classifiers.0/@members.4"/>
                  </next>
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1"/>
                  </arraySelectors>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Return">
                    <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@statement/@statements.0/@variable">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.32/@members.4"/>
                    </returnValue>
                  </statements>
                </statement>
                <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@statement/@statements.0/@variable">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.32/@members.3">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.56"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
                    </next>
                  </next>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1"/>
            </arraySelectors>
          </children>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.30">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.3"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cache">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.32"/>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.32"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/ref/SoftReference.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.2/@variable"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getBundle">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/ResourceBundle.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="baseName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="locale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../util/ResourceBundle.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../security/AccessController.class.xmi#//@classifiers.0/@members.1"/>
              <arguments xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="../security/PrivilegedAction.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <anonymousClass>
                  <members xsi:type="members:ClassMethod" name="run">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <annotationsAndModifiers xsi:type="modifiers:Public"/>
                    <statements xsi:type="statements:Return">
                      <returnValue xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../util/ResourceBundle.class.xmi#//@classifiers.0/@members.20"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.1"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="../util/ResourceBundle.class.xmi#//@classifiers.0"/>
                      </returnValue>
                    </statements>
                  </members>
                </anonymousClass>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../security/AccessController.class.xmi#//@classifiers.0"/>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createBreakInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="where">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dictionaryName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bundle">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../util/ResourceBundle.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.29">
            <arguments xsi:type="references:StringReference" value="sun.text.resources.BreakIteratorInfo"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="classNames">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/ResourceBundle.class.xmi#//@classifiers.0/@members.12"/>
              <arguments xsi:type="references:StringReference" value="BreakIteratorClasses"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="dataFile">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/ResourceBundle.class.xmi#//@classifiers.0/@members.11"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.2"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="RuleBasedBreakIterator.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.2/@variable"/>
              </returnValue>
            </statements>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:StringReference" value="RuleBasedBreakIterator"/>
            </next>
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.1"/>
            </arraySelectors>
          </condition>
          <elseStatement xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="dictionaryFile">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../util/ResourceBundle.class.xmi#//@classifiers.0/@members.11"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.3"/>
                    </next>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="DictionaryBasedBreakIterator.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.2/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.3/@statements.0/@elseStatement/@statement/@statements.0/@variable"/>
                </returnValue>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:StringReference" value="DictionaryBasedBreakIterator"/>
              </next>
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.1"/>
              </arraySelectors>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value="Invalid break iterator class &quot;"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.1/@variable">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.1"/>
                      </arraySelectors>
                    </children>
                    <children xsi:type="references:StringReference" value="&quot;"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </throwable>
              </statements>
            </elseStatement>
          </elseStatement>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/InternalError.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.3/@catcheBlocks.0/@parameter">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Throwable.class.xmi#//@classifiers.0/@members.13"/>
                </next>
              </arguments>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Exception.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAvailableLocales">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an array of all locales for which the&#xA;     * &lt;code>get*Instance&lt;/code> methods of this class can return&#xA;     * localized instances.&#xA;     * The array returned must contain at least a &lt;code>Locale&lt;/code>&#xA;     * instance equal to {@link java.util.Locale#US Locale.US}.&#xA;     *&#xA;     * @return An array of locales for which localized&#xA;     *         &lt;code>BreakIterator&lt;/code> instances are available.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Return">
        <comments>//FIX ME - this is a known bug.  It should return</comments>
        <comments>//all locales.</comments>
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0/@members.7"/>
            <arguments xsi:type="references:StringReference" value="NumberPatterns"/>
          </next>
          <target xsi:type="classifiers:Class" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="classifiers:Class" name="BreakIteratorCache">
      <members xsi:type="members:Field" name="iter">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Field" name="where">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Constructor" name="BreakIteratorCache">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@members.1"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@members.2/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@members.0"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@members.2/@parameters.1">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
              </child>
            </value>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="where">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="iter">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </parameters>
      </members>
      <members xsi:type="members:ClassMethod" name="getLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@members.1"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="createBreakInstance">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@members.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
            </child>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getLong">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="num">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="expressions:AndExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.1"/>
              </arraySelectors>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:InclusiveOrExpression">
                <children xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                  <shiftOperators xsi:type="operators:LeftShift"/>
                </children>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AndExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0">
                      <arraySelectors>
                        <position xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.1"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.1/@init"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                        </position>
                      </arraySelectors>
                    </children>
                    <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
                  </expression>
                </children>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.1/@init"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.1/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="num">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AndExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.1"/>
              </arraySelectors>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:InclusiveOrExpression">
                <children xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                  <shiftOperators xsi:type="operators:LeftShift"/>
                </children>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AndExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
                      <arraySelectors>
                        <position xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.1"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@init"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                        </position>
                      </arraySelectors>
                    </children>
                    <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
                  </expression>
                </children>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@init"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getShort">
      <typeReference xsi:type="types:Short"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="num">
          <typeReference xsi:type="types:Short"/>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Short"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
                  </arraySelectors>
                </children>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
              </expression>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.0/@variable"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Short"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:InclusiveOrExpression">
                <children xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                  <shiftOperators xsi:type="operators:LeftShift"/>
                </children>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AndExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0">
                      <arraySelectors>
                        <position xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
                          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                        </position>
                      </arraySelectors>
                    </children>
                    <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
                  </expression>
                </children>
              </expression>
            </child>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.0/@variable"/>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>BreakIterator&lt;/code> class implements methods for finding&#xA; * the location of boundaries in text. Instances of &lt;code>BreakIterator&lt;/code>&#xA; * maintain a current position and scan over text&#xA; * returning the index of characters where boundaries occur.&#xA; * Internally, &lt;code>BreakIterator&lt;/code> scans text using a&#xA; * &lt;code>CharacterIterator&lt;/code>, and is thus able to scan text held&#xA; * by any object implementing that protocol. A &lt;code>StringCharacterIterator&lt;/code>&#xA; * is used to scan &lt;code>String&lt;/code> objects passed to &lt;code>setText&lt;/code>.&#xA; *&#xA; * &lt;p>&#xA; * You use the factory methods provided by this class to create&#xA; * instances of various types of break iterators. In particular,&#xA; * use &lt;code>getWordIterator&lt;/code>, &lt;code>getLineIterator&lt;/code>,&#xA; * &lt;code>getSentenceIterator&lt;/code>, and &lt;code>getCharacterIterator&lt;/code>&#xA; * to create &lt;code>BreakIterator&lt;/code>s that perform&#xA; * word, line, sentence, and character boundary analysis respectively.&#xA; * A single &lt;code>BreakIterator&lt;/code> can work only on one unit&#xA; * (word, line, sentence, and so on). You must use a different iterator&#xA; * for each unit boundary analysis you wish to perform.&#xA; *&#xA; * &lt;p>&#xA; * Line boundary analysis determines where a text string can be&#xA; * broken when line-wrapping. The mechanism correctly handles&#xA; * punctuation and hyphenated words.&#xA; *&#xA; * &lt;p>&#xA; * Sentence boundary analysis allows selection with correct interpretation&#xA; * of periods within numbers and abbreviations, and trailing punctuation&#xA; * marks such as quotation marks and parentheses.&#xA; *&#xA; * &lt;p>&#xA; * Word boundary analysis is used by search and replace functions, as&#xA; * well as within text editing applications that allow the user to&#xA; * select words with a double click. Word selection provides correct&#xA; * interpretation of punctuation marks within and following&#xA; * words. Characters that are not part of a word, such as symbols&#xA; * or punctuation marks, have word-breaks on both sides.&#xA; *&#xA; * &lt;p>&#xA; * Character boundary analysis allows users to interact with characters&#xA; * as they expect to, for example, when moving the cursor through a text&#xA; * string. Character boundary analysis provides correct navigation of&#xA; * through character strings, regardless of how the character is stored.&#xA; * For example, an accented character might be stored as a base character&#xA; * and a diacritical mark. What users consider to be a character can&#xA; * differ between languages.&#xA; *&#xA; * &lt;p>&#xA; * &lt;code>BreakIterator&lt;/code> is intended for use with natural&#xA; * languages only. Do not use this class to tokenize a programming language.&#xA; *&#xA; * &lt;P>&#xA; * &lt;strong>Examples&lt;/strong>:&lt;P>&#xA; * Creating and using text boundaries&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * public static void main(String args[]) {&#xA; *      if (args.length == 1) {&#xA; *          String stringToExamine = args[0];&#xA; *          //print each word in order&#xA; *          BreakIterator boundary = BreakIterator.getWordInstance();&#xA; *          boundary.setText(stringToExamine);&#xA; *          printEachForward(boundary, stringToExamine);&#xA; *          //print each sentence in reverse order&#xA; *          boundary = BreakIterator.getSentenceInstance(Locale.US);&#xA; *          boundary.setText(stringToExamine);&#xA; *          printEachBackward(boundary, stringToExamine);&#xA; *          printFirst(boundary, stringToExamine);&#xA; *          printLast(boundary, stringToExamine);&#xA; *      }&#xA; * }&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * Print each element in order&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * public static void printEachForward(BreakIterator boundary, String source) {&#xA; *     int start = boundary.first();&#xA; *     for (int end = boundary.next();&#xA; *          end != BreakIterator.DONE;&#xA; *          start = end, end = boundary.next()) {&#xA; *          System.out.println(source.substring(start,end));&#xA; *     }&#xA; * }&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * Print each element in reverse order&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * public static void printEachBackward(BreakIterator boundary, String source) {&#xA; *     int end = boundary.last();&#xA; *     for (int start = boundary.previous();&#xA; *          start != BreakIterator.DONE;&#xA; *          end = start, start = boundary.previous()) {&#xA; *         System.out.println(source.substring(start,end));&#xA; *     }&#xA; * }&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * Print first element&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * public static void printFirst(BreakIterator boundary, String source) {&#xA; *     int start = boundary.first();&#xA; *     int end = boundary.next();&#xA; *     System.out.println(source.substring(start,end));&#xA; * }&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * Print last element&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * public static void printLast(BreakIterator boundary, String source) {&#xA; *     int end = boundary.last();&#xA; *     int start = boundary.previous();&#xA; *     System.out.println(source.substring(start,end));&#xA; * }&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * Print the element at a specified position&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * public static void printAt(BreakIterator boundary, int pos, String source) {&#xA; *     int end = boundary.following(pos);&#xA; *     int start = boundary.previous();&#xA; *     System.out.println(source.substring(start,end));&#xA; * }&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * Find the next word&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * public static int nextWordStartAfter(int pos, String text) {&#xA; *     BreakIterator wb = BreakIterator.getWordInstance();&#xA; *     wb.setText(text);&#xA; *     int last = wb.following(pos);&#xA; *     int current = wb.next();&#xA; *     while (current != BreakIterator.DONE) {&#xA; *         for (int p = last; p &lt; current; p++) {&#xA; *             if (Character.isLetter(text.codePointAt(p))&#xA; *                 return last;&#xA; *         }&#xA; *         last = current;&#xA; *         current = wb.next();&#xA; *     }&#xA; *     return BreakIterator.DONE;&#xA; * }&#xA; * &lt;/pre>&#xA; * (The iterator returned by BreakIterator.getWordInstance() is unique in that&#xA; * the break positions it returns don't represent both the start and end of the&#xA; * thing being iterated over.  That is, a sentence-break iterator returns breaks&#xA; * that each represent the end of one sentence and the beginning of the next.&#xA; * With the word-break iterator, the characters between two boundaries might be a&#xA; * word, or they might be the punctuation or whitespace between two words.  The&#xA; * above code uses a simple heuristic to determine which boundary is the beginning&#xA; * of a word: If the characters between this boundary and the next boundary&#xA; * include at least one letter (this can be an alphabetical letter, a CJK ideograph,&#xA; * a Hangul syllable, a Kana character, etc.), then the text between this boundary&#xA; * and the next is a word; otherwise, it's the material between words.)&#xA; * &lt;/blockquote>&#xA; *&#xA; * @see CharacterIterator&#xA; *&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../lang/Cloneable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
