<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="Collator.java">
  <comments>/*&#xA; * @(#)Collator.java&#x9;1.39 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/*&#xA; * (C) Copyright Taligent, Inc. 1996-1998 -  All Rights Reserved&#xA; * (C) Copyright IBM Corp. 1996-1998 - All Rights Reserved&#xA; *&#xA; *   The original version of this source code and documentation is copyrighted&#xA; * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These&#xA; * materials are provided under terms of a License Agreement between Taligent&#xA; * and Sun. This technology is protected by multiple US and International&#xA; * patents. This notice and attribution to Taligent may not be removed.&#xA; *   Taligent is a registered trademark of Taligent, Inc.&#xA; *&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>text</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/MissingResourceException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/ResourceBundle.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>misc</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/misc/SoftCache.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>text</namespaces>
    <namespaces>resources</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Collator">
    <members xsi:type="members:Field" name="PRIMARY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Collator strength value.  When set, only PRIMARY differences are&#xA;     * considered significant during comparison. The assignment of strengths&#xA;     * to language features is locale dependant. A common example is for&#xA;     * different base letters (&quot;a&quot; vs &quot;b&quot;) to be considered a PRIMARY difference.&#xA;     * @see java.text.Collator#setStrength&#xA;     * @see java.text.Collator#getStrength&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="SECONDARY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Collator strength value.  When set, only SECONDARY and above differences are&#xA;     * considered significant during comparison. The assignment of strengths&#xA;     * to language features is locale dependant. A common example is for&#xA;     * different accented forms of the same base letter (&quot;a&quot; vs &quot;\u00E4&quot;) to be&#xA;     * considered a SECONDARY difference.&#xA;     * @see java.text.Collator#setStrength&#xA;     * @see java.text.Collator#getStrength&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="TERTIARY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Collator strength value.  When set, only TERTIARY and above differences are&#xA;     * considered significant during comparison. The assignment of strengths&#xA;     * to language features is locale dependant. A common example is for&#xA;     * case differences (&quot;a&quot; vs &quot;A&quot;) to be considered a TERTIARY difference.&#xA;     * @see java.text.Collator#setStrength&#xA;     * @see java.text.Collator#getStrength&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="IDENTICAL">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Collator strength value.  When set, all differences are&#xA;     * considered significant during comparison. The assignment of strengths&#xA;     * to language features is locale dependant. A common example is for control&#xA;     * characters (&quot;&amp;#092;u0001&quot; vs &quot;&amp;#092;u0002&quot;) to be considered equal at the&#xA;     * PRIMARY, SECONDARY, and TERTIARY levels but different at the IDENTICAL&#xA;     * level.  Additionally, differences between pre-composed accents such as&#xA;     * &quot;&amp;#092;u00C0&quot; (A-grave) and combining accents such as &quot;A&amp;#092;u0300&quot;&#xA;     * (A, combining-grave) will be considered significant at the IDENTICAL&#xA;     * level if decomposition is set to NO_DECOMPOSITION.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="NO_DECOMPOSITION">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Decomposition mode value. With NO_DECOMPOSITION&#xA;     * set, accented characters will not be decomposed for collation. This&#xA;     * is the default setting and provides the fastest collation but &#xA;     * will only produce correct results for languages that do not use accents.&#xA;     * @see java.text.Collator#getDecomposition&#xA;     * @see java.text.Collator#setDecomposition&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="CANONICAL_DECOMPOSITION">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Decomposition mode value. With CANONICAL_DECOMPOSITION&#xA;     * set, characters that are canonical variants according to Unicode &#xA;     * standard will be decomposed for collation. This should be used to get &#xA;     * correct collation of accented characters.&#xA;     * &lt;p>&#xA;     * CANONICAL_DECOMPOSITION corresponds to Normalization Form D as&#xA;     * described in &#xA;     * &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr15/&quot;>Unicode &#xA;     * Technical Report #15&lt;/a>.&#xA;     * @see java.text.Collator#getDecomposition&#xA;     * @see java.text.Collator#setDecomposition&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="FULL_DECOMPOSITION">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Decomposition mode value. With FULL_DECOMPOSITION&#xA;     * set, both Unicode canonical variants and Unicode compatibility variants&#xA;     * will be decomposed for collation.  This causes not only accented&#xA;     * characters to be collated, but also characters that have special formats&#xA;     * to be collated with their norminal form. For example, the half-width and&#xA;     * full-width ASCII and Katakana characters are then collated together.&#xA;     * FULL_DECOMPOSITION is the most complete and therefore the slowest&#xA;     * decomposition mode.&#xA;     * &lt;p>&#xA;     * FULL_DECOMPOSITION corresponds to Normalization Form KD as&#xA;     * described in &#xA;     * &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr15/&quot;>Unicode &#xA;     * Technical Report #15&lt;/a>.&#xA;     * @see java.text.Collator#getDecomposition&#xA;     * @see java.text.Collator#setDecomposition&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the Collator for the current default locale.&#xA;     * The default locale is determined by java.util.Locale.getDefault.&#xA;     * @return the Collator for the default locale.(for example, en_US)&#xA;     * @see java.util.Locale#getDefault&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.8">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="desiredLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the Collator for the desired locale.&#xA;     * @param desiredLocale the desired locale.&#xA;     * @return the Collator for the desired locale.&#xA;     * @see java.util.Locale&#xA;     * @see java.util.ResourceBundle&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="RuleBasedCollator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="RuleBasedCollator.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/misc/SoftCache.class.xmi#//@classifiers.0/@members.11"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
              </next>
            </child>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <comments>// make the world safe</comments>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="RuleBasedCollator.class.xmi#//@classifiers.0/@members.19"/>
                </next>
              </child>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="colString">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Load the resource of the desired locale from resource</comments>
              <comments>// manager.</comments>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:StringReference" value=""/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="decomp">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="resource">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../util/ResourceBundle.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0/@members.8"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.3/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.5/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/ResourceBundle.class.xmi#//@classifiers.0/@members.11"/>
                <arguments xsi:type="references:StringReference" value="CollationElements"/>
              </next>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.4/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:NestedExpression">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Integer.class.xmi#//@classifiers.0/@members.27"/>
              </next>
              <expression xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.5/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../util/ResourceBundle.class.xmi#//@classifiers.0/@members.13"/>
                    <arguments xsi:type="references:StringReference" value="CollationDecomp"/>
                  </next>
                </child>
              </expression>
            </value>
          </expression>
        </statements>
        <catcheBlocks>
          <comments>// Use default values</comments>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../util/MissingResourceException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="RuleBasedCollator.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="CollationRules.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="CollationRules.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.3/@variable"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.4/@variable"/>
            </value>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:TryBlock">
            <comments>// predefined tables should contain correct grammar</comments>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="RuleBasedCollator.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="CollationRules.class.xmi#//@classifiers.0/@members.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CollationRules.class.xmi#//@classifiers.0"/>
                  </arguments>
                </value>
              </expression>
            </statements>
            <catcheBlocks>
              <comments>// do nothing</comments>
              <parameter name="bar">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="ParseException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </parameter>
            </catcheBlocks>
          </statements>
          <parameter name="foo">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="ParseException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable">
          <comments>// Now that RuleBasedCollator adds expansions for pre-composed characters</comments>
          <comments>// into their decomposed equivalents, the default collators don't need</comments>
          <comments>// to have decomposition turned on.  Laura, 5/5/98, bug 4114077</comments>
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../sun/misc/SoftCache.class.xmi#//@classifiers.0/@members.12"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="RuleBasedCollator.class.xmi#//@classifiers.0/@members.19"/>
            </next>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="compare">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="target">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares the source string to the target string according to the&#xA;     * collation rules for this Collator.  Returns an integer less than,&#xA;     * equal to or greater than zero depending on whether the source String is&#xA;     * less than, equal to or greater than the target string.  See the Collator&#xA;     * class description for an example of use.&#xA;     * &lt;p>&#xA;     * For a one time comparison, this method has the best performance. If a&#xA;     * given String will be involved in multiple comparisons, CollationKey.compareTo&#xA;     * has the best performance. See the Collator class description for an example&#xA;     * using CollationKeys.&#xA;     * @param source the source string.&#xA;     * @param target the target string.&#xA;     * @return Returns an integer value. Value is less than zero if source is less than&#xA;     * target, value is zero if source and target are equal, value is greater than zero&#xA;     * if source is greater than target.&#xA;     * @see java.text.CollationKey&#xA;     * @see java.text.Collator#getCollationKey&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="compare">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o1">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o2">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares its two arguments for order.  Returns a negative integer,&#xA;     * zero, or a positive integer as the first argument is less than, equal&#xA;     * to, or greater than the second.&#xA;     * &lt;p>&#xA;     * This implementation merely returns&#xA;     *  &lt;code> compare((String)o1, (String)o2) &lt;/code>.&#xA;     * &#xA;     * @return a negative integer, zero, or a positive integer as the&#xA;     *         first argument is less than, equal to, or greater than the&#xA;     *         second. &#xA;     * @exception ClassCastException the arguments cannot be cast to Strings.&#xA;     * @see java.util.Comparator&#xA;     * @since   1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.9">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          </arguments>
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCollationKey">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CollationKey.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Transforms the String into a series of bits that can be compared bitwise&#xA;     * to other CollationKeys. CollationKeys provide better performance than&#xA;     * Collator.compare when Strings are involved in multiple comparisons.&#xA;     * See the Collator class description for an example using CollationKeys.&#xA;     * @param source the string to be transformed into a collation key.&#xA;     * @return the CollationKey for the given String based on this Collator's collation&#xA;     * rules. If the source String is null, a null CollationKey is returned.&#xA;     * @see java.text.CollationKey&#xA;     * @see java.text.Collator#compare&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="target">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Convenience method for comparing the equality of two strings based on&#xA;     * this Collator's collation rules.&#xA;     * @param source the source string to be compared with.&#xA;     * @param target the target string to be compared with.&#xA;     * @return true if the strings are equal according to the collation&#xA;     * rules.  false, otherwise.&#xA;     * @see java.text.Collator#compare&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.9">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26"/>
            </children>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getStrength">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns this Collator's strength property.  The strength property determines&#xA;     * the minimum level of difference considered significant during comparison.&#xA;     * See the Collator class description for an example of use.&#xA;     * @return this Collator's current strength property.&#xA;     * @see java.text.Collator#setStrength&#xA;     * @see java.text.Collator#PRIMARY&#xA;     * @see java.text.Collator#SECONDARY&#xA;     * @see java.text.Collator#TERTIARY&#xA;     * @see java.text.Collator#IDENTICAL&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setStrength">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newStrength">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets this Collator's strength property.  The strength property determines&#xA;     * the minimum level of difference considered significant during comparison.&#xA;     * See the Collator class description for an example of use.&#xA;     * @param newStrength  the new strength value.&#xA;     * @see java.text.Collator#getStrength&#xA;     * @see java.text.Collator#PRIMARY&#xA;     * @see java.text.Collator#SECONDARY&#xA;     * @see java.text.Collator#TERTIARY&#xA;     * @see java.text.Collator#IDENTICAL&#xA;     * @exception  IllegalArgumentException If the new strength value is not one of&#xA;     * PRIMARY, SECONDARY, TERTIARY or IDENTICAL.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Incorrect comparison level."/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDecomposition">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Get the decomposition mode of this Collator. Decomposition mode&#xA;     * determines how Unicode composed characters are handled. Adjusting&#xA;     * decomposition mode allows the user to select between faster and more&#xA;     * complete collation behavior.&#xA;     * &lt;p>The three values for decomposition mode are:&#xA;     * &lt;UL>&#xA;     * &lt;LI>NO_DECOMPOSITION,&#xA;     * &lt;LI>CANONICAL_DECOMPOSITION&#xA;     * &lt;LI>FULL_DECOMPOSITION.&#xA;     * &lt;/UL>&#xA;     * See the documentation for these three constants for a description&#xA;     * of their meaning.&#xA;     * @return the decomposition mode&#xA;     * @see java.text.Collator#setDecomposition&#xA;     * @see java.text.Collator#NO_DECOMPOSITION&#xA;     * @see java.text.Collator#CANONICAL_DECOMPOSITION&#xA;     * @see java.text.Collator#FULL_DECOMPOSITION&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setDecomposition">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="decompositionMode">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set the decomposition mode of this Collator. See getDecomposition&#xA;     * for a description of decomposition mode.&#xA;     * @param decompositionMode  the new decomposition mode.&#xA;     * @see java.text.Collator#getDecomposition&#xA;     * @see java.text.Collator#NO_DECOMPOSITION&#xA;     * @see java.text.Collator#CANONICAL_DECOMPOSITION&#xA;     * @see java.text.Collator#FULL_DECOMPOSITION&#xA;     * @exception IllegalArgumentException If the given value is not a valid decomposition&#xA;     * mode.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Wrong decomposition mode."/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAvailableLocales">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an array of all locales for which the&#xA;     * &lt;code>getInstance&lt;/code> methods of this class can return&#xA;     * localized instances.&#xA;     * The array returned must contain at least a &lt;code>Locale&lt;/code>&#xA;     * instance equal to {@link java.util.Locale#US Locale.US}.&#xA;     *&#xA;     * @return An array of locales for which localized&#xA;     *         &lt;code>Collator&lt;/code> instances are available.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0/@members.7"/>
            <arguments xsi:type="references:StringReference" value="CollationElements"/>
          </next>
          <target xsi:type="classifiers:Class" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Overrides Cloneable&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.5"/>
              </next>
              <self xsi:type="literals:Super"/>
            </child>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/InternalError.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/CloneNotSupportedException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="that">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares the equality of two Collators.&#xA;     * @param that the Collator to be compared with this.&#xA;     * @return true if this Collator is the same as that Collator;&#xA;     * false otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="other">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22"/>
                </children>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23"/>
                </children>
              </expression>
            </children>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Generates the hash code for this Collator.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:Constructor" name="Collator">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Default constructor.  This constructor is&#xA;     * protected so subclasses can get access to it. Users typically create&#xA;     * a Collator sub-class by calling the factory method getInstance.&#xA;     * @see java.text.Collator#getInstance&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="strength">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="decmp">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="cache">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../sun/misc/SoftCache.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../sun/misc/SoftCache.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="LESS">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>//</comments>
        <comments>// FIXME: These three constants should be removed.</comments>
        <comments>//</comments>
        <comments>/**&#xA;     * LESS is returned if source string is compared to be less than target&#xA;     * string in the compare() method.&#xA;     * @see java.text.Collator#compare&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="EQUAL">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * EQUAL is returned if source string is compared to be equal to target&#xA;     * string in the compare() method.&#xA;     * @see java.text.Collator#compare&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="GREATER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * GREATER is returned if source string is compared to be greater than&#xA;     * target string in the compare() method.&#xA;     * @see java.text.Collator#compare&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>Collator&lt;/code> class performs locale-sensitive&#xA; * &lt;code>String&lt;/code> comparison. You use this class to build&#xA; * searching and sorting routines for natural language text.&#xA; *&#xA; * &lt;p>&#xA; * &lt;code>Collator&lt;/code> is an abstract base class. Subclasses&#xA; * implement specific collation strategies. One subclass,&#xA; * &lt;code>RuleBasedCollator&lt;/code>, is currently provided with&#xA; * the Java 2 platform and is applicable to a wide set of languages. Other&#xA; * subclasses may be created to handle more specialized needs.&#xA; *&#xA; * &lt;p>&#xA; * Like other locale-sensitive classes, you can use the static&#xA; * factory method, &lt;code>getInstance&lt;/code>, to obtain the appropriate&#xA; * &lt;code>Collator&lt;/code> object for a given locale. You will only need&#xA; * to look at the subclasses of &lt;code>Collator&lt;/code> if you need&#xA; * to understand the details of a particular collation strategy or&#xA; * if you need to modify that strategy.&#xA; *&#xA; * &lt;p>&#xA; * The following example shows how to compare two strings using&#xA; * the &lt;code>Collator&lt;/code> for the default locale.&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * // Compare two strings in the default locale&#xA; * Collator myCollator = Collator.getInstance();&#xA; * if( myCollator.compare(&quot;abc&quot;, &quot;ABC&quot;) &lt; 0 )&#xA; *     System.out.println(&quot;abc is less than ABC&quot;);&#xA; * else&#xA; *     System.out.println(&quot;abc is greater than or equal to ABC&quot;);&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p>&#xA; * You can set a &lt;code>Collator&lt;/code>'s &lt;em>strength&lt;/em> property&#xA; * to determine the level of difference considered significant in&#xA; * comparisons. Four strengths are provided: &lt;code>PRIMARY&lt;/code>,&#xA; * &lt;code>SECONDARY&lt;/code>, &lt;code>TERTIARY&lt;/code>, and &lt;code>IDENTICAL&lt;/code>.&#xA; * The exact assignment of strengths to language features is&#xA; * locale dependant.  For example, in Czech, &quot;e&quot; and &quot;f&quot; are considered&#xA; * primary differences, while &quot;e&quot; and &quot;\u00EA&quot; are secondary differences,&#xA; * &quot;e&quot; and &quot;E&quot; are tertiary differences and &quot;e&quot; and &quot;e&quot; are identical.&#xA; * The following shows how both case and accents could be ignored for&#xA; * US English.&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * //Get the Collator for US English and set its strength to PRIMARY&#xA; * Collator usCollator = Collator.getInstance(Locale.US);&#xA; * usCollator.setStrength(Collator.PRIMARY);&#xA; * if( usCollator.compare(&quot;abc&quot;, &quot;ABC&quot;) == 0 ) {&#xA; *     System.out.println(&quot;Strings are equivalent&quot;);&#xA; * }&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; * &lt;p>&#xA; * For comparing &lt;code>String&lt;/code>s exactly once, the &lt;code>compare&lt;/code>&#xA; * method provides the best performance. When sorting a list of&#xA; * &lt;code>String&lt;/code>s however, it is generally necessary to compare each&#xA; * &lt;code>String&lt;/code> multiple times. In this case, &lt;code>CollationKey&lt;/code>s&#xA; * provide better performance. The &lt;code>CollationKey&lt;/code> class converts&#xA; * a &lt;code>String&lt;/code> to a series of bits that can be compared bitwise&#xA; * against other &lt;code>CollationKey&lt;/code>s. A &lt;code>CollationKey&lt;/code> is&#xA; * created by a &lt;code>Collator&lt;/code> object for a given &lt;code>String&lt;/code>.&#xA; * &lt;br>&#xA; * &lt;strong>Note:&lt;/strong> &lt;code>CollationKey&lt;/code>s from different&#xA; * &lt;code>Collator&lt;/code>s can not be compared. See the class description&#xA; * for {@link CollationKey}&#xA; * for an example using &lt;code>CollationKey&lt;/code>s.&#xA; *&#xA; * @see         RuleBasedCollator&#xA; * @see         CollationKey&#xA; * @see         CollationElementIterator&#xA; * @see         Locale&#xA; * @version     1.39, 05/05/04&#xA; * @author      Helena Shih, Laura Werner, Richard Gillam&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <namespaces>java</namespaces>
      <namespaces>util</namespaces>
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="../util/Comparator.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../lang/Cloneable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
