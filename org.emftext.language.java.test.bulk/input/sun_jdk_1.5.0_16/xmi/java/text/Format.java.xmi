<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="Format.java">
  <comments>/*&#xA; * @(#)Format.java&#x9;1.34 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/*&#xA; * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved&#xA; * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved&#xA; *&#xA; *   The original version of this source code and documentation is copyrighted&#xA; * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These&#xA; * materials are provided under terms of a License Agreement between Taligent&#xA; * and Sun. This technology is protected by multiple US and International&#xA; * patents. This notice and attribution to Taligent may not be removed.&#xA; *   Taligent is a registered trademark of Taligent, Inc.&#xA; *&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>text</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../io/Serializable.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Format">
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="299282585814624189"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Formats an object to produce a string. This is equivalent to&#xA;     * &lt;blockquote>&#xA;     * {@link #format(Object, StringBuffer, FieldPosition) format}&lt;code>(obj,&#xA;     *         new StringBuffer(), new FieldPosition(0)).toString();&lt;/code>&#xA;     * &lt;/blockquote>&#xA;     *&#xA;     * @param obj    The object to format&#xA;     * @return       Formatted string.&#xA;     * @exception IllegalArgumentException if the Format cannot format the given&#xA;     *            object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.2">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </arguments>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="FieldPosition.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toAppendTo">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="FieldPosition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Formats an object and appends the resulting text to a given string&#xA;     * buffer.&#xA;     * If the &lt;code>pos&lt;/code> argument identifies a field used by the format,&#xA;     * then its indices are set to the beginning and end of the first such&#xA;     * field encountered.&#xA;     *&#xA;     * @param obj    The object to format&#xA;     * @param toAppendTo    where the text is to be appended&#xA;     * @param pos    A &lt;code>FieldPosition&lt;/code> identifying a field&#xA;     *               in the formatted text&#xA;     * @return       the string buffer passed in as &lt;code>toAppendTo&lt;/code>,&#xA;     *               with formatted text appended&#xA;     * @exception NullPointerException if &lt;code>toAppendTo&lt;/code> or&#xA;     *            &lt;code>pos&lt;/code> is null&#xA;     * @exception IllegalArgumentException if the Format cannot format the given&#xA;     *            object&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="formatToCharacterIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="AttributedCharacterIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Formats an Object producing an &lt;code>AttributedCharacterIterator&lt;/code>.&#xA;     * You can use the returned &lt;code>AttributedCharacterIterator&lt;/code>&#xA;     * to build the resulting String, as well as to determine information&#xA;     * about the resulting String.&#xA;     * &lt;p>&#xA;     * Each attribute key of the AttributedCharacterIterator will be of type&#xA;     * &lt;code>Field&lt;/code>. It is up to each &lt;code>Format&lt;/code> implementation&#xA;     * to define what the legal values are for each attribute in the&#xA;     * &lt;code>AttributedCharacterIterator&lt;/code>, but typically the attribute&#xA;     * key is also used as the attribute value.&#xA;     * &lt;p>The default implementation creates an&#xA;     * &lt;code>AttributedCharacterIterator&lt;/code> with no attributes. Subclasses&#xA;     * that support fields should override this and create an&#xA;     * &lt;code>AttributedCharacterIterator&lt;/code> with meaningful attributes.&#xA;     *&#xA;     * @exception NullPointerException if obj is null.&#xA;     * @exception IllegalArgumentException when the Format cannot format the&#xA;     *            given object.&#xA;     * @param obj The object to format&#xA;     * @return AttributedCharacterIterator describing the formatted value.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.1">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="parseObject">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ParsePosition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Parses text from a string to produce an object.&#xA;     * &lt;p>&#xA;     * The method attempts to parse text starting at the index given by&#xA;     * &lt;code>pos&lt;/code>.&#xA;     * If parsing succeeds, then the index of &lt;code>pos&lt;/code> is updated&#xA;     * to the index after the last character used (parsing does not necessarily&#xA;     * use all characters up to the end of the string), and the parsed&#xA;     * object is returned. The updated &lt;code>pos&lt;/code> can be used to&#xA;     * indicate the starting point for the next call to this method.&#xA;     * If an error occurs, then the index of &lt;code>pos&lt;/code> is not&#xA;     * changed, the error index of &lt;code>pos&lt;/code> is set to the index of&#xA;     * the character where the error occurred, and null is returned.&#xA;     *&#xA;     * @param source A &lt;code>String&lt;/code>, part of which should be parsed.&#xA;     * @param pos A &lt;code>ParsePosition&lt;/code> object with index and error&#xA;     *            index information as described above.&#xA;     * @return An &lt;code>Object&lt;/code> parsed from the string. In case of&#xA;     *         error, returns null.&#xA;     * @exception NullPointerException if &lt;code>pos&lt;/code> is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="parseObject">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ParseException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Parses text from the beginning of the given string to produce an object.&#xA;     * The method may not use the entire text of the given string.&#xA;     *&#xA;     * @param source A &lt;code>String&lt;/code> whose beginning should be parsed.&#xA;     * @return An &lt;code>Object&lt;/code> parsed from the string.&#xA;     * @exception ParseException if the beginning of the specified string&#xA;     *            cannot be parsed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="pos">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="ParsePosition.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="ParsePosition.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.4">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@statements.0/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="ParseException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Format.parseObject(String) failed"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="ParsePosition.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="ParsePosition.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates and returns a copy of this object.&#xA;     *&#xA;     * @return a clone of this instance.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.5"/>
            </next>
            <self xsi:type="literals:Super"/>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Return">
            <comments>// will never happen</comments>
            <returnValue xsi:type="literals:NullLiteral"/>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/CloneNotSupportedException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createAttributedCharacterIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>//</comments>
          <comments>// Convenience methods for creating AttributedCharacterIterators from</comments>
          <comments>// different parameters.</comments>
          <comments>// </comments>
          <comments>/**&#xA;     * Creates an &lt;code>AttributedCharacterIterator&lt;/code> for the String&#xA;     * &lt;code>s&lt;/code>.&#xA;     *&#xA;     * @param s String to create AttributedCharacterIterator from&#xA;     * @return AttributedCharacterIterator wrapping s&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="AttributedCharacterIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="as">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="AttributedString.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="AttributedString.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AttributedString.class.xmi#//@classifiers.0/@members.21"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createAttributedCharacterIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Creates an &lt;code>AttributedCharacterIterator&lt;/code> containg the&#xA;     * concatenated contents of the passed in&#xA;     * &lt;code>AttributedCharacterIterator&lt;/code>s.&#xA;     *&#xA;     * @param iterators AttributedCharacterIterators used to create resulting&#xA;     *                  AttributedCharacterIterators&#xA;     * @return AttributedCharacterIterator wrapping passed in&#xA;     *         AttributedCharacterIterators&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="AttributedCharacterIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="iterators">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="AttributedCharacterIterator.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="as">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="AttributedString.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="AttributedString.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AttributedString.class.xmi#//@classifiers.0/@members.21"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createAttributedCharacterIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns an AttributedCharacterIterator with the String&#xA;     * &lt;code>string&lt;/code> and additional key/value pair &lt;code>key&lt;/code>,&#xA;     * &lt;code>value&lt;/code>.&#xA;     *&#xA;     * @param string String to create AttributedCharacterIterator from&#xA;     * @param key Key for AttributedCharacterIterator&#xA;     * @param value Value associated with key in AttributedCharacterIterator&#xA;     * @return AttributedCharacterIterator wrapping args&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="AttributedCharacterIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="string">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>AttributedCharacterIterator</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="AttributedCharacterIterator$Attribute.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="as">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="AttributedString.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="AttributedString.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AttributedString.class.xmi#//@classifiers.0/@members.13"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.2"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AttributedString.class.xmi#//@classifiers.0/@members.21"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createAttributedCharacterIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Creates an AttributedCharacterIterator with the contents of&#xA;     * &lt;code>iterator&lt;/code> and the additional attribute &lt;code>key&lt;/code>&#xA;     * &lt;code>value&lt;/code>.&#xA;     *&#xA;     * @param iterator Initial AttributedCharacterIterator to add arg to&#xA;     * @param key Key for AttributedCharacterIterator&#xA;     * @param value Value associated with key in AttributedCharacterIterator&#xA;     * @return AttributedCharacterIterator wrapping args&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="AttributedCharacterIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="iterator">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="AttributedCharacterIterator.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>AttributedCharacterIterator</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="AttributedCharacterIterator$Attribute.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="as">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="AttributedString.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="AttributedString.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AttributedString.class.xmi#//@classifiers.0/@members.13"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.2"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AttributedString.class.xmi#//@classifiers.0/@members.21"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="classifiers:Class" name="Field">
      <members xsi:type="members:Field" name="serialVersionUID">
        <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="276966692217360283"/>
        <typeReference xsi:type="types:Long"/>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Proclaim serial compatibility with 1.4 FCS</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Constructor" name="Field">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@members.1/@parameters.0"/>
            <callTarget xsi:type="literals:Super"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="name">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected">
          <comments>/**&#xA;         * Creates a Field with the specified name.&#xA;         *&#xA;         * @param name Name of the attribute&#xA;         */</comments>
        </annotationsAndModifiers>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Defines constants that are used as attribute keys in the&#xA;     * &lt;code>AttributedCharacterIterator&lt;/code> returned&#xA;     * from &lt;code>Format.formatToCharacterIterator&lt;/code> and as&#xA;     * field identifiers in &lt;code>FieldPosition&lt;/code>.&#xA;     *&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <namespaces>AttributedCharacterIterator</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="AttributedCharacterIterator$Attribute.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </extends>
    </members>
    <members xsi:type="classifiers:Interface" name="FieldDelegate">
      <comments>/**&#xA;     * FieldDelegate is notified by the various &lt;code>Format&lt;/code>&#xA;     * implementations as they are formatting the Objects. This allows for&#xA;     * storage of the individual sections of the formatted String for&#xA;     * later use, such as in a &lt;code>FieldPosition&lt;/code> or for an&#xA;     * &lt;code>AttributedCharacterIterator&lt;/code>.&#xA;     * &lt;p>&#xA;     * Delegates should NOT assume that the &lt;code>Format&lt;/code> will notify&#xA;     * the delegate of fields in any particular order.&#xA;     *&#xA;     * @see FieldPosition.Delegate&#xA;     * @see CharacterIteratorFieldDelegate&#xA;     */</comments>
      <members xsi:type="members:InterfaceMethod" name="formatted">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="attr">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <namespaces>Format</namespaces>
            <classifierReferences target="//@classifiers.0/@members.11"/>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="value">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="end">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="buffer">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Notified when a particular region of the String is formatted. This&#xA;         * method will be invoked if there is no corresponding integer field id&#xA;         * matching &lt;code>attr&lt;/code>.&#xA;         *&#xA;         * @param attr Identifies the field matched&#xA;         * @param value Value associated with the field&#xA;         * @param start Beginning location of the field, will be >= 0&#xA;         * @param end End of the field, will be >= start and &lt;= buffer.length()&#xA;         * @param buffer Contains current formatted value, receiver should&#xA;         *        NOT modify it.&#xA;         */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:InterfaceMethod" name="formatted">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="fieldID">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="attr">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <namespaces>Format</namespaces>
            <classifierReferences target="//@classifiers.0/@members.11"/>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="value">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="end">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="buffer">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Notified when a particular region of the String is formatted.&#xA;         *&#xA;         * @param fieldID Identifies the field by integer&#xA;         * @param attr Identifies the field matched&#xA;         * @param value Value associated with the field&#xA;         * @param start Beginning location of the field, will be >= 0&#xA;         * @param end End of the field, will be >= start and &lt;= buffer.length()&#xA;         * @param buffer Contains current formatted value, receiver should&#xA;         *        NOT modify it.&#xA;         */</comments>
        </annotationsAndModifiers>
      </members>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;code>Format&lt;/code> is an abstract base class for formatting locale-sensitive&#xA; * information such as dates, messages, and numbers.&#xA; *&#xA; * &lt;p>&#xA; * &lt;code>Format&lt;/code> defines the programming interface for formatting&#xA; * locale-sensitive objects into &lt;code>String&lt;/code>s (the&#xA; * &lt;code>format&lt;/code> method) and for parsing &lt;code>String&lt;/code>s back&#xA; * into objects (the &lt;code>parseObject&lt;/code> method).&#xA; *&#xA; * &lt;p>&#xA; * Generally, a format's &lt;code>parseObject&lt;/code> method must be able to parse&#xA; * any string formatted by its &lt;code>format&lt;/code> method. However, there may &#xA; * be exceptional cases where this is not possible. For example, a&#xA; * &lt;code>format&lt;/code> method might create two adjacent integer numbers with&#xA; * no separator in between, and in this case the &lt;code>parseObject&lt;/code> could&#xA; * not tell which digits belong to which number.&#xA; *&#xA; * &lt;h4>Subclassing&lt;/h4>&#xA; *&#xA; * &lt;p>&#xA; * The Java 2 platform provides three specialized subclasses of &lt;code>Format&lt;/code>--&#xA; * &lt;code>DateFormat&lt;/code>, &lt;code>MessageFormat&lt;/code>, and&#xA; * &lt;code>NumberFormat&lt;/code>--for formatting dates, messages, and numbers,&#xA; * respectively.&#xA; * &lt;p>&#xA; * Concrete subclasses must implement three methods:&#xA; * &lt;ol>&#xA; * &lt;li> &lt;code>format(Object obj, StringBuffer toAppendTo, FieldPosition pos)&lt;/code>&#xA; * &lt;li> &lt;code>formatToCharacterIterator(Object obj)&lt;/code>&#xA; * &lt;li> &lt;code>parseObject(String source, ParsePosition pos)&lt;/code>&#xA; * &lt;/ol>&#xA; * These general methods allow polymorphic parsing and formatting of objects&#xA; * and are used, for example, by &lt;code>MessageFormat&lt;/code>.&#xA; * Subclasses often also provide additional &lt;code>format&lt;/code> methods for&#xA; * specific input types as well as &lt;code>parse&lt;/code> methods for specific&#xA; * result types. Any &lt;code>parse&lt;/code> method that does not take a&#xA; * &lt;code>ParsePosition&lt;/code> argument should throw &lt;code>ParseException&lt;/code>&#xA; * when no text in the required format is at the beginning of the input text.&#xA; *&#xA; * &lt;p>&#xA; * Most subclasses will also implement the following factory methods:&#xA; * &lt;ol>&#xA; * &lt;li>&#xA; * &lt;code>getInstance&lt;/code> for getting a useful format object appropriate&#xA; * for the current locale&#xA; * &lt;li>&#xA; * &lt;code>getInstance(Locale)&lt;/code> for getting a useful format&#xA; * object appropriate for the specified locale&#xA; * &lt;/ol>&#xA; * In addition, some subclasses may also implement other&#xA; * &lt;code>getXxxxInstance&lt;/code> methods for more specialized control. For&#xA; * example, the &lt;code>NumberFormat&lt;/code> class provides&#xA; * &lt;code>getPercentInstance&lt;/code> and &lt;code>getCurrencyInstance&lt;/code>&#xA; * methods for getting specialized number formatters.&#xA; *&#xA; * &lt;p>&#xA; * Subclasses of &lt;code>Format&lt;/code> that allow programmers to create objects&#xA; * for locales (with &lt;code>getInstance(Locale)&lt;/code> for example)&#xA; * must also implement the following class method:&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * public static Locale[] getAvailableLocales()&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p>&#xA; * And finally subclasses may define a set of constants to identify the various&#xA; * fields in the formatted output. These constants are used to create a FieldPosition&#xA; * object which identifies what information is contained in the field and its&#xA; * position in the formatted result. These constants should be named&#xA; * &lt;code>&lt;em>item&lt;/em>_FIELD&lt;/code> where &lt;code>&lt;em>item&lt;/em>&lt;/code> identifies&#xA; * the field. For examples of these constants, see &lt;code>ERA_FIELD&lt;/code> and its&#xA; * friends in {@link DateFormat}.&#xA; *&#xA; * &lt;h4>&lt;a name=&quot;synchronization&quot;>Synchronization&lt;/a>&lt;/h4>&#xA; *&#xA; * &lt;p>&#xA; * Formats are generally not synchronized.&#xA; * It is recommended to create separate format instances for each thread.&#xA; * If multiple threads access a format concurrently, it must be synchronized&#xA; * externally.&#xA; *&#xA; * @see          java.text.ParsePosition&#xA; * @see          java.text.FieldPosition&#xA; * @see          java.text.NumberFormat&#xA; * @see          java.text.DateFormat&#xA; * @see          java.text.MessageFormat&#xA; * @version      1.34, 12/19/03&#xA; * @author       Mark Davis&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../io/Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../lang/Cloneable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
