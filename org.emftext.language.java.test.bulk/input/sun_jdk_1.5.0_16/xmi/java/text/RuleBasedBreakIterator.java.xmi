<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="RuleBasedBreakIterator.java">
  <comments>/*&#xA; * @(#)RuleBasedBreakIterator.java&#x9;1.17 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/*&#xA; * @(#)RuleBasedBreakIterator.java&#x9;1.3 99/04/07&#xA; *&#xA; * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved&#xA; * (C) Copyright IBM Corp. 1996 - 2002 - All Rights Reserved&#xA; *&#xA; * The original version of this source code and documentation&#xA; * is copyrighted and owned by Taligent, Inc., a wholly-owned&#xA; * subsidiary of IBM. These materials are provided under terms&#xA; * of a License Agreement between Taligent and Sun. This technology&#xA; * is protected by multiple US and International patents.&#xA; *&#xA; * This notice and attribution to Taligent may not be removed.&#xA; * Taligent is a registered trademark of Taligent, Inc.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>text</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/BufferedInputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../security/AccessController.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../security/PrivilegedActionException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../security/PrivilegedExceptionAction.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Vector.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Stack.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Hashtable.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../util/Enumeration.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/MissingResourceException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>text</namespaces>
    <classifier xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>text</namespaces>
    <classifier xsi:type="classifiers:Class" href="StringCharacterIterator.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>text</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/text/CompactByteArray.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>text</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/text/SupplementaryCharacterData.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="RuleBasedBreakIterator">
    <comments>/**&#xA; * &lt;p>A subclass of BreakIterator whose behavior is specified using a list of rules.&lt;/p>&#xA; *&#xA; * &lt;p>There are two kinds of rules, which are separated by semicolons: &lt;i>substitutions&lt;/i>&#xA; * and &lt;i>regular expressions.&lt;/i>&lt;/p>&#xA; *&#xA; * &lt;p>A substitution rule defines a name that can be used in place of an expression. It&#xA; * consists of a name, which is a string of characters contained in angle brackets, an equals&#xA; * sign, and an expression. (There can be no whitespace on either side of the equals sign.)&#xA; * To keep its syntactic meaning intact, the expression must be enclosed in parentheses or&#xA; * square brackets. A substitution is visible after its definition, and is filled in using&#xA; * simple textual substitution. Substitution definitions can contain other substitutions, as&#xA; * long as those substitutions have been defined first. Substitutions are generally used to&#xA; * make the regular expressions (which can get quite complex) shorted and easier to read.&#xA; * They typically define either character categories or commonly-used subexpressions.&lt;/p>&#xA; *&#xA; * &lt;p>There is one special substitution.&amp;nbsp; If the description defines a substitution&#xA; * called &amp;quot;&amp;lt;ignore&amp;gt;&amp;quot;, the expression must be a [] expression, and the&#xA; * expression defines a set of characters (the &amp;quot;&lt;em>ignore characters&lt;/em>&amp;quot;) that&#xA; * will be transparent to the BreakIterator.&amp;nbsp; A sequence of characters will break the&#xA; * same way it would if any ignore characters it contains are taken out.&amp;nbsp; Break&#xA; * positions never occur befoer ignore characters.&lt;/p>&#xA; *&#xA; * &lt;p>A regular expression uses a subset of the normal Unix regular-expression syntax, and&#xA; * defines a sequence of characters to be kept together. With one significant exception, the&#xA; * iterator uses a longest-possible-match algorithm when matching text to regular&#xA; * expressions. The iterator also treats descriptions containing multiple regular expressions&#xA; * as if they were ORed together (i.e., as if they were separated by |).&lt;/p>&#xA; *&#xA; * &lt;p>The special characters recognized by the regular-expression parser are as follows:&lt;/p>&#xA; *&#xA; * &lt;blockquote>&#xA; *   &lt;table border=&quot;1&quot; width=&quot;100%&quot;>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>*&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>Specifies that the expression preceding the asterisk may occur any number&#xA; *       of times (including not at all).&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>{}&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>Encloses a sequence of characters that is optional.&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>()&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>Encloses a sequence of characters.&amp;nbsp; If followed by *, the sequence&#xA; *       repeats.&amp;nbsp; Otherwise, the parentheses are just a grouping device and a way to delimit&#xA; *       the ends of expressions containing |.&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>|&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>Separates two alternative sequences of characters.&amp;nbsp; Either one&#xA; *       sequence or the other, but not both, matches this expression.&amp;nbsp; The | character can&#xA; *       only occur inside ().&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>.&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>Matches any character.&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>*?&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>Specifies a non-greedy asterisk.&amp;nbsp; *? works the same way as *, except&#xA; *       when there is overlap between the last group of characters in the expression preceding the&#xA; *       * and the first group of characters following the *.&amp;nbsp; When there is this kind of&#xA; *       overlap, * will match the longest sequence of characters that match the expression before&#xA; *       the *, and *? will match the shortest sequence of characters matching the expression&#xA; *       before the *?.&amp;nbsp; For example, if you have &amp;quot;xxyxyyyxyxyxxyxyxyy&amp;quot; in the text,&#xA; *       &amp;quot;x[xy]*x&amp;quot; will match through to the last x (i.e., &amp;quot;&lt;strong>xxyxyyyxyxyxxyxyx&lt;/strong>yy&amp;quot;,&#xA; *       but &amp;quot;x[xy]*?x&amp;quot; will only match the first two xes (&amp;quot;&lt;strong>xx&lt;/strong>yxyyyxyxyxxyxyxyy&amp;quot;).&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>[]&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>Specifies a group of alternative characters.&amp;nbsp; A [] expression will&#xA; *       match any single character that is specified in the [] expression.&amp;nbsp; For more on the&#xA; *       syntax of [] expressions, see below.&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>/&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>Specifies where the break position should go if text matches this&#xA; *       expression.&amp;nbsp; (e.g., &amp;quot;[a-z]&amp;#42;/[:Zs:]*[1-0]&amp;quot; will match if the iterator sees a run&#xA; *       of letters, followed by a run of whitespace, followed by a digit, but the break position&#xA; *       will actually go before the whitespace).&amp;nbsp; Expressions that don't contain / put the&#xA; *       break position at the end of the matching text.&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>\&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>Escape character.&amp;nbsp; The \ itself is ignored, but causes the next&#xA; *       character to be treated as literal character.&amp;nbsp; This has no effect for many&#xA; *       characters, but for the characters listed above, this deprives them of their special&#xA; *       meaning.&amp;nbsp; (There are no special escape sequences for Unicode characters, or tabs and&#xA; *       newlines; these are all handled by a higher-level protocol.&amp;nbsp; In a Java string,&#xA; *       &amp;quot;\n&amp;quot; will be converted to a literal newline character by the time the&#xA; *       regular-expression parser sees it.&amp;nbsp; Of course, this means that \ sequences that are&#xA; *       visible to the regexp parser must be written as \\ when inside a Java string.)&amp;nbsp; All&#xA; *       characters in the ASCII range except for letters, digits, and control characters are&#xA; *       reserved characters to the parser and must be preceded by \ even if they currently don't&#xA; *       mean anything.&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>!&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>If ! appears at the beginning of a regular expression, it tells the regexp&#xA; *       parser that this expression specifies the backwards-iteration behavior of the iterator,&#xA; *       and not its normal iteration behavior.&amp;nbsp; This is generally only used in situations&#xA; *       where the automatically-generated backwards-iteration brhavior doesn't produce&#xA; *       satisfactory results and must be supplemented with extra client-specified rules.&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>&lt;em>(all others)&lt;/em>&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>All other characters are treated as literal characters, which must match&#xA; *       the corresponding character(s) in the text exactly.&lt;/td>&#xA; *     &lt;/tr>&#xA; *   &lt;/table>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p>Within a [] expression, a number of other special characters can be used to specify&#xA; * groups of characters:&lt;/p>&#xA; *&#xA; * &lt;blockquote>&#xA; *   &lt;table border=&quot;1&quot; width=&quot;100%&quot;>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>-&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>Specifies a range of matching characters.&amp;nbsp; For example&#xA; *       &amp;quot;[a-p]&amp;quot; matches all lowercase Latin letters from a to p (inclusive).&amp;nbsp; The -&#xA; *       sign specifies ranges of continuous Unicode numeric values, not ranges of characters in a&#xA; *       language's alphabetical order: &amp;quot;[a-z]&amp;quot; doesn't include capital letters, nor does&#xA; *       it include accented letters such as a-umlaut.&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>::&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>A pair of colons containing a one- or two-letter code matches all&#xA; *       characters in the corresponding Unicode category.&amp;nbsp; The two-letter codes are the same&#xA; *       as the two-letter codes in the Unicode database (for example, &amp;quot;[:Sc::Sm:]&amp;quot;&#xA; *       matches all currency symbols and all math symbols).&amp;nbsp; Specifying a one-letter code is&#xA; *       the same as specifying all two-letter codes that begin with that letter (for example,&#xA; *       &amp;quot;[:L:]&amp;quot; matches all letters, and is equivalent to&#xA; *       &amp;quot;[:Lu::Ll::Lo::Lm::Lt:]&amp;quot;).&amp;nbsp; Anything other than a valid two-letter Unicode&#xA; *       category code or a single letter that begins a Unicode category code is illegal within&#xA; *       colons.&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>[]&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>[] expressions can nest.&amp;nbsp; This has no effect, except when used in&#xA; *       conjunction with the ^ token.&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>^&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>Excludes the character (or the characters in the [] expression) following&#xA; *       it from the group of characters.&amp;nbsp; For example, &amp;quot;[a-z^p]&amp;quot; matches all Latin&#xA; *       lowercase letters except p.&amp;nbsp; &amp;quot;[:L:^[&amp;#92;u4e00-&amp;#92;u9fff]]&amp;quot; matches all letters&#xA; *       except the Han ideographs.&lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;td width=&quot;6%&quot;>&lt;em>(all others)&lt;/em>&lt;/td>&#xA; *       &lt;td width=&quot;94%&quot;>All other characters are treated as literal characters.&amp;nbsp; (For&#xA; *       example, &amp;quot;[aeiou]&amp;quot; specifies just the letters a, e, i, o, and u.)&lt;/td>&#xA; *     &lt;/tr>&#xA; *   &lt;/table>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p>For a more complete explanation, see &lt;a&#xA; * href=&quot;http://www.ibm.com/java/education/boundaries/boundaries.html&quot;>http://www.ibm.com/java/education/boundaries/boundaries.html&lt;/a>.&#xA; * &amp;nbsp; For examples, see the resource data (which is annotated).&lt;/p>&#xA; *&#xA; * @author Richard Gillam&#xA; * @version $RCSFile$ $Revision: 1.1 $ $Date: 1998/11/05 19:32:04 $&#xA; */</comments>
    <members xsi:type="members:Field" name="IGNORE">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      </initialValue>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * A token used as a character-category value to identify ignore characters&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="START_STATE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The state number of the starting state&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="STOP_STATE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The state-transition value indicating &quot;stop&quot;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="LABEL">
      <initialValue xsi:type="arrays:ArrayInstantiationByValues">
        <arrayInitializer>
          <initialValues xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Byte"/>
            <child xsi:type="literals:CharacterLiteral" value="66"/>
          </initialValues>
          <initialValues xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Byte"/>
            <child xsi:type="literals:CharacterLiteral" value="73"/>
          </initialValues>
          <initialValues xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Byte"/>
            <child xsi:type="literals:CharacterLiteral" value="100"/>
          </initialValues>
          <initialValues xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Byte"/>
            <child xsi:type="literals:CharacterLiteral" value="97"/>
          </initialValues>
          <initialValues xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Byte"/>
            <child xsi:type="literals:CharacterLiteral" value="116"/>
          </initialValues>
          <initialValues xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Byte"/>
            <child xsi:type="literals:CharacterLiteral" value="97"/>
          </initialValues>
          <initialValues xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Byte"/>
            <child xsi:type="literals:CharacterLiteral"/>
          </initialValues>
        </arrayInitializer>
      </initialValue>
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Magic number for the BreakIterator data file format.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="LABEL_LENGTH">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
        <next xsi:type="references:IdentifierReference"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="supportedVersion">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Version number of the dictionary that was read in.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="HEADER_LENGTH">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="36"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Header size in byte count&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="BMP_INDICES_LENGTH">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="512"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * An array length of indices for BMP characters&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="charCategoryTable">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../sun/text/CompactByteArray.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Tables that indexes from character values to character category numbers&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="supplementaryCharCategoryTable">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../sun/text/SupplementaryCharacterData.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="stateTable">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:Short"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The table of state transitions used for forward iteration&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="backwardsStateTable">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:Short"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The table of state transitions used to sync up the iterator with the&#xA;     * text in backwards and random-access iteration&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="endStates">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * A list of flags indicating which states in the state table are accepting&#xA;     * (&quot;end&quot;) states&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="lookaheadStates">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * A list of flags indicating which states in the state table are&#xA;     * lookahead states (states which turn lookahead on and off)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="additionalData">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * A table for additional data. May be used by a subclass of&#xA;     * RuleBasedBreakIterator.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="numCategories">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The number of character categories (and, thus, the number of columns in&#xA;     * the state tables)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="text">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The character iterator through which this BreakIterator accesses the text&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="checksum">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * A CRC32 value of all data in datafile&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="RuleBasedBreakIterator">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="datafile">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/MissingResourceException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>//=======================================================================</comments>
        <comments>// constructors</comments>
        <comments>//=======================================================================</comments>
        <comments>/**&#xA;     * Constructs a RuleBasedBreakIterator according to the datafile&#xA;     * provided.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="readTables">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="datafile">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/MissingResourceException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Read datafile. The datafile's format is as follows:&#xA;     * &lt;pre>&#xA;     *   BreakIteratorData {&#xA;     *       u1           magic[7];&#xA;     *       u1           version;&#xA;     *       u4           totalDataSize;&#xA;     *       header_info  header;&#xA;     *       body         value;&#xA;     *   }&#xA;     * &lt;/pre>&#xA;     * &lt;code>totalDataSize&lt;/code> is the summation of the size of&#xA;     * &lt;code>header_info&lt;/code> and &lt;code>body&lt;/code> in byte count.&#xA;     * &lt;p>&#xA;     * In &lt;code>header&lt;/code>, each field except for checksum implies the&#xA;     * length of each field. Since &lt;code>BMPdataLength&lt;/code> is a fixed-length&#xA;     *  data(512 entries), its length isn't included in &lt;code>header&lt;/code>.&#xA;     * &lt;code>checksum&lt;/code> is a CRC32 value of all in &lt;code>body&lt;/code>.&#xA;     * &lt;pre>&#xA;     *   header_info { &#xA;     *       u4           stateTableLength;&#xA;     *       u4           backwardsStateTableLength;&#xA;     *       u4           endStatesLength;&#xA;     *       u4           lookaheadStatesLength;&#xA;     *       u4           BMPdataLength;&#xA;     *       u4           nonBMPdataLength;&#xA;     *       u4           additionalDataLength;&#xA;     *       u8           checksum;&#xA;     *   }&#xA;     * &lt;/pre>&#xA;     * &lt;p>&#xA;     * &#xA;     * Finally, &lt;code>BMPindices&lt;/code> and &lt;code>BMPdata&lt;/code> are set to&#xA;     * &lt;code>charCategoryTable&lt;/code>. &lt;code>nonBMPdata&lt;/code> is set to&#xA;     * &lt;code>supplementaryCharCategoryTable&lt;/code>.&#xA;     * &lt;pre>&#xA;     *   body {&#xA;     *       u2           stateTable[stateTableLength];&#xA;     *       u2           backwardsStateTable[backwardsStateTableLength];&#xA;     *       u1           endStates[endStatesLength];&#xA;     *       u1           lookaheadStates[lookaheadStatesLength];&#xA;     *       u2           BMPindices[512];&#xA;     *       u1           BMPdata[BMPdataLength];&#xA;     *       u4           nonBMPdata[numNonBMPdataLength];&#xA;     *       u1           additionalData[additionalDataLength];&#xA;     *   }&#xA;     * &lt;/pre>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="buffer">
          <typeReference xsi:type="types:Byte"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.20">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="stateTableLength">
          <typeReference xsi:type="types:Int">
            <comments>/* Read header_info. */</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </next>
            <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="backwardsStateTableLength">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
            </next>
            <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="endStatesLength">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
            </next>
            <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lookaheadStatesLength">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
            </next>
            <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="BMPdataLength">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
            </next>
            <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="nonBMPdataLength">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="20"/>
            </next>
            <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="additionalDataLength">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="24"/>
            </next>
            <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.32"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="28"/>
            </next>
            <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10">
            <comments>/* Read stateTable[numCategories * numRows] */</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Short"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="offset">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.11/@init"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.34"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.11/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.11/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
        <updates xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
        </updates>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11">
            <comments>/* Read backwardsStateTable[numCategories * numRows] */</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Short"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.13/@init"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.34"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.13/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.13/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
        <updates xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
        </updates>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12">
            <comments>/* Read endStates[numRows] */</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Boolean"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.15/@init"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
                  </arraySelectors>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.15/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.15/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13">
            <comments>/* Read lookaheadStates[numRows] */</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Boolean"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.4/@variable"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.17/@init"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
                  </arraySelectors>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.17/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.4/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.17/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="temp1">
          <typeReference xsi:type="types:Short">
            <comments>/* Read a category table and indices for BMP characters. */</comments>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Short"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <comments>// BMPindices</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.18/@variable">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.19/@init"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.34"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.19/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.19/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
        <updates xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
        </updates>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="temp2">
          <typeReference xsi:type="types:Byte"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Byte"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.5/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <comments>// BMPdata</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.20/@variable"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.5/@variable"/>
          </next>
          <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.5/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../sun/text/CompactByteArray.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.18/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.20/@variable"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="temp3">
          <typeReference xsi:type="types:Int">
            <comments>/* Read a category table for non-BMP characters. */</comments>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Int"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.6/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.24/@variable">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.25/@init"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.33"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.25/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.6/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.25/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
        <updates xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
        </updates>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../sun/text/SupplementaryCharacterData.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.24/@variable"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>/* Read additional data */</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="arrays:ArrayInstantiationBySize">
                <typeReference xsi:type="types:Byte"/>
                <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.7/@variable"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.20"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.10/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.7/@variable"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.7/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15">
            <comments>/* Set numCategories */</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <multiplicativeOperators xsi:type="operators:Division"/>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readFile">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="datafile">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/MissingResourceException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Protected"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="is">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../io/BufferedInputStream.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../io/BufferedInputStream.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../security/AccessController.class.xmi#//@classifiers.0/@members.3"/>
                  <arguments xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Interface" href="../security/PrivilegedExceptionAction.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <anonymousClass>
                      <members xsi:type="members:ClassMethod" name="run">
                        <typeReference xsi:type="types:NamespaceClassifierReference">
                          <classifierReferences>
                            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                          </classifierReferences>
                        </typeReference>
                        <exceptions>
                          <classifierReferences>
                            <target xsi:type="classifiers:Class" href="../lang/Exception.class.xmi#//@classifiers.0"/>
                          </classifierReferences>
                        </exceptions>
                        <annotationsAndModifiers xsi:type="modifiers:Public"/>
                        <statements xsi:type="statements:Return">
                          <returnValue xsi:type="instantiations:NewConstructorCall">
                            <typeReference xsi:type="types:NamespaceClassifierReference">
                              <classifierReferences>
                                <target xsi:type="classifiers:Class" href="../io/BufferedInputStream.class.xmi#//@classifiers.0"/>
                              </classifierReferences>
                            </typeReference>
                            <arguments xsi:type="references:MethodCall">
                              <next xsi:type="references:MethodCall">
                                <target xsi:type="members:ClassMethod" href="../lang/Class.class.xmi#//@classifiers.0/@members.87"/>
                                <arguments xsi:type="expressions:AdditiveExpression">
                                  <children xsi:type="references:StringReference" value="/sun/text/resources/"/>
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
                                  <additiveOperators xsi:type="operators:Addition"/>
                                </arguments>
                              </next>
                              <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
                            </arguments>
                          </returnValue>
                        </statements>
                      </members>
                    </anonymousClass>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../security/AccessController.class.xmi#//@classifiers.0"/>
              </child>
            </value>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/InternalError.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@catcheBlocks.0/@parameter">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../security/PrivilegedActionException.class.xmi#//@classifiers.0/@members.5"/>
                </next>
              </arguments>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../security/PrivilegedActionException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="offset">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Int">
            <comments>/* First, read magic, version, and header_info. */</comments>
          </typeReference>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="buf">
          <typeReference xsi:type="types:Byte"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Byte"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.3/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../util/MissingResourceException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Wrong header length"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
              <arguments xsi:type="references:StringReference" value=""/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../io/FilterInputStream.class.xmi#//@classifiers.0/@members.3"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.4/@variable"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.3/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <comments>/* Validate the magic number. */</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../util/MissingResourceException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:StringReference" value="Wrong magic number"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
                  <arguments xsi:type="references:StringReference" value=""/>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.4/@variable">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.2/@variable"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.2/@variable"/>
                </arraySelectors>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.6/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.6/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.2/@variable"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>/* Validate the version number. */</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../util/MissingResourceException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Unsupported version("/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.4/@variable">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.2/@variable"/>
                  </arraySelectors>
                </children>
                <children xsi:type="references:StringReference" value=")"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
              <arguments xsi:type="references:StringReference" value=""/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.4/@variable">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.2/@variable"/>
            </arraySelectors>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.3/@variable">
            <comments>/* Read data: totalDataSize + 8(for checksum) */</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.4/@variable"/>
              <arguments xsi:type="expressions:PrefixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.2/@variable"/>
                <operator xsi:type="operators:PlusPlus"/>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.4/@variable"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Byte"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.3/@variable"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../util/MissingResourceException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Wrong data length"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
              <arguments xsi:type="references:StringReference" value=""/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../io/FilterInputStream.class.xmi#//@classifiers.0/@members.3"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.4/@variable"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.3/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/BufferedInputStream.class.xmi#//@classifiers.0/@members.20"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.4/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAdditionalData">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setAdditionalData">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>//=======================================================================</comments>
        <comments>// boilerplate</comments>
        <comments>//=======================================================================</comments>
        <comments>/**&#xA;     * Clones this iterator.&#xA;     * @return A newly-constructed RuleBasedBreakIterator with the same&#xA;     * behavior as this one.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BreakIterator.class.xmi#//@classifiers.0/@members.7"/>
              </next>
              <self xsi:type="literals:Super"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.10"/>
                  </next>
                </child>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="that">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns true if both BreakIterators are of the same class, have the same&#xA;     * rules, and iterate over the same text.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="literals:BooleanLiteral"/>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="other">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <initialValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="literals:BooleanLiteral"/>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@statements.1/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@statements.1/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
                </children>
                <children xsi:type="literals:NullLiteral"/>
              </returnValue>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.4"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@statements.1/@variable">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
                  </arguments>
                </next>
              </returnValue>
            </statements>
          </elseStatement>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/ClassCastException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns text&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
            <arguments xsi:type="literals:CharacterLiteral" value="91"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="checksum=0x"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Long.class.xmi#//@classifiers.0/@members.7"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
              </children>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
            <arguments xsi:type="literals:CharacterLiteral" value="93"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compute a hashcode for this BreakIterator&#xA;     * @return A hash code&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Int"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="first">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>//=======================================================================</comments>
        <comments>// BreakIterator overrides</comments>
        <comments>//=======================================================================</comments>
        <comments>/**&#xA;     * Sets the current iteration position to the beginning of the text.&#xA;     * (i.e., the CharacterIterator's starting offset).&#xA;     * @return The offset of the beginning of the text.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="t">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.1"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.9"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="last">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the current iteration position to the end of the text.&#xA;     * (i.e., the CharacterIterator's ending offset).&#xA;     * @return The text's past-the-end offset.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="t">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@variable">
          <comments>// I'm not sure why, but t.last() returns the offset of the last character,</comments>
          <comments>// rather than the past-the-end offset</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.8"/>
              </next>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.9"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="next">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Advances the iterator either forward or backward the specified number of steps.&#xA;     * Negative values move backward, and positive values move forward.  This is&#xA;     * equivalent to repeatedly calling next() or previous().&#xA;     * @param n The number of steps to move.  The sign indicates the direction&#xA;     * (negative is backwards, and positive is forwards).&#xA;     * @return The character offset of the boundary position n boundaries away from&#xA;     * the current one.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.41"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.44"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:PrefixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
              <operator xsi:type="operators:MinusMinus"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.31"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:PrefixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
              <operator xsi:type="operators:PlusPlus"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="next">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Advances the iterator to the next boundary position.&#xA;     * @return The position of the first boundary after this one.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.44"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="previous">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Advances the iterator backwards, to the last boundary preceding this one.&#xA;     * @return The position of the last boundary position preceding this one.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="text">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// if we're already sitting at the beginning of the text, return DONE</comments>
              <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="BreakIterator.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.41"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.7"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="start">
          <typeReference xsi:type="types:Int">
            <comments>// set things up.  handlePrevious() will back us up to some valid</comments>
            <comments>// break position before the current position (we back our internal</comments>
            <comments>// iterator up one step to prevent handlePrevious() from returning</comments>
            <comments>// the current position), but not necessarily the last one before</comments>
            <comments>// where we started</comments>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.41"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.32"/>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lastResult">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.45"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@variable"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>// iterate forward from the known break position until we pass our</comments>
        <comments>// starting point.  The last break position before the starting</comments>
        <comments>// point is our return value</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.5/@variable"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.5/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.44"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.5/@variable"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="BreakIterator.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
            </children>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.5/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.2/@variable"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.0/@variable">
          <comments>// set the current iteration position to be the last break position</comments>
          <comments>// before where we started, and then return that value</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@variable"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPrevious">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Returns previous character&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c2">
          <typeReference xsi:type="types:Char"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.5"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="c1">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.5"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.84"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.0/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.0/@variable"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
                </returnValue>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.80"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.0/@variable"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.4"/>
                  </next>
                </expression>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.81"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.0/@variable"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.9"/>
              </next>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.7"/>
              </next>
            </children>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Int"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.0/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCurrent">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Returns current character&#xA;     */</comments>
      </typeReference>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c1">
          <typeReference xsi:type="types:Char"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.3"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="c2">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.4"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.5"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.84"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.0/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.1/@statement/@statements.0/@variable"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
                </returnValue>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.81"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.1/@statement/@statements.0/@variable"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.80"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.0/@variable"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.9"/>
              </next>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.8"/>
              </next>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Int"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.0/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCurrentCodePointCount">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Returns the count of next character.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c1">
          <typeReference xsi:type="types:Char"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.3"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="c2">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.4"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.5"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.81"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@statement/@statements.0/@variable"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.80"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.9"/>
              </next>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.8"/>
              </next>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNext">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Returns next character&#xA;     */</comments>
      </typeReference>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="index">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.9"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="endIndex">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="CharacterIterator.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.1/@variable"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.0/@variable"/>
                  <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.34"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </value>
              </expression>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.1/@variable"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.0/@variable"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNextIndex">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Returns the position of next character.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="index">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.9"/>
              </next>
            </children>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.34"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="endIndex">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.1/@variable"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkOffset">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="text">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Throw IllegalArgumentException unless begin &lt;= offset &lt; end.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="offset out of bounds"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.7"/>
              </next>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.8"/>
              </next>
            </children>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="following">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the iterator to refer to the first boundary position following&#xA;     * the specified position.&#xA;     * @offset The position from which to begin searching for a break position.&#xA;     * @return The position of the first break after the current position.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="text">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.37">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@variable">
          <comments>// Set our internal iteration position (temporarily)</comments>
          <comments>// to the position passed in.  If this is the _beginning_ position,</comments>
          <comments>// then we can just use next() to get our return value</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.44"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.7"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Int">
            <comments>// otherwise, we have to sync up first.  Use handlePrevious() to back</comments>
            <comments>// us up to a known break position before the specified position (if</comments>
            <comments>// we can determine that the specified position is a break position,</comments>
            <comments>// we don't back up at all).  This may or may not be the last break</comments>
            <comments>// position at or before our starting position.  Advance forward</comments>
            <comments>// from here until we've passed the starting position.  The position</comments>
            <comments>// we stop on will be the first break position after the specified one.</comments>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.45"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.4/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.44"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.4/@variable"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="BreakIterator.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
            </children>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.4/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.4/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="preceding">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the iterator to refer to the last boundary position before the&#xA;     * specified position.&#xA;     * @offset The position to begin searching for a break from.&#xA;     * @return The position of the last boundary before the starting position.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="text">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// if we start by updating the current iteration position to the</comments>
              <comments>// position specified by the caller, we can just use previous()</comments>
              <comments>// to carry out this operation</comments>
              <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.37">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.0/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.31"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isBoundary">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns true if the specfied position is a boundary position.  As a side&#xA;     * effect, leaves the iterator pointing to the first boundary position at&#xA;     * or after &quot;offset&quot;.&#xA;     * @param offset the offset to check.&#xA;     * @return True if &quot;offset&quot; is a boundary position.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="text">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.37">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// to check whether this is a boundary, we can use following() on the</comments>
        <comments>// position before the specified one and return true if the position we</comments>
        <comments>// get back is the one the user specified</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.7"/>
            </next>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.38">
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </arguments>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
            </returnValue>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="current">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current iteration position.&#xA;     * @return The current iteration position.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.9"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getText">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return a CharacterIterator over the text being analyzed.  This version&#xA;     * of this method returns the actual CharacterIterator we're using internally.&#xA;     * Changing the state of this iterator can have undefined consequences.  If&#xA;     * you need to change it, clone it first.&#xA;     * @return An iterator over the text being analyzed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// The iterator is initialized pointing to no text at all, so if this</comments>
        <comments>// function is called while we're in that state, we have to fudge an</comments>
        <comments>// iterator to return.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="StringCharacterIterator.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value=""/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setText">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newText">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set the iterator to analyze a new piece of text.  This function resets&#xA;     * the current iteration position to the beginning of the text.&#xA;     * @param newText An iterator over the text to analyze.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="end">
          <typeReference xsi:type="types:Int">
            <comments>// Test iterator to see if we need to wrap it in a SafeCharIterator.</comments>
            <comments>// The correct behavior for CharacterIterators is to allow the</comments>
            <comments>// position to be set to the endpoint of the iterator.  Many</comments>
            <comments>// CharacterIterators do not uphold this, so this is a workaround</comments>
            <comments>// to permit them to use this class.</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="goodIterator">
          <typeReference xsi:type="types:Boolean"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.6"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@variable"/>
            </next>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.1/@variable">
              <comments>// some buggy iterators throw an exception here</comments>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.9"/>
                </next>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@variable"/>
            </value>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral"/>
            </expression>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.1/@variable"/>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@members.49"/>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.1"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="handleNext">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>//=======================================================================</comments>
        <comments>// implementation</comments>
        <comments>//=======================================================================</comments>
        <comments>/**&#xA;     * This method is the actual implementation of the next() method.  All iteration&#xA;     * vectors through here.  This method initializes the state machine to state 1&#xA;     * and advances through the text character by character until we reach the end&#xA;     * of the text or the state machine transitions to state 0.  We update our return&#xA;     * value every time the state machine passes through a possible end state.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="text">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// if we're already at the end of the text, return DONE.</comments>
              <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="BreakIterator.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.9"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Int">
            <comments>// no matter what, we always advance at least one character forward</comments>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.36"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lookaheadResult">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="state">
          <typeReference xsi:type="types:Int">
            <comments>// begin in state 1</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="category">
          <typeReference xsi:type="types:Int"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>// loop until we reach the end of the text or transition to state 0</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.5/@variable">
                <comments>// look up the current character's character category (which tells us</comments>
                <comments>// which column in the state table to look at)</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.46">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.6/@variable"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// if the character isn't an ignore character, look up a state</comments>
            <comments>// transition in the state table</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.4/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.47">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.4/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.5/@variable"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.5/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// if the state we've just transitioned to is a lookahead state,</comments>
            <comments>// (but not also an end state), save its position.  If it's</comments>
            <comments>// both a lookahead state and an end state, update the break position</comments>
            <comments>// to the last saved lookup-state position</comments>
            <comments>// otherwise, if the state we've just transitioned to is an accepting</comments>
            <comments>// state, update the break position to be the current iteration position</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.2/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.3/@variable"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.4/@variable"/>
                  </arraySelectors>
                </condition>
                <elseStatement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.3/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.36"/>
                    </expression>
                  </statements>
                </elseStatement>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.4/@variable"/>
              </arraySelectors>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.2/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.36"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.4/@variable"/>
                  </arraySelectors>
                </condition>
              </statements>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.6/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.35"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.6/@variable"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="CharacterIterator.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
            </children>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.4/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// if we've run off the end of the text, and the very last character took us into</comments>
        <comments>// a lookahead state, advance the break position to the lookahead position</comments>
        <comments>// (the theory here is that if there are no characters at all after the lookahead</comments>
        <comments>// position, that always matches the lookahead criteria)</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.3/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.6/@variable"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="CharacterIterator.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
            </children>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.3/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.8"/>
              </next>
            </children>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.2/@variable"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="handlePrevious">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * This method backs the iterator back up to a &quot;safe position&quot; in the text.&#xA;     * This is a position that we know, without any context, must be a break position.&#xA;     * The various calling methods then iterate forward from this safe position to&#xA;     * the appropriate position to return.  (For more information, see the description&#xA;     * of buildBackwardsStateTable() in RuleBasedBreakIterator.Builder.)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="text">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="state">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="category">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lastCategory">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>// loop until we reach the beginning of the text or transition to state 0</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.3/@variable">
                <comments>// save the last character's category and look up the current</comments>
                <comments>// character's category</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.2/@variable"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.46">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.4/@variable"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// if the current character isn't an ignore character, look up a</comments>
            <comments>// state transition in the backwards state table</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.48">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.1/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.2/@variable"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.4/@variable">
                <comments>// then advance one character backwards</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.32"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.4/@variable"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="CharacterIterator.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
            </children>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.1/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// if we didn't march off the beginning of the text, we're either one or two</comments>
        <comments>// positions away from the real break position.  (One because of the call to</comments>
        <comments>// previous() at the end of the loop above, and another because the character</comments>
        <comments>// that takes us into the stop state will always be the character BEFORE</comments>
        <comments>// the break position.)</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.35"/>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.35"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.3/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.35"/>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.4/@variable"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="CharacterIterator.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.9"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lookupCategory">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Looks up a character's category (i.e., its category for breaking purposes,&#xA;     * not its Unicode category)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/text/CompactByteArray.class.xmi#//@classifiers.0/@members.14"/>
                <arguments xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Char"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
                </arguments>
              </next>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../lang/Character.class.xmi#//@classifiers.0/@members.62"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/text/SupplementaryCharacterData.class.xmi#//@classifiers.0/@members.3"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
              </next>
            </returnValue>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lookupState">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="state">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="category">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Given a current state and a character category, looks up the&#xA;     * next state to transition to in the state table.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10">
          <arraySelectors>
            <position xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </position>
          </arraySelectors>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lookupBackwardState">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="state">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="category">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Given a current state and a character category, looks up the&#xA;     * next state to transition to in the backwards state table.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11">
          <arraySelectors>
            <position xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </position>
          </arraySelectors>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="classifiers:Class" name="SafeCharIterator">
      <members xsi:type="members:Field" name="base">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Field" name="rangeStart">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Field" name="rangeLimit">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Field" name="currentIndex">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Constructor" name="SafeCharIterator">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.0"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.4/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.1"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.4/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.7"/>
              </next>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.2"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.4/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.8"/>
              </next>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.4/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.9"/>
              </next>
            </value>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="base">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
      </members>
      <members xsi:type="members:ClassMethod" name="first">
        <typeReference xsi:type="types:Char"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.49/@members.10">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.1"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="last">
        <typeReference xsi:type="types:Char"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.49/@members.10">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.2"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="current">
        <typeReference xsi:type="types:Char"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="CharacterIterator.class.xmi#//@classifiers.0/@members.0"/>
              </returnValue>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalOrExpression">
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.1"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </children>
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.2"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </children>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.6"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
                </next>
              </returnValue>
            </statements>
          </elseStatement>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="next">
        <typeReference xsi:type="types:Char"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
            <operator xsi:type="operators:PlusPlus"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.2"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="CharacterIterator.class.xmi#//@classifiers.0/@members.0"/>
              </returnValue>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.2"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.6"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
                </next>
              </returnValue>
            </statements>
          </elseStatement>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="previous">
        <typeReference xsi:type="types:Char"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
            <operator xsi:type="operators:MinusMinus"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.1"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="CharacterIterator.class.xmi#//@classifiers.0/@members.0"/>
              </returnValue>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.1"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.6"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
                </next>
              </returnValue>
            </statements>
          </elseStatement>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="setIndex">
        <typeReference xsi:type="types:Char"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="i">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="Invalid position"/>
              </throwable>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalOrExpression">
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.10/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.1"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </children>
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.10/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.2"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.10/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.49/@members.7"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getBeginIndex">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.1"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getEndIndex">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.2"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getIndex">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.3"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="clone">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="copy">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.49"/>
            </typeReference>
            <initialValue xsi:type="literals:NullLiteral"/>
          </variable>
        </statements>
        <statements xsi:type="statements:TryBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.14/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@members.49"/>
                </typeReference>
                <child xsi:type="references:SelfReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.5"/>
                  </next>
                  <self xsi:type="literals:Super"/>
                </child>
              </value>
            </expression>
          </statements>
          <catcheBlocks>
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/Error.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:StringReference" value="Clone not supported: "/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.14/@statements.1/@catcheBlocks.0/@parameter"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
              </throwable>
            </statements>
            <parameter name="e">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/CloneNotSupportedException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </parameter>
          </catcheBlocks>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="copyOfBase">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharacterIterator.class.xmi#//@classifiers.0/@members.10"/>
                </next>
              </child>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.14/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.0"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.14/@statements.2/@variable"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@members.14/@statements.0/@variable"/>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/*&#xA;     * This class exists to work around a bug in incorrect implementations&#xA;     * of CharacterIterator, which incorrectly handle setIndex(endIndex).&#xA;     * This iterator relies only on base.setIndex(n) where n is less than&#xA;     * endIndex.&#xA;     *&#xA;     * One caveat:  if the base iterator's begin and end indices change&#xA;     * the change will not be reflected by this wrapper.  Does that matter?&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <implements xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </implements>
      <implements xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../lang/Cloneable.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </implements>
    </members>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="BreakIterator.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
