<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="DateFormat.java">
  <comments>/*&#xA; * @(#)DateFormat.java&#x9;1.51 04/04/12&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/*&#xA; * (C) Copyright Taligent, Inc. 1996 - All Rights Reserved&#xA; * (C) Copyright IBM Corp. 1996 - All Rights Reserved&#xA; *&#xA; *   The original version of this source code and documentation is copyrighted&#xA; * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These&#xA; * materials are provided under terms of a License Agreement between Taligent&#xA; * and Sun. This technology is protected by multiple US and International&#xA; * patents. This notice and attribution to Taligent may not be removed.&#xA; *   Taligent is a registered trademark of Taligent, Inc.&#xA; *&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>text</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/InvalidObjectException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/HashMap.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/ResourceBundle.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/MissingResourceException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/TimeZone.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/GregorianCalendar.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Date.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>text</namespaces>
    <namespaces>resources</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="DateFormat">
    <members xsi:type="members:Field" name="calendar">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The calendar that &lt;code>DateFormat&lt;/code> uses to produce the time field&#xA;     * values needed to implement date and time formatting.  Subclasses should&#xA;     * initialize this to a calendar appropriate for the locale associated with&#xA;     * this &lt;code>DateFormat&lt;/code>.&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="numberFormat">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NumberFormat.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The number formatter that &lt;code>DateFormat&lt;/code> uses to format numbers&#xA;     * in dates and times.  Subclasses should initialize this to a number format&#xA;     * appropriate for the locale associated with this &lt;code>DateFormat&lt;/code>.&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="ERA_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for ERA field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="YEAR_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for YEAR field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="MONTH_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for MONTH field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DATE_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for DATE field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="HOUR_OF_DAY1_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for one-based HOUR_OF_DAY field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     * HOUR_OF_DAY1_FIELD is used for the one-based 24-hour clock.&#xA;     * For example, 23:59 + 01:00 results in 24:59.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="HOUR_OF_DAY0_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for zero-based HOUR_OF_DAY field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     * HOUR_OF_DAY0_FIELD is used for the zero-based 24-hour clock.&#xA;     * For example, 23:59 + 01:00 results in 00:59.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="MINUTE_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for MINUTE field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="SECOND_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for SECOND field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="MILLISECOND_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for MILLISECOND field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DAY_OF_WEEK_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for DAY_OF_WEEK field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DAY_OF_YEAR_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for DAY_OF_YEAR field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DAY_OF_WEEK_IN_MONTH_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for DAY_OF_WEEK_IN_MONTH field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="WEEK_OF_YEAR_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for WEEK_OF_YEAR field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="WEEK_OF_MONTH_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for WEEK_OF_MONTH field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="AM_PM_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for AM_PM field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="HOUR1_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for one-based HOUR field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     * HOUR1_FIELD is used for the one-based 12-hour clock.&#xA;     * For example, 11:30 PM + 1 hour results in 12:30 AM.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="HOUR0_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for zero-based HOUR field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     * HOUR0_FIELD is used for the zero-based 12-hour clock.&#xA;     * For example, 11:30 PM + 1 hour results in 00:30 AM.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="TIMEZONE_FIELD">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="17"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Useful constant for TIMEZONE field alignment.&#xA;     * Used in FieldPosition of date/time formatting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="7218322306649953788"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Proclaim serial compatibility with 1.1 FCS</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toAppendTo">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fieldPosition">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="FieldPosition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Overrides Format.&#xA;     * Formats a time object into a time string. Examples of time objects&#xA;     * are a time value expressed in milliseconds and a Date object.&#xA;     * @param obj must be a Number or a Date.&#xA;     * @param toAppendTo the string buffer for the returning time string.&#xA;     * @return the formatted time string.&#xA;     * @param fieldPosition keeps track of the position of the field&#xA;     * within the returned string.&#xA;     * On input: an alignment field,&#xA;     * if desired. On output: the offsets of the alignment field. For&#xA;     * example, given a time text &quot;1996.07.10 AD at 15:08:56 PDT&quot;,&#xA;     * if the given fieldPosition is DateFormat.YEAR_FIELD, the&#xA;     * begin index and end index of fieldPosition will be set to&#xA;     * 0 and 4, respectively.&#xA;     * Notice that if the same time field appears&#xA;     * more than once in a pattern, the fieldPosition will be set for the first&#xA;     * occurrence of that time field. For instance, formatting a Date to&#xA;     * the time string &quot;1 PM PDT (Pacific Daylight Time)&quot; using the pattern&#xA;     * &quot;h a z (zzzz)&quot; and the alignment field DateFormat.TIMEZONE_FIELD,&#xA;     * the begin index and end index of fieldPosition will be set to&#xA;     * 5 and 8, respectively, for the first occurrence of the timezone&#xA;     * pattern character 'z'.&#xA;     * @see java.text.Format&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../util/Date.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../util/Date.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
              <arguments xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../util/Date.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="expressions:NestedExpression">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Number.class.xmi#//@classifiers.0/@members.3"/>
                  </next>
                  <expression xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../lang/Number.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
                  </expression>
                </arguments>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
            </returnValue>
          </statement>
          <condition xsi:type="expressions:InstanceOfExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Number.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          </condition>
          <elseStatement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Cannot format given Object as a Date"/>
            </throwable>
          </elseStatement>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="date">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toAppendTo">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fieldPosition">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="FieldPosition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Formats a Date into a date/time string.&#xA;     * @param date a Date to be formatted into a date/time string.&#xA;     * @param toAppendTo the string buffer for the returning date/time string.&#xA;     * @param fieldPosition keeps track of the position of the field&#xA;     * within the returned string.&#xA;     * On input: an alignment field,&#xA;     * if desired. On output: the offsets of the alignment field. For&#xA;     * example, given a time text &quot;1996.07.10 AD at 15:08:56 PDT&quot;,&#xA;     * if the given fieldPosition is DateFormat.YEAR_FIELD, the&#xA;     * begin index and end index of fieldPosition will be set to&#xA;     * 0 and 4, respectively.&#xA;     * Notice that if the same time field appears&#xA;     * more than once in a pattern, the fieldPosition will be set for the first&#xA;     * occurrence of that time field. For instance, formatting a Date to&#xA;     * the time string &quot;1 PM PDT (Pacific Daylight Time)&quot; using the pattern&#xA;     * &quot;h a z (zzzz)&quot; and the alignment field DateFormat.TIMEZONE_FIELD,&#xA;     * the begin index and end index of fieldPosition will be set to&#xA;     * 5 and 8, respectively, for the first occurrence of the timezone&#xA;     * pattern character 'z'.&#xA;     * @return the formatted date/time string.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="date">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Formats a Date into a date/time string.&#xA;     * @param date the time value to be formatted into a time string.&#xA;     * @return the formatted time string.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </arguments>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DontCareFieldPosition.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="DontCareFieldPosition.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="parse">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Date.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ParseException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Parses text from the beginning of the given string to produce a date.&#xA;     * The method may not use the entire text of the given string.&#xA;     * &lt;p>&#xA;     * See the {@link #parse(String, ParsePosition)} method for more information&#xA;     * on date parsing.&#xA;     *&#xA;     * @param source A &lt;code>String&lt;/code> whose beginning should be parsed.&#xA;     * @return A &lt;code>Date&lt;/code> parsed from the string.&#xA;     * @exception ParseException if the beginning of the specified string&#xA;     *            cannot be parsed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="pos">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="ParsePosition.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="ParsePosition.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../util/Date.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="ParseException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="Unparseable date: &quot;"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
              <children xsi:type="references:StringReference" value="&quot;"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="ParsePosition.class.xmi#//@classifiers.0/@members.1"/>
              </next>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="ParsePosition.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="parse">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Date.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ParsePosition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Parse a date/time string according to the given parse position.  For&#xA;     * example, a time text &quot;07/10/96 4:5 PM, PDT&quot; will be parsed into a Date&#xA;     * that is equivalent to Date(837039928046).&#xA;     *&#xA;     * &lt;p> By default, parsing is lenient: If the input is not in the form used&#xA;     * by this object's format method but can still be parsed as a date, then&#xA;     * the parse succeeds.  Clients may insist on strict adherence to the&#xA;     * format by calling setLenient(false).&#xA;     *&#xA;     * @see java.text.DateFormat#setLenient(boolean)&#xA;     *&#xA;     * @param source  The date/time string to be parsed&#xA;     *&#xA;     * @param pos   On input, the position at which to start parsing; on&#xA;     *              output, the position at which parsing terminated, or the&#xA;     *              start position if the parse failed.&#xA;     *&#xA;     * @return      A Date, or null if the input could not be parsed&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="parseObject">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ParsePosition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Parses text from a string to produce a &lt;code>Date&lt;/code>.&#xA;     * &lt;p>&#xA;     * The method attempts to parse text starting at the index given by&#xA;     * &lt;code>pos&lt;/code>.&#xA;     * If parsing succeeds, then the index of &lt;code>pos&lt;/code> is updated&#xA;     * to the index after the last character used (parsing does not necessarily&#xA;     * use all characters up to the end of the string), and the parsed&#xA;     * date is returned. The updated &lt;code>pos&lt;/code> can be used to&#xA;     * indicate the starting point for the next call to this method.&#xA;     * If an error occurs, then the index of &lt;code>pos&lt;/code> is not&#xA;     * changed, the error index of &lt;code>pos&lt;/code> is set to the index of&#xA;     * the character where the error occurred, and null is returned.&#xA;     * &lt;p>&#xA;     * See the {@link #parse(String, ParsePosition)} method for more information&#xA;     * on date parsing.&#xA;     *&#xA;     * @param source A &lt;code>String&lt;/code>, part of which should be parsed.&#xA;     * @param pos A &lt;code>ParsePosition&lt;/code> object with index and error&#xA;     *            index information as described above.&#xA;     * @return A &lt;code>Date&lt;/code> parsed from the string. In case of&#xA;     *         error, returns null.&#xA;     * @exception NullPointerException if &lt;code>pos&lt;/code> is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="FULL">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constant for full style pattern.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="LONG">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constant for long style pattern.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MEDIUM">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constant for medium style pattern.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SHORT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constant for short style pattern.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DEFAULT">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constant for default style pattern.  Its value is MEDIUM.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getTimeInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the time formatter with the default formatting style&#xA;     * for the default locale.&#xA;     * @return a time formatter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.54">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getTimeInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="style">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the time formatter with the given formatting style&#xA;     * for the default locale.&#xA;     * @param style the given formatting style. For example,&#xA;     * SHORT for &quot;h:mm a&quot; in the US locale.&#xA;     * @return a time formatter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.54">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getTimeInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="style">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the time formatter with the given formatting style&#xA;     * for the given locale.&#xA;     * @param style the given formatting style. For example,&#xA;     * SHORT for &quot;h:mm a&quot; in the US locale.&#xA;     * @param aLocale the given locale.&#xA;     * @return a time formatter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.54">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDateInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the date formatter with the default formatting style&#xA;     * for the default locale.&#xA;     * @return a date formatter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.54">
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDateInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="style">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the date formatter with the given formatting style&#xA;     * for the default locale.&#xA;     * @param style the given formatting style. For example,&#xA;     * SHORT for &quot;M/d/yy&quot; in the US locale.&#xA;     * @return a date formatter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.54">
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDateInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="style">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the date formatter with the given formatting style&#xA;     * for the given locale.&#xA;     * @param style the given formatting style. For example,&#xA;     * SHORT for &quot;M/d/yy&quot; in the US locale.&#xA;     * @param aLocale the given locale.&#xA;     * @return a date formatter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.54">
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDateTimeInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the date/time formatter with the default formatting style&#xA;     * for the default locale.&#xA;     * @return a date/time formatter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.54">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDateTimeInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dateStyle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeStyle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the date/time formatter with the given date and time&#xA;     * formatting styles for the default locale.&#xA;     * @param dateStyle the given date formatting style. For example,&#xA;     * SHORT for &quot;M/d/yy&quot; in the US locale.&#xA;     * @param timeStyle the given time formatting style. For example,&#xA;     * SHORT for &quot;h:mm a&quot; in the US locale.&#xA;     * @return a date/time formatter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.54">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDateTimeInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dateStyle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeStyle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the date/time formatter with the given formatting styles&#xA;     * for the given locale.&#xA;     * @param dateStyle the given date formatting style.&#xA;     * @param timeStyle the given time formatting style.&#xA;     * @param aLocale the given locale.&#xA;     * @return a date/time formatter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.54">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Get a default date/time formatter that uses the SHORT style for both the&#xA;     * date and the time.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.39">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAvailableLocales">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an array of all locales for which the&#xA;     * &lt;code>get*Instance&lt;/code> methods of this class can return&#xA;     * localized instances.&#xA;     * The array returned must contain at least a &lt;code>Locale&lt;/code>&#xA;     * instance equal to {@link java.util.Locale#US Locale.US}.&#xA;     *&#xA;     * @return An array of locales for which localized&#xA;     *         &lt;code>DateFormat&lt;/code> instances are available.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0/@members.7"/>
            <arguments xsi:type="references:StringReference" value="DateTimePatterns"/>
          </next>
          <target xsi:type="classifiers:Class" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setCalendar">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newCalendar">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Set the calendar to be used by this date format.  Initially, the default&#xA;     * calendar for the specified or default locale is used.&#xA;     * @param newCalendar the new Calendar to be used by the date format&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCalendar">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the calendar associated with this date/time formatter.&#xA;     * @return the calendar associated with this date/time formatter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setNumberFormat">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newNumberFormat">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="NumberFormat.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allows you to set the number formatter.&#xA;     * @param newNumberFormat the given new NumberFormat.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNumberFormat">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NumberFormat.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the number formatter which this date/time formatter uses to&#xA;     * format and parse a time.&#xA;     * @return the number formatter which this date/time formatter uses.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setTimeZone">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="zone">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/TimeZone.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the time zone for the calendar of this DateFormat object.&#xA;     * @param zone the given new time zone.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../util/Calendar.class.xmi#//@classifiers.0/@members.125"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getTimeZone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/TimeZone.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the time zone.&#xA;     * @return the time zone associated with the calendar of DateFormat.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../util/Calendar.class.xmi#//@classifiers.0/@members.126"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setLenient">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lenient">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Specify whether or not date/time parsing is to be lenient.  With&#xA;     * lenient parsing, the parser may use heuristics to interpret inputs that&#xA;     * do not precisely match this object's format.  With strict parsing,&#xA;     * inputs must match this object's format.&#xA;     * @param lenient when true, parsing is lenient&#xA;     * @see java.util.Calendar#setLenient&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../util/Calendar.class.xmi#//@classifiers.0/@members.129"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isLenient">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tell whether date/time parsing is to be lenient.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../util/Calendar.class.xmi#//@classifiers.0/@members.130"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <comments>// just enough fields for a reasonable distribution</comments>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Overrides hashCode&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="NumberFormat.class.xmi#//@classifiers.0/@members.45"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Overrides equals&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
              </next>
            </children>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="other">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <comments>// calendar.equivalentTo(other.calendar) // THIS API DOESN'T EXIST YET!</comments>
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../util/Calendar.class.xmi#//@classifiers.0/@members.132"/>
                </next>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.2/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../util/Calendar.class.xmi#//@classifiers.0/@members.132"/>
                  </next>
                </next>
              </children>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../util/Calendar.class.xmi#//@classifiers.0/@members.134"/>
                </next>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.2/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../util/Calendar.class.xmi#//@classifiers.0/@members.134"/>
                  </next>
                </next>
              </children>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../util/Calendar.class.xmi#//@classifiers.0/@members.130"/>
                </next>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.2/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../util/Calendar.class.xmi#//@classifiers.0/@members.130"/>
                  </next>
                </next>
              </children>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.4"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.2/@variable">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../util/Calendar.class.xmi#//@classifiers.0/@members.126"/>
                      </next>
                    </next>
                  </arguments>
                </next>
                <target xsi:type="members:ClassMethod" href="../util/Calendar.class.xmi#//@classifiers.0/@members.126"/>
              </next>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="NumberFormat.class.xmi#//@classifiers.0/@members.46"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.2/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                </arguments>
              </next>
            </children>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Overrides Cloneable&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="other">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Format.class.xmi#//@classifiers.0/@members.7"/>
              </next>
              <self xsi:type="literals:Super"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/Calendar.class.xmi#//@classifiers.0/@members.141"/>
              </next>
            </child>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="NumberFormat.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="NumberFormat.class.xmi#//@classifiers.0/@members.47"/>
              </next>
            </child>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeStyle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dateStyle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="flags">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="loc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Creates a DateFormat with the given time and/or date style in the given&#xA;     * locale.&#xA;     * @param timeStyle a value from 0 to 3 indicating the time format,&#xA;     * ignored if flags is 2&#xA;     * @param dateStyle a value from 0 to 3 indicating the time format,&#xA;     * ignored if flags is 1&#xA;     * @param flags either 1 for a time format, 2 for a date format,&#xA;     * or 3 for a date/time format&#xA;     * @param loc the locale for the format&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value="Illegal time style "/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AndExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.2"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value="Illegal date style "/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AndExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.2"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SimpleDateFormat.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.3"/>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="SimpleDateFormat.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="M/d/yy h:mm a"/>
            </returnValue>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../util/MissingResourceException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:Constructor" name="DateFormat">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Create a new date format.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="classifiers:Class" name="Field">
      <members xsi:type="members:Field" name="serialVersionUID">
        <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="7441350119349544720"/>
        <typeReference xsi:type="types:Long"/>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Proclaim serial compatibility with 1.4 FCS</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="instanceMap">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../util/HashMap.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="18"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// table of all instances in this class, used by readResolve</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="calendarToFieldMapping">
        <initialValue xsi:type="arrays:ArrayInstantiationBySize">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <sizes xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.18"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </sizes>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <arrayDimensionsBefore/>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Maps from Calendar constant (such as Calendar.ERA) to Field</comments>
          <comments>// constant (such as Field.ERA).</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="calendarField">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>/** Calendar field. */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:ClassMethod" name="ofCalendarField">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="calendarField">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Returns the &lt;code>Field&lt;/code> constant that corresponds to&#xA;         * the &lt;code>Calendar&lt;/code> constant &lt;code>calendarField&lt;/code>.&#xA;         * If there is no direct mapping between the &lt;code>Calendar&lt;/code>&#xA;         * constant and a &lt;code>Field&lt;/code>, null is returned.&#xA;         *&#xA;         * @throws IllegalArgumentException if &lt;code>calendarField&lt;/code> is&#xA;         *         not the value of a &lt;code>Calendar&lt;/code> field constant.&#xA;         * @param calendarField Calendar field constant&#xA;         * @return Field instance representing calendarField.&#xA;         * @see java.util.Calendar&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:StringReference" value="Unknown Calendar constant "/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.4/@parameters.0"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
              </throwable>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalOrExpression">
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.4/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </children>
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.4/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.2">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.2">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.4/@parameters.0"/>
            </arraySelectors>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:Constructor" name="Field">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.5/@parameters.0"/>
            <callTarget xsi:type="literals:Super"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.3"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.5/@parameters.1"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../util/Map.class.xmi#//@classifiers.0/@members.5"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.5/@parameters.0"/>
                  <arguments xsi:type="references:SelfReference">
                    <self xsi:type="literals:This"/>
                  </arguments>
                </next>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.2">
                      <comments>// assert(calendarField &lt; Calendar.FIELD_COUNT);</comments>
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.5/@parameters.1"/>
                      </arraySelectors>
                    </child>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:SelfReference">
                      <self xsi:type="literals:This"/>
                    </value>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.5/@parameters.1"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
              </next>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56">
                <next xsi:type="references:ReflectiveClassReference"/>
              </next>
            </children>
          </condition>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="name">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="calendarField">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected">
          <comments>/**&#xA;         * Creates a Field with the specified name.&#xA;         * calendarField is used to identify the &lt;code>Calendar&lt;/code>&#xA;         * field this attribute represents. Use -1 if this field does&#xA;         * not have a corresponding &lt;code>Calendar&lt;/code> value.&#xA;         *&#xA;         * @param name Name of the attribute&#xA;         * @param calendarField Calendar constant&#xA;         */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:ClassMethod" name="getCalendarField">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Returns the &lt;code>Calendar&lt;/code> field associated with this&#xA;         * attribute. For example, if this represents the hours field of&#xA;         * a &lt;code>Calendar&lt;/code>, this would return&#xA;         * &lt;code>Calendar.HOUR&lt;/code>. If there is no corresponding&#xA;         * &lt;code>Calendar&lt;/code> constant, this will return -1.&#xA;         *&#xA;         * @return Calendar constant for this field&#xA;         * @see java.util.Calendar&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.3"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="readResolve">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/InvalidObjectException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Protected">
          <comments>/**&#xA;         * Resolves instances being deserialized to the predefined constants.&#xA;         *&#xA;&#x9; * @throws InvalidObjectException if the constant could not be&#xA;         *         resolved.&#xA;         * @return resolved DateFormat.Field constant&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../io/InvalidObjectException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="subclass didn't correctly implement readResolve"/>
              </throwable>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
              </next>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56">
                <next xsi:type="references:ReflectiveClassReference"/>
              </next>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="instance">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../util/Map.class.xmi#//@classifiers.0/@members.4"/>
                <arguments xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="AttributedCharacterIterator$Attribute.class.xmi#//@classifiers.0/@members.10"/>
                </arguments>
              </next>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.7/@statements.1/@variable"/>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@members.7/@statements.1/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../io/InvalidObjectException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="unknown attribute name"/>
              </throwable>
            </statements>
          </elseStatement>
        </statements>
      </members>
      <members xsi:type="members:Field" name="ERA">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="era"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>//</comments>
          <comments>// The constants</comments>
          <comments>//</comments>
          <comments>/**&#xA;         * Constant identifying the era field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="YEAR">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="year"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the year field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="MONTH">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="month"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.2"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the month field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="DAY_OF_MONTH">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="day of month"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.6"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the day of month field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="HOUR_OF_DAY1">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="hour of day 1"/>
          <arguments xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the hour of day field, where the legal values&#xA;         * are 1 to 24.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="HOUR_OF_DAY0">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="hour of day"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.12"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the hour of day field, where the legal values&#xA;         * are 0 to 23.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="MINUTE">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="minute"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.13"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the minute field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="SECOND">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="second"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.14"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the second field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="MILLISECOND">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="millisecond"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.15"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the millisecond field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="DAY_OF_WEEK">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="day of week"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.8"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the day of week field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="DAY_OF_YEAR">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="day of year"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.7"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the day of year field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="DAY_OF_WEEK_IN_MONTH">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="day of week in month"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.9"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the day of week field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="WEEK_OF_YEAR">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="week of year"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.3"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the week of year field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="WEEK_OF_MONTH">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="week of month"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.4"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the week of month field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="AM_PM">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="am pm"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.10"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the time of day indicator&#xA;         * (e.g. &quot;a.m.&quot; or &quot;p.m.&quot;) field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="HOUR1">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="hour 1"/>
          <arguments xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the hour field, where the legal values are&#xA;         * 1 to 12.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="HOUR0">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="hour"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../util/Calendar.class.xmi#//@classifiers.0/@members.11"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the hour field, where the legal values are&#xA;         * 0 to 11.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Field" name="TIME_ZONE">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.56"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="time zone"/>
          <arguments xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.56"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant identifying the time zone field.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Defines constants that are used as attribute keys in the&#xA;     * &lt;code>AttributedCharacterIterator&lt;/code> returned&#xA;     * from &lt;code>DateFormat.formatToCharacterIterator&lt;/code> and as&#xA;     * field identifiers in &lt;code>FieldPosition&lt;/code>.&#xA;     * &lt;p>&#xA;     * The class also provides two methods to map&#xA;     * between its constants and the corresponding Calendar constants.&#xA;     *&#xA;     * @since 1.4&#xA;     * @see java.util.Calendar&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <namespaces>Format</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Format$Field.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </extends>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * DateFormat is an abstract class for date/time formatting subclasses which&#xA; * formats and parses dates or time in a language-independent manner.&#xA; * The date/time formatting subclass, such as SimpleDateFormat, allows for&#xA; * formatting (i.e., date -> text), parsing (text -> date), and&#xA; * normalization.  The date is represented as a &lt;code>Date&lt;/code> object or&#xA; * as the milliseconds since January 1, 1970, 00:00:00 GMT.&#xA; *&#xA; * &lt;p>DateFormat provides many class methods for obtaining default date/time&#xA; * formatters based on the default or a given locale and a number of formatting&#xA; * styles. The formatting styles include FULL, LONG, MEDIUM, and SHORT. More&#xA; * detail and examples of using these styles are provided in the method&#xA; * descriptions.&#xA; *&#xA; * &lt;p>DateFormat helps you to format and parse dates for any locale.&#xA; * Your code can be completely independent of the locale conventions for&#xA; * months, days of the week, or even the calendar format: lunar vs. solar.&#xA; *&#xA; * &lt;p>To format a date for the current Locale, use one of the&#xA; * static factory methods:&#xA; * &lt;pre>&#xA; *  myString = DateFormat.getDateInstance().format(myDate);&#xA; * &lt;/pre>&#xA; * &lt;p>If you are formatting multiple dates, it is&#xA; * more efficient to get the format and use it multiple times so that&#xA; * the system doesn't have to fetch the information about the local&#xA; * language and country conventions multiple times.&#xA; * &lt;pre>&#xA; *  DateFormat df = DateFormat.getDateInstance();&#xA; *  for (int i = 0; i &lt; myDate.length; ++i) {&#xA; *    output.println(df.format(myDate[i]) + &quot;; &quot;);&#xA; *  }&#xA; * &lt;/pre>&#xA; * &lt;p>To format a date for a different Locale, specify it in the&#xA; * call to getDateInstance().&#xA; * &lt;pre>&#xA; *  DateFormat df = DateFormat.getDateInstance(DateFormat.LONG, Locale.FRANCE);&#xA; * &lt;/pre>&#xA; * &lt;p>You can use a DateFormat to parse also.&#xA; * &lt;pre>&#xA; *  myDate = df.parse(myString);&#xA; * &lt;/pre>&#xA; * &lt;p>Use getDateInstance to get the normal date format for that country.&#xA; * There are other static factory methods available.&#xA; * Use getTimeInstance to get the time format for that country.&#xA; * Use getDateTimeInstance to get a date and time format. You can pass in &#xA; * different options to these factory methods to control the length of the&#xA; * result; from SHORT to MEDIUM to LONG to FULL. The exact result depends&#xA; * on the locale, but generally:&#xA; * &lt;ul>&lt;li>SHORT is completely numeric, such as 12.13.52 or 3:30pm&#xA; * &lt;li>MEDIUM is longer, such as Jan 12, 1952&#xA; * &lt;li>LONG is longer, such as January 12, 1952 or 3:30:32pm&#xA; * &lt;li>FULL is pretty completely specified, such as&#xA; * Tuesday, April 12, 1952 AD or 3:30:42pm PST.&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p>You can also set the time zone on the format if you wish.&#xA; * If you want even more control over the format or parsing,&#xA; * (or want to give your users more control),&#xA; * you can try casting the DateFormat you get from the factory methods&#xA; * to a SimpleDateFormat. This will work for the majority&#xA; * of countries; just remember to put it in a try block in case you&#xA; * encounter an unusual one.&#xA; *&#xA; * &lt;p>You can also use forms of the parse and format methods with&#xA; * ParsePosition and FieldPosition to&#xA; * allow you to&#xA; * &lt;ul>&lt;li>progressively parse through pieces of a string.&#xA; * &lt;li>align any particular field, or find out where it is for selection&#xA; * on the screen.&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;h4>&lt;a name=&quot;synchronization&quot;>Synchronization&lt;/a>&lt;/h4>&#xA; *&#xA; * &lt;p>&#xA; * Date formats are not synchronized.&#xA; * It is recommended to create separate format instances for each thread.&#xA; * If multiple threads access a format concurrently, it must be synchronized&#xA; * externally.&#xA; *&#xA; * @see          Format&#xA; * @see          NumberFormat&#xA; * @see          SimpleDateFormat&#xA; * @see          java.util.Calendar&#xA; * @see          java.util.GregorianCalendar&#xA; * @see          java.util.TimeZone&#xA; * @version      1.51 04/12/04&#xA; * @author       Mark Davis, Chen-Lieh Huang, Alan Liu&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="Format.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
