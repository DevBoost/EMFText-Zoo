<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="RuleBasedCollator.java">
  <comments>/*&#xA; * @(#)RuleBasedCollator.java&#x9;1.37 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/*&#xA; * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved&#xA; * (C) Copyright IBM Corp. 1996-1998 - All Rights Reserved&#xA; *&#xA; *   The original version of this source code and documentation is copyrighted&#xA; * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These&#xA; * materials are provided under terms of a License Agreement between Taligent&#xA; * and Sun. This technology is protected by multiple US and International&#xA; * patents. This notice and attribution to Taligent may not be removed.&#xA; *   Taligent is a registered trademark of Taligent, Inc.&#xA; *&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>text</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Vector.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>text</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/text/Normalizer.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>text</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/text/NormalizerUtilities.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="RuleBasedCollator">
    <members xsi:type="members:Constructor" name="RuleBasedCollator">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.5"/>
            </next>
            <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rules">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ParseException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// IMPLEMENTATION NOTES:  The implementation of the collation algorithm is</comments>
        <comments>// divided across three classes: RuleBasedCollator, RBCollationTables, and</comments>
        <comments>// CollationElementIterator.  RuleBasedCollator contains the collator's</comments>
        <comments>// transient state and includes the code that uses the other classes to</comments>
        <comments>// implement comparison and sort-key building.  RuleBasedCollator also</comments>
        <comments>// contains the logic to handle French secondary accent sorting.</comments>
        <comments>// A RuleBasedCollator has two CollationElementIterators.  State doesn't</comments>
        <comments>// need to be preserved in these objects between calls to compare() or</comments>
        <comments>// getCollationKey(), but the objects persist anyway to avoid wasting extra</comments>
        <comments>// creation time.  compare() and getCollationKey() are synchronized to ensure</comments>
        <comments>// thread safety with this scheme.  The CollationElementIterator is responsible</comments>
        <comments>// for generating collation elements from strings and returning one element at</comments>
        <comments>// a time (sometimes there's a one-to-many or many-to-one mapping between</comments>
        <comments>// characters and collation elements-- this class handles that).</comments>
        <comments>// CollationElementIterator depends on RBCollationTables, which contains the</comments>
        <comments>// collator's static state.  RBCollationTables contains the actual data</comments>
        <comments>// tables specifying the collation order of characters for a particular locale</comments>
        <comments>// or use.  It also contains the base logic that CollationElementIterator</comments>
        <comments>// uses to map from characters to collation elements.  A single RBCollationTables</comments>
        <comments>// object is shared among all RuleBasedCollators for the same locale, and</comments>
        <comments>// thus by all the CollationElementIterators they create.</comments>
        <comments>/**&#xA;     * RuleBasedCollator constructor.  This takes the table rules and builds&#xA;     * a collation table out of them.  Please see RuleBasedCollator class&#xA;     * description for more details on the collation rule syntax.&#xA;     * @see java.util.Locale&#xA;     * @param rules the collation rules to build the collation table from.&#xA;     * @exception ParseException A format exception&#xA;     * will be thrown if the build process of the rules fails. For&#xA;     * example, build rule &quot;a &lt; ? &lt; d&quot; will cause the constructor to&#xA;     * throw the ParseException because the '?' is not quoted.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="RuleBasedCollator">
      <comments>/**&#xA;     * RuleBasedCollator constructor.  This takes the table rules and builds&#xA;     * a collation table out of them.  Please see RuleBasedCollator class&#xA;     * description for more details on the collation rule syntax.&#xA;     * @see java.util.Locale&#xA;     * @param rules the collation rules to build the collation table from.&#xA;     * @param decomp the decomposition strength used to build the&#xA;     * collation table and to perform comparisons.&#xA;     * @exception ParseException A format exception&#xA;     * will be thrown if the build process of the rules fails. For&#xA;     * example, build rule &quot;a &lt; ? &lt; d&quot; will cause the constructor to&#xA;     * throw the ParseException because the '?' is not quoted.&#xA;     */</comments>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.20"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.2"/>
            </next>
            <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.22"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="RBCollationTables.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.1"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rules">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="decomp">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ParseException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:Constructor" name="RuleBasedCollator">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.20"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.19"/>
            </next>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.22"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.21"/>
            </next>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="that">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * &quot;Copy constructor.&quot;  Used in clone() for performance.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getRules">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the table-based rules for the collation object.&#xA;     * @return returns the collation rules that the table collation object&#xA;     * was created from.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="RBCollationTables.class.xmi#//@classifiers.0/@members.20"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCollationElementIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return a CollationElementIterator for the given String.&#xA;     * @see java.text.CollationElementIterator&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
          <arguments xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCollationElementIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharacterIterator.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return a CollationElementIterator for the given String.&#xA;     * @see java.text.CollationElementIterator&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          <arguments xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compare">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="target">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares the character data stored in two different strings based on the&#xA;     * collation rules.  Returns information about whether a string is less&#xA;     * than, greater than or equal to another string in a language.&#xA;     * This can be overriden in a subclass.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Int">
            <comments>// The basic algorithm here is that we use CollationElementIterators</comments>
            <comments>// to step through both the source and target strings.  We compare each</comments>
            <comments>// collation element in the source string against the corresponding one</comments>
            <comments>// in the target, checking for differences.</comments>
            <comments>//</comments>
            <comments>// If a difference is found, we set &lt;result> to LESS or GREATER to</comments>
            <comments>// indicate whether the source string is less or greater than the target.</comments>
            <comments>//</comments>
            <comments>// However, it's not that simple.  If we find a tertiary difference</comments>
            <comments>// (e.g. 'A' vs. 'a') near the beginning of a string, it can be</comments>
            <comments>// overridden by a primary difference (e.g. &quot;A&quot; vs. &quot;B&quot;) later in</comments>
            <comments>// the string.  For example, &quot;AA&quot; &lt; &quot;aB&quot;, even though 'A' > 'a'.</comments>
            <comments>//</comments>
            <comments>// To keep track of this, we use strengthResult to keep track of the</comments>
            <comments>// strength of the most significant difference that has been found</comments>
            <comments>// so far.  When we find a difference whose strength is greater than</comments>
            <comments>// strengthResult, it overrides the last difference (if any) that</comments>
            <comments>// was found.</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.11"/>
            </next>
            <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.4">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.21"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
              </next>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.4">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.1"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.21"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.1"/>
              </next>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sOrder">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <additionalLocalVariables name="tOrder">
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </additionalLocalVariables>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="initialCheckSecTer">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="expressions:RelationExpression">
            <children xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.19"/>
            </children>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="checkSecTer">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.4/@variable"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="checkTertiary">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="expressions:RelationExpression">
            <children xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.19"/>
            </children>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.2"/>
              </next>
              <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="gets">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral" value="true"/>
          <additionalLocalVariables name="gett">
            <initialValue xsi:type="literals:BooleanLiteral" value="true"/>
          </additionalLocalVariables>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <comments>// if ( pSOrder != pTOrder )</comments>
          <statements xsi:type="statements:Condition">
            <comments>// Get the next collation element in each of the strings, unless</comments>
            <comments>// we've been requested to skip it.</comments>
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.12"/>
                  </next>
                </value>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.7/@variable"/>
            <elseStatement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.7/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral" value="true"/>
              </expression>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable/@additionalLocalVariables.0"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.12"/>
                  </next>
                </value>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.7/@variable/@additionalLocalVariables.0"/>
            <elseStatement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.7/@variable/@additionalLocalVariables.0"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral" value="true"/>
              </expression>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// If we've hit the end of one of the strings, jump out of the loop</comments>
            <statement xsi:type="statements:Break"/>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
                  </children>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable/@additionalLocalVariables.0"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
                  </children>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="pSOrder">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.14"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="pTOrder">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.14"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable/@additionalLocalVariables.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// If there's no difference at this position, we can skip it</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.5/@variable">
                            <comments>// in french, a secondary difference more to the right is stronger,</comments>
                            <comments>// so accents have to be checked with each base element</comments>
                          </child>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.4/@variable"/>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.6/@variable">
                            <comments>// but tertiary differences are less important than the first</comments>
                            <comments>// secondary difference, so checking tertiary remains disabled</comments>
                          </child>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="literals:BooleanLiteral"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:UnaryExpression">
                      <operators xsi:type="operators:Negate"/>
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.5/@variable"/>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="RBCollationTables.class.xmi#//@classifiers.0/@members.21"/>
                    </next>
                  </children>
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.3/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </children>
                </condition>
              </statements>
              <statements xsi:type="statements:Continue"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable/@additionalLocalVariables.0"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// Compare primary differences first.</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.7/@variable/@additionalLocalVariables.0">
                        <comments>// The entire source element is ignorable.</comments>
                        <comments>// Skip to the next source element, but don't fetch another target element.</comments>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="literals:BooleanLiteral"/>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:Continue"/>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </condition>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.7/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="literals:BooleanLiteral"/>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:Continue"/>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable/@additionalLocalVariables.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </condition>
              </statements>
              <statements xsi:type="statements:Condition">
                <comments>// The source and target elements aren't ignorable, but it's still possible</comments>
                <comments>// for the primary component of one of the elements to be ignorable....</comments>
                <statement xsi:type="statements:Block">
                  <comments>// primary order in source is ignorable</comments>
                  <statements xsi:type="statements:Condition">
                    <comments>// The source's primary is ignorable, but the target's isn't.  We treat ignorables</comments>
                    <comments>// as a secondary difference, so remember that we found one.</comments>
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="references:IdentifierReference">
                            <next xsi:type="references:IdentifierReference">
                              <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.12"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
                          </value>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.5/@variable">
                            <comments>// (strength is SECONDARY)</comments>
                          </child>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="literals:BooleanLiteral"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.5/@variable"/>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.7/@variable/@additionalLocalVariables.0">
                        <comments>// Skip to the next source element, but don't fetch another target element.</comments>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="literals:BooleanLiteral"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.3/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </condition>
                <elseStatement xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:Condition">
                      <comments>// record differences - see the comment above.</comments>
                      <statement xsi:type="statements:Block">
                        <statements xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="expressions:AssignmentExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable"/>
                            <assignmentOperator xsi:type="operators:Assignment"/>
                            <value xsi:type="references:IdentifierReference">
                              <next xsi:type="references:IdentifierReference">
                                <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.10"/>
                              </next>
                              <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
                            </value>
                          </expression>
                        </statements>
                        <statements xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="expressions:AssignmentExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.5/@variable">
                              <comments>// (strength is SECONDARY)</comments>
                            </child>
                            <assignmentOperator xsi:type="operators:Assignment"/>
                            <value xsi:type="literals:BooleanLiteral"/>
                          </expression>
                        </statements>
                      </statement>
                      <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.5/@variable"/>
                    </statements>
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.7/@variable">
                          <comments>// Skip to the next source element, but don't fetch another target element.</comments>
                        </child>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="literals:BooleanLiteral"/>
                      </expression>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.4/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </condition>
                  <elseStatement xsi:type="statements:Block">
                    <statements xsi:type="statements:Condition">
                      <comments>// Neither of the orders is ignorable, and we already know that the primary</comments>
                      <comments>// orders are different because of the (pSOrder != pTOrder) test above.</comments>
                      <comments>// Record the difference and stop the comparison.</comments>
                      <statement xsi:type="statements:Block">
                        <comments>// (strength is PRIMARY)</comments>
                        <statements xsi:type="statements:Return">
                          <returnValue xsi:type="references:IdentifierReference">
                            <next xsi:type="references:IdentifierReference">
                              <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.10"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
                          </returnValue>
                        </statements>
                      </statement>
                      <condition xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.3/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.4/@variable"/>
                        <relationOperators xsi:type="operators:LessThan"/>
                      </condition>
                      <elseStatement xsi:type="statements:Block">
                        <comments>// (strength is PRIMARY)</comments>
                        <statements xsi:type="statements:Return">
                          <returnValue xsi:type="references:IdentifierReference">
                            <next xsi:type="references:IdentifierReference">
                              <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.12"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
                          </returnValue>
                        </statements>
                      </elseStatement>
                    </statements>
                  </elseStatement>
                </elseStatement>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.3/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.4/@variable"/>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <comments>// if (checkSecTer)</comments>
              <statements xsi:type="statements:Condition">
                <comments>// else of if ( pSOrder != pTOrder )</comments>
                <comments>// primary order is the same, but complete order is different. So there</comments>
                <comments>// are no base elements at this point, only ignorables (Since the strings are</comments>
                <comments>// normalized)</comments>
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="secSOrder">
                      <typeReference xsi:type="types:Short">
                        <comments>// a secondary or tertiary difference may still matter</comments>
                      </typeReference>
                      <initialValue xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.15"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="secTOrder">
                      <typeReference xsi:type="types:Short"/>
                      <initialValue xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.15"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable/@additionalLocalVariables.0"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <comments>// (even in french, only the first secondary difference within</comments>
                      <comments>//  a base character matters)</comments>
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable">
                            <comments>// there is a secondary difference</comments>
                          </child>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="expressions:ConditionalExpression">
                            <child xsi:type="expressions:NestedExpression">
                              <expression xsi:type="expressions:RelationExpression">
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.6/@elseStatement/@statements.0/@statement/@statements.0/@variable"/>
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.6/@elseStatement/@statements.0/@statement/@statements.1/@variable"/>
                                <relationOperators xsi:type="operators:LessThan"/>
                              </expression>
                            </child>
                            <expressionIf xsi:type="references:IdentifierReference">
                              <next xsi:type="references:IdentifierReference">
                                <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.10"/>
                              </next>
                              <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
                            </expressionIf>
                            <expressionElse xsi:type="references:IdentifierReference">
                              <next xsi:type="references:IdentifierReference">
                                <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.12"/>
                              </next>
                              <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
                            </expressionElse>
                          </value>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.5/@variable">
                            <comments>// (strength is SECONDARY)</comments>
                          </child>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="literals:BooleanLiteral"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.6/@elseStatement/@statements.0/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.6/@elseStatement/@statements.0/@statement/@statements.1/@variable"/>
                    </condition>
                    <elseStatement xsi:type="statements:Block">
                      <statements xsi:type="statements:Condition">
                        <statement xsi:type="statements:Block">
                          <statements xsi:type="statements:LocalVariableStatement">
                            <variable name="terSOrder">
                              <typeReference xsi:type="types:Short">
                                <comments>// a tertiary difference may still matter</comments>
                              </typeReference>
                              <initialValue xsi:type="references:IdentifierReference">
                                <next xsi:type="references:MethodCall">
                                  <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.16"/>
                                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable"/>
                                </next>
                                <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
                              </initialValue>
                            </variable>
                          </statements>
                          <statements xsi:type="statements:LocalVariableStatement">
                            <variable name="terTOrder">
                              <typeReference xsi:type="types:Short"/>
                              <initialValue xsi:type="references:IdentifierReference">
                                <next xsi:type="references:MethodCall">
                                  <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.16"/>
                                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable/@additionalLocalVariables.0"/>
                                </next>
                                <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
                              </initialValue>
                            </variable>
                          </statements>
                          <statements xsi:type="statements:Condition">
                            <statement xsi:type="statements:Block">
                              <statements xsi:type="statements:ExpressionStatement">
                                <expression xsi:type="expressions:AssignmentExpression">
                                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable">
                                    <comments>// there is a tertiary difference</comments>
                                  </child>
                                  <assignmentOperator xsi:type="operators:Assignment"/>
                                  <value xsi:type="expressions:ConditionalExpression">
                                    <child xsi:type="expressions:NestedExpression">
                                      <expression xsi:type="expressions:RelationExpression">
                                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.6/@elseStatement/@statements.0/@statement/@statements.2/@elseStatement/@statements.0/@statement/@statements.0/@variable"/>
                                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.6/@elseStatement/@statements.0/@statement/@statements.2/@elseStatement/@statements.0/@statement/@statements.1/@variable"/>
                                        <relationOperators xsi:type="operators:LessThan"/>
                                      </expression>
                                    </child>
                                    <expressionIf xsi:type="references:IdentifierReference">
                                      <next xsi:type="references:IdentifierReference">
                                        <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.10"/>
                                      </next>
                                      <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
                                    </expressionIf>
                                    <expressionElse xsi:type="references:IdentifierReference">
                                      <next xsi:type="references:IdentifierReference">
                                        <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.12"/>
                                      </next>
                                      <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
                                    </expressionElse>
                                  </value>
                                </expression>
                              </statements>
                              <statements xsi:type="statements:ExpressionStatement">
                                <expression xsi:type="expressions:AssignmentExpression">
                                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.6/@variable">
                                    <comments>// (strength is TERTIARY)</comments>
                                  </child>
                                  <assignmentOperator xsi:type="operators:Assignment"/>
                                  <value xsi:type="literals:BooleanLiteral"/>
                                </expression>
                              </statements>
                            </statement>
                            <condition xsi:type="expressions:EqualityExpression">
                              <equalityOperators xsi:type="operators:NotEqual"/>
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.6/@elseStatement/@statements.0/@statement/@statements.2/@elseStatement/@statements.0/@statement/@statements.0/@variable"/>
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.8/@statement/@statements.6/@elseStatement/@statements.0/@statement/@statements.2/@elseStatement/@statements.0/@statement/@statements.1/@variable"/>
                            </condition>
                          </statements>
                        </statement>
                        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.6/@variable"/>
                      </statements>
                    </elseStatement>
                  </statements>
                </statement>
                <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.5/@variable"/>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// while()</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:DoWhileLoop">
            <comments>// (tOrder must be CollationElementIterator::NULLORDER,</comments>
            <comments>//  since this point is only reached when sOrder or tOrder is NULLORDER.)</comments>
            <comments>// The source string has more elements, but the target string hasn't.</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <comments>// (strength is PRIMARY)</comments>
                  <statements xsi:type="statements:Return">
                    <comments>// We found an additional non-ignorable base character in the source string.</comments>
                    <comments>// This is a primary difference, so the source is greater</comments>
                    <returnValue xsi:type="references:IdentifierReference">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.12"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
                    </returnValue>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.14"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </condition>
                <elseStatement xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:Condition">
                      <comments>// Additional secondary elements mean the source string is greater</comments>
                      <statement xsi:type="statements:Block">
                        <statements xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="expressions:AssignmentExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable"/>
                            <assignmentOperator xsi:type="operators:Assignment"/>
                            <value xsi:type="references:IdentifierReference">
                              <next xsi:type="references:IdentifierReference">
                                <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.12"/>
                              </next>
                              <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
                            </value>
                          </expression>
                        </statements>
                        <statements xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="expressions:AssignmentExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.5/@variable">
                              <comments>// (strength is SECONDARY)</comments>
                            </child>
                            <assignmentOperator xsi:type="operators:Assignment"/>
                            <value xsi:type="literals:BooleanLiteral"/>
                          </expression>
                        </statements>
                      </statement>
                      <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.5/@variable"/>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.15"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
                    </children>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </condition>
                </elseStatement>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.12"/>
                    </next>
                  </value>
                </expression>
              </children>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:DoWhileLoop">
              <comments>// The target string has more elements, but the source string hasn't.</comments>
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:Condition">
                  <comments>// (strength is PRIMARY)</comments>
                  <statement xsi:type="statements:Return">
                    <comments>// We found an additional non-ignorable base character in the target string.</comments>
                    <comments>// This is a primary difference, so the source is less</comments>
                    <returnValue xsi:type="references:IdentifierReference">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.10"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
                    </returnValue>
                  </statement>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.14"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable/@additionalLocalVariables.0"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
                    </children>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </condition>
                  <elseStatement xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:Condition">
                        <comments>// Additional secondary elements in the target mean the source string is less</comments>
                        <statement xsi:type="statements:Block">
                          <statements xsi:type="statements:ExpressionStatement">
                            <expression xsi:type="expressions:AssignmentExpression">
                              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable"/>
                              <assignmentOperator xsi:type="operators:Assignment"/>
                              <value xsi:type="references:IdentifierReference">
                                <next xsi:type="references:IdentifierReference">
                                  <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.10"/>
                                </next>
                                <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
                              </value>
                            </expression>
                          </statements>
                          <statements xsi:type="statements:ExpressionStatement">
                            <expression xsi:type="expressions:AssignmentExpression">
                              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.5/@variable">
                                <comments>// (strength is SECONDARY)</comments>
                              </child>
                              <assignmentOperator xsi:type="operators:Assignment"/>
                              <value xsi:type="literals:BooleanLiteral"/>
                            </expression>
                          </statements>
                        </statement>
                        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.5/@variable"/>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.15"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable/@additionalLocalVariables.0"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
                      </children>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    </condition>
                  </elseStatement>
                </statements>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable/@additionalLocalVariables.0"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.12"/>
                      </next>
                    </value>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
                </children>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.3/@variable/@additionalLocalVariables.0"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
            </children>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// For IDENTICAL comparisons, we use a bitwise character comparison</comments>
        <comments>// as a tiebreaker if all else is equal</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="mode">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>Normalizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../sun/text/Normalizer$Mode.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../sun/text/NormalizerUtilities.class.xmi#//@classifiers.0/@members.3"/>
                  <arguments xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.21"/>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../../sun/text/NormalizerUtilities.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="sourceDecomposition">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../sun/text/Normalizer.class.xmi#//@classifiers.0/@members.31"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.10/@statement/@statements.0/@variable"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../sun/text/Normalizer.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="targetDecomposition">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../sun/text/Normalizer.class.xmi#//@classifiers.0/@members.31"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.10/@statement/@statements.0/@variable"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../sun/text/Normalizer.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.10/@statement/@statements.1/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.37"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.10/@statement/@statements.2/@variable"/>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.19"/>
            </children>
            <children xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.3"/>
            </children>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCollationKey">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CollationKey.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Transforms the string into a series of characters that can be compared&#xA;     * with CollationKey.compareTo. This overrides java.text.Collator.getCollationKey.&#xA;     * It can be overriden in a subclass.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Condition">
        <comments>//</comments>
        <comments>// The basic algorithm here is to find all of the collation elements for each</comments>
        <comments>// character in the source string, convert them to a char representation,</comments>
        <comments>// and put them into the collation key.  But it's trickier than that.</comments>
        <comments>// Each collation element in a string has three components: primary (A vs B),</comments>
        <comments>// secondary (A vs A-acute), and tertiary (A' vs a); and a primary difference</comments>
        <comments>// at the end of a string takes precedence over a secondary or tertiary</comments>
        <comments>// difference earlier in the string.</comments>
        <comments>//</comments>
        <comments>// To account for this, we put all of the primary orders at the beginning of the</comments>
        <comments>// string, followed by the secondary and tertiary orders, separated by nulls.</comments>
        <comments>//</comments>
        <comments>// Here's a hypothetical example, with the collation element represented as</comments>
        <comments>// a three-digit number, one digit for primary, one for secondary, etc.</comments>
        <comments>//</comments>
        <comments>// String:              A     a     B   \u00e9 &lt;--(e-acute)</comments>
        <comments>// Collation Elements: 101   100   201  510</comments>
        <comments>//</comments>
        <comments>// Collation Key:      1125&lt;null>0001&lt;null>1010</comments>
        <comments>//</comments>
        <comments>// To make things even trickier, secondary differences (accent marks) are compared</comments>
        <comments>// starting at the *end* of the string in languages with French secondary ordering.</comments>
        <comments>// But when comparing the accent marks on a single base character, they are compared</comments>
        <comments>// from the beginning.  To handle this, we reverse all of the accents that belong</comments>
        <comments>// to each base character, then we reverse the entire string of secondary orderings</comments>
        <comments>// at the end.  Taking the same example above, a French collator might return</comments>
        <comments>// this instead:</comments>
        <comments>//</comments>
        <comments>// Collation Key:      1125&lt;null>1000&lt;null>1010</comments>
        <comments>//</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:NullLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.10"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.10"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.10"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </next>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="order">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="compareSec">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.19"/>
              </children>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="compareTer">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.19"/>
              </children>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.2"/>
                </next>
                <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="secOrder">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="terOrder">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="preSecIgnore">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.4">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.21"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
              </next>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>// walk through each character</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.5/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.15"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.6/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.16"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                    <arguments xsi:type="expressions:CastExpression">
                      <typeReference xsi:type="types:Char"/>
                      <child xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.14"/>
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
                          </children>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                        </expression>
                      </child>
                    </arguments>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <comments>//</comments>
                    <comments>// accumulate all of the ignorable/secondary characters attached</comments>
                    <comments>// to a given base character</comments>
                    <comments>//</comments>
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="references:IdentifierReference">
                          <comments>//</comments>
                          <comments>// We're doing reversed secondary ordering and we've hit a base</comments>
                          <comments>// (non-ignorable) character.  Reverse any secondary orderings</comments>
                          <comments>// that applied to the last base character.  (see block comment above.)</comments>
                          <comments>//</comments>
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="RBCollationTables.class.xmi#//@classifiers.0/@members.31"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.7/@variable"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
                              <next xsi:type="references:MethodCall">
                                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.6"/>
                              </next>
                            </arguments>
                          </next>
                          <target xsi:type="classifiers:Class" href="RBCollationTables.class.xmi#//@classifiers.0"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:ConditionalAndExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="RBCollationTables.class.xmi#//@classifiers.0/@members.21"/>
                        </next>
                      </children>
                      <children xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.7/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.6"/>
                          </next>
                        </children>
                        <relationOperators xsi:type="operators:LessThan"/>
                      </children>
                    </condition>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
                      <comments>// Remember where we are in the secondary orderings - this is how far</comments>
                      <comments>// back to go if we need to reverse them later.</comments>
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                        <arguments xsi:type="expressions:CastExpression">
                          <typeReference xsi:type="types:Char"/>
                          <child xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:AdditiveExpression">
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.5/@variable"/>
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
                              <additiveOperators xsi:type="operators:Addition"/>
                            </expression>
                          </child>
                        </arguments>
                      </next>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.7/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.6"/>
                        </next>
                      </value>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.3/@variable"/>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                        <arguments xsi:type="expressions:CastExpression">
                          <typeReference xsi:type="types:Char"/>
                          <child xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:AdditiveExpression">
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.6/@variable"/>
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
                              <additiveOperators xsi:type="operators:Addition"/>
                            </expression>
                          </child>
                        </arguments>
                      </next>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.4/@variable"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.28"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
              </child>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                      <arguments xsi:type="expressions:CastExpression">
                        <typeReference xsi:type="types:Char"/>
                        <child xsi:type="expressions:NestedExpression">
                          <expression xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.5/@variable"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17">
                              <next xsi:type="references:MethodCall">
                                <target xsi:type="members:ClassMethod" href="RBCollationTables.class.xmi#//@classifiers.0/@members.29"/>
                              </next>
                            </children>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                          </expression>
                        </child>
                      </arguments>
                    </next>
                  </expression>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.3/@variable"/>
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.5/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </children>
                </condition>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                      <arguments xsi:type="expressions:CastExpression">
                        <typeReference xsi:type="types:Char"/>
                        <child xsi:type="expressions:NestedExpression">
                          <expression xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.6/@variable"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17">
                              <next xsi:type="references:MethodCall">
                                <target xsi:type="members:ClassMethod" href="RBCollationTables.class.xmi#//@classifiers.0/@members.30"/>
                              </next>
                            </children>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                          </expression>
                        </child>
                      </arguments>
                    </next>
                  </expression>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.4/@variable"/>
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.6/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </children>
                </condition>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.12"/>
                </next>
              </value>
            </expression>
          </children>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="CollationElementIterator.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference">
                  <comments>// If we've accumlated any secondary characters after the last base character,</comments>
                  <comments>// reverse them.</comments>
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="RBCollationTables.class.xmi#//@classifiers.0/@members.31"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.7/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.6"/>
                      </next>
                    </arguments>
                  </next>
                  <target xsi:type="classifiers:Class" href="RBCollationTables.class.xmi#//@classifiers.0"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.7/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.6"/>
                </next>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <comments>// And now reverse the entire secResult to get French secondary ordering.</comments>
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="RBCollationTables.class.xmi#//@classifiers.0/@members.31"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.6"/>
                  </next>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="RBCollationTables.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="RBCollationTables.class.xmi#//@classifiers.0/@members.21"/>
          </next>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Char"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Char"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
              </next>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
              </next>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                <arguments xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Char"/>
                  <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </arguments>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="mode">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>Normalizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../sun/text/Normalizer$Mode.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../sun/text/NormalizerUtilities.class.xmi#//@classifiers.0/@members.3"/>
                  <arguments xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.21"/>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../../sun/text/NormalizerUtilities.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../sun/text/Normalizer.class.xmi#//@classifiers.0/@members.31"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.15/@statement/@statements.1/@variable"/>
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../../sun/text/Normalizer.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.19"/>
          </children>
          <children xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="Collator.class.xmi#//@classifiers.0/@members.3"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="CollationKey.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Standard override; no change in semantics.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// if we know we're not actually a subclass of RuleBasedCollator</comments>
        <comments>// (this class really should have been made final), bypass</comments>
        <comments>// Object.clone() and use our &quot;copy constructor&quot;.  This is faster.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <arguments xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </arguments>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0">
            <next xsi:type="references:ReflectiveClassReference"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="result">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <child xsi:type="references:SelfReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.24"/>
                  </next>
                  <self xsi:type="literals:Super"/>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:NullLiteral"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:NullLiteral"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:NullLiteral"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:NullLiteral"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:NullLiteral"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares the equality of two collation objects.&#xA;     * @param obj the table-based collation object to be compared with this.&#xA;     * @return true if the current table-based collation object is the same&#xA;     * as the table-based collation object obj; false otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Collator.class.xmi#//@classifiers.0/@members.25"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
            </next>
            <self xsi:type="literals:Super"/>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="other">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>// super does class check</comments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// all other non-transient information is also contained in rules.</comments>
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.3">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.2/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
              </arguments>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates the hash code for the table-based collation object&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.44"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getTables">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Allows CollationElementIterator access to the tables object&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="RBCollationTables.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
      </statements>
    </members>
    <members xsi:type="members:Field" name="CHARINDEX">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="1879048192"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>// ==============================================================</comments>
        <comments>// private</comments>
        <comments>// ==============================================================</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="EXPANDCHARINDEX">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="2113929216"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>// need look up in .commit()</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="CONTRACTCHARINDEX">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="2130706432"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>// Expand index follows</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="UNMAPPED">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="4294967295"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>// contract indexes follow</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="COLLATIONKEYOFFSET">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="tables">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RBCollationTables.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="primResult">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Internal objects that are cached across calls so that they don't have to</comments>
        <comments>// be created/destroyed on every call to compare() and getCollationKey()</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="secResult">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="terResult">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="sourceCursor">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="targetCursor">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CollationElementIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>RuleBasedCollator&lt;/code> class is a concrete subclass of&#xA; * &lt;code>Collator&lt;/code> that provides a simple, data-driven, table&#xA; * collator.  With this class you can create a customized table-based&#xA; * &lt;code>Collator&lt;/code>.  &lt;code>RuleBasedCollator&lt;/code> maps&#xA; * characters to sort keys.&#xA; *&#xA; * &lt;p>&#xA; * &lt;code>RuleBasedCollator&lt;/code> has the following restrictions&#xA; * for efficiency (other subclasses may be used for more complex languages) :&#xA; * &lt;ol>&#xA; * &lt;li>If a special collation rule controlled by a &amp;lt;modifier&amp;gt; is&#xA;      specified it applies to the whole collator object.&#xA; * &lt;li>All non-mentioned characters are at the end of the&#xA; *     collation order.&#xA; * &lt;/ol>&#xA; *&#xA; * &lt;p>&#xA; * The collation table is composed of a list of collation rules, where each&#xA; * rule is of one of three forms:&#xA; * &lt;pre>&#xA; *    &amp;lt;modifier&amp;gt;&#xA; *    &amp;lt;relation&amp;gt; &amp;lt;text-argument&amp;gt;&#xA; *    &amp;lt;reset&amp;gt; &amp;lt;text-argument&amp;gt;&#xA; * &lt;/pre>&#xA; * The definitions of the rule elements is as follows:&#xA; * &lt;UL Type=disc>&#xA; *    &lt;LI>&lt;strong>Text-Argument&lt;/strong>: A text-argument is any sequence of&#xA; *        characters, excluding special characters (that is, common&#xA; *        whitespace characters [0009-000D, 0020] and rule syntax characters&#xA; *        [0021-002F, 003A-0040, 005B-0060, 007B-007E]). If those&#xA; *        characters are desired, you can put them in single quotes&#xA; *        (e.g. ampersand => '&amp;'). Note that unquoted white space characters&#xA; *        are ignored; e.g. &lt;code>b c&lt;/code> is treated as &lt;code>bc&lt;/code>.&#xA; *    &lt;LI>&lt;strong>Modifier&lt;/strong>: There are currently two modifiers that &#xA; *        turn on special collation rules.&#xA; *        &lt;UL Type=square>&#xA; *            &lt;LI>'@' : Turns on backwards sorting of accents (secondary&#xA; *                      differences), as in French.&#xA; *            &lt;LI>'!' : Turns on Thai/Lao vowel-consonant swapping.  If this&#xA; *                      rule is in force when a Thai vowel of the range&#xA; *                      &amp;#92;U0E40-&amp;#92;U0E44 precedes a Thai consonant of the range&#xA; *                      &amp;#92;U0E01-&amp;#92;U0E2E OR a Lao vowel of the range &amp;#92;U0EC0-&amp;#92;U0EC4&#xA; *                      precedes a Lao consonant of the range &amp;#92;U0E81-&amp;#92;U0EAE then&#xA; *                      the vowel is placed after the consonant for collation&#xA; *                      purposes.&#xA; *        &lt;/UL>&#xA; *        &lt;p>'@' : Indicates that accents are sorted backwards, as in French.&#xA; *    &lt;LI>&lt;strong>Relation&lt;/strong>: The relations are the following:&#xA; *        &lt;UL Type=square>&#xA; *            &lt;LI>'&amp;lt;' : Greater, as a letter difference (primary)&#xA; *            &lt;LI>';' : Greater, as an accent difference (secondary)&#xA; *            &lt;LI>',' : Greater, as a case difference (tertiary)&#xA; *            &lt;LI>'=' : Equal&#xA; *        &lt;/UL>&#xA; *    &lt;LI>&lt;strong>Reset&lt;/strong>: There is a single reset&#xA; *        which is used primarily for contractions and expansions, but which&#xA; *        can also be used to add a modification at the end of a set of rules.&#xA; *        &lt;p>'&amp;' : Indicates that the next rule follows the position to where&#xA; *            the reset text-argument would be sorted.&#xA; * &lt;/UL>&#xA; *&#xA; * &lt;p>&#xA; * This sounds more complicated than it is in practice. For example, the&#xA; * following are equivalent ways of expressing the same thing:&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * a &amp;lt; b &amp;lt; c&#xA; * a &amp;lt; b &amp;amp; b &amp;lt; c&#xA; * a &amp;lt; c &amp;amp; a &amp;lt; b&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; * Notice that the order is important, as the subsequent item goes immediately&#xA; * after the text-argument. The following are not equivalent:&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * a &amp;lt; b &amp;amp; a &amp;lt; c&#xA; * a &amp;lt; c &amp;amp; a &amp;lt; b&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; * Either the text-argument must already be present in the sequence, or some&#xA; * initial substring of the text-argument must be present. (e.g. &quot;a &amp;lt; b &amp;amp; ae &amp;lt; &#xA; * e&quot; is valid since &quot;a&quot; is present in the sequence before &quot;ae&quot; is reset). In&#xA; * this latter case, &quot;ae&quot; is not entered and treated as a single character;&#xA; * instead, &quot;e&quot; is sorted as if it were expanded to two characters: &quot;a&quot;&#xA; * followed by an &quot;e&quot;. This difference appears in natural languages: in&#xA; * traditional Spanish &quot;ch&quot; is treated as though it contracts to a single&#xA; * character (expressed as &quot;c &amp;lt; ch &amp;lt; d&quot;), while in traditional German&#xA; * a-umlaut is treated as though it expanded to two characters&#xA; * (expressed as &quot;a,A &amp;lt; b,B ... &amp;amp;ae;&amp;#92;u00e3&amp;amp;AE;&amp;#92;u00c3&quot;).&#xA; * [&amp;#92;u00e3 and &amp;#92;u00c3 are, of course, the escape sequences for a-umlaut.]&#xA; * &lt;p>&#xA; * &lt;strong>Ignorable Characters&lt;/strong>&#xA; * &lt;p>&#xA; * For ignorable characters, the first rule must start with a relation (the&#xA; * examples we have used above are really fragments; &quot;a &amp;lt; b&quot; really should be&#xA; * &quot;&amp;lt; a &amp;lt; b&quot;). If, however, the first relation is not &quot;&amp;lt;&quot;, then all the all&#xA; * text-arguments up to the first &quot;&amp;lt;&quot; are ignorable. For example, &quot;, - &amp;lt; a &amp;lt; b&quot;&#xA; * makes &quot;-&quot; an ignorable character, as we saw earlier in the word&#xA; * &quot;black-birds&quot;. In the samples for different languages, you see that most&#xA; * accents are ignorable.&#xA; *&#xA; * &lt;p>&lt;strong>Normalization and Accents&lt;/strong>&#xA; * &lt;p>&#xA; * &lt;code>RuleBasedCollator&lt;/code> automatically processes its rule table to&#xA; * include both pre-composed and combining-character versions of&#xA; * accented characters.  Even if the provided rule string contains only&#xA; * base characters and separate combining accent characters, the pre-composed&#xA; * accented characters matching all canonical combinations of characters from&#xA; * the rule string will be entered in the table.&#xA; * &lt;p>&#xA; * This allows you to use a RuleBasedCollator to compare accented strings&#xA; * even when the collator is set to NO_DECOMPOSITION.  There are two caveats,&#xA; * however.  First, if the strings to be collated contain combining&#xA; * sequences that may not be in canonical order, you should set the collator to&#xA; * CANONICAL_DECOMPOSITION or FULL_DECOMPOSITION to enable sorting of&#xA; * combining sequences.  Second, if the strings contain characters with&#xA; * compatibility decompositions (such as full-width and half-width forms),&#xA; * you must use FULL_DECOMPOSITION, since the rule tables only include&#xA; * canonical mappings.&#xA; *&#xA; * &lt;p>&lt;strong>Errors&lt;/strong>&#xA; * &lt;p>&#xA; * The following are errors:&#xA; * &lt;UL Type=disc>&#xA; *     &lt;LI>A text-argument contains unquoted punctuation symbols&#xA; *        (e.g. &quot;a &amp;lt; b-c &amp;lt; d&quot;).&#xA; *     &lt;LI>A relation or reset character not followed by a text-argument&#xA; *        (e.g. &quot;a &amp;lt; ,b&quot;).&#xA; *     &lt;LI>A reset where the text-argument (or an initial substring of the&#xA; *         text-argument) is not already in the sequence.&#xA; *         (e.g. &quot;a &amp;lt; b &amp;amp; e &amp;lt; f&quot;)&#xA; * &lt;/UL>&#xA; * If you produce one of these errors, a &lt;code>RuleBasedCollator&lt;/code> throws&#xA; * a &lt;code>ParseException&lt;/code>.&#xA; * &#xA; * &lt;p>&lt;strong>Examples&lt;/strong>&#xA; * &lt;p>Simple:     &quot;&amp;lt; a &amp;lt; b &amp;lt; c &amp;lt; d&quot;&#xA; * &lt;p>Norwegian:  &quot;&amp;lt; a,A&amp;lt; b,B&amp;lt; c,C&amp;lt; d,D&amp;lt; e,E&amp;lt; f,F&amp;lt; g,G&amp;lt; h,H&amp;lt; i,I&amp;lt; j,J&#xA; *                 &amp;lt; k,K&amp;lt; l,L&amp;lt; m,M&amp;lt; n,N&amp;lt; o,O&amp;lt; p,P&amp;lt; q,Q&amp;lt; r,R&amp;lt; s,S&amp;lt; t,T&#xA; *                 &amp;lt; u,U&amp;lt; v,V&amp;lt; w,W&amp;lt; x,X&amp;lt; y,Y&amp;lt; z,Z&#xA; *                 &amp;lt; &amp;#92;u00E5=a&amp;#92;u030A,&amp;#92;u00C5=A&amp;#92;u030A&#xA; *                 ;aa,AA&amp;lt; &amp;#92;u00E6,&amp;#92;u00C6&amp;lt; &amp;#92;u00F8,&amp;#92;u00D8&quot;&#xA; *&#xA; * &lt;p>&#xA; * Normally, to create a rule-based Collator object, you will use&#xA; * &lt;code>Collator&lt;/code>'s factory method &lt;code>getInstance&lt;/code>.&#xA; * However, to create a rule-based Collator object with specialized&#xA; * rules tailored to your needs, you construct the &lt;code>RuleBasedCollator&lt;/code>&#xA; * with the rules contained in a &lt;code>String&lt;/code> object. For example:&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * String Simple = &quot;&amp;lt; a&amp;lt; b&amp;lt; c&amp;lt; d&quot;;&#xA; * RuleBasedCollator mySimple = new RuleBasedCollator(Simple);&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; * Or:&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * String Norwegian = &quot;&amp;lt; a,A&amp;lt; b,B&amp;lt; c,C&amp;lt; d,D&amp;lt; e,E&amp;lt; f,F&amp;lt; g,G&amp;lt; h,H&amp;lt; i,I&amp;lt; j,J&quot; +&#xA; *                 &quot;&amp;lt; k,K&amp;lt; l,L&amp;lt; m,M&amp;lt; n,N&amp;lt; o,O&amp;lt; p,P&amp;lt; q,Q&amp;lt; r,R&amp;lt; s,S&amp;lt; t,T&quot; +&#xA; *                 &quot;&amp;lt; u,U&amp;lt; v,V&amp;lt; w,W&amp;lt; x,X&amp;lt; y,Y&amp;lt; z,Z&quot; +&#xA; *                 &quot;&amp;lt; &amp;#92;u00E5=a&amp;#92;u030A,&amp;#92;u00C5=A&amp;#92;u030A&quot; +&#xA; *                 &quot;;aa,AA&amp;lt; &amp;#92;u00E6,&amp;#92;u00C6&amp;lt; &amp;#92;u00F8,&amp;#92;u00D8&quot;;&#xA; * RuleBasedCollator myNorwegian = new RuleBasedCollator(Norwegian);&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p>&#xA; * Combining &lt;code>Collator&lt;/code>s is as simple as concatenating strings.&#xA; * Here's an example that combines two &lt;code>Collator&lt;/code>s from two&#xA; * different locales:&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * // Create an en_US Collator object&#xA; * RuleBasedCollator en_USCollator = (RuleBasedCollator)&#xA; *     Collator.getInstance(new Locale(&quot;en&quot;, &quot;US&quot;, &quot;&quot;));&#xA; * // Create a da_DK Collator object&#xA; * RuleBasedCollator da_DKCollator = (RuleBasedCollator)&#xA; *     Collator.getInstance(new Locale(&quot;da&quot;, &quot;DK&quot;, &quot;&quot;));&#xA; * // Combine the two&#xA; * // First, get the collation rules from en_USCollator&#xA; * String en_USRules = en_USCollator.getRules();&#xA; * // Second, get the collation rules from da_DKCollator&#xA; * String da_DKRules = da_DKCollator.getRules();&#xA; * RuleBasedCollator newCollator =&#xA; *     new RuleBasedCollator(en_USRules + da_DKRules);&#xA; * // newCollator has the combined rules&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p>&#xA; * Another more interesting example would be to make changes on an existing&#xA; * table to create a new &lt;code>Collator&lt;/code> object.  For example, add&#xA; * &quot;&amp;amp;C&amp;lt; ch, cH, Ch, CH&quot; to the &lt;code>en_USCollator&lt;/code> object to create&#xA; * your own:&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * // Create a new Collator object with additional rules&#xA; * String addRules = &quot;&amp;amp;C&amp;lt; ch, cH, Ch, CH&quot;;&#xA; * RuleBasedCollator myCollator =&#xA; *     new RuleBasedCollator(en_USCollator + addRules);&#xA; * // myCollator contains the new rules&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p>&#xA; * The following example demonstrates how to change the order of&#xA; * non-spacing accents,&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * // old rule&#xA; * String oldRules = &quot;=&amp;#92;u0301;&amp;#92;u0300;&amp;#92;u0302;&amp;#92;u0308&quot;    // main accents&#xA; *                 + &quot;;&amp;#92;u0327;&amp;#92;u0303;&amp;#92;u0304;&amp;#92;u0305&quot;    // main accents&#xA; *                 + &quot;;&amp;#92;u0306;&amp;#92;u0307;&amp;#92;u0309;&amp;#92;u030A&quot;    // main accents&#xA; *                 + &quot;;&amp;#92;u030B;&amp;#92;u030C;&amp;#92;u030D;&amp;#92;u030E&quot;    // main accents&#xA; *                 + &quot;;&amp;#92;u030F;&amp;#92;u0310;&amp;#92;u0311;&amp;#92;u0312&quot;    // main accents&#xA; *                 + &quot;&amp;lt; a , A ; ae, AE ; &amp;#92;u00e6 , &amp;#92;u00c6&quot;&#xA; *                 + &quot;&amp;lt; b , B &amp;lt; c, C &amp;lt; e, E &amp; C &amp;lt; d, D&quot;;&#xA; * // change the order of accent characters&#xA; * String addOn = &quot;&amp; &amp;#92;u0300 ; &amp;#92;u0308 ; &amp;#92;u0302&quot;;&#xA; * RuleBasedCollator myCollator = new RuleBasedCollator(oldRules + addOn);&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p>&#xA; * The last example shows how to put new primary ordering in before the&#xA; * default setting. For example, in Japanese &lt;code>Collator&lt;/code>, you&#xA; * can either sort English characters before or after Japanese characters,&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * // get en_US Collator rules&#xA; * RuleBasedCollator en_USCollator = (RuleBasedCollator)Collator.getInstance(Locale.US);&#xA; * // add a few Japanese character to sort before English characters&#xA; * // suppose the last character before the first base letter 'a' in&#xA; * // the English collation rule is &amp;#92;u2212&#xA; * String jaString = &quot;&amp; &amp;#92;u2212 &amp;lt; &amp;#92;u3041, &amp;#92;u3042 &amp;lt; &amp;#92;u3043, &amp;#92;u3044&quot;;&#xA; * RuleBasedCollator myJapaneseCollator = new&#xA; *     RuleBasedCollator(en_USCollator.getRules() + jaString);&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * @see        Collator&#xA; * @see        CollationElementIterator&#xA; * @version    1.25 07/24/98&#xA; * @author     Helena Shih, Laura Werner, Richard Gillam&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="Collator.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
