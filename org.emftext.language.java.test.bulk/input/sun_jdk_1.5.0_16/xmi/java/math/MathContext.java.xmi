<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="MathContext.java">
  <comments>/*&#xA; * @(#)MathContext.java&#x9;1.2 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/*&#xA; * @(#)MathContext.java  1.x 01/xx/xx&#xA; *&#xA; * Copyright IBM Corporation, 1997, 2001. All Rights Reserved.&#xA; *&#xA; * This software is the proprietary information of Sun Microsystems, Inc.&#xA; * and IBM Corporation.  Use is subject to license terms.&#xA; *&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>math</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="MathContext">
    <members xsi:type="members:Field" name="DEFAULT_DIGITS">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/* ----- Constants ----- */</comments>
        <comments>// defaults for constructors</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DEFAULT_ROUNDINGMODE">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:IdentifierReference">
          <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.4"/>
        </next>
        <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MIN_DIGITS">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Smallest values for digits (Maximum is Integer.MAX_VALUE)</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="5579720004786848255"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Serialization version</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="UNLIMITED">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        <arguments xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.4"/>
          </next>
          <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
        </arguments>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* ----- Public Properties ----- */</comments>
        <comments>/**&#xA;     *  A &lt;tt>MathContext&lt;/tt> object whose settings have the values&#xA;     *  required for unlimited precision arithmetic.&#xA;     *  The values of the settings are:&#xA;     *  &lt;code>&#xA;     *  precision=0 roundingMode=HALF_UP&#xA;     *  &lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DECIMAL32">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
        <arguments xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.6"/>
          </next>
          <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
        </arguments>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  A &lt;tt>MathContext&lt;/tt> object with a precision setting&#xA;     *  matching the IEEE 754R Decimal32 format, 7 digits, and a&#xA;     *  rounding mode of {@link RoundingMode#HALF_EVEN HALF_EVEN}, the&#xA;     *  IEEE 754R default.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DECIMAL64">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
        <arguments xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.6"/>
          </next>
          <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
        </arguments>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  A &lt;tt>MathContext&lt;/tt> object with a precision setting&#xA;     *  matching the IEEE 754R Decimal64 format, 16 digits, and a&#xA;     *  rounding mode of {@link RoundingMode#HALF_EVEN HALF_EVEN}, the&#xA;     *  IEEE 754R default.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DECIMAL128">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="34"/>
        <arguments xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.6"/>
          </next>
          <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
        </arguments>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  A &lt;tt>MathContext&lt;/tt> object with a precision setting&#xA;     *  matching the IEEE 754R Decimal128 format, 34 digits, and a&#xA;     *  rounding mode of {@link RoundingMode#HALF_EVEN HALF_EVEN}, the&#xA;     *  IEEE 754R default.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="precision">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/* ----- Shared Properties ----- */</comments>
        <comments>/**&#xA;     * The number of digits to be used for an operation.  A value of 0&#xA;     * indicates that unlimited precision (as many digits as are&#xA;     * required) will be used.  Note that leading zeros (in the&#xA;     * coefficient of a number) are never significant.&#xA;     * &#xA;     * &lt;p>&lt;tt>precision&lt;/tt> will always be non-negative.&#xA;     *&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="roundingMode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * The rounding algorithm to be used for an operation.&#xA;     *&#xA;     * @see RoundingMode&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="roundingMax">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Transient">
        <comments>/**&#xA;     *  Lookaside for the rounding points (the numbers which determine&#xA;     *  whether the coefficient of a number will require rounding).&#xA;     *  These will be present if precision&amp;gt;0 and&#xA;     *  precision&amp;lt;=MAX_LOOKASIDE.  In this case they will share the&#xA;     *  &lt;tt>BigInteger int[]&lt;/tt> array.  Note that the transients&#xA;     *  cannot be &lt;tt>final&lt;/tt> because they are reconstructed on&#xA;     *  deserialization.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="roundingMin">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="MAX_LOOKASIDE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1000"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="MathContext">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="setPrecision">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* ----- Constructors ----- */</comments>
        <comments>/**&#xA;     * Constructs a new &lt;tt>MathContext&lt;/tt> with the specified&#xA;     * precision and the {@link RoundingMode#HALF_UP HALF_UP} rounding&#xA;     * mode.&#xA;     *&#xA;     * @param setPrecision The non-negative &lt;tt>int&lt;/tt> precision setting.&#xA;     * @throws IllegalArgumentException &lt;tt>setPrecision&lt;/tt> parameter less &#xA;     *         than zero.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="MathContext">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Digits &lt; 0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="null RoundingMode"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.67"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                  </next>
                  <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.18"/>
                </next>
                <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.74"/>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="setPrecision">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="setRoundingMode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new &lt;tt>MathContext&lt;/tt> with a specified&#xA;     * precision and rounding mode.&#xA;     *&#xA;     * @param setPrecision The non-negative &lt;tt>int&lt;/tt> precision setting.&#xA;     * @param setRoundingMode The rounding mode to use.&#xA;     * @throws IllegalArgumentException &lt;tt>setPrecision&lt;/tt> parameter less &#xA;     *         than zero.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="MathContext">
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bad">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="setPrecision">
          <typeReference xsi:type="types:Int"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="null String"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Condition">
          <comments>// any error here is a string format problem</comments>
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/RuntimeException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.42"/>
                <arguments xsi:type="references:StringReference" value="precision="/>
              </next>
            </child>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="fence">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.45"/>
                <arguments xsi:type="literals:CharacterLiteral" value="32"/>
              </next>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="off">
            <typeReference xsi:type="types:Int">
              <comments>// could be -1</comments>
            </typeReference>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.1/@variable">
              <comments>// where value starts</comments>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Integer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.56"/>
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@statements.1/@variable"/>
                  </next>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/RuntimeException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.41"/>
                <arguments xsi:type="references:StringReference" value="roundingMode="/>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@statements.1/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
              </next>
            </child>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@statements.2/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@statements.1/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="str">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.56"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@statements.2/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                  </next>
                </arguments>
              </next>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="RoundingMode.class.xmi#//@classifiers.0/@members.3"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@statements.6/@variable"/>
              </next>
              <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
            </value>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="bad string format"/>
            </throwable>
          </statements>
          <parameter name="re">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/RuntimeException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Digits &lt; 0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.1/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
            <comments>// the other parameters cannot be invalid if we got here</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.1/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.67"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                  </next>
                  <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.18"/>
                </next>
                <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.74"/>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new &lt;tt>MathContext&lt;/tt> from a string.&#xA;     *&#xA;     * The string must be in the same format as that produced by the&#xA;     * {@link #toString} method.&#xA;     * &#xA;     * &lt;p>An &lt;tt>IllegalArgumentException&lt;/tt> is thrown if the precision&#xA;     * section of the string is out of range (&amp;lt; 0) or the string is&#xA;     * not in the format created by the {@link #toString} method.&#xA;     *&#xA;     * @param val The string to be parsed&#xA;     * @throws IllegalArgumentException precision parameter out of range&#xA;     * or incorrect format&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getPrecision">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;tt>precision&lt;/tt> setting.&#xA;     * This value is always non-negative.&#xA;     *&#xA;     * @return an &lt;tt>int&lt;/tt> which is the value of the &lt;tt>precision&lt;/tt>&#xA;     *         setting&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getRoundingMode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the roundingMode setting.&#xA;     * This will be one of&#xA;     * {@link  RoundingMode#CEILING},&#xA;     * {@link  RoundingMode#DOWN},&#xA;     * {@link  RoundingMode#FLOOR},&#xA;     * {@link  RoundingMode#HALF_DOWN},&#xA;     * {@link  RoundingMode#HALF_EVEN},&#xA;     * {@link  RoundingMode#HALF_UP},&#xA;     * {@link  RoundingMode#UNNECESSARY}, or&#xA;     * {@link  RoundingMode#UP}.&#xA;     *&#xA;     * @return a &lt;tt>RoundingMode&lt;/tt> object which is the value of the&#xA;     *         &lt;tt>roundingMode&lt;/tt> setting&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <comments>// no need for .equals()</comments>
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares this &lt;tt>MathContext&lt;/tt> with the specified&#xA;     * &lt;tt>Object&lt;/tt> for equality.&#xA;     *&#xA;     * @param  x &lt;tt>Object&lt;/tt> to which this &lt;tt>MathContext&lt;/tt> is to &#xA;     *         be compared.&#xA;     * @return &lt;tt>true&lt;/tt> if and only if the specified &lt;tt>Object&lt;/tt> is&#xA;     *         a &lt;tt>MathContext&lt;/tt> object which has exactly the same &#xA;     *         settings as this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="mc">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            </children>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
              <self xsi:type="literals:This"/>
            </children>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
            </children>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
              <self xsi:type="literals:This"/>
            </children>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the hash code for this &lt;tt>MathContext&lt;/tt>.&#xA;     *&#xA;     * @return hash code for this &lt;tt>MathContext&lt;/tt>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Enum.class.xmi#//@classifiers.0/@members.7"/>
              </next>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="59"/>
            <multiplicativeOperators xsi:type="operators:Multiplication"/>
          </children>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <namespaces>java</namespaces>
        <namespaces>lang</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Returns the string representation of this &lt;tt>MathContext&lt;/tt>.&#xA;     * The &lt;tt>String&lt;/tt> returned represents the settings of the&#xA;     * &lt;tt>MathContext&lt;/tt> object as two space-delimited words&#xA;     * (separated by a single space character, &lt;tt>'&amp;#92;u0020'&lt;/tt>,&#xA;     * and with no leading or trailing white space), as follows:&#xA;     * &lt;ol>&#xA;     * &lt;li>&#xA;     * The string &lt;tt>&amp;quot;precision=&amp;quot;&lt;/tt>, immediately followed&#xA;     * by the value of the precision setting as a numeric string as if&#xA;     * generated by the {@link Integer#toString(int) Integer.toString}&#xA;     * method.&#xA;     *&#xA;     * &lt;li>&#xA;     * The string &lt;tt>&amp;quot;roundingMode=&amp;quot;&lt;/tt>, immediately&#xA;     * followed by the value of the &lt;tt>roundingMode&lt;/tt> setting as a&#xA;     * word.  This word will be the same as the name of the&#xA;     * corresponding public constant in the {@link RoundingMode}&#xA;     * enum.&#xA;     * &lt;/ol>&#xA;     * &lt;p>&#xA;     * For example:&#xA;     * &lt;pre>&#xA;     * precision=9 roundingMode=HALF_UP&#xA;     * &lt;/pre>&#xA;     *&#xA;     * Additional words may be appended to the result of&#xA;     * &lt;tt>toString&lt;/tt> in the future if more properties are added to&#xA;     * this class.&#xA;     *&#xA;     * @return a &lt;tt>String&lt;/tt> representing the context settings.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:StringReference" value="precision="/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          <children xsi:type="references:StringReference" value=" "/>
          <children xsi:type="references:StringReference" value="roundingMode="/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Enum.class.xmi#//@classifiers.0/@members.5"/>
            </next>
          </children>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/ObjectInputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>java</namespaces>
        <namespaces>io</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/ClassNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Private methods</comments>
        <comments>/**&#xA;     * Reconstitute the &lt;tt>MathContext&lt;/tt> instance from a stream (that is,&#xA;     * deserialize it).&#xA;     *&#xA;     * @param s the stream being read.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectInputStream.class.xmi#//@classifiers.0/@members.19"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// read in all fields</comments>
        <comments>// validate possibly bad fields</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="message">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:StringReference" value="MathContext: invalid digits in stream"/>
            </variable>
          </statements>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>java</namespaces>
                <namespaces>io</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../io/StreamCorruptedException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.1/@statement/@statements.0/@variable"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="message">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:StringReference" value="MathContext: null roundingMode in stream"/>
            </variable>
          </statements>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>java</namespaces>
                <namespaces>io</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../io/StreamCorruptedException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.2/@statement/@statements.0/@variable"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Set the lookaside, if applicable</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.67"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                  </next>
                  <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.18"/>
                </next>
                <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.74"/>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Immutable objects which encapsulate the context settings which&#xA; * describe certain rules for numerical operators, such as those&#xA; * implemented by the {@link BigDecimal} class.&#xA; * &#xA; * &lt;p>The base-independent settings are:&#xA; * &lt;ol>&#xA; * &lt;li>&lt;tt>precision&lt;/tt>:&#xA; * the number of digits to be used for an operation; results are&#xA; * rounded to this precision&#xA; * &#xA; * &lt;li>&lt;tt>roundingMode&lt;/tt>:&#xA; * a {@link RoundingMode} object which specifies the algorithm to be&#xA; * used for rounding.&#xA; * &lt;/ol>&#xA; *&#xA; * @see     BigDecimal&#xA; * @see     RoundingMode&#xA; * @author  Mike Cowlishaw&#xA; * @author  Joseph D. Darcy&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Final"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../io/Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
