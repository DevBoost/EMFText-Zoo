<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="BigDecimal.java">
  <comments>/*&#xA; * @(#)BigDecimal.java&#x9;1.56 06/02/08&#xA; *&#xA; * Copyright 2006 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/*&#xA; * @(#)BigDecimal.java  1.x 01/xx/xx&#xA; *&#xA; * Copyright 1996-2001 Sun Microsystems, Inc. All Rights Reserved.&#xA; * Portions Copyright IBM Corporation, 2001. All Rights Reserved.&#xA; *&#xA; * This software is the proprietary information of Sun Microsystems, Inc.&#xA; * Use is subject to license terms.&#xA; *&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>math</namespaces>
  <classifiers xsi:type="classifiers:Class" name="BigDecimal">
    <members xsi:type="members:Field" name="intVal">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The unscaled value of this BigDecimal, as returned by {@link&#xA;     * #unscaledValue}.&#xA;     *&#xA;     * @serial&#xA;     * @see #unscaledValue&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Volatile"/>
    </members>
    <members xsi:type="members:Field" name="scale">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The scale of this BigDecimal, as returned by {@link #scale}.&#xA;     *&#xA;     * @serial&#xA;     * @see #scale&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="precision">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Note: this may have any value, so</comments>
        <comments>// calculations must be done in longs</comments>
        <comments>/**&#xA;     * The number of decimal digits in this BigDecimal, or 0 if the&#xA;     * number of digits are not known (lookaside information).  If&#xA;     * nonzero, the value is guaranteed correct.  Use the precision()&#xA;     * method to obtain and set the value if it might be 0.  This&#xA;     * field is mutable until set nonzero.&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Volatile"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="stringCache">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Used to store the canonical string representation, if computed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Volatile"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="INFLATED">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.0"/>
        </next>
        <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Sentinel value for {@link #intCompact} indicating the&#xA;     * significand information is only available from {@code intVal}.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="intCompact">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * If the absolute value of the significand of this BigDecimal is&#xA;     * less than or equal to {@code Long.MAX_VALUE}, the value can be&#xA;     * compactly stored in this field and used in computations.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="MAX_COMPACT_DIGITS">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="18"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// All 18-digit base ten strings fit into a long; not all 19-digit</comments>
        <comments>// strings will</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MAX_BIGINT_BITS">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="62"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="6108874887143696463"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/* Appease the serialization gods */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="zeroThroughTen">
      <initialValue xsi:type="arrays:ArrayInstantiationByValues">
        <arrayInitializer>
          <initialValues xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.15"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValues>
          <initialValues xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.16"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValues>
          <initialValues xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValues>
          <initialValues xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValues>
          <initialValues xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValues>
          <initialValues xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValues>
          <initialValues xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValues>
          <initialValues xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValues>
          <initialValues xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValues>
          <initialValues xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValues>
          <initialValues xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.18"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValues>
        </arrayInitializer>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsAfter/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Cache of common small BigDecimal values.</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ZERO">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
        <arraySelectors>
          <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </arraySelectors>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Constants</comments>
        <comments>/**&#xA;     * The value 0, with a scale of 0.&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ONE">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
        <arraySelectors>
          <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </arraySelectors>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The value 1, with a scale of 0.&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="TEN">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
        <arraySelectors>
          <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
        </arraySelectors>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The value 10, with a scale of 0.&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:TryBlock">
        <comments>// This is the primary string to BigDecimal constructor; all</comments>
        <comments>// incoming strings end up here; it uses explicit (inline)</comments>
        <comments>// parsing for speed and generates at most one intermediate</comments>
        <comments>// (temporary) object (a char[] array).</comments>
        <comments>// use array bounds checking to handle too-long, len == 0,</comments>
        <comments>// bad offset, etc.</comments>
        <comments>// System.out.println(&quot; new: &quot; +intVal+&quot; [&quot;+scale+&quot;] &quot;+precision);</comments>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="isneg">
            <typeReference xsi:type="types:Boolean">
              <comments>// handle the sign</comments>
            </typeReference>
            <initialValue xsi:type="literals:BooleanLiteral"/>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <comments>// assume positive</comments>
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral" value="true"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1">
                  <comments>// leading minus means negative</comments>
                </child>
                <operator xsi:type="operators:PlusPlus"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
                <operator xsi:type="operators:MinusMinus"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
              </arraySelectors>
            </children>
            <children xsi:type="literals:CharacterLiteral" value="45"/>
          </condition>
          <elseStatement xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1">
                    <comments>// leading + allowed</comments>
                  </child>
                  <operator xsi:type="operators:PlusPlus"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
                  <operator xsi:type="operators:MinusMinus"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
                </arraySelectors>
              </children>
              <children xsi:type="literals:CharacterLiteral" value="43"/>
            </condition>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="dotoff">
            <typeReference xsi:type="types:Int">
              <comments>// should now be at numeric part of the significand</comments>
            </typeReference>
            <initialValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="cfirst">
            <typeReference xsi:type="types:Int">
              <comments>// '.' offset, -1 if none</comments>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="exp">
            <typeReference xsi:type="types:Long">
              <comments>// record start of integer</comments>
            </typeReference>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <comments>// exponent</comments>
          <statement xsi:type="statements:Throw">
            <comments>// protect against huge length</comments>
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="coeff">
            <typeReference xsi:type="types:Char"/>
            <arrayDimensionsAfter/>
            <initialValue xsi:type="arrays:ArrayInstantiationBySize">
              <typeReference xsi:type="types:Char"/>
              <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="c">
            <typeReference xsi:type="types:Char">
              <comments>// integer significand array</comments>
            </typeReference>
          </variable>
        </statements>
        <statements xsi:type="statements:ForLoop">
          <comments>// work</comments>
          <statement xsi:type="statements:Block">
            <comments>// [saves a test]</comments>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
                  </arraySelectors>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.6/@variable">
                      <comments>// have digit</comments>
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                      </arraySelectors>
                    </child>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:Continue">
                  <comments>// count of digits</comments>
                </statements>
              </statement>
              <condition xsi:type="expressions:ConditionalOrExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ConditionalAndExpression">
                    <children xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                      <children xsi:type="literals:CharacterLiteral" value="48"/>
                      <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                    </children>
                    <children xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                      <children xsi:type="literals:CharacterLiteral" value="57"/>
                      <relationOperators xsi:type="operators:LessThanOrEqual"/>
                    </children>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.108"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
                </children>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:Condition">
                  <comments>// have dot</comments>
                  <statement xsi:type="statements:Throw">
                    <comments>// two dots</comments>
                    <throwable xsi:type="instantiations:NewConstructorCall">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                    </throwable>
                  </statement>
                  <condition xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.2/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                  </condition>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.2/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:Continue"/>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                <children xsi:type="literals:CharacterLiteral" value="46"/>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <comments>// exponent expected</comments>
              <statement xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </throwable>
              </statement>
              <condition xsi:type="expressions:ConditionalAndExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                    <children xsi:type="literals:CharacterLiteral" value="101"/>
                  </expression>
                </children>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                    <children xsi:type="literals:CharacterLiteral" value="69"/>
                  </expression>
                </children>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
                <operator xsi:type="operators:PlusPlus"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
                  </arraySelectors>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
                <operator xsi:type="operators:MinusMinus"/>
              </expression>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="negexp">
                <typeReference xsi:type="types:Boolean"/>
                <initialValue xsi:type="literals:BooleanLiteral"/>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <comments>// optional sign</comments>
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.8/@statement/@statements.7/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:EqualityExpression">
                        <equalityOperators xsi:type="operators:Equal"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                        <children xsi:type="literals:CharacterLiteral" value="45"/>
                      </expression>
                    </value>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
                      </arraySelectors>
                    </value>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
                    <operator xsi:type="operators:MinusMinus"/>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:ConditionalOrExpression">
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                  <children xsi:type="literals:CharacterLiteral" value="45"/>
                </children>
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                  <children xsi:type="literals:CharacterLiteral" value="43"/>
                </children>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Throw">
                <comments>// no exponent digits</comments>
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </throwable>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:WhileLoop">
              <comments>// skip leading zeros in the exponent </comments>
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
                      </arraySelectors>
                    </value>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
                    <operator xsi:type="operators:MinusMinus"/>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:ConditionalAndExpression">
                <children xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </children>
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.134"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                      <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </children>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Throw">
                <comments>// too many nonzero exponent digits</comments>
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </throwable>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ForLoop">
              <comments>// c now holds first digit of exponent</comments>
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:LocalVariableStatement">
                  <variable name="v">
                    <typeReference xsi:type="types:Int"/>
                  </variable>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.8/@statement/@statements.12/@statement/@statements.0/@variable"/>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                          <children xsi:type="literals:CharacterLiteral" value="48"/>
                          <additiveOperators xsi:type="operators:Subtraction"/>
                        </value>
                      </expression>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:ConditionalAndExpression">
                    <children xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                      <children xsi:type="literals:CharacterLiteral" value="48"/>
                      <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                    </children>
                    <children xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                      <children xsi:type="literals:CharacterLiteral" value="57"/>
                      <relationOperators xsi:type="operators:LessThanOrEqual"/>
                    </children>
                  </condition>
                  <elseStatement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.8/@statement/@statements.12/@statement/@statements.0/@variable"/>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="references:IdentifierReference">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.134"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
                          </next>
                          <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
                        </value>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:Condition">
                      <statement xsi:type="statements:Throw">
                        <comments>// not a digit</comments>
                        <throwable xsi:type="instantiations:NewConstructorCall">
                          <typeReference xsi:type="types:NamespaceClassifierReference">
                            <classifierReferences>
                              <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
                            </classifierReferences>
                          </typeReference>
                        </throwable>
                      </statement>
                      <condition xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.8/@statement/@statements.12/@statement/@statements.0/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        <relationOperators xsi:type="operators:LessThan"/>
                      </condition>
                    </statements>
                  </elseStatement>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.4/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="expressions:MultiplicativeExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.4/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
                        <multiplicativeOperators xsi:type="operators:Multiplication"/>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.8/@statement/@statements.12/@statement/@statements.0/@variable"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </value>
                  </expression>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Break"/>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  </condition>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1">
                      <comments>// that was final character</comments>
                    </child>
                    <operator xsi:type="operators:PlusPlus"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.7/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
                      </arraySelectors>
                    </value>
                  </expression>
                </statements>
              </statement>
              <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
                <operator xsi:type="operators:MinusMinus"/>
              </updates>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.4/@variable">
                    <comments>// apply sign</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:UnaryExpression">
                    <operators xsi:type="operators:Subtraction"/>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.4/@variable"/>
                  </value>
                </expression>
              </statement>
              <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.8/@statement/@statements.7/@variable"/>
            </statements>
            <statements xsi:type="statements:Condition">
              <comments>// Next test is required for backwards compatibility</comments>
              <statement xsi:type="statements:Throw">
                <comments>// overflow</comments>
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </throwable>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Int"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.4/@variable"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.4/@variable"/>
              </condition>
            </statements>
            <statements xsi:type="statements:Break"/>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
          <updates xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
            <operator xsi:type="operators:PlusPlus"/>
          </updates>
          <updates xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
            <operator xsi:type="operators:MinusMinus"/>
          </updates>
        </statements>
        <statements xsi:type="statements:Condition">
          <comments>// here when no characters left</comments>
          <statement xsi:type="statements:Throw">
            <comments>// no digits found</comments>
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <comments>// [cannot overflow]</comments>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
                  <comments>// had dot; set scale</comments>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.2/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.3/@variable"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </expression>
                  </children>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.2/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:TryBlock">
              <comments>// had significant exponent</comments>
              <comments>// adjust</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.117">
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="expressions:UnaryExpression">
                        <operators xsi:type="operators:Subtraction"/>
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.4/@variable"/>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                  </value>
                </expression>
              </statements>
              <catcheBlocks>
                <statements xsi:type="statements:Throw">
                  <throwable xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="references:StringReference" value="Scale out of range."/>
                  </throwable>
                </statements>
                <parameter name="e">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </parameter>
              </catcheBlocks>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.4/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="first">
            <typeReference xsi:type="types:Int">
              <comments>// Remove leading zeros from precision (digits count)</comments>
            </typeReference>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <operator xsi:type="operators:MinusMinus"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ConditionalOrExpression">
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.6/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.12/@variable"/>
                    </arraySelectors>
                  </children>
                  <children xsi:type="literals:CharacterLiteral" value="48"/>
                </children>
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.134"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.6/@variable">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.12/@variable"/>
                        </arraySelectors>
                      </arguments>
                      <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </children>
              </expression>
            </children>
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </children>
          </condition>
          <updates xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.12/@variable"/>
            <operator xsi:type="operators:PlusPlus"/>
          </updates>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="quick">
            <typeReference xsi:type="types:Char">
              <comments>// Set the significand ..</comments>
              <comments>// Copy significand to exact-sized array, with sign if</comments>
              <comments>// negative</comments>
              <comments>// Later use: BigInteger(coeff, first, precision) for</comments>
              <comments>//   both cases, by allowing an extra char at the front of</comments>
              <comments>//   coeff.</comments>
            </typeReference>
            <arrayDimensionsAfter/>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.14/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="arrays:ArrayInstantiationBySize">
                  <typeReference xsi:type="types:Char"/>
                  <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.20"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.6/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.12/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.14/@variable"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.0/@variable"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.14/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="arrays:ArrayInstantiationBySize">
                  <typeReference xsi:type="types:Char"/>
                  <sizes xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </sizes>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.14/@variable">
                  <arraySelectors>
                    <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </arraySelectors>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:CharacterLiteral" value="45"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.20"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.6/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.12/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.14/@variable"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
              </expression>
            </statements>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Long.class.xmi#//@classifiers.0/@members.15"/>
                  <arguments xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.14/@variable"/>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </condition>
          <elseStatement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@statements.14/@variable"/>
              </value>
            </expression>
          </elseStatement>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/NegativeArraySizeException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="in">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Constructors</comments>
        <comments>/**&#xA;     * Translates a character array representation of a&#xA;     * &lt;tt>BigDecimal&lt;/tt> into a &lt;tt>BigDecimal&lt;/tt>, accepting the&#xA;     * same sequence of characters as the {@link #BigDecimal(String)}&#xA;     * constructor, while allowing a sub-array to be specified.&#xA;     * &#xA;     * &lt;p>Note that if the sequence of characters is already available&#xA;     * within a character array, using this constructor is faster than&#xA;     * converting the &lt;tt>char&lt;/tt> array to string and using the&#xA;     * &lt;tt>BigDecimal(String)&lt;/tt> constructor .&#xA;     *&#xA;     * @param  in &lt;tt>char&lt;/tt> array that is the source of characters.&#xA;     * @param  offset first character in the array to inspect.&#xA;     * @param  len number of characters to consider.&#xA;     * @throws NumberFormatException if &lt;tt>in&lt;/tt> is not a valid&#xA;     *         representation of a &lt;tt>BigDecimal&lt;/tt> or the defined subarray&#xA;     *         is not wholly within &lt;tt>in&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.2"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.119">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.3"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.3">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="in">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates a character array representation of a&#xA;     * &lt;tt>BigDecimal&lt;/tt> into a &lt;tt>BigDecimal&lt;/tt>, accepting the&#xA;     * same sequence of characters as the {@link #BigDecimal(String)}&#xA;     * constructor, while allowing a sub-array to be specified and&#xA;     * with rounding according to the context settings.&#xA;     * &#xA;     * &lt;p>Note that if the sequence of characters is already available&#xA;     * within a character array, using this constructor is faster than&#xA;     * converting the &lt;tt>char&lt;/tt> array to string and using the&#xA;     * &lt;tt>BigDecimal(String)&lt;/tt> constructor .&#xA;     *&#xA;     * @param  in &lt;tt>char&lt;/tt> array that is the source of characters.&#xA;     * @param  offset first character in the array to inspect.&#xA;     * @param  len number of characters to consider..&#xA;     * @param  mc the context to use.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     * @throws NumberFormatException if &lt;tt>in&lt;/tt> is not a valid&#xA;     *         representation of a &lt;tt>BigDecimal&lt;/tt> or the defined subarray&#xA;     *         is not wholly within &lt;tt>in&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="in">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates a character array representation of a&#xA;     * &lt;tt>BigDecimal&lt;/tt> into a &lt;tt>BigDecimal&lt;/tt>, accepting the&#xA;     * same sequence of characters as the {@link #BigDecimal(String)}&#xA;     * constructor.&#xA;     * &#xA;     * &lt;p>Note that if the sequence of characters is already available&#xA;     * as a character array, using this constructor is faster than&#xA;     * converting the &lt;tt>char&lt;/tt> array to string and using the&#xA;     * &lt;tt>BigDecimal(String)&lt;/tt> constructor .&#xA;     *&#xA;     * @param in &lt;tt>char&lt;/tt> array that is the source of characters.&#xA;     * @throws NumberFormatException if &lt;tt>in&lt;/tt> is not a valid&#xA;     *         representation of a &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="in">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates a character array representation of a&#xA;     * &lt;tt>BigDecimal&lt;/tt> into a &lt;tt>BigDecimal&lt;/tt>, accepting the&#xA;     * same sequence of characters as the {@link #BigDecimal(String)}&#xA;     * constructor and with rounding according to the context&#xA;     * settings.&#xA;     * &#xA;     * &lt;p>Note that if the sequence of characters is already available&#xA;     * as a character array, using this constructor is faster than&#xA;     * converting the &lt;tt>char&lt;/tt> array to string and using the&#xA;     * &lt;tt>BigDecimal(String)&lt;/tt> constructor .&#xA;     *&#xA;     * @param  in &lt;tt>char&lt;/tt> array that is the source of characters.&#xA;     * @param  mc the context to use.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     * @throws NumberFormatException if &lt;tt>in&lt;/tt> is not a valid&#xA;     *         representation of a &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.73"/>
            </next>
          </arguments>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates the string representation of a &lt;tt>BigDecimal&lt;/tt>&#xA;     * into a &lt;tt>BigDecimal&lt;/tt>.  The string representation consists&#xA;     * of an optional sign, &lt;tt>'+'&lt;/tt> (&lt;tt>'&amp;#92;u002B'&lt;/tt>) or&#xA;     * &lt;tt>'-'&lt;/tt> (&lt;tt>'&amp;#92;u002D'&lt;/tt>), followed by a sequence of&#xA;     * zero or more decimal digits (&quot;the integer&quot;), optionally&#xA;     * followed by a fraction, optionally followed by an exponent.&#xA;     * &#xA;     * &lt;p>The fraction consists of a decimal point followed by zero&#xA;     * or more decimal digits.  The string must contain at least one&#xA;     * digit in either the integer or the fraction.  The number formed&#xA;     * by the sign, the integer and the fraction is referred to as the&#xA;     * &lt;i>significand&lt;/i>.&#xA;     *&#xA;     * &lt;p>The exponent consists of the character &lt;tt>'e'&lt;/tt>&#xA;     * (&lt;tt>'&amp;#92;u0075'&lt;/tt>) or &lt;tt>'E'&lt;/tt> (&lt;tt>'&amp;#92;u0045'&lt;/tt>)&#xA;     * followed by one or more decimal digits.  The value of the&#xA;     * exponent must lie between -{@link Integer#MAX_VALUE} ({@link&#xA;     * Integer#MIN_VALUE}+1) and {@link Integer#MAX_VALUE}, inclusive.&#xA;     *&#xA;     * &lt;p>More formally, the strings this constructor accepts are&#xA;     * described by the following grammar:&#xA;     * &lt;blockquote>&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;i>BigDecimalString:&lt;/i>&#xA;     * &lt;dd>&lt;i>Sign&lt;sub>opt&lt;/sub> Significand Exponent&lt;sub>opt&lt;/sub>&lt;/i>&#xA;     * &lt;p>&#xA;     * &lt;dt>&lt;i>Sign:&lt;/i>&#xA;     * &lt;dd>&lt;tt>+&lt;/tt>&#xA;     * &lt;dd>&lt;tt>-&lt;/tt>&#xA;     * &lt;p>&#xA;     * &lt;dt>&lt;i>Significand:&lt;/i>&#xA;     * &lt;dd>&lt;i>IntegerPart&lt;/i> &lt;tt>.&lt;/tt> &lt;i>FractionPart&lt;sub>opt&lt;/sub>&lt;/i>&#xA;     * &lt;dd>&lt;tt>.&lt;/tt> &lt;i>FractionPart&lt;/i>&#xA;     * &lt;dd>&lt;i>IntegerPart&lt;/i>&#xA;     * &lt;p>&#xA;     * &lt;dt>&lt;i>IntegerPart:&#xA;     * &lt;dd>Digits&lt;/i>&#xA;     * &lt;p>&#xA;     * &lt;dt>&lt;i>FractionPart:&#xA;     * &lt;dd>Digits&lt;/i>&#xA;     * &lt;p>&#xA;     * &lt;dt>&lt;i>Exponent:&#xA;     * &lt;dd>ExponentIndicator SignedInteger&lt;/i>&#xA;     * &lt;p>&#xA;     * &lt;dt>&lt;i>ExponentIndicator:&lt;/i>&#xA;     * &lt;dd>&lt;tt>e&lt;/tt>&#xA;     * &lt;dd>&lt;tt>E&lt;/tt>&#xA;     * &lt;p>&#xA;     * &lt;dt>&lt;i>SignedInteger:&#xA;     * &lt;dd>Sign&lt;sub>opt&lt;/sub> Digits&lt;/i>&#xA;     * &lt;p>&#xA;     * &lt;dt>&lt;i>Digits:&#xA;     * &lt;dd>Digit&#xA;     * &lt;dd>Digits Digit&lt;/i>&#xA;     * &lt;p>&#xA;     * &lt;dt>&lt;i>Digit:&lt;/i>&#xA;     * &lt;dd>any character for which {@link Character#isDigit}&#xA;     * returns &lt;tt>true&lt;/tt>, including 0, 1, 2 ...&#xA;     * &lt;/dl>&#xA;     * &lt;/blockquote>&#xA;     *&#xA;     * &lt;p>The scale of the returned &lt;tt>BigDecimal&lt;/tt> will be the&#xA;     * number of digits in the fraction, or zero if the string&#xA;     * contains no decimal point, subject to adjustment for any&#xA;     * exponent; if the string contains an exponent, the exponent is&#xA;     * subtracted from the scale.  The value of the resulting scale&#xA;     * must lie between &lt;tt>Integer.MIN_VALUE&lt;/tt> and&#xA;     * &lt;tt>Integer.MAX_VALUE&lt;/tt>, inclusive.&#xA;     *&#xA;     * &lt;p>The character-to-digit mapping is provided by {@link&#xA;     * java.lang.Character#digit} set to convert to radix 10.  The&#xA;     * String may not contain any extraneous characters (whitespace,&#xA;     * for example).&#xA;     *&#xA;     * &lt;p>&lt;b>Examples:&lt;/b>&lt;br>&#xA;     * The value of the returned &lt;tt>BigDecimal&lt;/tt> is equal to&#xA;     * &lt;i>significand&lt;/i> &amp;times; 10&lt;sup>&amp;nbsp;&lt;i>exponent&lt;/i>&lt;/sup>.  &#xA;     * For each string on the left, the resulting representation&#xA;     * [&lt;tt>BigInteger&lt;/tt>, &lt;tt>scale&lt;/tt>] is shown on the right.&#xA;     * &lt;pre>&#xA;     * &quot;0&quot;            [0,0]&#xA;     * &quot;0.00&quot;         [0,2]&#xA;     * &quot;123&quot;          [123,0]&#xA;     * &quot;-123&quot;         [-123,0]&#xA;     * &quot;1.23E3&quot;       [123,-1]&#xA;     * &quot;1.23E+3&quot;      [123,-1]&#xA;     * &quot;12.3E+7&quot;      [123,-6]&#xA;     * &quot;12.0&quot;         [120,1]&#xA;     * &quot;12.3&quot;         [123,1]&#xA;     * &quot;0.00123&quot;      [123,5]&#xA;     * &quot;-1.23E-12&quot;    [-123,14]&#xA;     * &quot;1234.5E-4&quot;    [12345,5]&#xA;     * &quot;0E+7&quot;         [0,-7]&#xA;     * &quot;-0&quot;           [0,0]&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;p>Note: For values other than &lt;tt>float&lt;/tt> and&#xA;     * &lt;tt>double&lt;/tt> NaN and &amp;plusmn;Infinity, this constructor is&#xA;     * compatible with the values returned by {@link Float#toString}&#xA;     * and {@link Double#toString}.  This is generally the preferred&#xA;     * way to convert a &lt;tt>float&lt;/tt> or &lt;tt>double&lt;/tt> into a&#xA;     * BigDecimal, as it doesn't suffer from the unpredictability of&#xA;     * the {@link #BigDecimal(double)} constructor.&#xA;     *&#xA;     * @param val String representation of &lt;tt>BigDecimal&lt;/tt>.&#xA;     *&#xA;     * @throws NumberFormatException if &lt;tt>val&lt;/tt> is not a valid &#xA;     *&#x9;       representation of a &lt;tt>BigDecimal&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.73"/>
            </next>
          </arguments>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.119">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates the string representation of a &lt;tt>BigDecimal&lt;/tt>&#xA;     * into a &lt;tt>BigDecimal&lt;/tt>, accepting the same strings as the&#xA;     * {@link #BigDecimal(String)} constructor, with rounding&#xA;     * according to the context settings.&#xA;     * &#xA;     * @param  val string representation of a &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @param  mc the context to use.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     * @throws NumberFormatException if &lt;tt>val&lt;/tt> is not a valid&#xA;     *         representation of a BigDecimal.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Infinite or NaN"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Double.class.xmi#//@classifiers.0/@members.15"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Double.class.xmi#//@classifiers.0"/>
          </children>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Double.class.xmi#//@classifiers.0/@members.14"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Double.class.xmi#//@classifiers.0"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="valBits">
          <typeReference xsi:type="types:Long">
            <comments>// Translate the double into sign, exponent and significand, according</comments>
            <comments>// to the formulae in JLS, Section 20.10.22.</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Double.class.xmi#//@classifiers.0/@members.29"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Double.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sign">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalExpression">
              <child xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ShiftExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="63"/>
                    <shiftOperators xsi:type="operators:RightShift"/>
                  </expression>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </child>
              <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <expressionElse xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </expressionElse>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="exponent">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ShiftExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="52"/>
                    <shiftOperators xsi:type="operators:RightShift"/>
                  </expression>
                </children>
                <children xsi:type="literals:HexLongLiteral" hexValue="2047"/>
              </expression>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="significand">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalExpression">
              <child xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </child>
              <expressionIf xsi:type="expressions:ShiftExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AndExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable"/>
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="expressions:NestedExpression">
                          <expression xsi:type="expressions:ShiftExpression">
                            <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="52"/>
                            <shiftOperators xsi:type="operators:LeftShift"/>
                          </expression>
                        </children>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </expression>
                    </children>
                  </expression>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <shiftOperators xsi:type="operators:LeftShift"/>
              </expressionIf>
              <expressionElse xsi:type="expressions:InclusiveOrExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AndExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable"/>
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="expressions:NestedExpression">
                          <expression xsi:type="expressions:ShiftExpression">
                            <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="52"/>
                            <shiftOperators xsi:type="operators:LeftShift"/>
                          </expression>
                        </children>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </expression>
                    </children>
                  </expression>
                </children>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ShiftExpression">
                    <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="52"/>
                    <shiftOperators xsi:type="operators:LeftShift"/>
                  </expression>
                </children>
              </expressionElse>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable"/>
          <assignmentOperator xsi:type="operators:AssignmentMinus"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="1075"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// At this point, val == sign * significand * 2**exponent.</comments>
        <comments>/*&#xA; &#x9; * Special case zero to supress nonterminating normalization&#xA; &#x9; * and bogus scale calculation.&#xA; &#x9; */</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.15"/>
                </next>
                <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.4/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>// Normalize</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.4/@variable">
                <comments>//  i.e., significand is even</comments>
              </child>
              <assignmentOperator xsi:type="operators:AssignmentRightShift"/>
              <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AndExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.4/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <comments>// Calculate intVal and scale</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
              <arguments xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.4/@variable"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.60"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.67"/>
                        <arguments xsi:type="expressions:UnaryExpression">
                          <operators xsi:type="operators:Subtraction"/>
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable"/>
                        </arguments>
                      </next>
                      <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                      <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.60"/>
                    <arguments xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.67"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable"/>
                        </next>
                        <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
                    </arguments>
                  </next>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.116"/>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.100"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates a &lt;tt>double&lt;/tt> into a &lt;tt>BigDecimal&lt;/tt> which&#xA;     * is the exact decimal representation of the &lt;tt>double&lt;/tt>'s&#xA;     * binary floating-point value.  The scale of the returned&#xA;     * &lt;tt>BigDecimal&lt;/tt> is the smallest value such that&#xA;     * &lt;tt>(10&lt;sup>scale&lt;/sup> &amp;times; val)&lt;/tt> is an integer.&#xA;     * &lt;p>&#xA;     * &lt;b>Notes:&lt;/b>&#xA;     * &lt;ol>&#xA;     * &lt;li>&#xA;     * The results of this constructor can be somewhat unpredictable.&#xA;     * One might assume that writing &lt;tt>new BigDecimal(0.1)&lt;/tt> in&#xA;     * Java creates a &lt;tt>BigDecimal&lt;/tt> which is exactly equal to&#xA;     * 0.1 (an unscaled value of 1, with a scale of 1), but it is&#xA;     * actually equal to&#xA;     * 0.1000000000000000055511151231257827021181583404541015625.&#xA;     * This is because 0.1 cannot be represented exactly as a&#xA;     * &lt;tt>double&lt;/tt> (or, for that matter, as a binary fraction of&#xA;     * any finite length).  Thus, the value that is being passed&#xA;     * &lt;i>in&lt;/i> to the constructor is not exactly equal to 0.1,&#xA;     * appearances notwithstanding.&#xA;     *&#xA;     * &lt;li>&#xA;     * The &lt;tt>String&lt;/tt> constructor, on the other hand, is&#xA;     * perfectly predictable: writing &lt;tt>new BigDecimal(&quot;0.1&quot;)&lt;/tt>&#xA;     * creates a &lt;tt>BigDecimal&lt;/tt> which is &lt;i>exactly&lt;/i> equal to&#xA;     * 0.1, as one would expect.  Therefore, it is generally&#xA;     * recommended that the {@linkplain #BigDecimal(String)&#xA;     * &lt;tt>String&lt;/tt> constructor} be used in preference to this one.&#xA;     *&#xA;     * &lt;li>&#xA;     * When a &lt;tt>double&lt;/tt> must be used as a source for a&#xA;     * &lt;tt>BigDecimal&lt;/tt>, note that this constructor provides an&#xA;     * exact conversion; it does not give the same result as&#xA;     * converting the &lt;tt>double&lt;/tt> to a &lt;tt>String&lt;/tt> using the&#xA;     * {@link Double#toString(double)} method and then using the&#xA;     * {@link #BigDecimal(String)} constructor.  To get that result,&#xA;     * use the &lt;tt>static&lt;/tt> {@link #valueOf(double)} method.&#xA;     * &lt;/ol>&#xA;     *&#xA;     * @param val &lt;tt>double&lt;/tt> value to be converted to &#xA;     *        &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @throws NumberFormatException if &lt;tt>val&lt;/tt> is infinite or NaN.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.119">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates a &lt;tt>double&lt;/tt> into a &lt;tt>BigDecimal&lt;/tt>, with&#xA;     * rounding according to the context settings.  The scale of the&#xA;     * &lt;tt>BigDecimal&lt;/tt> is the smallest value such that&#xA;     * &lt;tt>(10&lt;sup>scale&lt;/sup> &amp;times; val)&lt;/tt> is an integer.&#xA;     * &#xA;     * &lt;p>The results of this constructor can be somewhat unpredictable&#xA;     * and its use is generally not recommended; see the notes under&#xA;     * the {@link #BigDecimal(double)} constructor.&#xA;     *&#xA;     * @param  val &lt;tt>double&lt;/tt> value to be converted to &#xA;     *         &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @param  mc the context to use.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         RoundingMode is UNNECESSARY.&#xA;     * @throws NumberFormatException if &lt;tt>val&lt;/tt> is infinite or NaN.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.116"/>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.100"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates a &lt;tt>BigInteger&lt;/tt> into a &lt;tt>BigDecimal&lt;/tt>.&#xA;     * The scale of the &lt;tt>BigDecimal&lt;/tt> is zero.&#xA;     *&#xA;     * @param val &lt;tt>BigInteger&lt;/tt> value to be converted to&#xA;     *            &lt;tt>BigDecimal&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.119">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.1"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.1">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates a &lt;tt>BigInteger&lt;/tt> into a &lt;tt>BigDecimal&lt;/tt>&#xA;     * rounding according to the context settings.  The scale of the&#xA;     * &lt;tt>BigDecimal&lt;/tt> is zero.&#xA;     * &#xA;     * @param val &lt;tt>BigInteger&lt;/tt> value to be converted to&#xA;     *            &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @param  mc the context to use.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <comments>// Negative scales are now allowed</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.116"/>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.100"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="unscaledVal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates a &lt;tt>BigInteger&lt;/tt> unscaled value and an&#xA;     * &lt;tt>int&lt;/tt> scale into a &lt;tt>BigDecimal&lt;/tt>.  The value of&#xA;     * the &lt;tt>BigDecimal&lt;/tt> is&#xA;     * &lt;tt>(unscaledVal &amp;times; 10&lt;sup>-scale&lt;/sup>)&lt;/tt>.&#xA;     *&#xA;     * @param unscaledVal unscaled value of the &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @param scale scale of the &lt;tt>BigDecimal&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.119">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.2"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.2">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="unscaledVal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates a &lt;tt>BigInteger&lt;/tt> unscaled value and an&#xA;     * &lt;tt>int&lt;/tt> scale into a &lt;tt>BigDecimal&lt;/tt>, with rounding&#xA;     * according to the context settings.  The value of the&#xA;     * &lt;tt>BigDecimal&lt;/tt> is &lt;tt>(unscaledVal &amp;times;&#xA;     * 10&lt;sup>-scale&lt;/sup>)&lt;/tt>, rounded according to the&#xA;     * &lt;tt>precision&lt;/tt> and rounding mode settings.&#xA;     *&#xA;     * @param  unscaledVal unscaled value of the &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @param  scale scale of the &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @param  mc the context to use.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates an &lt;tt>int&lt;/tt> into a &lt;tt>BigDecimal&lt;/tt>.  The&#xA;     * scale of the &lt;tt>BigDecimal&lt;/tt> is zero.&#xA;     *&#xA;     * @param val &lt;tt>int&lt;/tt> value to be converted to&#xA;     *            &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.119">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.1"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.1">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates an &lt;tt>int&lt;/tt> into a &lt;tt>BigDecimal&lt;/tt>, with&#xA;     * rounding according to the context settings.  The scale of the&#xA;     * &lt;tt>BigDecimal&lt;/tt>, before any rounding, is zero.&#xA;     * &#xA;     * @param  val &lt;tt>int&lt;/tt> value to be converted to &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @param  mc the context to use.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
          </expression>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.108">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
        </condition>
        <elseStatement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </value>
          </expression>
        </elseStatement>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates a &lt;tt>long&lt;/tt> into a &lt;tt>BigDecimal&lt;/tt>.  The&#xA;     * scale of the &lt;tt>BigDecimal&lt;/tt> is zero.&#xA;     *&#xA;     * @param val &lt;tt>long&lt;/tt> value to be converted to &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
          </expression>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.108">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
        </condition>
        <elseStatement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </value>
          </expression>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.119">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates a &lt;tt>long&lt;/tt> into a &lt;tt>BigDecimal&lt;/tt>, with&#xA;     * rounding according to the context settings.  The scale of the&#xA;     * &lt;tt>BigDecimal&lt;/tt>, before any rounding, is zero.&#xA;     * &#xA;     * @param  val &lt;tt>long&lt;/tt> value to be converted to &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @param  mc the context to use.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.1"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Trusted internal constructor&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="BigDecimal">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.2"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="intVal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Trusted internal constructor&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="unscaledVal">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Static Factory Methods</comments>
        <comments>/**&#xA;     * Translates a &lt;tt>long&lt;/tt> unscaled value and an&#xA;     * &lt;tt>int&lt;/tt> scale into a &lt;tt>BigDecimal&lt;/tt>.  This&#xA;     * &amp;quot;static factory method&amp;quot; is provided in preference to&#xA;     * a (&lt;tt>long&lt;/tt>, &lt;tt>int&lt;/tt>) constructor because it&#xA;     * allows for reuse of frequently used &lt;tt>BigDecimal&lt;/tt> values..&#xA;     *&#xA;     * @param unscaledVal unscaled value of the &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @param scale scale of the &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @return a &lt;tt>BigDecimal&lt;/tt> whose value is&#xA;     *&#x9;       &lt;tt>(unscaledVal &amp;times; 10&lt;sup>-scale&lt;/sup>)&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9">
              <arraySelectors>
                <position xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Int"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
                </position>
              </arraySelectors>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.1"/>
          </returnValue>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.108">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates a &lt;tt>long&lt;/tt> value into a &lt;tt>BigDecimal&lt;/tt>&#xA;     * with a scale of zero.  This &amp;quot;static factory method&amp;quot;&#xA;     * is provided in preference to a (&lt;tt>long&lt;/tt>) constructor&#xA;     * because it allows for reuse of frequently used&#xA;     * &lt;tt>BigDecimal&lt;/tt> values.&#xA;     *&#xA;     * @param val value of the &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @return a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>val&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates a &lt;tt>double&lt;/tt> into a &lt;tt>BigDecimal&lt;/tt>, using&#xA;     * the &lt;tt>double&lt;/tt>'s canonical string representation provided&#xA;     * by the {@link Double#toString(double)} method.&#xA;     * &#xA;     * &lt;p>&lt;b>Note:&lt;/b> This is generally the preferred way to convert&#xA;     * a &lt;tt>double&lt;/tt> (or &lt;tt>float&lt;/tt>) into a&#xA;     * &lt;tt>BigDecimal&lt;/tt>, as the value returned is equal to that&#xA;     * resulting from constructing a &lt;tt>BigDecimal&lt;/tt> from the&#xA;     * result of using {@link Double#toString(double)}.&#xA;     *&#xA;     * @param  val &lt;tt>double&lt;/tt> to convert to a &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @return a &lt;tt>BigDecimal&lt;/tt> whose value is equal to or approximately&#xA;     *         equal to the value of &lt;tt>val&lt;/tt>.&#xA;     * @throws NumberFormatException if &lt;tt>val&lt;/tt> is infinite or NaN.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <comments>// Reminder: a zero double returns '0.0', so we cannot fastpath</comments>
        <comments>// to use the constant ZERO.  This might be important enough to</comments>
        <comments>// justify a factory approach, a cache, or a few private</comments>
        <comments>// constants, later.</comments>
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Double.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Double.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="add">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="augend">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Arithmetic Operations</comments>
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this +&#xA;     * augend)&lt;/tt>, and whose scale is &lt;tt>max(this.scale(),&#xA;     * augend.scale())&lt;/tt>.&#xA;     *&#xA;     * @param  augend value to be added to this &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @return &lt;tt>this + augend&lt;/tt>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="arg">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <initialValues xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </initialValues>
              <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
            </arrayInitializer>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.110">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="x">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="y">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Might be able to do a more clever check incorporating the</comments>
        <comments>// inflated check into the overflow computation.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="sum">
              <typeReference xsi:type="types:Long"/>
              <initialValue xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.3/@variable"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>/*&#xA;&#x9;     * If the sum is not an overflowed value, continue to use&#xA;&#x9;     * the compact representation.  if either of x or y is&#xA;&#x9;     * INFLATED, the sum should also be regarded as an&#xA;&#x9;     * overflow.  See &quot;Hacker's Delight&quot; section 2-12 for&#xA;&#x9;     * explanation of the overflow test.&#xA;&#x9;     */</comments>
            <statement xsi:type="statements:Return">
              <comments>// not overflowed</comments>
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.4/@statement/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    </arraySelectors>
                  </arguments>
                </next>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AndExpression">
                      <children xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:ExclusiveOrExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.4/@statement/@statements.0/@variable"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.2/@variable"/>
                        </expression>
                      </children>
                      <children xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:ExclusiveOrExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.4/@statement/@statements.0/@variable"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.3/@variable"/>
                        </expression>
                      </children>
                    </expression>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="63"/>
                  <shiftOperators xsi:type="operators:RightShift"/>
                </expression>
              </children>
              <children xsi:type="literals:DecimalLongLiteral" decimalValue="0"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.2/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.3/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.56"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                    </next>
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    </arraySelectors>
                  </arguments>
                </next>
              </next>
            </next>
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="add">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="augend">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this + augend)&lt;/tt>,&#xA;     * with rounding according to the context settings.&#xA;     *&#xA;     * If either number is zero and the precision setting is nonzero then&#xA;     * the other number, rounded if necessary, is used as the result.&#xA;     *&#xA;     * @param  augend value to be added to this &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @param  mc the context to use.&#xA;     * @return &lt;tt>this + augend&lt;/tt>, rounded as necessary.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.34">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lhs">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
          <self xsi:type="literals:This">
            <comments>// Could optimize if values are compact</comments>
          </self>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Block">
        <comments>// If either number is zero then the other number, rounded and</comments>
        <comments>// scaled if necessary, is used as the result.</comments>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="lhsIsZero">
            <typeReference xsi:type="types:Boolean"/>
            <initialValue xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.1/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="augendIsZero">
            <typeReference xsi:type="types:Boolean"/>
            <initialValue xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="preferredScale">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.1/@variable">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                    </arguments>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="result">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <comments>// Could use a factory for zero instead of a new object</comments>
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0"/>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.15"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
                  </arguments>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.0/@variable"/>
                </returnValue>
              </statement>
              <condition xsi:type="expressions:ConditionalAndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.0/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.1/@variable"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:ConditionalExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.0/@variable"/>
                  <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.120">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
                    </next>
                  </expressionIf>
                  <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.1/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.120">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
                    </next>
                  </expressionElse>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.1/@variable"/>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.1/@variable">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.0/@variable"/>
              </condition>
              <elseStatement xsi:type="statements:Condition">
                <statement xsi:type="statements:Return">
                  <returnValue xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0"/>
                    </typeReference>
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.116">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.0/@variable"/>
                    </next>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.1/@variable">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.1/@variable">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.1/@variable">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    </arguments>
                  </returnValue>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.1/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.0/@variable"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </condition>
                <elseStatement xsi:type="statements:Block">
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="precisionDiff">
                      <typeReference xsi:type="types:Int">
                        <comments>// result.scale &lt; preferredScale</comments>
                      </typeReference>
                      <initialValue xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1">
                          <next xsi:type="references:IdentifierReference">
                            <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
                          </next>
                        </children>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.1/@variable">
                          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
                        </children>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="scaleDiff">
                      <typeReference xsi:type="types:Int"/>
                      <initialValue xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.0/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.1/@variable">
                          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                        </children>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:Condition">
                    <comments>// can achieve target scale</comments>
                    <statement xsi:type="statements:Return">
                      <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.1/@variable">
                        <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.0/@variable"/>
                        </next>
                      </returnValue>
                    </statement>
                    <condition xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.4/@elseStatement/@elseStatement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.4/@elseStatement/@elseStatement/@statements.1/@variable"/>
                      <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                    </condition>
                    <elseStatement xsi:type="statements:Return">
                      <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.1/@variable">
                        <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
                          <arguments xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.1/@variable">
                              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                            </children>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.2/@statement/@statements.4/@elseStatement/@elseStatement/@statements.0/@variable"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                          </arguments>
                        </next>
                      </returnValue>
                    </elseStatement>
                  </statements>
                </elseStatement>
              </elseStatement>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalOrExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.4/@statements.1/@variable"/>
          </condition>
        </statements>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="padding">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Long"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </child>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </children>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="arg">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0">
                  <comments>// scales differ; alignment needed</comments>
                </classifierReferences>
              </typeReference>
              <arrayDimensionsAfter/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.36">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.1/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.5/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.110">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.6/@statement/@statements.0/@variable"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.6/@statement/@statements.0/@variable">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </arraySelectors>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.6/@statement/@statements.0/@variable">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </arraySelectors>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.5/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.120">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.1/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.56"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                    </next>
                  </arguments>
                </next>
              </next>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.1/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="preAlign">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lhs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="augend">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="padding">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Returns an array of length two, the sum of whose entries is&#xA;     * equal to the rounded sum of the {@code BigDecimal} arguments.&#xA;     *&#xA;     * &lt;p>If the digit positions of the arguments have a sufficient&#xA;     * gap between them, the value smaller in magnitude can be&#xA;     * condensed into a &amp;quot;sticky bit&amp;quot; and the end result will&#xA;     * round the same way &lt;em>if&lt;/em> the precision of the final&#xA;     * result does not include the high order digit of the small&#xA;     * magnitude operand.&#xA;     *&#xA;     * &lt;p>Note that while strictly speaking this is an optimization,&#xA;     * it makes a much wider range of additions practical.&#xA;     * &#xA;     * &lt;p>This corresponds to a pre-shift operation in a fixed&#xA;     * precision floating-point adder; this method is complicated by&#xA;     * variable precision of the result as determined by the&#xA;     * MathContext.  A more nuanced operation could implement a&#xA;     * &amp;quot;right shift&amp;quot; on the smaller magnitude operand so&#xA;     * that the number of digits of the smaller operand could be&#xA;     * reduced even though the significands partially overlapped.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Assert">
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.2"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="big">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="small">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.1/@variable">
                <comments>// lhs is big;   augend is small</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.2"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.1/@variable">
                <comments>// lhs is small; augend is big</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="estResultUlpScale">
          <typeReference xsi:type="types:Long">
            <comments>/*&#xA;&#x9; * This is the estimated scale of an ulp of the result; it&#xA;&#x9; * assumes that the result doesn't have a carry-out on a true&#xA;&#x9; * add (e.g. 999 + 1 => 1000) or any subtractive cancellation&#xA;&#x9; * on borrowing (e.g. 100 - 1.2 => 98.8)&#xA;&#x9; */</comments>
          </typeReference>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Long"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </child>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.1/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.3">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
              </next>
            </children>
            <additiveOperators xsi:type="operators:Subtraction"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="smallHighDigitPos">
          <typeReference xsi:type="types:Long">
            <comments>/*&#xA;&#x9; * The low-order digit position of big is big.scale().  This&#xA;&#x9; * is true regardless of whether big has a positive or&#xA;&#x9; * negative scale.  The high-order digit position of small is&#xA;&#x9; * small.scale - (small.precision() - 1).  To do the full&#xA;&#x9; * condensation, the digit positions of big and small must be&#xA;&#x9; * disjoint *and* the digit positions of small should not be&#xA;&#x9; * directly visible in the result.&#xA;&#x9; */</comments>
          </typeReference>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Long"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.2/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </child>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.2/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.2/@variable">
                <comments>// small digits not visible</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.2/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
                  </arguments>
                  <arguments xsi:type="references:SelfReference">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.117">
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.1/@variable">
                              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                            </arguments>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.4/@variable"/>
                          </next>
                          <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                        </children>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </arguments>
                    </next>
                    <self xsi:type="literals:This"/>
                  </arguments>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.5/@variable"/>
            <children xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.5/@variable">
              <comments>// big and small disjoint</comments>
            </children>
            <children xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.4/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>// Since addition is symmetric, preserving input order in</comments>
              <comments>// returned operands doesn't matter</comments>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.1/@variable"/>
              <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.2/@variable"/>
            </arrayInitializer>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="subtract">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="subtrahend">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this -&#xA;     * subtrahend)&lt;/tt>, and whose scale is &lt;tt>max(this.scale(),&#xA;     * subtrahend.scale())&lt;/tt>.&#xA;     *&#xA;     * @param  subtrahend value to be subtracted from this &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @return &lt;tt>this - subtrahend&lt;/tt>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="arg">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <initialValues xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </initialValues>
              <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
            </arrayInitializer>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.110">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="x">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="y">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Might be able to do a more clever check incorporating the</comments>
        <comments>// inflated check into the overflow computation.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="difference">
              <typeReference xsi:type="types:Long"/>
              <initialValue xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.3/@variable"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>/*&#xA;&#x9;     * If the difference is not an overflowed value, continue&#xA;&#x9;     * to use the compact representation.  if either of x or y&#xA;&#x9;     * is INFLATED, the difference should also be regarded as&#xA;&#x9;     * an overflow.  See &quot;Hacker's Delight&quot; section 2-12 for&#xA;&#x9;     * explanation of the overflow test.&#xA;&#x9;     */</comments>
            <statement xsi:type="statements:Return">
              <comments>// not overflowed</comments>
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.4/@statement/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    </arraySelectors>
                  </arguments>
                </next>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="expressions:ShiftExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AndExpression">
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:ExclusiveOrExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.2/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.3/@variable"/>
                      </expression>
                    </children>
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:ExclusiveOrExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.4/@statement/@statements.0/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.2/@variable"/>
                      </expression>
                    </children>
                  </expression>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="63"/>
                <shiftOperators xsi:type="operators:RightShift"/>
              </children>
              <children xsi:type="literals:DecimalLongLiteral" decimalValue="0"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.2/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.3/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.58"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                    </next>
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    </arraySelectors>
                  </arguments>
                </next>
              </next>
            </next>
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="subtract">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="subtrahend">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this - subtrahend)&lt;/tt>,&#xA;     * with rounding according to the context settings.&#xA;     *&#xA;     * If &lt;tt>subtrahend&lt;/tt> is zero then this, rounded if necessary, is used as the&#xA;     * result.  If this is zero then the result is &lt;tt>subtrahend.negate(mc)&lt;/tt>.&#xA;     *&#xA;     * @param  subtrahend value to be subtracted from this &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @param  mc the context to use.&#xA;     * @return &lt;tt>this - subtrahend&lt;/tt>, rounded as necessary.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.37">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.1">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
          <self xsi:type="literals:This">
            <comments>// share the special rounding code in add()</comments>
          </self>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="rhs">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.74"/>
                </next>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.3/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.35">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.3/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="multiply">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="multiplicand">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this &amp;times;&#xA;     * multiplicand)&lt;/tt>, and whose scale is &lt;tt>(this.scale() +&#xA;     * multiplicand.scale())&lt;/tt>.&#xA;     *&#xA;     * @param  multiplicand value to be multiplied by this &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @return &lt;tt>this * multiplicand&lt;/tt>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="x">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="y">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="productScale">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.117">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Long"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </children>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Might be able to do a more clever check incorporating the</comments>
        <comments>// inflated check into the overflow computation.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="product">
              <typeReference xsi:type="types:Long">
                <comments>/*&#xA;&#x9;     * If the product is not an overflowed value, continue&#xA;&#x9;     * to use the compact representation.  if either of x or y&#xA;&#x9;     * is INFLATED, the product should also be regarded as&#xA;&#x9;     * an overflow.  See &quot;Hacker's Delight&quot; section 2-12 for&#xA;&#x9;     * explanation of the overflow test.&#xA;&#x9;     */</comments>
              </typeReference>
              <initialValue xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.0/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.1/@variable"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <comments>// not overflowed</comments>
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.3/@statement/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.2/@variable"/>
                </next>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.1/@variable"/>
                    <children xsi:type="literals:DecimalLongLiteral" decimalValue="0"/>
                  </children>
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="expressions:MultiplicativeExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.3/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.1/@variable"/>
                      <multiplicativeOperators xsi:type="operators:Division"/>
                    </children>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.0/@variable"/>
                  </children>
                </expression>
              </child>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.1/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.60"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
                        <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                      </next>
                    </arguments>
                  </next>
                </next>
              </next>
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.2/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.4/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="multiply">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="multiplicand">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this &amp;times;&#xA;     * multiplicand)&lt;/tt>, with rounding according to the context settings.&#xA;     *&#xA;     * @param  multiplicand value to be multiplied by this &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @param  mc the context to use.&#xA;     * @return &lt;tt>this * multiplicand&lt;/tt>, rounded as necessary.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.39">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lhs">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.1/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.39">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.120">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
              </next>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
              </arguments>
            </next>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="divide">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="divisor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="roundingMode">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this /&#xA;     * divisor)&lt;/tt>, and whose scale is as specified.  If rounding must&#xA;     * be performed to generate a result with the specified scale, the&#xA;     * specified rounding mode is applied.&#xA;     * &#xA;     * &lt;p>The new {@link #divide(BigDecimal, int, RoundingMode)} method&#xA;     * should be used in preference to this legacy method.&#xA;     * &#xA;     * @param  divisor value by which this &lt;tt>BigDecimal&lt;/tt> is to be divided.&#xA;     * @param  scale scale of the &lt;tt>BigDecimal&lt;/tt> quotient to be returned.&#xA;     * @param  roundingMode rounding mode to apply.&#xA;     * @return &lt;tt>this / divisor&lt;/tt>&#xA;     * @throws ArithmeticException if &lt;tt>divisor&lt;/tt> is zero,&#xA;     *         &lt;tt>roundingMode==ROUND_UNNECESSARY&lt;/tt> and&#xA;     *         the specified scale is insufficient to represent the result&#xA;     *         of the division exactly.&#xA;     * @throws IllegalArgumentException if &lt;tt>roundingMode&lt;/tt> does not&#xA;     *         represent a valid rounding mode.&#xA;     * @see    #ROUND_UP&#xA;     * @see    #ROUND_DOWN&#xA;     * @see    #ROUND_CEILING&#xA;     * @see    #ROUND_FLOOR&#xA;     * @see    #ROUND_HALF_UP&#xA;     * @see    #ROUND_HALF_DOWN&#xA;     * @see    #ROUND_HALF_EVEN&#xA;     * @see    #ROUND_UNNECESSARY&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>/* &#xA;&#x9; * IMPLEMENTATION NOTE: This method *must* return a new object&#xA;&#x9; * since dropDigits uses divide to generate a value whose&#xA;&#x9; * scale is then modified.&#xA;&#x9; */</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Invalid rounding mode"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="dividend">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>/*&#xA;         * Rescale dividend or divisor (whichever can be &quot;upscaled&quot; to&#xA;         * produce correctly scaled quotient).&#xA;         * Take care to detect out-of-range scales&#xA;         */</comments>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    </children>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </next>
                <self xsi:type="literals:This"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.117">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Long"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </children>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </children>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
                  <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.117">
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="expressions:CastExpression">
                        <typeReference xsi:type="types:Long"/>
                        <child xsi:type="references:SelfReference">
                          <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                          <self xsi:type="literals:This"/>
                        </child>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </arguments>
                  </arguments>
                </next>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="compact">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            </children>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="div">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="rem">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
        </variable>
      </statements>
      <statements xsi:type="statements:EmptyStatement"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="q">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
          <additionalLocalVariables name="r">
            <initialValue xsi:type="literals:NullLiteral"/>
          </additionalLocalVariables>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.4/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.1/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                </children>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.5/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.1/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                </children>
                <multiplicativeOperators xsi:type="operators:Remainder"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@variable"/>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="i">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <comments>// Do the division and return result if it's exact.</comments>
                  <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arrayDimensionsAfter/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.1/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.65"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
                        <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
                          <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                        </next>
                      </arguments>
                    </next>
                  </next>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.7/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.8/@elseStatement/@statements.0/@variable">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </arraySelectors>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.7/@variable/@additionalLocalVariables.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.8/@elseStatement/@statements.0/@variable">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </arraySelectors>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Check for exact result</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.4/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.5/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@variable"/>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.7/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.7/@variable/@additionalLocalVariables.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.75"/>
                </next>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <comments>// Rounding prohibited</comments>
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Rounding necessary"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.2"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="signum">
          <typeReference xsi:type="types:Int">
            <comments>/* Round as appropriate */</comments>
          </typeReference>
          <initialValue xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.1/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
            </children>
            <multiplicativeOperators xsi:type="operators:Multiplication"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="increment">
          <typeReference xsi:type="types:Boolean">
            <comments>// Sign of result</comments>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.12/@variable">
                <comments>// Away from zero</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.2"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.12/@variable">
                  <comments>// Towards zero</comments>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66"/>
          </condition>
          <elseStatement xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.12/@variable">
                    <comments>// Towards +infinity</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.11/@variable"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <relationOperators xsi:type="operators:GreaterThan"/>
                    </expression>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.2"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
            </condition>
            <elseStatement xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.12/@variable">
                      <comments>// Towards -infinity</comments>
                    </child>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.11/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        <relationOperators xsi:type="operators:LessThan"/>
                      </expression>
                    </value>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.2"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68"/>
              </condition>
              <elseStatement xsi:type="statements:Block">
                <statements xsi:type="statements:LocalVariableStatement">
                  <variable name="cmpFracHalf">
                    <typeReference xsi:type="types:Int">
                      <comments>// Remaining modes based on nearest-neighbor determination</comments>
                    </typeReference>
                  </variable>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.13/@elseStatement/@elseStatement/@elseStatement/@elseStatement/@statements.0/@variable"/>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.122">
                          <arguments xsi:type="references:IdentifierReference">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.29"/>
                              <arguments xsi:type="expressions:MultiplicativeExpression">
                                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.5/@variable"/>
                                <multiplicativeOperators xsi:type="operators:Multiplication"/>
                              </arguments>
                            </next>
                            <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                          </arguments>
                          <arguments xsi:type="references:IdentifierReference">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.30"/>
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
                                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                              </arguments>
                            </next>
                            <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                          </arguments>
                        </value>
                      </expression>
                    </statements>
                  </statement>
                  <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@variable"/>
                  <elseStatement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.13/@elseStatement/@elseStatement/@elseStatement/@elseStatement/@statements.0/@variable">
                          <comments>// add(r) here is faster than multiply(2) or shiftLeft(1)</comments>
                        </child>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.7/@variable/@additionalLocalVariables.0">
                          <next xsi:type="references:MethodCall">
                            <next xsi:type="references:MethodCall">
                              <next xsi:type="references:MethodCall">
                                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.106"/>
                                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
                                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                                    <next xsi:type="references:MethodCall">
                                      <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.73"/>
                                    </next>
                                  </next>
                                </arguments>
                              </next>
                              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.73"/>
                            </next>
                            <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.56"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.7/@variable/@additionalLocalVariables.0"/>
                          </next>
                        </value>
                      </expression>
                    </statements>
                  </elseStatement>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.12/@variable">
                          <comments>// We're closer to higher digit</comments>
                        </child>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="literals:BooleanLiteral"/>
                      </expression>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.13/@elseStatement/@elseStatement/@elseStatement/@elseStatement/@statements.0/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    <relationOperators xsi:type="operators:LessThan"/>
                  </condition>
                  <elseStatement xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.12/@variable">
                            <comments>// We're closer to lower digit</comments>
                          </child>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="literals:BooleanLiteral" value="true"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.13/@elseStatement/@elseStatement/@elseStatement/@elseStatement/@statements.0/@variable"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <relationOperators xsi:type="operators:GreaterThan"/>
                    </condition>
                    <elseStatement xsi:type="statements:Block">
                      <statements xsi:type="statements:Condition">
                        <comments>// We're dead-center</comments>
                        <statement xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="expressions:AssignmentExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.12/@variable"/>
                            <assignmentOperator xsi:type="operators:Assignment"/>
                            <value xsi:type="literals:BooleanLiteral" value="true"/>
                          </expression>
                        </statement>
                        <condition xsi:type="expressions:EqualityExpression">
                          <equalityOperators xsi:type="operators:Equal"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.2"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69"/>
                        </condition>
                        <elseStatement xsi:type="statements:Condition">
                          <statement xsi:type="statements:ExpressionStatement">
                            <expression xsi:type="expressions:AssignmentExpression">
                              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.12/@variable"/>
                              <assignmentOperator xsi:type="operators:Assignment"/>
                              <value xsi:type="literals:BooleanLiteral"/>
                            </expression>
                          </statement>
                          <condition xsi:type="expressions:EqualityExpression">
                            <equalityOperators xsi:type="operators:Equal"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.2"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70"/>
                          </condition>
                          <elseStatement xsi:type="statements:Block">
                            <comments>// true iff q is odd</comments>
                            <statements xsi:type="statements:Condition">
                              <comments>// roundingMode == ROUND_HALF_EVEN</comments>
                              <statement xsi:type="statements:ExpressionStatement">
                                <expression xsi:type="expressions:AssignmentExpression">
                                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.12/@variable"/>
                                  <assignmentOperator xsi:type="operators:Assignment"/>
                                  <value xsi:type="expressions:EqualityExpression">
                                    <equalityOperators xsi:type="operators:NotEqual"/>
                                    <children xsi:type="expressions:NestedExpression">
                                      <expression xsi:type="expressions:AndExpression">
                                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.4/@variable"/>
                                        <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                                      </expression>
                                    </children>
                                    <children xsi:type="literals:DecimalLongLiteral" decimalValue="0"/>
                                  </value>
                                </expression>
                              </statement>
                              <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@variable"/>
                              <elseStatement xsi:type="statements:ExpressionStatement">
                                <expression xsi:type="expressions:AssignmentExpression">
                                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.12/@variable"/>
                                  <assignmentOperator xsi:type="operators:Assignment"/>
                                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.7/@variable">
                                    <next xsi:type="references:MethodCall">
                                      <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.95"/>
                                      <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                                    </next>
                                  </value>
                                </expression>
                              </elseStatement>
                            </statements>
                          </elseStatement>
                        </elseStatement>
                      </statements>
                    </elseStatement>
                  </elseStatement>
                </statements>
              </elseStatement>
            </elseStatement>
          </elseStatement>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.4/@variable"/>
                <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.11/@variable"/>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.12/@variable"/>
          </statements>
          <statements xsi:type="statements:Return">
            <comments>// guaranteed not to overflow</comments>
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.4/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@variable"/>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ConditionalExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.12/@variable"/>
                <expressionIf xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0"/>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.7/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.56"/>
                      <arguments xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.11/@variable"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
                      </arguments>
                    </next>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
                </expressionIf>
                <expressionElse xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0"/>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.7/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
                </expressionElse>
              </expression>
            </returnValue>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="divide">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="divisor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="roundingMode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this /&#xA;     * divisor)&lt;/tt>, and whose scale is as specified.  If rounding must&#xA;     * be performed to generate a result with the specified scale, the&#xA;     * specified rounding mode is applied.&#xA;     * &#xA;     * @param  divisor value by which this &lt;tt>BigDecimal&lt;/tt> is to be divided.&#xA;     * @param  scale scale of the &lt;tt>BigDecimal&lt;/tt> quotient to be returned.&#xA;     * @param  roundingMode rounding mode to apply.&#xA;     * @return &lt;tt>this / divisor&lt;/tt>&#xA;     * @throws ArithmeticException if &lt;tt>divisor&lt;/tt> is zero,&#xA;     *         &lt;tt>roundingMode==RoundingMode.UNNECESSARY&lt;/tt> and&#xA;     *         the specified scale is insufficient to represent the result&#xA;     *         of the division exactly.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.41">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.2">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="RoundingMode.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="divide">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="divisor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="roundingMode">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this /&#xA;     * divisor)&lt;/tt>, and whose scale is &lt;tt>this.scale()&lt;/tt>.  If&#xA;     * rounding must be performed to generate a result with the given&#xA;     * scale, the specified rounding mode is applied.&#xA;     * &#xA;     * &lt;p>The new {@link #divide(BigDecimal, RoundingMode)} method&#xA;     * should be used in preference to this legacy method.&#xA;     * &#xA;     * @param  divisor value by which this &lt;tt>BigDecimal&lt;/tt> is to be divided.&#xA;     * @param  roundingMode rounding mode to apply.&#xA;     * @return &lt;tt>this / divisor&lt;/tt>&#xA;     * @throws ArithmeticException if &lt;tt>divisor==0&lt;/tt>, or&#xA;     *         &lt;tt>roundingMode==ROUND_UNNECESSARY&lt;/tt> and&#xA;     *         &lt;tt>this.scale()&lt;/tt> is insufficient to represent the result&#xA;     *         of the division exactly.&#xA;     * @throws IllegalArgumentException if &lt;tt>roundingMode&lt;/tt> does not&#xA;     *         represent a valid rounding mode.&#xA;     * @see    #ROUND_UP&#xA;     * @see    #ROUND_DOWN&#xA;     * @see    #ROUND_CEILING&#xA;     * @see    #ROUND_FLOOR&#xA;     * @see    #ROUND_HALF_UP&#xA;     * @see    #ROUND_HALF_DOWN&#xA;     * @see    #ROUND_HALF_EVEN&#xA;     * @see    #ROUND_UNNECESSARY&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.41">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.1"/>
          </next>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="divide">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="divisor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="roundingMode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this /&#xA;     * divisor)&lt;/tt>, and whose scale is &lt;tt>this.scale()&lt;/tt>.  If&#xA;     * rounding must be performed to generate a result with the given&#xA;     * scale, the specified rounding mode is applied.&#xA;     * &#xA;     * @param  divisor value by which this &lt;tt>BigDecimal&lt;/tt> is to be divided.&#xA;     * @param  roundingMode rounding mode to apply.&#xA;     * @return &lt;tt>this / divisor&lt;/tt>&#xA;     * @throws ArithmeticException if &lt;tt>divisor==0&lt;/tt>, or&#xA;     *         &lt;tt>roundingMode==RoundingMode.UNNECESSARY&lt;/tt> and&#xA;     *         &lt;tt>this.scale()&lt;/tt> is insufficient to represent the result&#xA;     *         of the division exactly.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.41">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.1">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="RoundingMode.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </arguments>
          </next>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="divide">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="divisor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this /&#xA;     * divisor)&lt;/tt>, and whose preferred scale is &lt;tt>(this.scale() -&#xA;     * divisor.scale())&lt;/tt>; if the exact quotient cannot be&#xA;     * represented (because it has a non-terminating decimal&#xA;     * expansion) an &lt;tt>ArithmeticException&lt;/tt> is thrown.&#xA;     *&#xA;     * @param  divisor value by which this &lt;tt>BigDecimal&lt;/tt> is to be divided.&#xA;     * @throws ArithmeticException if the exact quotient does not have a&#xA;     *         terminating decimal expansion&#xA;     * @return &lt;tt>this / divisor&lt;/tt>&#xA;     * @since 1.5&#xA;     * @author Joseph D. Darcy&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>/*&#xA;&#x9; * Handle zero cases first.&#xA;&#x9; */</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>// x/0</comments>
            <statement xsi:type="statements:Throw">
              <comments>// 0/0</comments>
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="Division undefined"/>
              </throwable>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
                <self xsi:type="literals:This"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Throw">
            <comments>// NaN</comments>
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Division by zero"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="preferredScale">
          <typeReference xsi:type="types:Int">
            <comments>// Calculate preferred scale</comments>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="expressions:CastExpression">
                        <typeReference xsi:type="types:Long"/>
                        <child xsi:type="references:SelfReference">
                          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                          <self xsi:type="literals:This"/>
                        </child>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0">
                        <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                      </children>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                    </arguments>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// 0/y</comments>
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.1/@variable"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
              <self xsi:type="literals:This"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
            </expression>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="mc">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <comments>/*&#xA;&#x9;     * If the quotient this/divisor has a terminating decimal&#xA;&#x9;     * expansion, the expansion can have no more than&#xA;&#x9;     * (a.precision() + ceil(10*b.precision)/3) digits.&#xA;&#x9;     * Therefore, create a MathContext object with this&#xA;&#x9;     * precision and do a divide with the UNNECESSARY rounding&#xA;&#x9;     * mode.&#xA;&#x9;     */</comments>
                  <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Int"/>
                  <child xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:SelfReference">
                          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
                          <self xsi:type="literals:This"/>
                        </children>
                        <children xsi:type="expressions:CastExpression">
                          <typeReference xsi:type="types:Long"/>
                          <child xsi:type="references:IdentifierReference">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.20"/>
                              <arguments xsi:type="expressions:MultiplicativeExpression">
                                <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="10.0"/>
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0">
                                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
                                </children>
                                <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="3.0"/>
                                <multiplicativeOperators xsi:type="operators:Multiplication"/>
                                <multiplicativeOperators xsi:type="operators:Division"/>
                              </arguments>
                            </next>
                            <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                          </child>
                        </children>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </arguments>
                      <arguments xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                  </child>
                </arguments>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.7"/>
                  </next>
                  <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
                </arguments>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="quotient">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
            </variable>
          </statements>
          <statements xsi:type="statements:TryBlock">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.2/@elseStatement/@statements.3/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:SelfReference">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.46">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.2/@elseStatement/@statements.2/@variable"/>
                  </next>
                  <self xsi:type="literals:This"/>
                </value>
              </expression>
            </statements>
            <catcheBlocks>
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value="Non-terminating decimal expansion; "/>
                    <children xsi:type="references:StringReference" value="no exact representable decimal result."/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </throwable>
              </statements>
              <parameter name="e">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </parameter>
            </catcheBlocks>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="quotientScale">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.2/@elseStatement/@statements.3/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// divide(BigDecimal, mc) tries to adjust the quotient to</comments>
            <comments>// the desired one by removing trailing zeros; since the</comments>
            <comments>// exact divide method does not have an explicit digit</comments>
            <comments>// limit, we can add zeros too.</comments>
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.2/@elseStatement/@statements.3/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.1/@variable"/>
                </next>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.2/@elseStatement/@statements.5/@variable"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.2/@elseStatement/@statements.3/@variable"/>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="divide">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="divisor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this /&#xA;     * divisor)&lt;/tt>, with rounding according to the context settings.&#xA;     *&#xA;     * @param  divisor value by which this &lt;tt>BigDecimal&lt;/tt> is to be divided.&#xA;     * @param  mc the context to use.&#xA;     * @return &lt;tt>this / divisor&lt;/tt>, rounded as necessary.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt> or &#xA;     *         &lt;tt>mc.precision == 0&lt;/tt> and the quotient has a &#xA;     *         non-terminating decimal expansion.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.45">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.1">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lhs">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="rhs">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>// left-hand-side</comments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>// right-hand-side</comments>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="preferredScale">
          <typeReference xsi:type="types:Long">
            <comments>// work</comments>
          </typeReference>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Long"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.1/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
              </child>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.2/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
            </children>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Now calculate the answer.  We use the existing</comments>
        <comments>// divide-and-round method, but as this rounds to scale we have</comments>
        <comments>// to normalize the values here to achieve the desired result.</comments>
        <comments>// For x/y we first handle y=0 and x=0, and then normalize x and</comments>
        <comments>// y to give x' and y' with the following constraints:</comments>
        <comments>//   (a) 0.1 &lt;= x' &lt; 1</comments>
        <comments>//   (b)  x' &lt;= y' &lt; 10*x'</comments>
        <comments>// Dividing x'/y' with the required scale set to mc.precision then</comments>
        <comments>// will give a result in the range 0.1 to 1 rounded to exactly</comments>
        <comments>// the right number of digits (except in the case of a result of</comments>
        <comments>// 1.000... which can arise when x=y, or when rounding overflows</comments>
        <comments>// The 1.000... case will reduce properly to 1.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>// x/0</comments>
            <statement xsi:type="statements:Throw">
              <comments>// 0/0</comments>
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="Division undefined"/>
              </throwable>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.1/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Throw">
            <comments>// NaN</comments>
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Division by zero"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.2/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// 0/y</comments>
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.15"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.4/@variable"/>
                      <arguments xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
              </child>
            </arguments>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.1/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="xprime">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.1/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.73"/>
                </next>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.1/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="yprime">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.2/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.73"/>
                </next>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.2/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// xprime and yprime are now both in range 0.1 through 0.999...</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>// The floor (round toward negative infinity) and ceil</comments>
            <comments>// (round toward positive infinity) rounding modes are not</comments>
            <comments>// invariant under a sign flip.  If xprime/yprime has a</comments>
            <comments>// different sign than lhs/rhs, the rounding mode must be</comments>
            <comments>// changed.</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.1"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.1">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
                      </next>
                    </arguments>
                    <arguments xsi:type="expressions:ConditionalExpression">
                      <child xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:EqualityExpression">
                          <equalityOperators xsi:type="operators:Equal"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.1">
                            <next xsi:type="references:IdentifierReference">
                              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.9"/>
                            </next>
                          </children>
                          <children xsi:type="references:IdentifierReference">
                            <next xsi:type="references:IdentifierReference">
                              <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.2"/>
                            </next>
                            <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
                          </children>
                        </expression>
                      </child>
                      <expressionIf xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.3"/>
                        </next>
                        <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
                      </expressionIf>
                      <expressionElse xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.2"/>
                        </next>
                        <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
                      </expressionElse>
                    </arguments>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ExclusiveOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.7/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.1/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
                  </children>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.8/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.2/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
                  </children>
                </expression>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.1">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.9"/>
              </next>
            </children>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.2"/>
              </next>
              <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
            </children>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.1">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.9"/>
              </next>
            </children>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.3"/>
              </next>
              <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
            </children>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.8/@variable">
              <comments>// satisfy constraint (b)</comments>
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </child>
            <assignmentOperator xsi:type="operators:AssignmentMinus"/>
            <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.7/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.8/@variable"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.3/@variable">
            <comments>// [that is, yprime *= 10]</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.7/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.41">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.8/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.1">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
                </next>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.1">
                <next xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="RoundingMode.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.9"/>
                </next>
              </arguments>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.3/@variable">
            <comments>// correct the scale of the result...</comments>
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.117">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Long"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.8/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                </child>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.7/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.2/@variable">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.1/@variable">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                  </children>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </expression>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.1">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
                </next>
              </children>
              <additiveOperators xsi:type="operators:Subtraction"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// apply the sign</comments>
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.3/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.3/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.57"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.1/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.2/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.3/@variable">
            <comments>// doRound, here, only affects 1000000000 case.</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.3/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.120">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.1"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <comments>// Apply preferred scale rules for exact quotients</comments>
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.3/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.116">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.4/@variable"/>
              </next>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.3/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.39">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
              </next>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.3/@variable"/>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="divideToIntegralValue">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="divisor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is the integer part&#xA;     * of the quotient &lt;tt>(this / divisor)&lt;/tt> rounded down.  The&#xA;     * preferred scale of the result is &lt;code>(this.scale() -&#xA;     * divisor.scale())&lt;/code>.&#xA;     *&#xA;     * @param  divisor value by which this &lt;tt>BigDecimal&lt;/tt> is to be divided.&#xA;     * @return The integer part of &lt;tt>this / divisor&lt;/tt>.&#xA;     * @throws ArithmeticException if &lt;tt>divisor==0&lt;/tt>&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="preferredScale">
          <typeReference xsi:type="types:Int">
            <comments>// Calculate preferred scale</comments>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="expressions:CastExpression">
                        <typeReference xsi:type="types:Long"/>
                        <child xsi:type="references:SelfReference">
                          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                          <self xsi:type="literals:This"/>
                        </child>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0">
                        <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                      </children>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                    </arguments>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
          <self xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <comments>// much faster when this &lt;&lt; divisor</comments>
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.0/@variable"/>
              </next>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.55"/>
                </arguments>
              </next>
            </next>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.0/@variable"/>
            </next>
            <self xsi:type="literals:This"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="maxDigits">
          <typeReference xsi:type="types:Int">
            <comments>// Perform a divide with enough digits to round to a correct</comments>
            <comments>// integer value; then remove any fractional digits</comments>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:SelfReference">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
                    <self xsi:type="literals:This"/>
                  </children>
                  <children xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:Long"/>
                    <child xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.20"/>
                        <arguments xsi:type="expressions:MultiplicativeExpression">
                          <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="10.0"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0">
                            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
                          </children>
                          <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="3.0"/>
                          <multiplicativeOperators xsi:type="operators:Multiplication"/>
                          <multiplicativeOperators xsi:type="operators:Division"/>
                        </arguments>
                      </next>
                      <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                    </child>
                  </children>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.30"/>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="expressions:CastExpression">
                          <typeReference xsi:type="types:Long"/>
                          <child xsi:type="references:SelfReference">
                            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                            <self xsi:type="literals:This"/>
                          </child>
                        </children>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0">
                          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                        </children>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="quotient">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.46">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
              <arguments xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.5/@variable"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.1"/>
                  </next>
                  <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
                </arguments>
              </arguments>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.6/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.6/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.74">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.116">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.0/@variable"/>
                  </next>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.1"/>
                    </next>
                    <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.6/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.6/@variable">
                <comments>// pad with zeros if necessary</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.6/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.0/@variable"/>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.6/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.6/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="divideToIntegralValue">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="divisor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is the integer part&#xA;     * of &lt;tt>(this / divisor)&lt;/tt>.  Since the integer part of the&#xA;     * exact quotient does not depend on the rounding mode, the&#xA;     * rounding mode does not affect the values returned by this&#xA;     * method.  The preferred scale of the result is&#xA;     * &lt;code>(this.scale() - divisor.scale())&lt;/code>.  An&#xA;     * &lt;tt>ArithmeticException&lt;/tt> is thrown if the integer part of&#xA;     * the exact quotient needs more than &lt;tt>mc.precision&lt;/tt>&#xA;     * digits.&#xA;     *&#xA;     * @param  divisor value by which this &lt;tt>BigDecimal&lt;/tt> is to be divided.&#xA;     * @param  mc the context to use.&#xA;     * @return The integer part of &lt;tt>this / divisor&lt;/tt>.&#xA;     * @throws ArithmeticException if &lt;tt>divisor==0&lt;/tt>&#xA;     * @throws ArithmeticException if &lt;tt>mc.precision&lt;/tt> &amp;gt; 0 and the result&#xA;     *         requires a precision of more than &lt;tt>mc.precision&lt;/tt> digits.&#xA;     * @since  1.5&#xA;     * @author Joseph D. Darcy&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// zero result</comments>
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.47">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.1">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
              </next>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <comments>// exact result</comments>
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.55"/>
                    </arguments>
                  </next>
                </next>
                <self xsi:type="literals:This"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="preferredScale">
          <typeReference xsi:type="types:Int">
            <comments>// Calculate preferred scale</comments>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="expressions:CastExpression">
                        <typeReference xsi:type="types:Long"/>
                        <child xsi:type="references:SelfReference">
                          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                          <self xsi:type="literals:This"/>
                        </child>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0">
                        <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                      </children>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                    </arguments>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>/*&#xA;&#x9; * Perform a normal divide to mc.precision digits.  If the&#xA;&#x9; * remainder has absolute value less than the divisor, the&#xA;&#x9; * integer portion of the quotient fits into mc.precision&#xA;&#x9; * digits.  Next, remove any fractional digits from the&#xA;&#x9; * quotient and adjust the scale to the preferred value.&#xA;&#x9; */</comments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.46">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
              <arguments xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.1">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
                  </next>
                </arguments>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.1"/>
                  </next>
                  <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
                </arguments>
              </arguments>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="resultScale">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="product">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0">
                  <comments>/*&#xA;&#x9;     * Result is an integer. See if quotient represents the&#xA;&#x9;     * full integer portion of the exact quotient; if it does,&#xA;&#x9;     * the computed remainder will be less than the divisor.&#xA;&#x9;     */</comments>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.39">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// If the quotient is the full integer value,</comments>
            <comments>// |dividend-product| &lt; |divisor|.</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:StringReference" value="Division impossible"/>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.37">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0">
                        <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.55"/>
                      </arguments>
                    </next>
                  </next>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.4/@statement/@statements.0/@variable"/>
                </next>
                <self xsi:type="literals:This"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
                  <comments>/*&#xA;&#x9;     * Integer portion of quotient will fit into precision&#xA;&#x9;     * digits; recompute quotient to scale 0 to avoid double&#xA;&#x9;     * rounding and then try to adjust, if necessary.&#xA;&#x9;     */</comments>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.74">
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    <arguments xsi:type="references:IdentifierReference">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:EnumConstant" href="RoundingMode.class.xmi#//@classifiers.0/@constants.1"/>
                      </next>
                      <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
                    </arguments>
                  </next>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="precisionDiff">
          <typeReference xsi:type="types:Int">
            <comments>// else result.scale() == 0; </comments>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
                  </children>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.5/@variable"/>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.1/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
                          <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                        </children>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                  </children>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
              </next>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.5/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.1">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
                    </next>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
                  </children>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </value>
              </expression>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.116">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.1/@variable"/>
            </next>
          </returnValue>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="remainder">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="divisor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this % divisor)&lt;/tt>.&#xA;     * &#xA;     * &lt;p>The remainder is given by&#xA;     * &lt;tt>this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))&lt;/tt>.&#xA;     * Note that this is not the modulo operation (the result can be&#xA;     * negative).&#xA;     *&#xA;     * @param  divisor value by which this &lt;tt>BigDecimal&lt;/tt> is to be divided.&#xA;     * @return &lt;tt>this % divisor&lt;/tt>.&#xA;     * @throws ArithmeticException if &lt;tt>divisor==0&lt;/tt>&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="divrem">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.51">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0"/>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.0/@variable">
          <arraySelectors>
            <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </arraySelectors>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="remainder">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="divisor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(this %&#xA;     * divisor)&lt;/tt>, with rounding according to the context settings.&#xA;     * The &lt;tt>MathContext&lt;/tt> settings affect the implicit divide&#xA;     * used to compute the remainder.  The remainder computation&#xA;     * itself is by definition exact.  Therefore, the remainder may&#xA;     * contain more than &lt;tt>mc.getPrecision()&lt;/tt> digits.&#xA;     * &#xA;     * &lt;p>The remainder is given by&#xA;     * &lt;tt>this.subtract(this.divideToIntegralValue(divisor,&#xA;     * mc).multiply(divisor))&lt;/tt>.  Note that this is not the modulo&#xA;     * operation (the result can be negative).&#xA;     *&#xA;     * @param  divisor value by which this &lt;tt>BigDecimal&lt;/tt> is to be divided.&#xA;     * @param  mc the context to use.&#xA;     * @return &lt;tt>this % divisor&lt;/tt>, rounded as necessary.&#xA;     * @throws ArithmeticException if &lt;tt>divisor==0&lt;/tt>&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>, or &lt;tt>mc.precision&lt;/tt> &#xA;     *         &amp;gt; 0 and the result of &lt;tt>this.divideToIntgralValue(divisor)&lt;/tt> would &#xA;     *         require a precision of more than &lt;tt>mc.precision&lt;/tt> digits.&#xA;     * @see    #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="divrem">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.52">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.1"/>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable">
          <arraySelectors>
            <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </arraySelectors>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="divideAndRemainder">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="divisor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a two-element &lt;tt>BigDecimal&lt;/tt> array containing the&#xA;     * result of &lt;tt>divideToIntegralValue&lt;/tt> followed by the result of&#xA;     * &lt;tt>remainder&lt;/tt> on the two operands.&#xA;     * &#xA;     * &lt;p>Note that if both the integer quotient and remainder are&#xA;     * needed, this method is faster than using the&#xA;     * &lt;tt>divideToIntegralValue&lt;/tt> and &lt;tt>remainder&lt;/tt> methods&#xA;     * separately because the division need only be carried out once.&#xA;     *&#xA;     * @param  divisor value by which this &lt;tt>BigDecimal&lt;/tt> is to be divided, &#xA;     *         and the remainder computed.&#xA;     * @return a two element &lt;tt>BigDecimal&lt;/tt> array: the quotient &#xA;     *         (the result of &lt;tt>divideToIntegralValue&lt;/tt>) is the initial element &#xA;     *         and the remainder is the final element.&#xA;     * @throws ArithmeticException if &lt;tt>divisor==0&lt;/tt>&#xA;     * @see    #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)&#xA;     * @see    #remainder(java.math.BigDecimal, java.math.MathContext)&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>// we use the identity  x = i * y + r to determine r</comments>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@statements.0/@variable">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.47">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@parameters.0"/>
            </next>
            <self xsi:type="literals:This"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@statements.0/@variable">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.37">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@statements.0/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.39">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@parameters.0"/>
                </next>
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </arraySelectors>
              </arguments>
            </next>
            <self xsi:type="literals:This"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="divideAndRemainder">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="divisor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a two-element &lt;tt>BigDecimal&lt;/tt> array containing the&#xA;     * result of &lt;tt>divideToIntegralValue&lt;/tt> followed by the result of&#xA;     * &lt;tt>remainder&lt;/tt> on the two operands calculated with rounding&#xA;     * according to the context settings.&#xA;     * &#xA;     * &lt;p>Note that if both the integer quotient and remainder are&#xA;     * needed, this method is faster than using the&#xA;     * &lt;tt>divideToIntegralValue&lt;/tt> and &lt;tt>remainder&lt;/tt> methods&#xA;     * separately because the division need only be carried out once.&#xA;     *&#xA;     * @param  divisor value by which this &lt;tt>BigDecimal&lt;/tt> is to be divided, &#xA;     *         and the remainder computed.&#xA;     * @param  mc the context to use.&#xA;     * @return a two element &lt;tt>BigDecimal&lt;/tt> array: the quotient &#xA;     *         (the result of &lt;tt>divideToIntegralValue&lt;/tt>) is the &#xA;     *         initial element and the remainder is the final element.&#xA;     * @throws ArithmeticException if &lt;tt>divisor==0&lt;/tt>&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>, or &lt;tt>mc.precision&lt;/tt> &#xA;     *         &amp;gt; 0 and the result of &lt;tt>this.divideToIntgralValue(divisor)&lt;/tt> would &#xA;     *         require a precision of more than &lt;tt>mc.precision&lt;/tt> digits.&#xA;     * @see    #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)&#xA;     * @see    #remainder(java.math.BigDecimal, java.math.MathContext)&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.51">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.1">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lhs">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.1/@variable">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.2/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.48">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.1"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.1/@variable">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.2/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.37">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.1/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.39">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0"/>
                </next>
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </arraySelectors>
              </arguments>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="pow">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is&#xA;     * &lt;tt>(this&lt;sup>n&lt;/sup>)&lt;/tt>, The power is computed exactly, to&#xA;     * unlimited precision.&#xA;     * &#xA;     * &lt;p>The parameter &lt;tt>n&lt;/tt> must be in the range 0 through&#xA;     * 999999999, inclusive.  &lt;tt>ZERO.pow(0)&lt;/tt> returns {@link&#xA;     * #ONE}.&#xA;     *&#xA;     * Note that future releases may expand the allowable exponent&#xA;     * range of this method.&#xA;     *&#xA;     * @param  n power to raise this &lt;tt>BigDecimal&lt;/tt> to.&#xA;     * @return &lt;tt>this&lt;sup>n&lt;/sup>&lt;/tt>&#xA;     * @throws ArithmeticException if &lt;tt>n&lt;/tt> is out of range.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Invalid operation"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="999999999"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newScale">
          <typeReference xsi:type="types:Int">
            <comments>// No need to calculate pow(n) if result will over/underflow.</comments>
            <comments>// Don't attempt to support &quot;supernormal&quot; numbers.</comments>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.117">
            <arguments xsi:type="expressions:MultiplicativeExpression">
              <children xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Long"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0"/>
              <multiplicativeOperators xsi:type="operators:Multiplication"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
          <self xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.67"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@statements.1/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="pow">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is&#xA;     * &lt;tt>(this&lt;sup>n&lt;/sup>)&lt;/tt>.  The current implementation uses&#xA;     * the core algorithm defined in ANSI standard X3.274-1996 with&#xA;     * rounding according to the context settings.  In general, the&#xA;     * returned numerical value is within two ulps of the exact&#xA;     * numerical value for the chosen precision.  Note that future&#xA;     * releases may use a different algorithm with a decreased&#xA;     * allowable error bound and increased allowable exponent range.&#xA;     *&#xA;     * &lt;p>The X3.274-1996 algorithm is:&#xA;     *&#xA;     * &lt;ul>&#xA;     * &lt;li> An &lt;tt>ArithmeticException&lt;/tt> exception is thrown if&#xA;     *  &lt;ul>&#xA;     *    &lt;li>&lt;tt>abs(n) &amp;gt; 999999999&lt;/tt>&#xA;     *    &lt;li>&lt;tt>mc.precision == 0&lt;/tt> and &lt;tt>n &amp;lt; 0&lt;/tt>&#xA;     *    &lt;li>&lt;tt>mc.precision &amp;gt; 0&lt;/tt> and &lt;tt>n&lt;/tt> has more than&#xA;     *    &lt;tt>mc.precision&lt;/tt> decimal digits&#xA;     *  &lt;/ul>&#xA;     *&#xA;     * &lt;li> if &lt;tt>n&lt;/tt> is zero, {@link #ONE} is returned even if&#xA;     * &lt;tt>this&lt;/tt> is zero, otherwise&#xA;     * &lt;ul>&#xA;     *   &lt;li> if &lt;tt>n&lt;/tt> is positive, the result is calculated via&#xA;     *   the repeated squaring technique into a single accumulator.&#xA;     *   The individual multiplications with the accumulator use the&#xA;     *   same math context settings as in &lt;tt>mc&lt;/tt> except for a&#xA;     *   precision increased to &lt;tt>mc.precision + elength + 1&lt;/tt>&#xA;     *   where &lt;tt>elength&lt;/tt> is the number of decimal digits in&#xA;     *   &lt;tt>n&lt;/tt>.&#xA;     *&#xA;     *   &lt;li> if &lt;tt>n&lt;/tt> is negative, the result is calculated as if&#xA;     *   &lt;tt>n&lt;/tt> were positive; this value is then divided into one&#xA;     *   using the working precision specified above.&#xA;     *&#xA;     *   &lt;li> The final value from either the positive or negative case&#xA;     *   is then rounded to the destination precision.&#xA;     *   &lt;/ul>&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param  n power to raise this &lt;tt>BigDecimal&lt;/tt> to.&#xA;     * @param  mc the context to use.&#xA;     * @return &lt;tt>this&lt;sup>n&lt;/sup>&lt;/tt> using the ANSI standard X3.274-1996&#xA;     *         algorithm&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>, or &lt;tt>n&lt;/tt> is out &#xA;     *         of range.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.53">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Invalid operation"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
            <children xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="999999999"/>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="999999999"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
          <self xsi:type="literals:This">
            <comments>// x**0 == 1 in X3.274</comments>
          </self>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lhs">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="workmc">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="mag">
          <typeReference xsi:type="types:Int">
            <comments>// working settings</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.29"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// magnitude of n</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="elength">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.115">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.6/@variable"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// length of n in digits</comments>
            <statement xsi:type="statements:Throw">
              <comments>// X3.274 rule</comments>
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="Invalid operation"/>
              </throwable>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.7/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
                </next>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.5/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
                    </next>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.7/@statement/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.9"/>
                  </next>
                </arguments>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="acc">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>// ready to carry out power calculation...</comments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="seenbit">
          <typeReference xsi:type="types:Boolean">
            <comments>// accumulator</comments>
          </typeReference>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <comments>// set once we've seen a 1-bit</comments>
        <statement xsi:type="statements:Block">
          <comments>// acc=acc*acc [square]</comments>
          <comments>// else (!seenbit) no point in squaring ONE</comments>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.6/@variable">
                <comments>// for each bit [top bit ignored]</comments>
              </child>
              <assignmentOperator xsi:type="operators:AssignmentPlus"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.6/@variable"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// shift left 1 bit</comments>
            <statement xsi:type="statements:Block">
              <comments>// acc=acc*x</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.9/@variable">
                    <comments>// top bit is set</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:BooleanLiteral" value="true"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.8/@variable">
                    <comments>// OK, we're off</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.8/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.4/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.5/@variable"/>
                    </next>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.6/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Break"/>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.10/@init"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="31"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// that was the last bit</comments>
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.8/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.8/@variable">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.40">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.8/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.5/@variable"/>
                  </next>
                </value>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.9/@variable"/>
          </statements>
        </statement>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.10/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// if negative n, calculate the reciprocal using working precision</comments>
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.8/@variable">
              <comments>// [hence mc.precision>0]</comments>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.46">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.8/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.5/@variable"/>
              </next>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// round to final precision and strip zeros</comments>
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.8/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.120">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="abs">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is the absolute value&#xA;     * of this &lt;tt>BigDecimal&lt;/tt>, and whose scale is&#xA;     * &lt;tt>this.scale()&lt;/tt>.&#xA;     *&#xA;     * @return &lt;tt>abs(this)&lt;/tt>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:RelationExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </child>
            <expressionIf xsi:type="references:MethodCall" target="//@classifiers.0/@members.57"/>
            <expressionElse xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </expressionElse>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="abs">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is the absolute value&#xA;     * of this &lt;tt>BigDecimal&lt;/tt>, with rounding according to the&#xA;     * context settings.&#xA;     *&#xA;     * @param mc the context to use.&#xA;     * @return &lt;tt>abs(this)&lt;/tt>, rounded as necessary.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:RelationExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </child>
            <expressionIf xsi:type="references:MethodCall" target="//@classifiers.0/@members.58">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0"/>
            </expressionIf>
            <expressionElse xsi:type="references:MethodCall" target="//@classifiers.0/@members.60">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0"/>
            </expressionElse>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="negate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(-this)&lt;/tt>,&#xA;     * and whose scale is &lt;tt>this.scale()&lt;/tt>.&#xA;     *&#xA;     * @return &lt;tt>-this&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
                <arguments xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Subtraction"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.74"/>
                  </next>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="negate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(-this)&lt;/tt>,&#xA;     * with rounding according to the context settings.&#xA;     *&#xA;     * @param mc the context to use.&#xA;     * @return &lt;tt>-this&lt;/tt>, rounded as necessary.&#xA;     * @throws ArithmeticException if or the result is inexact but the &#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.57">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.60">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="plus">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(+this)&lt;/tt>, and whose&#xA;     * scale is &lt;tt>this.scale()&lt;/tt>.&#xA;     * &#xA;     * &lt;p>This method, which simply returns this &lt;tt>BigDecimal&lt;/tt>&#xA;     * is included for symmetry with the unary minus method {@link&#xA;     * #negate()}.&#xA;     * &#xA;     * @return &lt;tt>this&lt;/tt>.&#xA;     * @see #negate()&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="plus">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose value is &lt;tt>(+this)&lt;/tt>,&#xA;     * with rounding according to the context settings.&#xA;     * &#xA;     * &lt;p>The effect of this method is identical to that of the {@link&#xA;     * #round(MathContext)} method.&#xA;     *&#xA;     * @param mc the context to use.&#xA;     * @return &lt;tt>this&lt;/tt>, rounded as necessary.  A zero result will&#xA;     *         have a scale of 0.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     * @see    #round(MathContext)&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// no rounding please</comments>
          <returnValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.120">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.0"/>
          </next>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="signum">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the signum function of this &lt;tt>BigDecimal&lt;/tt>.&#xA;     *&#xA;     * @return -1, 0, or 1 as the value of this &lt;tt>BigDecimal&lt;/tt> &#xA;     *         is negative, zero, or positive.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Long.class.xmi#//@classifiers.0/@members.43"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
          </expressionIf>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.75"/>
            </next>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="scale">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;i>scale&lt;/i> of this &lt;tt>BigDecimal&lt;/tt>.  If zero&#xA;     * or positive, the scale is the number of digits to the right of&#xA;     * the decimal point.  If negative, the unscaled value of the&#xA;     * number is multiplied by ten to the power of the negation of the&#xA;     * scale.  For example, a scale of &lt;tt>-3&lt;/tt> means the unscaled&#xA;     * value is multiplied by 1000.&#xA;     *&#xA;     * @return the scale of this &lt;tt>BigDecimal&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="precision">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;i>precision&lt;/i> of this &lt;tt>BigDecimal&lt;/tt>.  (The&#xA;     * precision is the number of digits in the unscaled value.)&#xA;     *&#xA;     * &lt;p>The precision of a zero value is 1.&#xA;     *&#xA;     * @return the precision of this &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.113"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="unscaledValue">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigInteger&lt;/tt> whose value is the &lt;i>unscaled&#xA;     * value&lt;/i> of this &lt;tt>BigDecimal&lt;/tt>.  (Computes &lt;tt>(this *&#xA;     * 10&lt;sup>this.scale()&lt;/sup>)&lt;/tt>.)&#xA;     *&#xA;     * @return the unscaled value of this &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @since  1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </next>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="ROUND_UP">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Rounding Modes</comments>
        <comments>/**&#xA;     * Rounding mode to round away from zero.  Always increments the&#xA;     * digit prior to a nonzero discarded fraction.  Note that this rounding&#xA;     * mode never decreases the magnitude of the calculated value.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="ROUND_DOWN">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Rounding mode to round towards zero.  Never increments the digit&#xA;     * prior to a discarded fraction (i.e., truncates).  Note that this&#xA;     * rounding mode never increases the magnitude of the calculated value.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="ROUND_CEILING">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Rounding mode to round towards positive infinity.  If the&#xA;     * &lt;tt>BigDecimal&lt;/tt> is positive, behaves as for&#xA;     * &lt;tt>ROUND_UP&lt;/tt>; if negative, behaves as for&#xA;     * &lt;tt>ROUND_DOWN&lt;/tt>.  Note that this rounding mode never&#xA;     * decreases the calculated value.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="ROUND_FLOOR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Rounding mode to round towards negative infinity.  If the&#xA;     * &lt;tt>BigDecimal&lt;/tt> is positive, behave as for&#xA;     * &lt;tt>ROUND_DOWN&lt;/tt>; if negative, behave as for&#xA;     * &lt;tt>ROUND_UP&lt;/tt>.  Note that this rounding mode never&#xA;     * increases the calculated value.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="ROUND_HALF_UP">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Rounding mode to round towards &amp;quot;nearest neighbor&amp;quot;&#xA;     * unless both neighbors are equidistant, in which case round up.&#xA;     * Behaves as for &lt;tt>ROUND_UP&lt;/tt> if the discarded fraction is&#xA;     * &amp;gt;= 0.5; otherwise, behaves as for &lt;tt>ROUND_DOWN&lt;/tt>.  Note&#xA;     * that this is the rounding mode that most of us were taught in&#xA;     * grade school.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="ROUND_HALF_DOWN">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Rounding mode to round towards &amp;quot;nearest neighbor&amp;quot;&#xA;     * unless both neighbors are equidistant, in which case round&#xA;     * down.  Behaves as for &lt;tt>ROUND_UP&lt;/tt> if the discarded&#xA;     * fraction is &amp;gt; 0.5; otherwise, behaves as for&#xA;     * &lt;tt>ROUND_DOWN&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="ROUND_HALF_EVEN">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Rounding mode to round towards the &amp;quot;nearest neighbor&amp;quot;&#xA;     * unless both neighbors are equidistant, in which case, round&#xA;     * towards the even neighbor.  Behaves as for&#xA;     * &lt;tt>ROUND_HALF_UP&lt;/tt> if the digit to the left of the&#xA;     * discarded fraction is odd; behaves as for&#xA;     * &lt;tt>ROUND_HALF_DOWN&lt;/tt> if it's even.  Note that this is the&#xA;     * rounding mode that minimizes cumulative error when applied&#xA;     * repeatedly over a sequence of calculations.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="ROUND_UNNECESSARY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Rounding mode to assert that the requested operation has an exact&#xA;     * result, hence no rounding is necessary.  If this rounding mode is&#xA;     * specified on an operation that yields an inexact result, an&#xA;     * &lt;tt>ArithmeticException&lt;/tt> is thrown.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="round">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Scaling/Rounding Operations</comments>
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> rounded according to the&#xA;     * &lt;tt>MathContext&lt;/tt> settings.  If the precision setting is 0 then&#xA;     * no rounding takes place.&#xA;     * &#xA;     * &lt;p>The effect of this method is identical to that of the&#xA;     * {@link #plus(MathContext)} method.&#xA;     *&#xA;     * @param mc the context to use.&#xA;     * @return a &lt;tt>BigDecimal&lt;/tt> rounded according to the &#xA;     *         &lt;tt>MathContext&lt;/tt> settings.&#xA;     * @throws ArithmeticException if the rounding mode is&#xA;     *         &lt;tt>UNNECESSARY&lt;/tt> and the&#xA;     *         &lt;tt>BigDecimal&lt;/tt>  operation would require rounding.&#xA;     * @see    #plus(MathContext)&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.60">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setScale">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newScale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="roundingMode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Enumeration" href="RoundingMode.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose scale is the specified&#xA;     * value, and whose unscaled value is determined by multiplying or&#xA;     * dividing this &lt;tt>BigDecimal&lt;/tt>'s unscaled value by the&#xA;     * appropriate power of ten to maintain its overall value.  If the&#xA;     * scale is reduced by the operation, the unscaled value must be&#xA;     * divided (rather than multiplied), and the value may be changed;&#xA;     * in this case, the specified rounding mode is applied to the&#xA;     * division.&#xA;     *&#xA;     * @param  newScale scale of the &lt;tt>BigDecimal&lt;/tt> value to be returned.&#xA;     * @param  roundingMode The rounding mode to apply.&#xA;     * @return a &lt;tt>BigDecimal&lt;/tt> whose scale is the specified value, &#xA;     *         and whose unscaled value is determined by multiplying or &#xA;     *         dividing this &lt;tt>BigDecimal&lt;/tt>'s unscaled value by the &#xA;     *         appropriate power of ten to maintain its overall value.&#xA;     * @throws ArithmeticException if &lt;tt>roundingMode==UNNECESSARY&lt;/tt>&#xA;     *         and the specified scaling operation would require&#xA;     *         rounding.&#xA;     * @see    RoundingMode&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.75">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.1">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="RoundingMode.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setScale">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newScale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="roundingMode">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose scale is the specified&#xA;     * value, and whose unscaled value is determined by multiplying or&#xA;     * dividing this &lt;tt>BigDecimal&lt;/tt>'s unscaled value by the&#xA;     * appropriate power of ten to maintain its overall value.  If the&#xA;     * scale is reduced by the operation, the unscaled value must be&#xA;     * divided (rather than multiplied), and the value may be changed;&#xA;     * in this case, the specified rounding mode is applied to the&#xA;     * division.&#xA;     * &#xA;     * &lt;p>Note that since BigDecimal objects are immutable, calls of&#xA;     * this method do &lt;i>not&lt;/i> result in the original object being&#xA;     * modified, contrary to the usual convention of having methods&#xA;     * named &lt;tt>set&lt;i>X&lt;/i>&lt;/tt> mutate field &lt;tt>&lt;i>X&lt;/i>&lt;/tt>.&#xA;     * Instead, &lt;tt>setScale&lt;/tt> returns an object with the proper&#xA;     * scale; the returned object may or may not be newly allocated.&#xA;     * &#xA;     * &lt;p>The new {@link #setScale(int, RoundingMode)} method should&#xA;     * be used in preference to this legacy method.&#xA;     * &#xA;     * @param  newScale scale of the &lt;tt>BigDecimal&lt;/tt> value to be returned.&#xA;     * @param  roundingMode The rounding mode to apply.&#xA;     * @return a &lt;tt>BigDecimal&lt;/tt> whose scale is the specified value, &#xA;     *         and whose unscaled value is determined by multiplying or &#xA;     *         dividing this &lt;tt>BigDecimal&lt;/tt>'s unscaled value by the &#xA;     *         appropriate power of ten to maintain its overall value.&#xA;     * @throws ArithmeticException if &lt;tt>roundingMode==ROUND_UNNECESSARY&lt;/tt>&#xA;     *         and the specified scaling operation would require&#xA;     *         rounding.&#xA;     * @throws IllegalArgumentException if &lt;tt>roundingMode&lt;/tt> does not&#xA;     *         represent a valid rounding mode.&#xA;     * @see    #ROUND_UP&#xA;     * @see    #ROUND_DOWN&#xA;     * @see    #ROUND_CEILING&#xA;     * @see    #ROUND_FLOOR&#xA;     * @see    #ROUND_HALF_UP&#xA;     * @see    #ROUND_HALF_DOWN&#xA;     * @see    #ROUND_HALF_EVEN&#xA;     * @see    #ROUND_UNNECESSARY&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Invalid rounding mode"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// easy case</comments>
          <returnValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// zero can have any scale</comments>
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0"/>
            </next>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="raise">
              <typeReference xsi:type="types:Int">
                <comments>// [we can use checkScale to assure multiplier is valid]</comments>
              </typeReference>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.117">
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:Long"/>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0"/>
                  </children>
                  <children xsi:type="references:SelfReference">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <self xsi:type="literals:This"/>
                  </children>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </arguments>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="scaledResult">
                  <typeReference xsi:type="types:Long"/>
                  <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.106">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.3/@statement/@statements.0/@variable"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Return">
                  <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.3/@statement/@statements.1/@statement/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0"/>
                    </next>
                  </returnValue>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.3/@statement/@statements.1/@statement/@statements.0/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:SelfReference">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
                  <self xsi:type="literals:This"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            </condition>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="result">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <initialValue xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.60"/>
                    <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.104">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.3/@statement/@statements.0/@variable"/>
                    </arguments>
                  </next>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.3/@statement/@statements.2/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:SelfReference">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                    <self xsi:type="literals:This"/>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0"/>
                  <children xsi:type="references:SelfReference">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <self xsi:type="literals:This"/>
                  </children>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </value>
              </expression>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                <self xsi:type="literals:This"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.3/@statement/@statements.2/@variable"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// scale &lt; this.scale</comments>
        <comments>// we cannot perfectly predict the precision after rounding</comments>
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.41">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setScale">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newScale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> whose scale is the specified&#xA;     * value, and whose value is numerically equal to this&#xA;     * &lt;tt>BigDecimal&lt;/tt>'s.  Throws an &lt;tt>ArithmeticException&lt;/tt>&#xA;     * if this is not possible.&#xA;     * &#xA;     * &lt;p>This call is typically used to increase the scale, in which&#xA;     * case it is guaranteed that there exists a &lt;tt>BigDecimal&lt;/tt>&#xA;     * of the specified scale and the correct value.  The call can&#xA;     * also be used to reduce the scale if the caller knows that the&#xA;     * &lt;tt>BigDecimal&lt;/tt> has sufficiently many zeros at the end of&#xA;     * its fractional part (i.e., factors of ten in its integer value)&#xA;     * to allow for the rescaling without changing its value.&#xA;     * &#xA;     * &lt;p>This method returns the same result as the two-argument&#xA;     * versions of &lt;tt>setScale&lt;/tt>, but saves the caller the trouble&#xA;     * of specifying a rounding mode in cases where it is irrelevant.&#xA;     * &#xA;     * &lt;p>Note that since &lt;tt>BigDecimal&lt;/tt> objects are immutable,&#xA;     * calls of this method do &lt;i>not&lt;/i> result in the original&#xA;     * object being modified, contrary to the usual convention of&#xA;     * having methods named &lt;tt>set&lt;i>X&lt;/i>&lt;/tt> mutate field&#xA;     * &lt;tt>&lt;i>X&lt;/i>&lt;/tt>.  Instead, &lt;tt>setScale&lt;/tt> returns an&#xA;     * object with the proper scale; the returned object may or may&#xA;     * not be newly allocated.&#xA;     *&#xA;     * @param  newScale scale of the &lt;tt>BigDecimal&lt;/tt> value to be returned.&#xA;     * @return a &lt;tt>BigDecimal&lt;/tt> whose scale is the specified value, and &#xA;     *         whose unscaled value is determined by multiplying or dividing &#xA;     *         this &lt;tt>BigDecimal&lt;/tt>'s unscaled value by the appropriate &#xA;     *         power of ten to maintain its overall value.&#xA;     * @throws ArithmeticException if the specified scaling operation would&#xA;     *         require rounding.&#xA;     * @see    #setScale(int, int)&#xA;     * @see    #setScale(int, RoundingMode)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.75">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="movePointLeft">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Decimal Point Motion Operations</comments>
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> which is equivalent to this one&#xA;     * with the decimal point moved &lt;tt>n&lt;/tt> places to the left.  If&#xA;     * &lt;tt>n&lt;/tt> is non-negative, the call merely adds &lt;tt>n&lt;/tt> to&#xA;     * the scale.  If &lt;tt>n&lt;/tt> is negative, the call is equivalent&#xA;     * to &lt;tt>movePointRight(-n)&lt;/tt>.  The &lt;tt>BigDecimal&lt;/tt>&#xA;     * returned by this call has value &lt;tt>(this &amp;times;&#xA;     * 10&lt;sup>-n&lt;/sup>)&lt;/tt> and scale &lt;tt>max(this.scale()+n,&#xA;     * 0)&lt;/tt>.&#xA;     *&#xA;     * @param  n number of places to move the decimal point to the left.&#xA;     * @return a &lt;tt>BigDecimal&lt;/tt> which is equivalent to this one with the &#xA;     *         decimal point moved &lt;tt>n&lt;/tt> places to the left.&#xA;     * @throws ArithmeticException if scale overflows.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newScale">
          <typeReference xsi:type="types:Int">
            <comments>// Cannot use movePointRight(-n) in case of n==Integer.MIN_VALUE</comments>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.117">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Long"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="num">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.0/@variable"/>
              </next>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
        </condition>
        <elseStatement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.0/@variable"/>
            </value>
          </expression>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </child>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.1/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </next>
            </expressionIf>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.1/@variable"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="movePointRight">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> which is equivalent to this one&#xA;     * with the decimal point moved &lt;tt>n&lt;/tt> places to the right.&#xA;     * If &lt;tt>n&lt;/tt> is non-negative, the call merely subtracts&#xA;     * &lt;tt>n&lt;/tt> from the scale.  If &lt;tt>n&lt;/tt> is negative, the call&#xA;     * is equivalent to &lt;tt>movePointLeft(-n)&lt;/tt>.  The&#xA;     * &lt;tt>BigDecimal&lt;/tt> returned by this call has value &lt;tt>(this&#xA;     * &amp;times; 10&lt;sup>n&lt;/sup>)&lt;/tt> and scale &lt;tt>max(this.scale()-n,&#xA;     * 0)&lt;/tt>.&#xA;     *&#xA;     * @param  n number of places to move the decimal point to the right.&#xA;     * @return a &lt;tt>BigDecimal&lt;/tt> which is equivalent to this one&#xA;     *         with the decimal point moved &lt;tt>n&lt;/tt> places to the right.&#xA;     * @throws ArithmeticException if scale overflows.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newScale">
          <typeReference xsi:type="types:Int">
            <comments>// Cannot use movePointLeft(-n) in case of n==Integer.MIN_VALUE</comments>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.117">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Long"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="num">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.0/@variable"/>
              </next>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
        </condition>
        <elseStatement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.0/@variable"/>
            </value>
          </expression>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </child>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.1/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </next>
            </expressionIf>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.1/@variable"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="scaleByPowerOfTen">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a BigDecimal whose numerical value is equal to&#xA;     * (&lt;tt>this&lt;/tt> * 10&lt;sup>n&lt;/sup>).  The scale of&#xA;     * the result is &lt;tt>(this.scale() - n)&lt;/tt>.&#xA;     *&#xA;     * @throws ArithmeticException if the scale would be&#xA;     *         outside the range of a 32-bit integer.&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
          <self xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="num">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.117">
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Long"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@parameters.0"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </arguments>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@statements.1/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="stripTrailingZeros">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> which is numerically equal to&#xA;     * this one but with any trailing zeros removed from the&#xA;     * representation.  For example, stripping the trailing zeros from&#xA;     * the &lt;tt>BigDecimal&lt;/tt> value &lt;tt>600.0&lt;/tt>, which has&#xA;     * [&lt;tt>BigInteger&lt;/tt>, &lt;tt>scale&lt;/tt>] components equals to&#xA;     * [6000, 1], yields &lt;tt>6E2&lt;/tt> with [&lt;tt>BigInteger&lt;/tt>,&#xA;     * &lt;tt>scale&lt;/tt>] components equals to [6, -2]&#xA;     *&#xA;     * @return a numerically equal &lt;tt>BigDecimal&lt;/tt> with any&#xA;     * trailing zeros removed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
          <self xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.116">
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
            </arguments>
          </next>
          <expression xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Comparison Operations</comments>
        <comments>/**&#xA;     * Compares this &lt;tt>BigDecimal&lt;/tt> with the specified&#xA;     * &lt;tt>BigDecimal&lt;/tt>.  Two &lt;tt>BigDecimal&lt;/tt> objects that are&#xA;     * equal in value but have a different scale (like 2.0 and 2.00)&#xA;     * are considered equal by this method.  This method is provided&#xA;     * in preference to individual methods for each of the six boolean&#xA;     * comparison operators (&amp;lt;, ==, &amp;gt;, &amp;gt;=, !=, &amp;lt;=).  The&#xA;     * suggested idiom for performing these comparisons is:&#xA;     * &lt;tt>(x.compareTo(y)&lt;/tt> &amp;lt;&lt;i>op&lt;/i>&amp;gt; &lt;tt>0)&lt;/tt>, where&#xA;     * &amp;lt;&lt;i>op&lt;/i>&amp;gt; is one of the six comparison operators.&#xA;     *&#xA;     * @param  val &lt;tt>BigDecimal&lt;/tt> to which this &lt;tt>BigDecimal&lt;/tt> is &#xA;     *         to be compared.&#xA;     * @return -1, 0, or 1 as this &lt;tt>BigDecimal&lt;/tt> is numerically &#xA;     *          less than, equal to, or greater than &lt;tt>val&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sigDiff">
          <typeReference xsi:type="types:Int">
            <comments>// Optimization: would run fine without the next three lines</comments>
          </typeReference>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
            </children>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalExpression">
              <child xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.0/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </child>
              <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <expressionElse xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </expressionElse>
            </expression>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="aethis">
          <typeReference xsi:type="types:Int">
            <comments>// If the (adjusted) exponents are different we do not need to</comments>
            <comments>// expensively match scales and compare the significands</comments>
          </typeReference>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <self xsi:type="literals:This"/>
            </children>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="aeval">
          <typeReference xsi:type="types:Int">
            <comments>// [-1]</comments>
          </typeReference>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </children>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// [-1]</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
              <self xsi:type="literals:This"/>
            </child>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.2/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.3/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
              <self xsi:type="literals:This"/>
            </returnValue>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.2/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.3/@variable"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="arg">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>// Scale and compare intVals</comments>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <initialValues xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </initialValues>
              <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@parameters.0"/>
            </arrayInitializer>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.110">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.5/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.122">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.5/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <arraySelectors>
                <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </arraySelectors>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.5/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <arraySelectors>
                <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </arraySelectors>
            </arguments>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.5/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <arraySelectors>
                <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </arraySelectors>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.5/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <arraySelectors>
                <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </arraySelectors>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.5/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.106"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.5/@variable">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                  </next>
                  <arraySelectors>
                    <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  </arraySelectors>
                </arguments>
              </next>
            </next>
          </next>
          <arraySelectors>
            <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </arraySelectors>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares this &lt;tt>BigDecimal&lt;/tt> with the specified&#xA;     * &lt;tt>Object&lt;/tt> for equality.  Unlike {@link&#xA;     * #compareTo(BigDecimal) compareTo}, this method considers two&#xA;     * &lt;tt>BigDecimal&lt;/tt> objects equal only if they are equal in&#xA;     * value and scale (thus 2.0 is not equal to 2.00 when compared by&#xA;     * this method).&#xA;     *&#xA;     * @param  x &lt;tt>Object&lt;/tt> to which this &lt;tt>BigDecimal&lt;/tt> is &#xA;     *         to be compared.&#xA;     * @return &lt;tt>true&lt;/tt> if and only if the specified &lt;tt>Object&lt;/tt> is a&#xA;     *         &lt;tt>BigDecimal&lt;/tt> whose value and scale are equal to this &#xA;     *         &lt;tt>BigDecimal&lt;/tt>'s.&#xA;     * @see    #compareTo(java.math.BigDecimal)&#xA;     * @see    #hashCode&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="xDec">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@statements.1/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@statements.1/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            </children>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@statements.1/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.108"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@statements.1/@variable">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                  </next>
                </arguments>
              </next>
            </next>
          </next>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="min">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the minimum of this &lt;tt>BigDecimal&lt;/tt> and&#xA;     * &lt;tt>val&lt;/tt>.&#xA;     *&#xA;     * @param  val value with which the minimum is to be computed.&#xA;     * @return the &lt;tt>BigDecimal&lt;/tt> whose value is the lesser of this &#xA;     *         &lt;tt>BigDecimal&lt;/tt> and &lt;tt>val&lt;/tt>.  If they are equal, &#xA;     *         as defined by the {@link #compareTo(BigDecimal) compareTo}  &#xA;     *         method, &lt;tt>this&lt;/tt> is returned.&#xA;     * @see    #compareTo(java.math.BigDecimal)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:RelationExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.83/@parameters.0"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </child>
            <expressionIf xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </expressionIf>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.83/@parameters.0"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="max">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the maximum of this &lt;tt>BigDecimal&lt;/tt> and &lt;tt>val&lt;/tt>.&#xA;     *&#xA;     * @param  val value with which the maximum is to be computed.&#xA;     * @return the &lt;tt>BigDecimal&lt;/tt> whose value is the greater of this &#xA;     *         &lt;tt>BigDecimal&lt;/tt> and &lt;tt>val&lt;/tt>.  If they are equal, &#xA;     *         as defined by the {@link #compareTo(BigDecimal) compareTo} &#xA;     *         method, &lt;tt>this&lt;/tt> is returned.&#xA;     * @see    #compareTo(java.math.BigDecimal)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:RelationExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@parameters.0"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </child>
            <expressionIf xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </expressionIf>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@parameters.0"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Hash Function</comments>
        <comments>/**&#xA;     * Returns the hash code for this &lt;tt>BigDecimal&lt;/tt>.  Note that&#xA;     * two &lt;tt>BigDecimal&lt;/tt> objects that are numerically equal but&#xA;     * differ in scale (like 2.0 and 2.00) will generally &lt;i>not&lt;/i>&#xA;     * have the same hash code.&#xA;     *&#xA;     * @return hash code for this &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @see #equals(Object)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="val2">
              <typeReference xsi:type="types:Long"/>
              <initialValue xsi:type="expressions:ConditionalExpression">
                <child xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    <relationOperators xsi:type="operators:LessThan"/>
                  </expression>
                </child>
                <expressionIf xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Subtraction"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                </expressionIf>
                <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="temp">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Int"/>
                <child xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="expressions:MultiplicativeExpression">
                      <children xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:CastExpression">
                          <typeReference xsi:type="types:Int"/>
                          <child xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:ShiftExpression">
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85/@statements.0/@statement/@statements.0/@variable"/>
                              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="32"/>
                              <shiftOperators xsi:type="operators:UnsignedRightShift"/>
                            </expression>
                          </child>
                        </expression>
                      </children>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="31"/>
                      <multiplicativeOperators xsi:type="operators:Multiplication"/>
                    </children>
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:AndExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85/@statements.0/@statement/@statements.0/@variable"/>
                        <children xsi:type="literals:HexLongLiteral" hexValue="4294967295"/>
                      </expression>
                    </children>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </expression>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="31"/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ConditionalExpression">
                    <child xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        <relationOperators xsi:type="operators:LessThan"/>
                      </expression>
                    </child>
                    <expressionIf xsi:type="expressions:UnaryExpression">
                      <operators xsi:type="operators:Subtraction"/>
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85/@statements.0/@statement/@statements.1/@variable"/>
                    </expressionIf>
                    <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85/@statements.0/@statement/@statements.1/@variable"/>
                  </expression>
                </children>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
        </condition>
        <elseStatement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="expressions:MultiplicativeExpression">
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="31"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.111"/>
                </next>
              </children>
              <multiplicativeOperators xsi:type="operators:Multiplication"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </returnValue>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Format Converters</comments>
        <comments>/**&#xA;     * Returns the string representation of this &lt;tt>BigDecimal&lt;/tt>,&#xA;     * using scientific notation if an exponent is needed.&#xA;     * &#xA;     * &lt;p>A standard canonical string form of the &lt;tt>BigDecimal&lt;/tt>&#xA;     * is created as though by the following steps: first, the&#xA;     * absolute value of the unscaled value of the &lt;tt>BigDecimal&lt;/tt>&#xA;     * is converted to a string in base ten using the characters&#xA;     * &lt;tt>'0'&lt;/tt> through &lt;tt>'9'&lt;/tt> with no leading zeros (except&#xA;     * if its value is zero, in which case a single &lt;tt>'0'&lt;/tt>&#xA;     * character is used).&#xA;     * &#xA;     * &lt;p>Next, an &lt;i>adjusted exponent&lt;/i> is calculated; this is the&#xA;     * negated scale, plus the number of characters in the converted&#xA;     * unscaled value, less one.  That is,&#xA;     * &lt;tt>-scale+(ulength-1)&lt;/tt>, where &lt;tt>ulength&lt;/tt> is the&#xA;     * length of the absolute value of the unscaled value in decimal&#xA;     * digits (its &lt;i>precision&lt;/i>).&#xA;     * &#xA;     * &lt;p>If the scale is greater than or equal to zero and the&#xA;     * adjusted exponent is greater than or equal to &lt;tt>-6&lt;/tt>, the&#xA;     * number will be converted to a character form without using&#xA;     * exponential notation.  In this case, if the scale is zero then&#xA;     * no decimal point is added and if the scale is positive a&#xA;     * decimal point will be inserted with the scale specifying the&#xA;     * number of characters to the right of the decimal point.&#xA;     * &lt;tt>'0'&lt;/tt> characters are added to the left of the converted&#xA;     * unscaled value as necessary.  If no character precedes the&#xA;     * decimal point after this insertion then a conventional&#xA;     * &lt;tt>'0'&lt;/tt> character is prefixed.&#xA;     * &#xA;     * &lt;p>Otherwise (that is, if the scale is negative, or the&#xA;     * adjusted exponent is less than &lt;tt>-6&lt;/tt>), the number will be&#xA;     * converted to a character form using exponential notation.  In&#xA;     * this case, if the converted &lt;tt>BigInteger&lt;/tt> has more than&#xA;     * one digit a decimal point is inserted after the first digit.&#xA;     * An exponent in character form is then suffixed to the converted&#xA;     * unscaled value (perhaps with inserted decimal point); this&#xA;     * comprises the letter &lt;tt>'E'&lt;/tt> followed immediately by the&#xA;     * adjusted exponent converted to a character form.  The latter is&#xA;     * in base ten, using the characters &lt;tt>'0'&lt;/tt> through&#xA;     * &lt;tt>'9'&lt;/tt> with no leading zeros, and is always prefixed by a&#xA;     * sign character &lt;tt>'-'&lt;/tt> (&lt;tt>'&amp;#92;u002D'&lt;/tt>) if the&#xA;     * adjusted exponent is negative, &lt;tt>'+'&lt;/tt>&#xA;     * (&lt;tt>'&amp;#92;u002B'&lt;/tt>) otherwise).&#xA;     * &#xA;     * &lt;p>Finally, the entire string is prefixed by a minus sign&#xA;     * character &lt;tt>'-'&lt;/tt> (&lt;tt>'&amp;#92;u002D'&lt;/tt>) if the unscaled&#xA;     * value is less than zero.  No sign character is prefixed if the&#xA;     * unscaled value is zero or positive.&#xA;     * &#xA;     * &lt;p>&lt;b>Examples:&lt;/b>&#xA;     * &lt;p>For each representation [&lt;i>unscaled value&lt;/i>, &lt;i>scale&lt;/i>]&#xA;     * on the left, the resulting string is shown on the right.&#xA;     * &lt;pre>&#xA;     * [123,0]      &amp;quot;123&amp;quot;&#xA;     * [-123,0]     &amp;quot;-123&amp;quot;&#xA;     * [123,-1]     &amp;quot;1.23E+3&amp;quot;&#xA;     * [123,-3]     &amp;quot;1.23E+5&amp;quot;&#xA;     * [123,1]      &amp;quot;12.3&amp;quot;&#xA;     * [123,5]      &amp;quot;0.00123&amp;quot;&#xA;     * [123,10]     &amp;quot;1.23E-8&amp;quot;&#xA;     * [-123,12]    &amp;quot;-1.23E-10&amp;quot;&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;b>Notes:&lt;/b>&#xA;     * &lt;ol>&#xA;     *&#xA;     * &lt;li>There is a one-to-one mapping between the distinguishable&#xA;     * &lt;tt>BigDecimal&lt;/tt> values and the result of this conversion.&#xA;     * That is, every distinguishable &lt;tt>BigDecimal&lt;/tt> value&#xA;     * (unscaled value and scale) has a unique string representation&#xA;     * as a result of using &lt;tt>toString&lt;/tt>.  If that string&#xA;     * representation is converted back to a &lt;tt>BigDecimal&lt;/tt> using&#xA;     * the {@link #BigDecimal(String)} constructor, then the original&#xA;     * value will be recovered.&#xA;     * &#xA;     * &lt;li>The string produced for a given number is always the same;&#xA;     * it is not affected by locale.  This means that it can be used&#xA;     * as a canonical string representation for exchanging decimal&#xA;     * data, or as a key for a Hashtable, etc.  Locale-sensitive&#xA;     * number formatting and parsing is handled by the {@link&#xA;     * java.text.NumberFormat} class and its subclasses.&#xA;     * &#xA;     * &lt;li>The {@link #toEngineeringString} method may be used for&#xA;     * presenting numbers with exponents in engineering notation, and the&#xA;     * {@link #setScale(int,RoundingMode) setScale} method may be used for&#xA;     * rounding a &lt;tt>BigDecimal&lt;/tt> so it has a known number of digits after&#xA;     * the decimal point.&#xA;     * &#xA;     * &lt;li>The digit-to-character mapping provided by&#xA;     * &lt;tt>Character.forDigit&lt;/tt> is used.&#xA;     *&#xA;     * &lt;/ol>&#xA;     *&#xA;     * @return string representation of this &lt;tt>BigDecimal&lt;/tt>.&#xA;     * @see    Character#forDigit&#xA;     * @see    #BigDecimal(java.lang.String)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.103">
              <arguments xsi:type="literals:BooleanLiteral" value="true"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toEngineeringString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string representation of this &lt;tt>BigDecimal&lt;/tt>,&#xA;     * using engineering notation if an exponent is needed.&#xA;     * &#xA;     * &lt;p>Returns a string that represents the &lt;tt>BigDecimal&lt;/tt> as&#xA;     * described in the {@link #toString()} method, except that if&#xA;     * exponential notation is used, the power of ten is adjusted to&#xA;     * be a multiple of three (engineering notation) such that the&#xA;     * integer part of nonzero values will be in the range 1 through&#xA;     * 999.  If exponential notation is used for zero values, a&#xA;     * decimal point and one or two fractional zero digits are used so&#xA;     * that the scale of the zero value is preserved.  Note that&#xA;     * unlike the output of {@link #toString()}, the output of this&#xA;     * method is &lt;em>not&lt;/em> guaranteed to recover the same [integer,&#xA;     * scale] pair of this &lt;tt>BigDecimal&lt;/tt> if the output string is&#xA;     * converting back to a &lt;tt>BigDecimal&lt;/tt> using the {@linkplain&#xA;     * #BigDecimal(String) string constructor}.  The result of this method meets&#xA;     * the weaker constraint of always producing a numerically equal&#xA;     * result from applying the string constructor to the method's output.&#xA;     *&#xA;     * @return string representation of this &lt;tt>BigDecimal&lt;/tt>, using&#xA;     *         engineering notation if an exponent is needed.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.103">
          <arguments xsi:type="literals:BooleanLiteral"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toPlainString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string representation of this &lt;tt>BigDecimal&lt;/tt>&#xA;     * without an exponent field.  For values with a positive scale,&#xA;     * the number of digits to the right of the decimal point is used&#xA;     * to indicate scale.  For values with a zero or negative scale,&#xA;     * the resulting string is generated as if the value were&#xA;     * converted to a numerically equal value with zero scale and as&#xA;     * if all the trailing zeros of the zero scale value were present&#xA;     * in the result.&#xA;     *&#xA;     * The entire string is prefixed by a minus sign character '-'&#xA;     * (&lt;tt>'&amp;#92;u002D'&lt;/tt>) if the unscaled value is less than&#xA;     * zero. No sign character is prefixed if the unscaled value is&#xA;     * zero or positive.&#xA;     *&#xA;     * Note that if the result of this method is passed to the&#xA;     * {@linkplain #BigDecimal(String) string constructor}, only the&#xA;     * numerical value of this &lt;tt>BigDecimal&lt;/tt> will necessarily be&#xA;     * recovered; the representation of the new &lt;tt>BigDecimal&lt;/tt>&#xA;     * may have a different scale.  In particular, if this&#xA;     * &lt;tt>BigDecimal&lt;/tt> has a positive scale, the string resulting&#xA;     * from this method will have a scale of zero when processed by&#xA;     * the string constructor.&#xA;     *&#xA;     * (This method behaves analogously to the &lt;tt>toString&lt;/tt>&#xA;     * method in 1.4 and earlier releases.)&#xA;     *&#xA;     * @return a string representation of this &lt;tt>BigDecimal&lt;/tt>&#xA;     * without an exponent field.&#xA;     * @since 1.5&#xA;     * @see #toString()&#xA;     * @see #toEngineeringString()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bd">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@statements.0/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </next>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@statements.0/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// No decimal point</comments>
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.113"/>
              </next>
            </next>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@statements.0/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.89">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@statements.0/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.113"/>
                  </next>
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.73"/>
                </next>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getValueString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="signum">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="intString">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/* Returns a digit.digit string */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="buf">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>/* Insert decimal point */</comments>
              <target xsi:type="classifiers:Class" href="../lang/StringBuilder.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="insertionPoint">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
              </next>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.2"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <comments>/* Point goes right before intVal */</comments>
            <returnValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ConditionalExpression">
                  <child xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.0"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    <relationOperators xsi:type="operators:LessThan"/>
                  </child>
                  <expressionIf xsi:type="references:StringReference" value="-0."/>
                  <expressionElse xsi:type="references:StringReference" value="0."/>
                </expression>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.1/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.0/@variable">
                  <comments>/* Point goes inside intVal */</comments>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/StringBuilder.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.1"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.0/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.30"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.1/@variable"/>
                  <arguments xsi:type="literals:CharacterLiteral" value="46"/>
                </next>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.30"/>
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    <arguments xsi:type="literals:CharacterLiteral" value="45"/>
                  </next>
                </expression>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.1/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.0/@variable">
                  <comments>/* We must insert zeros between point and intVal */</comments>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/StringBuilder.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.1/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.1">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                      </next>
                    </children>
                    <additiveOperators xsi:type="operators:Subtraction"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.0/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.6"/>
                  <arguments xsi:type="expressions:ConditionalExpression">
                    <child xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.0"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <relationOperators xsi:type="operators:LessThan"/>
                    </child>
                    <expressionIf xsi:type="references:StringReference" value="-0."/>
                    <expressionElse xsi:type="references:StringReference" value="0."/>
                  </arguments>
                </next>
              </expression>
            </statements>
            <statements xsi:type="statements:ForLoop">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                    <arguments xsi:type="literals:CharacterLiteral" value="48"/>
                  </next>
                </expression>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.2/@elseStatement/@elseStatement/@statements.2/@init"/>
                <children xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Subtraction"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.1/@variable"/>
                </children>
                <relationOperators xsi:type="operators:LessThan"/>
              </condition>
              <init xsi:type="variables:LocalVariable" name="i">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </init>
              <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.2/@elseStatement/@elseStatement/@statements.2/@init"/>
                <operator xsi:type="operators:PlusPlus"/>
              </updates>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.0/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.6"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.1"/>
                </next>
              </expression>
            </statements>
          </elseStatement>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.40"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toBigInteger">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this &lt;tt>BigDecimal&lt;/tt> to a &lt;tt>BigInteger&lt;/tt>.&#xA;     * This conversion is analogous to a &lt;a&#xA;     * href=&quot;http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25363&quot;>&lt;i>narrowing&#xA;     * primitive conversion&lt;/i>&lt;/a> from &lt;tt>double&lt;/tt> to&#xA;     * &lt;tt>long&lt;/tt> as defined in the &lt;a&#xA;     * href=&quot;http://java.sun.com/docs/books/jls/html/&quot;>Java Language&#xA;     * Specification&lt;/a>: any fractional part of this&#xA;     * &lt;tt>BigDecimal&lt;/tt> will be discarded.  Note that this&#xA;     * conversion can lose information about the precision of the&#xA;     * &lt;tt>BigDecimal&lt;/tt> value.&#xA;     * &lt;p>&#xA;     * To have an exception thrown if the conversion is inexact (in&#xA;     * other words if a nonzero fractional part is discarded), use the&#xA;     * {@link #toBigIntegerExact()} method.&#xA;     *&#xA;     * @return this &lt;tt>BigDecimal&lt;/tt> converted to a &lt;tt>BigInteger&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// force to an integer, quietly</comments>
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.75">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </next>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66"/>
          </next>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toBigIntegerExact">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this &lt;tt>BigDecimal&lt;/tt> to a &lt;tt>BigInteger&lt;/tt>,&#xA;     * checking for lost information.  An exception is thrown if this&#xA;     * &lt;tt>BigDecimal&lt;/tt> has a nonzero fractional part.&#xA;     *&#xA;     * @return this &lt;tt>BigDecimal&lt;/tt> converted to a &lt;tt>BigInteger&lt;/tt>.&#xA;     * @throws ArithmeticException if &lt;tt>this&lt;/tt> has a nonzero&#xA;     *         fractional part.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// round to an integer, with Exception if decimal part non-0</comments>
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.75">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </next>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72"/>
          </next>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="longValue">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this &lt;tt>BigDecimal&lt;/tt> to a &lt;tt>long&lt;/tt>.  This&#xA;     * conversion is analogous to a &lt;a&#xA;     * href=&quot;http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25363&quot;>&lt;i>narrowing&#xA;     * primitive conversion&lt;/i>&lt;/a> from &lt;tt>double&lt;/tt> to&#xA;     * &lt;tt>short&lt;/tt> as defined in the &lt;a&#xA;     * href=&quot;http://java.sun.com/docs/books/jls/html/&quot;>Java Language&#xA;     * Specification&lt;/a>: any fractional part of this&#xA;     * &lt;tt>BigDecimal&lt;/tt> will be discarded, and if the resulting&#xA;     * &amp;quot;&lt;tt>BigInteger&lt;/tt>&amp;quot; is too big to fit in a&#xA;     * &lt;tt>long&lt;/tt>, only the low-order 64 bits are returned.&#xA;     * Note that this conversion can lose information about the&#xA;     * overall magnitude and precision of this &lt;tt>BigDecimal&lt;/tt> value as well&#xA;     * as return a result with the opposite sign.&#xA;     * &#xA;     * @return this &lt;tt>BigDecimal&lt;/tt> converted to a &lt;tt>long&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </children>
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </children>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <expressionElse xsi:type="references:MethodCall" target="//@classifiers.0/@members.90">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.116"/>
            </next>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="longValueExact">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this &lt;tt>BigDecimal&lt;/tt> to a &lt;tt>long&lt;/tt>, checking&#xA;     * for lost information.  If this &lt;tt>BigDecimal&lt;/tt> has a&#xA;     * nonzero fractional part or is out of the possible range for a&#xA;     * &lt;tt>long&lt;/tt> result then an &lt;tt>ArithmeticException&lt;/tt> is&#xA;     * thrown.&#xA;     *&#xA;     * @return this &lt;tt>BigDecimal&lt;/tt> converted to a &lt;tt>long&lt;/tt>.&#xA;     * @throws ArithmeticException if &lt;tt>this&lt;/tt> has a nonzero&#xA;     *         fractional part, or will not fit in a &lt;tt>long&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// If more than 19 digits in integer part it cannot possibly fit</comments>
        <statement xsi:type="statements:Throw">
          <comments>// [OK for negative scale too]</comments>
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <namespaces>java</namespaces>
              <namespaces>lang</namespaces>
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Overflow"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="19"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Fastpath zero and &lt; 1.0 numbers (the latter can be very slow</comments>
        <comments>// to round if very small)</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Rounding necessary"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
                <self xsi:type="literals:This"/>
              </children>
              <children xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <self xsi:type="literals:This"/>
              </children>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="num">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>// round to an integer, with Exception if decimal part non-0</comments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.75">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72"/>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>// need to check carefully</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94">
                    <comments>// initialize constants</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                      <arguments xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.0"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                      <arguments xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <namespaces>java</namespaces>
                  <namespaces>lang</namespaces>
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="Overflow"/>
              </throwable>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@statements.4/@variable">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.106"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94"/>
                      </next>
                    </next>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@statements.4/@variable">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.106"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95"/>
                      </next>
                    </next>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </expression>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@statements.4/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="19"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@statements.4/@variable">
          <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.116"/>
            </next>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="LONGMIN">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// These constants are only initialized if needed</comments>
        <comments>/** BigInteger equal to Long.MIN_VALUE. */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="LONGMAX">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** BigInteger equal to Long.MAX_VALUE. */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="intValue">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this &lt;tt>BigDecimal&lt;/tt> to an &lt;tt>int&lt;/tt>.  This&#xA;     * conversion is analogous to a &lt;a&#xA;     * href=&quot;http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25363&quot;>&lt;i>narrowing&#xA;     * primitive conversion&lt;/i>&lt;/a> from &lt;tt>double&lt;/tt> to&#xA;     * &lt;tt>short&lt;/tt> as defined in the &lt;a&#xA;     * href=&quot;http://java.sun.com/docs/books/jls/html/&quot;>Java Language&#xA;     * Specification&lt;/a>: any fractional part of this&#xA;     * &lt;tt>BigDecimal&lt;/tt> will be discarded, and if the resulting&#xA;     * &amp;quot;&lt;tt>BigInteger&lt;/tt>&amp;quot; is too big to fit in an&#xA;     * &lt;tt>int&lt;/tt>, only the low-order 32 bits are returned.&#xA;     * Note that this conversion can lose information about the&#xA;     * overall magnitude and precision of this &lt;tt>BigDecimal&lt;/tt>&#xA;     * value as well as return a result with the opposite sign.&#xA;     * &#xA;     * @return this &lt;tt>BigDecimal&lt;/tt> converted to an &lt;tt>int&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </children>
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </children>
            </expression>
          </child>
          <expressionIf xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          </expressionIf>
          <expressionElse xsi:type="references:MethodCall" target="//@classifiers.0/@members.90">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.115"/>
            </next>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="intValueExact">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this &lt;tt>BigDecimal&lt;/tt> to an &lt;tt>int&lt;/tt>, checking&#xA;     * for lost information.  If this &lt;tt>BigDecimal&lt;/tt> has a&#xA;     * nonzero fractional part or is out of the possible range for an&#xA;     * &lt;tt>int&lt;/tt> result then an &lt;tt>ArithmeticException&lt;/tt> is&#xA;     * thrown.&#xA;     *&#xA;     * @return this &lt;tt>BigDecimal&lt;/tt> converted to an &lt;tt>int&lt;/tt>.&#xA;     * @throws ArithmeticException if &lt;tt>this&lt;/tt> has a nonzero&#xA;     *         fractional part, or will not fit in an &lt;tt>int&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="num">
          <typeReference xsi:type="types:Long"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@statements.0/@variable"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.93"/>
            <self xsi:type="literals:This"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// will check decimal part</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <namespaces>java</namespaces>
              <namespaces>lang</namespaces>
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Overflow"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@statements.0/@variable"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@statements.0/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Int"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@statements.0/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="shortValueExact">
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this &lt;tt>BigDecimal&lt;/tt> to a &lt;tt>short&lt;/tt>, checking&#xA;     * for lost information.  If this &lt;tt>BigDecimal&lt;/tt> has a&#xA;     * nonzero fractional part or is out of the possible range for a&#xA;     * &lt;tt>short&lt;/tt> result then an &lt;tt>ArithmeticException&lt;/tt> is&#xA;     * thrown.&#xA;     *&#xA;     * @return this &lt;tt>BigDecimal&lt;/tt> converted to a &lt;tt>short&lt;/tt>.&#xA;     * @throws ArithmeticException if &lt;tt>this&lt;/tt> has a nonzero&#xA;     *         fractional part, or will not fit in a &lt;tt>short&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="num">
          <typeReference xsi:type="types:Long"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@statements.0/@variable"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.93"/>
            <self xsi:type="literals:This"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// will check decimal part</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <namespaces>java</namespaces>
              <namespaces>lang</namespaces>
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Overflow"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Short"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@statements.0/@variable"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@statements.0/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Short"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@statements.0/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="byteValueExact">
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this &lt;tt>BigDecimal&lt;/tt> to a &lt;tt>byte&lt;/tt>, checking&#xA;     * for lost information.  If this &lt;tt>BigDecimal&lt;/tt> has a&#xA;     * nonzero fractional part or is out of the possible range for a&#xA;     * &lt;tt>byte&lt;/tt> result then an &lt;tt>ArithmeticException&lt;/tt> is&#xA;     * thrown.&#xA;     *&#xA;     * @return this &lt;tt>BigDecimal&lt;/tt> converted to a &lt;tt>byte&lt;/tt>.&#xA;     * @throws ArithmeticException if &lt;tt>this&lt;/tt> has a nonzero&#xA;     *         fractional part, or will not fit in a &lt;tt>byte&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="num">
          <typeReference xsi:type="types:Long"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@statements.0/@variable"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.93"/>
            <self xsi:type="literals:This"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// will check decimal part</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <namespaces>java</namespaces>
              <namespaces>lang</namespaces>
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Overflow"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Byte"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@statements.0/@variable"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@statements.0/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Byte"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@statements.0/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="floatValue">
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this &lt;tt>BigDecimal&lt;/tt> to a &lt;tt>float&lt;/tt>.&#xA;     * This conversion is similar to the &lt;a&#xA;     * href=&quot;http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25363&quot;>&lt;i>narrowing&#xA;     * primitive conversion&lt;/i>&lt;/a> from &lt;tt>double&lt;/tt> to&#xA;     * &lt;tt>float&lt;/tt> defined in the &lt;a&#xA;     * href=&quot;http://java.sun.com/docs/books/jls/html/&quot;>Java Language&#xA;     * Specification&lt;/a>: if this &lt;tt>BigDecimal&lt;/tt> has too great a&#xA;     * magnitude to represent as a &lt;tt>float&lt;/tt>, it will be&#xA;     * converted to {@link Float#NEGATIVE_INFINITY} or {@link&#xA;     * Float#POSITIVE_INFINITY} as appropriate.  Note that even when&#xA;     * the return value is finite, this conversion can lose&#xA;     * information about the precision of the &lt;tt>BigDecimal&lt;/tt>&#xA;     * value.&#xA;     * &#xA;     * @return this &lt;tt>BigDecimal&lt;/tt> converted to a &lt;tt>float&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Float"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// Somewhat inefficient, but guaranteed to work.</comments>
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Float.class.xmi#//@classifiers.0/@members.13"/>
            <arguments xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.86"/>
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="../lang/Float.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="doubleValue">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this &lt;tt>BigDecimal&lt;/tt> to a &lt;tt>double&lt;/tt>.&#xA;     * This conversion is similar to the &lt;a&#xA;     * href=&quot;http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25363&quot;>&lt;i>narrowing&#xA;     * primitive conversion&lt;/i>&lt;/a> from &lt;tt>double&lt;/tt> to&#xA;     * &lt;tt>float&lt;/tt> as defined in the &lt;a&#xA;     * href=&quot;http://java.sun.com/docs/books/jls/html/&quot;>Java Language&#xA;     * Specification&lt;/a>: if this &lt;tt>BigDecimal&lt;/tt> has too great a&#xA;     * magnitude represent as a &lt;tt>double&lt;/tt>, it will be&#xA;     * converted to {@link Double#NEGATIVE_INFINITY} or {@link&#xA;     * Double#POSITIVE_INFINITY} as appropriate.  Note that even when&#xA;     * the return value is finite, this conversion can lose&#xA;     * information about the precision of the &lt;tt>BigDecimal&lt;/tt>&#xA;     * value.&#xA;     * &#xA;     * @return this &lt;tt>BigDecimal&lt;/tt> converted to a &lt;tt>double&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Double"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// Somewhat inefficient, but guaranteed to work.</comments>
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Double.class.xmi#//@classifiers.0/@members.13"/>
            <arguments xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.86"/>
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="../lang/Double.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="ulp">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the size of an ulp, a unit in the last place, of this&#xA;     * &lt;tt>BigDecimal&lt;/tt>.  An ulp of a nonzero &lt;tt>BigDecimal&lt;/tt>&#xA;     * value is the positive distance between this value and the&#xA;     * &lt;tt>BigDecimal&lt;/tt> value next larger in magnitude with the&#xA;     * same number of digits.  An ulp of a zero value is numerically&#xA;     * equal to 1 with the scale of &lt;tt>this&lt;/tt>.  The result is&#xA;     * stored with the same scale as &lt;code>this&lt;/code> so the result&#xA;     * for zero and nonzero values is equal to &lt;code>[1,&#xA;     * this.scale()]&lt;/code>.&#xA;     *&#xA;     * @return the size of an ulp of &lt;tt>this&lt;/tt>&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <arguments xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="layoutChars">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sci">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Private &quot;Helper&quot; Methods</comments>
        <comments>/**&#xA;     * Lay out this &lt;tt>BigDecimal&lt;/tt> into a &lt;tt>char[]&lt;/tt> array.&#xA;     * The Java 1.2 equivalent to this was called &lt;tt>getValueString&lt;/tt>.&#xA;     *&#xA;     * @param  sci &lt;tt>true&lt;/tt> for Scientific exponential notation;&#xA;     *          &lt;tt>false&lt;/tt> for Engineering&#xA;     * @return string with canonical string representation of this&#xA;     *         &lt;tt>BigDecimal&lt;/tt>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// zero scale is trivial</comments>
          <returnValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </expression>
            </child>
            <expressionIf xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Long.class.xmi#//@classifiers.0/@members.11"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
            </expressionIf>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.113"/>
              </next>
            </expressionElse>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="coeff">
          <typeReference xsi:type="types:Char">
            <comments>// Get the significand as an absolute value</comments>
          </typeReference>
          <arrayDimensionsAfter/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.73"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Long.class.xmi#//@classifiers.0/@members.11"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.30"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
        </condition>
        <elseStatement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.73"/>
                  </next>
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.113"/>
                </next>
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.73"/>
              </next>
            </value>
          </expression>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="buf">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Construct a buffer, with sufficient capacity for all cases.</comments>
              <comments>// If E-notation is needed, length will be: +1 if negative, +1</comments>
              <comments>// if '.' needed, +2 for &quot;E+&quot;, + up to 10 for adjusted exponent.</comments>
              <comments>// Otherwise it could have +1 if negative, plus leading &quot;0.00000&quot;</comments>
              <target xsi:type="classifiers:Class" href="../lang/StringBuilder.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuilder.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
            <comments>// prefix '-' if negative</comments>
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
              <arguments xsi:type="literals:CharacterLiteral" value="45"/>
            </next>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="adjusted">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Long"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </child>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </expression>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="pad">
              <typeReference xsi:type="types:Int">
                <comments>// plain number</comments>
              </typeReference>
              <initialValue xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// count of padding zeros</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                  <comments>// 0.xxx form</comments>
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                    <arguments xsi:type="literals:CharacterLiteral" value="48"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                    <arguments xsi:type="literals:CharacterLiteral" value="46"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ForLoop">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                        <arguments xsi:type="literals:CharacterLiteral" value="48"/>
                      </next>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@statement/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </condition>
                <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@statement/@statements.0/@variable"/>
                  <operator xsi:type="operators:MinusMinus"/>
                </updates>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.11"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable"/>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                  <comments>// xx.xx form</comments>
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.12"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable"/>
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    <arguments xsi:type="expressions:UnaryExpression">
                      <operators xsi:type="operators:Subtraction"/>
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@statement/@statements.0/@variable"/>
                    </arguments>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                    <arguments xsi:type="literals:CharacterLiteral" value="46"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.12"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable"/>
                    <arguments xsi:type="expressions:UnaryExpression">
                      <operators xsi:type="operators:Subtraction"/>
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@statement/@statements.0/@variable"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                  </next>
                </expression>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.5/@variable"/>
              <children xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>// E-notation is needed</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                  <comments>// Scientific notation</comments>
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable">
                      <arraySelectors>
                        <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      </arraySelectors>
                    </arguments>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <comments>// first character</comments>
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                      <comments>// more to come</comments>
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                        <arguments xsi:type="literals:CharacterLiteral" value="46"/>
                      </next>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.12"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable"/>
                        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <arguments xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable">
                            <next xsi:type="references:IdentifierReference"/>
                          </children>
                          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                          <additiveOperators xsi:type="operators:Subtraction"/>
                        </arguments>
                      </next>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable">
                    <next xsi:type="references:IdentifierReference"/>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@parameters.0"/>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="sig">
                  <typeReference xsi:type="types:Int">
                    <comments>// Engineering notation</comments>
                  </typeReference>
                  <initialValue xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:Int"/>
                    <child xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:MultiplicativeExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.5/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                        <multiplicativeOperators xsi:type="operators:Remainder"/>
                      </expression>
                    </child>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@elseStatement/@statements.0/@elseStatement/@statements.0/@variable"/>
                    <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                    <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                  </expression>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@elseStatement/@statements.0/@elseStatement/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.5/@variable">
                    <comments>// [adjusted was negative]</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:AssignmentMinus"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@elseStatement/@statements.0/@elseStatement/@statements.0/@variable"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@elseStatement/@statements.0/@elseStatement/@statements.0/@variable">
                    <comments>// now a multiple of 3</comments>
                  </child>
                  <operator xsi:type="operators:PlusPlus"/>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Switch">
                    <cases xsi:type="statements:NormalSwitchCase">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                            <arguments xsi:type="literals:CharacterLiteral" value="48"/>
                          </next>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:Break">
                        <comments>// exponent is a multiple of three</comments>
                      </statements>
                      <condition xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    </cases>
                    <cases xsi:type="statements:NormalSwitchCase">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.6"/>
                            <arguments xsi:type="references:StringReference" value="0.00"/>
                          </next>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.5/@variable"/>
                          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:Break"/>
                      <condition xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                    </cases>
                    <cases xsi:type="statements:NormalSwitchCase">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.6"/>
                            <arguments xsi:type="references:StringReference" value="0.0"/>
                          </next>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.5/@variable"/>
                          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:Break"/>
                      <condition xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                    </cases>
                    <cases xsi:type="statements:DefaultSwitchCase">
                      <statements xsi:type="statements:Throw">
                        <throwable xsi:type="instantiations:NewConstructorCall">
                          <typeReference xsi:type="types:NamespaceClassifierReference">
                            <classifierReferences>
                              <target xsi:type="classifiers:Class" href="../lang/AssertionError.class.xmi#//@classifiers.0"/>
                            </classifierReferences>
                          </typeReference>
                          <arguments xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:StringReference" value="Unexpected sig value "/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@elseStatement/@statements.0/@elseStatement/@statements.0/@variable"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                          </arguments>
                        </throwable>
                      </statements>
                    </cases>
                    <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@elseStatement/@statements.0/@elseStatement/@statements.0/@variable"/>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </condition>
                <elseStatement xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                        <comments>// significand all in integer</comments>
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.12"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable"/>
                          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable">
                            <next xsi:type="references:IdentifierReference"/>
                          </arguments>
                        </next>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:ForLoop">
                      <comments>// may need some zeros, too</comments>
                      <statement xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                            <arguments xsi:type="literals:CharacterLiteral" value="48"/>
                          </next>
                        </expression>
                      </statement>
                      <condition xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@elseStatement/@statements.0/@elseStatement/@statements.4/@elseStatement/@statement/@statements.1/@init"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        <relationOperators xsi:type="operators:GreaterThan"/>
                      </condition>
                      <init xsi:type="variables:LocalVariable" name="i">
                        <typeReference xsi:type="types:Int"/>
                        <initialValue xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@elseStatement/@statements.0/@elseStatement/@statements.0/@variable"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable">
                            <next xsi:type="references:IdentifierReference"/>
                          </children>
                          <additiveOperators xsi:type="operators:Subtraction"/>
                        </initialValue>
                      </init>
                      <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@elseStatement/@statements.0/@elseStatement/@statements.4/@elseStatement/@statement/@statements.1/@init"/>
                        <operator xsi:type="operators:MinusMinus"/>
                      </updates>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@elseStatement/@statements.0/@elseStatement/@statements.0/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable">
                      <next xsi:type="references:IdentifierReference"/>
                    </children>
                    <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                  </condition>
                  <elseStatement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                        <comments>// xx.xxE form</comments>
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.12"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable"/>
                          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@elseStatement/@statements.0/@elseStatement/@statements.0/@variable"/>
                        </next>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                          <arguments xsi:type="literals:CharacterLiteral" value="46"/>
                        </next>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.12"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@elseStatement/@statements.0/@elseStatement/@statements.0/@variable"/>
                          <arguments xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.1/@variable">
                              <next xsi:type="references:IdentifierReference"/>
                            </children>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.6/@elseStatement/@statements.0/@elseStatement/@statements.0/@variable"/>
                            <additiveOperators xsi:type="operators:Subtraction"/>
                          </arguments>
                        </next>
                      </expression>
                    </statements>
                  </elseStatement>
                </elseStatement>
              </statements>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                  <comments>// [!sci could have made 0]</comments>
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                    <arguments xsi:type="literals:CharacterLiteral" value="69"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                    <comments>// force sign for positive</comments>
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                      <arguments xsi:type="literals:CharacterLiteral" value="43"/>
                    </next>
                  </expression>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.5/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.16"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.5/@variable"/>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.5/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@statements.3/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.40"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="tenToThe">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Return 10 to the power n, as a &lt;tt>BigInteger&lt;/tt>.&#xA;     *&#xA;     * @param  n the power of ten to be returned (>=0)&#xA;     * @return a &lt;tt>BigInteger&lt;/tt> with the value (10&lt;sup>n&lt;/sup>)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// use value from constant array</comments>
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.105">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
            </arraySelectors>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.105">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="tenpow">
          <typeReference xsi:type="types:Char">
            <comments>// BigInteger.pow is slow, so make 10**n by constructing a</comments>
            <comments>// BigInteger from a character string (still not very fast)</comments>
          </typeReference>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </sizes>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.1/@variable">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:CharacterLiteral" value="49"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.1/@variable">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.3/@init"/>
              </arraySelectors>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:CharacterLiteral" value="48"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.1/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="TENPOWERS">
      <initialValue xsi:type="arrays:ArrayInstantiationByValues">
        <arrayInitializer>
          <initialValues xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.16"/>
            </next>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </initialValues>
          <initialValues xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
            </next>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </initialValues>
          <initialValues xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="100"/>
            </next>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </initialValues>
          <initialValues xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1000"/>
            </next>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </initialValues>
          <initialValues xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="10000"/>
            </next>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </initialValues>
          <initialValues xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="100000"/>
            </next>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </initialValues>
          <initialValues xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1000000"/>
            </next>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </initialValues>
          <initialValues xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="10000000"/>
            </next>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </initialValues>
          <initialValues xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="100000000"/>
            </next>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </initialValues>
          <initialValues xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1000000000"/>
            </next>
            <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
          </initialValues>
        </arrayInitializer>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsAfter/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="longTenToThe">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Compute val * 10 ^ n; return this product if it is&#xA;     * representable as a long, INFLATED otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <comments>// System.err.print(&quot;\tval &quot; + val + &quot;\t power &quot; + n + &quot;\tresult &quot;);</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <comments>// System.err.println(val * thresholds[n][1]);</comments>
                <returnValue xsi:type="expressions:MultiplicativeExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.0"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.1"/>
                    </arraySelectors>
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    </arraySelectors>
                  </children>
                  <multiplicativeOperators xsi:type="operators:Multiplication"/>
                </returnValue>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.30"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.1"/>
                </arraySelectors>
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </arraySelectors>
              </children>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// System.err.println(INFLATED);</comments>
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
      </statements>
    </members>
    <members xsi:type="members:Field" name="thresholds">
      <initialValue xsi:type="arrays:ArrayInstantiationByValues">
        <arrayInitializer>
          <comments>// 13</comments>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <initialValues xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
            </arrayInitializer>
          </initialValues>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <comments>// 0</comments>
              <initialValues xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="10"/>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="10"/>
            </arrayInitializer>
          </initialValues>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <comments>// 1</comments>
              <initialValues xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="100"/>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="100"/>
            </arrayInitializer>
          </initialValues>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <comments>// 2</comments>
              <initialValues xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="1000"/>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="1000"/>
            </arrayInitializer>
          </initialValues>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <comments>// 3</comments>
              <initialValues xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="10000"/>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="10000"/>
            </arrayInitializer>
          </initialValues>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <comments>// 4</comments>
              <initialValues xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="100000"/>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="100000"/>
            </arrayInitializer>
          </initialValues>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <comments>// 5</comments>
              <initialValues xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="1000000"/>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="1000000"/>
            </arrayInitializer>
          </initialValues>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <comments>// 6</comments>
              <initialValues xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="10000000"/>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="10000000"/>
            </arrayInitializer>
          </initialValues>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <comments>// 7</comments>
              <initialValues xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="100000000"/>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="100000000"/>
            </arrayInitializer>
          </initialValues>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <comments>// 8</comments>
              <initialValues xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="1000000000"/>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="1000000000"/>
            </arrayInitializer>
          </initialValues>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <comments>// 9</comments>
              <initialValues xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="10000000000"/>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="10000000000"/>
            </arrayInitializer>
          </initialValues>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <comments>// 10</comments>
              <initialValues xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="100000000000"/>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="100000000000"/>
            </arrayInitializer>
          </initialValues>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <comments>// 11</comments>
              <initialValues xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="1000000000000"/>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="1000000000000"/>
            </arrayInitializer>
          </initialValues>
          <initialValues xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <comments>// 12</comments>
              <initialValues xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
                </children>
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="100000000000000"/>
                <multiplicativeOperators xsi:type="operators:Division"/>
              </initialValues>
              <initialValues xsi:type="literals:DecimalLongLiteral" decimalValue="10000000000000"/>
            </arrayInitializer>
          </initialValues>
        </arrayInitializer>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <arrayDimensionsAfter/>
      <arrayDimensionsAfter/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="compactLong">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../lang/Long.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Long.class.xmi#//@classifiers.0"/>
            </children>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="inflate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Assign appropriate BigInteger to intVal field if intVal is&#xA;     * null, i.e. the compact representation is in use.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.53"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </next>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="matchScale">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Match the scales of two &lt;tt>BigDecimal&lt;tt>s to align their&#xA;     * least significant digits.&#xA;     * &#xA;     * &lt;p>If the scales of val[0] and val[1] differ, rescale&#xA;     * (non-destructively) the lower-scaled &lt;tt>BigDecimal&lt;/tt> so&#xA;     * they match.  That is, the lower-scaled reference will be&#xA;     * replaced by a reference to a new object with the same scale as&#xA;     * the other &lt;tt>BigDecimal&lt;/tt>.&#xA;     *&#xA;     * @param  val array of two elements referring to the two&#xA;     *         &lt;tt>BigDecimal&lt;/tt>s to be aligned.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0">
              <arraySelectors>
                <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </arraySelectors>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                  <arraySelectors>
                    <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  </arraySelectors>
                </arguments>
              </next>
              <arraySelectors>
                <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </arraySelectors>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arraySelectors>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    </arraySelectors>
                  </arguments>
                </next>
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </arraySelectors>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <arraySelectors>
                <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </arraySelectors>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <arraySelectors>
                <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </arraySelectors>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/ObjectInputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>java</namespaces>
        <namespaces>io</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/ClassNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Reconstitute the &lt;tt>BigDecimal&lt;/tt> instance from a stream (that is,&#xA;     * deserialize it).&#xA;     *&#xA;     * @param s the stream being read.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.111/@parameters.0">
          <comments>// Read in all fields</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectInputStream.class.xmi#//@classifiers.0/@members.19"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// validate possibly bad fields</comments>
        <statement xsi:type="statements:Block">
          <comments>// [all values of scale are now allowed]</comments>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="message">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:StringReference" value="BigDecimal: null intVal in stream"/>
            </variable>
          </statements>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>java</namespaces>
                <namespaces>io</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../io/StreamCorruptedException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.111/@statements.1/@statement/@statements.0/@variable"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
            <comments>// Set intCompact to uninitialized value; could also see if the</comments>
            <comments>// intVal was small enough to fit as a compact value.</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>java</namespaces>
        <namespaces>io</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;    * Serialize this &lt;tt>BigDecimal&lt;/tt> to the stream in question&#xA;    *&#xA;    * @param s the stream to serialize to.&#xA;    */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
          <self xsi:type="literals:This">
            <comments>// Must inflate to maintain compatible serial form.</comments>
          </self>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@parameters.0">
          <comments>// Write proper fields</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.17"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="digitLength">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Returns the length of this &lt;tt>BigDecimal&lt;/tt>, in decimal digits.&#xA;     *&#xA;     * Notes:&#xA;     *&lt;ul>&#xA;     * &lt;li> This is performance-critical; most operations where a&#xA;     *      context is supplied will need at least one call to this&#xA;     *      method.&#xA;     *&#xA;     * &lt;li> This should be a method on BigInteger; the call to this&#xA;     *      method in precision() can then be replaced with the&#xA;     *      term: intVal.digitLength().  It could also be called&#xA;     *      precision() in BigInteger.&#xA;     *&#xA;     *      Better still -- the precision lookaside could be moved to&#xA;     *      BigInteger, too.&#xA;     *&#xA;     * &lt;li> This could/should use MutableBigIntegers directly for the&#xA;     *      reduction loop.&#xA;     *&lt;ul>&#xA;     * @return the length of the unscaled value, in decimal digits&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.115">
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.29"/>
                <arguments xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Int"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
            </arguments>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.30"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
            </children>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
            </children>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// 0 is one decimal digit</comments>
          <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
          <self xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="work">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// we have a nonzero magnitude</comments>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="digits">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <comments>// counter</comments>
        <statement xsi:type="statements:Block">
          <comments>// (a power of a billion)</comments>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.3/@variable">
                <comments>// here when more than one integer in the magnitude; divide</comments>
                <comments>// by a billion (reduce by 9 digits) and try again</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.3/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.64"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.105">
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
                    </arraySelectors>
                  </arguments>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.4/@variable"/>
              <assignmentOperator xsi:type="operators:AssignmentPlus"/>
              <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <comments>// the division was exact</comments>
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.4/@variable"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.3/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.75"/>
                </next>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.3/@variable">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference"/>
              <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.4/@variable">
            <comments>// down to a simple nonzero integer</comments>
          </child>
          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
          <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.115">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.3/@variable">
              <next xsi:type="references:IdentifierReference">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </arraySelectors>
                <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.1"/>
              </next>
            </arguments>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// System.out.println(&quot;digitLength... &quot;+this+&quot;  ->  &quot;+digits);</comments>
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.4/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:Field" name="ilogTable">
      <initialValue xsi:type="arrays:ArrayInstantiationByValues">
        <arrayInitializer>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="99"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="999"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="9999"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="99999"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="999999"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="9999999"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="99999999"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="999999999"/>
          <initialValues xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
          </initialValues>
        </arrayInitializer>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="intLength">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Returns the length of an unsigned &lt;tt>int&lt;/tt>, in decimal digits.&#xA;     * @param i the &lt;tt>int&lt;/tt> (treated as unsigned)&#xA;     * @return the length of the unscaled value, in decimal digits&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="digits">
          <typeReference xsi:type="types:Int"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <comments>// 'negative' is 10 digits unsigned</comments>
            <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>// positive integer</comments>
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <comments>// &quot;Hacker's Delight&quot;  section 11-4</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Return">
                  <returnValue xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@statements.1/@elseStatement/@statements.1/@init"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </returnValue>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@parameters.0"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114">
                    <arraySelectors>
                      <position xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@statements.1/@elseStatement/@statements.1/@init"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </position>
                    </arraySelectors>
                  </children>
                  <relationOperators xsi:type="operators:LessThanOrEqual"/>
                </condition>
              </statements>
            </statement>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </initialValue>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@statements.1/@elseStatement/@statements.1/@init"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="stripZerosToMatchScale">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="preferredScale">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Remove insignificant trailing zeros from this&#xA;     * &lt;tt>BigDecimal&lt;/tt> until the preferred scale is reached or no&#xA;     * more zeros can be removed.  If the preferred scale is less than&#xA;     * Integer.MIN_VALUE, all the trailing zeros will be removed.&#xA;     *&#xA;     * &lt;tt>BigInteger&lt;/tt> assistance could help, here?&#xA;     *&#xA;     * &lt;p>WARNING: This method should only be called on new objects as&#xA;     * it mutates the value fields.&#xA;     *&#xA;     * @return this &lt;tt>BigDecimal&lt;/tt> with a scale possibly reduced&#xA;     * to be closed to the preferred scale.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="compact">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
          <self xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="qr">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsAfter/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>// quotient-remainder pair</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Break"/>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.95"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </next>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.2/@variable">
                <comments>// odd number cannot end in 0</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.65"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.18"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Break"/>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.2/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.75"/>
                </next>
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </arraySelectors>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <comments>// non-0 remainder</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.2/@variable">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </arraySelectors>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.117">
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:Long"/>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </arguments>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// could Overflow</comments>
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
                  <comments>// adjust precision if known</comments>
                </child>
                <operator xsi:type="operators:MinusMinus"/>
              </expression>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.106"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="BigInteger.class.xmi#//@classifiers.0/@members.18"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="BigInteger.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.73"/>
              </next>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@parameters.0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.116"/>
              </next>
            </value>
          </expression>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.0/@variable"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkScale">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Check a scale for Underflow or Overflow.  If this BigDecimal is&#xA;     * uninitialized or initialized and nonzero, throw an exception if&#xA;     * the scale is out of range.  If this is zero, saturate the scale&#xA;     * to the extreme value of the right sign if the scale is out of&#xA;     * range.&#xA;     *&#xA;     * @param val The new scale.&#xA;     * @throws ArithmeticException (overflow or underflow) if the new&#xA;     *         scale is out of range.&#xA;     * @return validated scale as an int.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Throw">
                  <throwable xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="references:StringReference" value="Underflow"/>
                  </throwable>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117/@parameters.0"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                  </children>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </condition>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Throw">
                  <throwable xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../lang/ArithmeticException.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="references:StringReference" value="Overflow"/>
                  </throwable>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117/@parameters.0"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                  </children>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:SelfReference">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                      <self xsi:type="literals:This"/>
                    </children>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                  </children>
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:SelfReference">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                      <self xsi:type="literals:This"/>
                    </children>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </children>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:SelfReference">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                      <self xsi:type="literals:This"/>
                    </children>
                    <children xsi:type="literals:NullLiteral"/>
                  </children>
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:SelfReference">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.61"/>
                      <self xsi:type="literals:This"/>
                    </children>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </children>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:SelfReference">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                      <self xsi:type="literals:This"/>
                    </children>
                    <children xsi:type="literals:NullLiteral"/>
                  </children>
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:SelfReference">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                      <self xsi:type="literals:This"/>
                    </children>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                  </children>
                </expression>
              </children>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="expressions:ConditionalExpression">
                  <child xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117/@parameters.0"/>
                      <children xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                      </children>
                      <relationOperators xsi:type="operators:GreaterThan"/>
                    </expression>
                  </child>
                  <expressionIf xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                  </expressionIf>
                  <expressionElse xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                  </expressionElse>
                </returnValue>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117/@parameters.0"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Int"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="roundOp">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Round an operand; used only if digits &amp;gt; 0.  Does not change&#xA;     * &lt;tt>this&lt;/tt>; if rounding is needed a new &lt;tt>BigDecimal&lt;/tt>&#xA;     * is created and returned.&#xA;     *&#xA;     * @param mc the context to use.&#xA;     * @throws ArithmeticException if the result is inexact but the&#xA;     *         rounding mode is &lt;tt>UNNECESSARY&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="rounded">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.120">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.118/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.118/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="roundThis">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** Round this BigDecimal according to the MathContext settings;&#xA;     *  used only if precision &amp;gt; 0.&#xA;     *&#xA;     * &lt;p>WARNING: This method should only be called on new objects as&#xA;     * it mutates the value fields.&#xA;     *&#xA;     * @param mc the context to use.&#xA;     * @throws ArithmeticException if the rounding mode is&#xA;     *         &lt;tt>RoundingMode.UNNECESSARY&lt;/tt> and the&#xA;     *         &lt;tt>BigDecimal&lt;/tt> operation would require rounding.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="rounded">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.120">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// wasn't rounded</comments>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@statements.0/@variable"/>
          <children xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="doRound">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Returns a &lt;tt>BigDecimal&lt;/tt> rounded according to the&#xA;     * MathContext settings; used only if &lt;tt>mc.precision&amp;gt;0&lt;/tt>.&#xA;     * Does not change &lt;tt>this&lt;/tt>; if rounding is needed a new&#xA;     * &lt;tt>BigDecimal&lt;/tt> is created and returned.&#xA;     *&#xA;     * @param mc the context to use.&#xA;     * @return a &lt;tt>BigDecimal&lt;/tt> rounded according to the MathContext&#xA;     *         settings.  May return this, if no rounding needed.&#xA;     * @throws ArithmeticException if the rounding mode is&#xA;     *         &lt;tt>RoundingMode.UNNECESSARY&lt;/tt> and the&#xA;     *         result is inexact.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.109"/>
          <self xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <comments>// find it</comments>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.10"/>
                  </next>
                </children>
                <children xsi:type="literals:NullLiteral"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.106"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.10"/>
                      </next>
                    </arguments>
                  </next>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.106"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.11"/>
                      </next>
                    </arguments>
                  </next>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.63">
              <comments>// no rounding needed</comments>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="drop">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.8"/>
              </next>
            </children>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// digits to discard</comments>
        <statement xsi:type="statements:Return">
          <comments>// we fit</comments>
          <returnValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.2/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="rounded">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.121">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.2/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// we need to double-check, in case of the 999=>1000 case</comments>
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.4/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.120">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="dropDigits">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="MathContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="drop">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Removes digits from the significand of a &lt;tt>BigDecimal&lt;/tt>,&#xA;     * rounding according to the MathContext settings.  Does not&#xA;     * change &lt;tt>this&lt;/tt>; a new &lt;tt>BigDecimal&lt;/tt> is always&#xA;     * created and returned.&#xA;     * &#xA;     * &lt;p>Actual rounding is carried out, as before, by the divide&#xA;     * method, as this minimized code changes.  It might be more&#xA;     * efficient in most cases to move rounding to here, so we can do&#xA;     * a round-to-length rather than round-to-scale.&#xA;     *&#xA;     * @param mc the context to use.&#xA;     * @param drop the number of digits to drop, must be &amp;gt; 0&#xA;     * @return a &lt;tt>BigDecimal&lt;/tt> rounded according to the MathContext&#xA;     *         settings.  May return &lt;tt>this&lt;/tt>, if no rounding needed.&#xA;     * @throws ArithmeticException if the rounding mode is&#xA;     *         &lt;tt>RoundingMode.UNNECESSARY&lt;/tt> and the&#xA;     *         result is inexact.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="divisor">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>// here if we need to round; make the divisor = 10**drop)</comments>
              <comments>// [calculating the BigInteger here saves setScale later]</comments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.104">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@parameters.1"/>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="rounded">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>// divide to same scale to force round to length</comments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.41">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@parameters.0">
                <next xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="RoundingMode.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="members:Field" href="MathContext.class.xmi#//@classifiers.0/@members.9"/>
                </next>
              </arguments>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@statements.1/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.117">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Long"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@statements.1/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                </child>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@parameters.1"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// adjust the scale</comments>
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="longCompareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.1"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </child>
          <expressionIf xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </expressionIf>
          <expressionElse xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.1"/>
              </expression>
            </child>
            <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <expressionElse xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bd">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/*&#xA;     * Internal printing routine&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../io/PrintStream.class.xmi#//@classifiers.0/@members.46"/>
              <arguments xsi:type="references:StringReference" value="%s:&#x9;intCompact %d&#x9;intVal %d&#x9;scale %d&#x9;precision %d%n"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              </arguments>
            </next>
            <target xsi:type="members:Field" href="../lang/System.class.xmi#//@classifiers.0/@members.2"/>
          </next>
          <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="audit">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Check internal invariants of this BigDecimal.  These invariants&#xA;     * include:&#xA;     *&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>The object must be initialized; either intCompact must not be&#xA;     * INFLATED or intVal is non-null.  Both of these conditions may&#xA;     * be true.&#xA;     *&#xA;     * &lt;li>If both intCompact and intVal and set, their values must be&#xA;     * consistent.&#xA;     * &#xA;     * &lt;li>If precision is nonzero, it must have the right value.&#xA;     * &lt;/ul>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// Check precision</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.123">
                  <arguments xsi:type="references:StringReference" value="audit"/>
                  <arguments xsi:type="references:SelfReference">
                    <self xsi:type="literals:This"/>
                  </arguments>
                </expression>
              </statements>
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/AssertionError.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:StringReference" value="precision mismatch"/>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.113"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.123">
                  <arguments xsi:type="references:StringReference" value="audit"/>
                  <arguments xsi:type="references:SelfReference">
                    <self xsi:type="literals:This"/>
                  </arguments>
                </expression>
              </statements>
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/AssertionError.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:StringReference" value="null intVal"/>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="val">
                  <typeReference xsi:type="types:Long"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="BigInteger.class.xmi#//@classifiers.0/@members.116"/>
                    </next>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.123">
                      <arguments xsi:type="references:StringReference" value="audit"/>
                      <arguments xsi:type="references:SelfReference">
                        <self xsi:type="literals:This"/>
                      </arguments>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:Throw">
                    <throwable xsi:type="instantiations:NewConstructorCall">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../lang/AssertionError.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:StringReference" value="Inconsistent state, intCompact="/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                        <children xsi:type="references:StringReference" value="&#x9; intVal="/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@statements.1/@elseStatement/@statements.0/@statement/@statements.0/@variable"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </arguments>
                    </throwable>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@statements.1/@elseStatement/@statements.0/@statement/@statements.0/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Immutable, arbitrary-precision signed decimal numbers.  A&#xA; * &lt;tt>BigDecimal&lt;/tt> consists of an arbitrary precision integer&#xA; * &lt;i>unscaled value&lt;/i> and a 32-bit integer &lt;i>scale&lt;/i>.  If zero&#xA; * or positive, the scale is the number of digits to the right of the&#xA; * decimal point.  If negative, the unscaled value of the number is&#xA; * multiplied by ten to the power of the negation of the scale.  The&#xA; * value of the number represented by the &lt;tt>BigDecimal&lt;/tt> is&#xA; * therefore &lt;tt>(unscaledValue &amp;times; 10&lt;sup>-scale&lt;/sup>)&lt;/tt>.&#xA; * &#xA; * &lt;p>The &lt;tt>BigDecimal&lt;/tt> class provides operations for&#xA; * arithmetic, scale manipulation, rounding, comparison, hashing, and&#xA; * format conversion.  The {@link #toString} method provides a&#xA; * canonical representation of a &lt;tt>BigDecimal&lt;/tt>.&#xA; * &#xA; * &lt;p>The &lt;tt>BigDecimal&lt;/tt> class gives its user complete control&#xA; * over rounding behavior.  If no rounding mode is specified and the&#xA; * exact result cannot be represented, an exception is thrown;&#xA; * otherwise, calculations can be carried out to a chosen precision&#xA; * and rounding mode by supplying an appropriate {@link MathContext}&#xA; * object to the operation.  In either case, eight &lt;em>rounding&#xA; * modes&lt;/em> are provided for the control of rounding.  Using the&#xA; * integer fields in this class (such as {@link #ROUND_HALF_UP}) to&#xA; * represent rounding mode is largely obsolete; the enumeration values&#xA; * of the &lt;tt>RoundingMode&lt;/tt> &lt;tt>enum&lt;/tt>, (such as {@link&#xA; * RoundingMode#HALF_UP}) should be used instead.&#xA; * &#xA; * &lt;p>When a &lt;tt>MathContext&lt;/tt> object is supplied with a precision&#xA; * setting of 0 (for example, {@link MathContext#UNLIMITED}),&#xA; * arithmetic operations are exact, as are the arithmetic methods&#xA; * which take no &lt;tt>MathContext&lt;/tt> object.  (This is the only&#xA; * behavior that was supported in releases prior to 5.)  As a&#xA; * corollary of computing the exact result, the rounding mode setting&#xA; * of a &lt;tt>MathContext&lt;/tt> object with a precision setting of 0 is&#xA; * not used and thus irrelevant.  In the case of divide, the exact&#xA; * quotient could have an infinitely long decimal expansion; for&#xA; * example, 1 divided by 3.  If the quotient has a nonterminating&#xA; * decimal expansion and the operation is specified to return an exact&#xA; * result, an &lt;tt>ArithmeticException&lt;/tt> is thrown.  Otherwise, the&#xA; * exact result of the division is returned, as done for other&#xA; * operations.&#xA; *&#xA; * &lt;p>When the precision setting is not 0, the rules of&#xA; * &lt;tt>BigDecimal&lt;/tt> arithmetic are broadly compatible with selected&#xA; * modes of operation of the arithmetic defined in ANSI X3.274-1996&#xA; * and ANSI X3.274-1996/AM 1-2000 (section 7.4).  Unlike those&#xA; * standards, &lt;tt>BigDecimal&lt;/tt> includes many rounding modes, which&#xA; * were mandatory for division in &lt;tt>BigDecimal&lt;/tt> releases prior&#xA; * to 5.  Any conflicts between these ANSI standards and the&#xA; * &lt;tt>BigDecimal&lt;/tt> specification are resolved in favor of&#xA; * &lt;tt>BigDecimal&lt;/tt>.  &#xA; *&#xA; * &lt;p>Since the same numerical value can have different&#xA; * representations (with different scales), the rules of arithmetic&#xA; * and rounding must specify both the numerical result and the scale&#xA; * used in the result's representation.&#xA; *&#xA; *&#xA; * &lt;p>In general the rounding modes and precision setting determine&#xA; * how operations return results with a limited number of digits when&#xA; * the exact result has more digits (perhaps infinitely many in the&#xA; * case of division) than the number of digits returned.&#xA; *&#xA; * First, the&#xA; * total number of digits to return is specified by the&#xA; * &lt;tt>MathContext&lt;/tt>'s &lt;tt>precision&lt;/tt> setting; this determines&#xA; * the result's &lt;i>precision&lt;/i>.  The digit count starts from the&#xA; * leftmost nonzero digit of the exact result.  The rounding mode&#xA; * determines how any discarded trailing digits affect the returned&#xA; * result.&#xA; *&#xA; * &lt;p>For all arithmetic operators , the operation is carried out as&#xA; * though an exact intermediate result were first calculated and then&#xA; * rounded to the number of digits specified by the precision setting&#xA; * (if necessary), using the selected rounding mode.  If the exact&#xA; * result is not returned, some digit positions of the exact result&#xA; * are discarded.  When rounding increases the magnitude of the&#xA; * returned result, it is possible for a new digit position to be&#xA; * created by a carry propagating to a leading &amp;quot;9&amp;quot; digit.&#xA; * For example, rounding the value 999.9 to three digits rounding up&#xA; * would be numerically equal to one thousand, represented as&#xA; * 100&amp;times;10&lt;sup>1&lt;/sup>.  In such cases, the new &amp;quot;1&amp;quot; is&#xA; * the leading digit position of the returned result.&#xA; *&#xA; * &lt;p>Besides a logical exact result, each arithmetic operation has a&#xA; * preferred scale for representing a result.  The preferred&#xA; * scale for each operation is listed in the table below.&#xA; *&#xA; * &lt;table border>&#xA; * &lt;caption top>&lt;h3>Preferred Scales for Results of Arithmetic Operations&#xA; * &lt;/h3>&lt;/caption>&#xA; * &lt;tr>&lt;th>Operation&lt;/th>&lt;th>Preferred Scale of Result&lt;/th>&lt;/tr>&#xA; * &lt;tr>&lt;td>Add&lt;/td>&lt;td>max(addend.scale(), augend.scale())&lt;/td>&#xA; * &lt;tr>&lt;td>Subtract&lt;/td>&lt;td>max(minuend.scale(), subtrahend.scale())&lt;/td>&#xA; * &lt;tr>&lt;td>Multiply&lt;/td>&lt;td>multiplier.scale() + multiplicand.scale()&lt;/td>&#xA; * &lt;tr>&lt;td>Divide&lt;/td>&lt;td>dividend.scale() - divisor.scale()&lt;/td>&#xA; * &lt;/table>&#xA; *&#xA; * These scales are the ones used by the methods which return exact&#xA; * arithmetic results; except that an exact divide may have to use a&#xA; * larger scale since the exact result may have more digits.  For&#xA; * example, &lt;tt>1/32&lt;/tt> is &lt;tt>0.03125&lt;/tt>.&#xA; *&#xA; * &lt;p>Before rounding, the scale of the logical exact intermediate&#xA; * result is the preferred scale for that operation.  If the exact&#xA; * numerical result cannot be represented in &lt;code>precision&lt;/code>&#xA; * digits, rounding selects the set of digits to return and the scale&#xA; * of the result is reduced from the scale of the intermediate result&#xA; * to the least scale which can represent the &lt;code>precision&lt;/code>&#xA; * digits actually returned.  If the exact result can be represented&#xA; * with at most &lt;code>precision&lt;/code> digits, the representation&#xA; * of the result with the scale closest to the preferred scale is&#xA; * returned.  In particular, an exactly representable quotient may be&#xA; * represented in fewer than &lt;code>precision&lt;/code> digits by removing&#xA; * trailing zeros and decreasing the scale.  For example, rounding to&#xA; * three digits using the {@linkplain RoundingMode#FLOOR floor}&#xA; * rounding mode, &lt;br>&#xA; *&#xA; * &lt;code>19/100 = 0.19   // integer=19,  scale=2&lt;/code> &lt;br>&#xA; *&#xA; * but&lt;br>&#xA; *&#xA; * &lt;code>21/110 = 0.190  // integer=190, scale=3&lt;/code> &lt;br>&#xA; *&#xA; * &lt;p>Note that for add, subtract, and multiply, the reduction in&#xA; * scale will equal the number of digit positions of the exact result&#xA; * which are discarded. If the rounding causes a carry propagation to&#xA; * create a new high-order digit position, an additional digit of the&#xA; * result is discarded than when no new digit position is created.&#xA; *&#xA; * &lt;p>Other methods may have slightly different rounding semantics.&#xA; * For example, the result of the &lt;tt>pow&lt;/tt> method using the&#xA; * {@linkplain #pow(int, MathContext) specified algorithm} can&#xA; * occasionally differ from the rounded mathematical result by more&#xA; * than one unit in the last place, one &lt;i>{@linkplain #ulp() ulp}&lt;/i>.&#xA; *&#xA; * &lt;p>Two types of operations are provided for manipulating the scale&#xA; * of a &lt;tt>BigDecimal&lt;/tt>: scaling/rounding operations and decimal&#xA; * point motion operations.  Scaling/rounding operations ({@link&#xA; * #setScale setScale} and {@link #round round}) return a&#xA; * &lt;tt>BigDecimal&lt;/tt> whose value is approximately (or exactly) equal&#xA; * to that of the operand, but whose scale or precision is the&#xA; * specified value; that is, they increase or decrease the precision&#xA; * of the stored number with minimal effect on its value.  Decimal&#xA; * point motion operations ({@link #movePointLeft movePointLeft} and&#xA; * {@link #movePointRight movePointRight}) return a&#xA; * &lt;tt>BigDecimal&lt;/tt> created from the operand by moving the decimal&#xA; * point a specified distance in the specified direction.&#xA; * &#xA; * &lt;p>For the sake of brevity and clarity, pseudo-code is used&#xA; * throughout the descriptions of &lt;tt>BigDecimal&lt;/tt> methods.  The&#xA; * pseudo-code expression &lt;tt>(i + j)&lt;/tt> is shorthand for &amp;quot;a&#xA; * &lt;tt>BigDecimal&lt;/tt> whose value is that of the &lt;tt>BigDecimal&lt;/tt>&#xA; * &lt;tt>i&lt;/tt> added to that of the &lt;tt>BigDecimal&lt;/tt>&#xA; * &lt;tt>j&lt;/tt>.&amp;quot; The pseudo-code expression &lt;tt>(i == j)&lt;/tt> is&#xA; * shorthand for &amp;quot;&lt;tt>true&lt;/tt> if and only if the&#xA; * &lt;tt>BigDecimal&lt;/tt> &lt;tt>i&lt;/tt> represents the same value as the&#xA; * &lt;tt>BigDecimal&lt;/tt> &lt;tt>j&lt;/tt>.&amp;quot; Other pseudo-code expressions&#xA; * are interpreted similarly.  Square brackets are used to represent&#xA; * the particular &lt;tt>BigInteger&lt;/tt> and scale pair defining a&#xA; * &lt;tt>BigDecimal&lt;/tt> value; for example [19, 2] is the&#xA; * &lt;tt>BigDecimal&lt;/tt> numerically equal to 0.19 having a scale of 2.&#xA; *&#xA; * &lt;p>Note: care should be exercised if &lt;tt>BigDecimal&lt;/tt> objects&#xA; * are used as keys in a {@link java.util.SortedMap SortedMap} or&#xA; * elements in a {@link java.util.SortedSet SortedSet} since&#xA; * &lt;tt>BigDecimal&lt;/tt>'s &lt;i>natural ordering&lt;/i> is &lt;i>inconsistent&#xA; * with equals&lt;/i>.  See {@link Comparable}, {@link&#xA; * java.util.SortedMap} or {@link java.util.SortedSet} for more&#xA; * information.&#xA; * &#xA; * &lt;p>All methods and constructors for this class throw&#xA; * &lt;tt>NullPointerException&lt;/tt> when passed a &lt;tt>null&lt;/tt> object&#xA; * reference for any input parameter.&#xA; *&#xA; * @see     BigInteger&#xA; * @see     MathContext&#xA; * @see     RoundingMode&#xA; * @see     java.util.SortedMap&#xA; * @see     java.util.SortedSet&#xA; * @author  Josh Bloch&#xA; * @author  Mike Cowlishaw&#xA; * @author  Joseph D. Darcy&#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="../lang/Comparable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="../lang/Number.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
