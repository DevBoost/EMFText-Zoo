<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="Comparable.java">
  <comments>/*&#xA; * @(#)Comparable.java&#x9;1.22 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>lang</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Comparable">
    <typeParameters name="T"/>
    <members xsi:type="members:InterfaceMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares this object with the specified object for order.  Returns a&#xA;     * negative integer, zero, or a positive integer as this object is less&#xA;     * than, equal to, or greater than the specified object.&lt;p>&#xA;     *&#xA;     * In the foregoing description, the notation&#xA;     * &lt;tt>sgn(&lt;/tt>&lt;i>expression&lt;/i>&lt;tt>)&lt;/tt> designates the mathematical&#xA;     * &lt;i>signum&lt;/i> function, which is defined to return one of &lt;tt>-1&lt;/tt>,&#xA;     * &lt;tt>0&lt;/tt>, or &lt;tt>1&lt;/tt> according to whether the value of &lt;i>expression&lt;/i>&#xA;     * is negative, zero or positive.&#xA;     *&#xA;     * The implementor must ensure &lt;tt>sgn(x.compareTo(y)) ==&#xA;     * -sgn(y.compareTo(x))&lt;/tt> for all &lt;tt>x&lt;/tt> and &lt;tt>y&lt;/tt>.  (This&#xA;     * implies that &lt;tt>x.compareTo(y)&lt;/tt> must throw an exception iff&#xA;     * &lt;tt>y.compareTo(x)&lt;/tt> throws an exception.)&lt;p>&#xA;     *&#xA;     * The implementor must also ensure that the relation is transitive:&#xA;     * &lt;tt>(x.compareTo(y)&amp;gt;0 &amp;amp;&amp;amp; y.compareTo(z)&amp;gt;0)&lt;/tt> implies&#xA;     * &lt;tt>x.compareTo(z)&amp;gt;0&lt;/tt>.&lt;p>&#xA;     *&#xA;     * Finally, the implementer must ensure that &lt;tt>x.compareTo(y)==0&lt;/tt>&#xA;     * implies that &lt;tt>sgn(x.compareTo(z)) == sgn(y.compareTo(z))&lt;/tt>, for&#xA;     * all &lt;tt>z&lt;/tt>.&lt;p>&#xA;     *&#xA;     * It is strongly recommended, but &lt;i>not&lt;/i> strictly required that&#xA;     * &lt;tt>(x.compareTo(y)==0) == (x.equals(y))&lt;/tt>.  Generally speaking, any&#xA;     * class that implements the &lt;tt>Comparable&lt;/tt> interface and violates&#xA;     * this condition should clearly indicate this fact.  The recommended&#xA;     * language is &quot;Note: this class has a natural ordering that is&#xA;     * inconsistent with equals.&quot;&#xA;     * &#xA;     * @param   o the Object to be compared.&#xA;     * @return  a negative integer, zero, or a positive integer as this object&#xA;     *&#x9;&#x9;is less than, equal to, or greater than the specified object.&#xA;     * &#xA;     * @throws ClassCastException if the specified object's type prevents it&#xA;     *         from being compared to this Object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This interface imposes a total ordering on the objects of each class that&#xA; * implements it.  This ordering is referred to as the class's &lt;i>natural&#xA; * ordering&lt;/i>, and the class's &lt;tt>compareTo&lt;/tt> method is referred to as&#xA; * its &lt;i>natural comparison method&lt;/i>.&lt;p>&#xA; *&#xA; * Lists (and arrays) of objects that implement this interface can be sorted&#xA; * automatically by &lt;tt>Collections.sort&lt;/tt> (and &lt;tt>Arrays.sort&lt;/tt>).&#xA; * Objects that implement this interface can be used as keys in a sorted map&#xA; * or elements in a sorted set, without the need to specify a comparator.&lt;p>&#xA; *&#xA; * The natural ordering for a class &lt;tt>C&lt;/tt> is said to be &lt;i>consistent&#xA; * with equals&lt;/i> if and only if &lt;tt>(e1.compareTo((Object)e2) == 0)&lt;/tt> has&#xA; * the same boolean value as &lt;tt>e1.equals((Object)e2)&lt;/tt> for every&#xA; * &lt;tt>e1&lt;/tt> and &lt;tt>e2&lt;/tt> of class &lt;tt>C&lt;/tt>.  Note that &lt;tt>null&lt;/tt>&#xA; * is not an instance of any class, and &lt;tt>e.compareTo(null)&lt;/tt> should&#xA; * throw a &lt;tt>NullPointerException&lt;/tt> even though &lt;tt>e.equals(null)&lt;/tt>&#xA; * returns &lt;tt>false&lt;/tt>.&lt;p>&#xA; *&#xA; * It is strongly recommended (though not required) that natural orderings be&#xA; * consistent with equals.  This is so because sorted sets (and sorted maps)&#xA; * without explicit comparators behave &quot;strangely&quot; when they are used with&#xA; * elements (or keys) whose natural ordering is inconsistent with equals.  In&#xA; * particular, such a sorted set (or sorted map) violates the general contract&#xA; * for set (or map), which is defined in terms of the &lt;tt>equals&lt;/tt>&#xA; * method.&lt;p>&#xA; *&#xA; * For example, if one adds two keys &lt;tt>a&lt;/tt> and &lt;tt>b&lt;/tt> such that&#xA; * &lt;tt>(!a.equals((Object)b) &amp;&amp; a.compareTo((Object)b) == 0)&lt;/tt> to a sorted&#xA; * set that does not use an explicit comparator, the second &lt;tt>add&lt;/tt>&#xA; * operation returns false (and the size of the sorted set does not increase)&#xA; * because &lt;tt>a&lt;/tt> and &lt;tt>b&lt;/tt> are equivalent from the sorted set's&#xA; * perspective.&lt;p>&#xA; *&#xA; * Virtually all Java core classes that implement comparable have natural&#xA; * orderings that are consistent with equals.  One exception is&#xA; * &lt;tt>java.math.BigDecimal&lt;/tt>, whose natural ordering equates&#xA; * &lt;tt>BigDecimal&lt;/tt> objects with equal values and different precisions &#xA; * (such as 4.0 and 4.00).&lt;p>&#xA; *&#xA; * For the mathematically inclined, the &lt;i>relation&lt;/i> that defines&#xA; * the natural ordering on a given class C is:&lt;pre>&#xA; *       {(x, y) such that x.compareTo((Object)y) &amp;lt;= 0}.&#xA; * &lt;/pre> The &lt;i>quotient&lt;/i> for this total order is: &lt;pre>&#xA; *       {(x, y) such that x.compareTo((Object)y) == 0}.&#xA; * &lt;/pre>&#xA; *&#xA; * It follows immediately from the contract for &lt;tt>compareTo&lt;/tt> that the&#xA; * quotient is an &lt;i>equivalence relation&lt;/i> on &lt;tt>C&lt;/tt>, and that the&#xA; * natural ordering is a &lt;i>total order&lt;/i> on &lt;tt>C&lt;/tt>.  When we say that a&#xA; * class's natural ordering is &lt;i>consistent with equals&lt;/i>, we mean that the&#xA; * quotient for the natural ordering is the equivalence relation defined by&#xA; * the class's &lt;tt>equals(Object)&lt;/tt> method:&lt;pre>&#xA; *     {(x, y) such that x.equals((Object)y)}.&#xA; * &lt;/pre>&lt;p>&#xA; *&#xA; * This interface is a member of the &#xA; * &lt;a href=&quot;{@docRoot}/../guide/collections/index.html&quot;>&#xA; * Java Collections Framework&lt;/a>.&#xA; *&#xA; * @author  Josh Bloch&#xA; * @version 1.22, 12/19/03&#xA; * @see java.util.Comparator&#xA; * @see java.util.Collections#sort(java.util.List)&#xA; * @see java.util.Arrays#sort(Object[])&#xA; * @see java.util.SortedSet&#xA; * @see java.util.SortedMap&#xA; * @see java.util.TreeSet&#xA; * @see java.util.TreeMap&#xA; * @since 1.2&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
