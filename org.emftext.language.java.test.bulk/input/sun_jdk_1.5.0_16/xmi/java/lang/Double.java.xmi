<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="Double.java">
  <comments>/*&#xA; * @(#)Double.java&#x9;1.94 04/05/11&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>lang</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>misc</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>misc</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>misc</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/misc/DoubleConsts.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Double">
    <members xsi:type="members:Field" name="POSITIVE_INFINITY">
      <initialValue xsi:type="expressions:MultiplicativeExpression">
        <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="1.0"/>
        <children xsi:type="literals:DecimalDoubleLiteral"/>
        <multiplicativeOperators xsi:type="operators:Division"/>
      </initialValue>
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A constant holding the positive infinity of type&#xA;     * &lt;code>double&lt;/code>. It is equal to the value returned by&#xA;     * &lt;code>Double.longBitsToDouble(0x7ff0000000000000L)&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="NEGATIVE_INFINITY">
      <initialValue xsi:type="expressions:MultiplicativeExpression">
        <children xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalDoubleLiteral" decimalValue="1.0"/>
        </children>
        <children xsi:type="literals:DecimalDoubleLiteral"/>
        <multiplicativeOperators xsi:type="operators:Division"/>
      </initialValue>
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A constant holding the negative infinity of type&#xA;     * &lt;code>double&lt;/code>. It is equal to the value returned by&#xA;     * &lt;code>Double.longBitsToDouble(0xfff0000000000000L)&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="NaN">
      <initialValue xsi:type="expressions:MultiplicativeExpression">
        <children xsi:type="literals:DecimalDoubleLiteral"/>
        <children xsi:type="literals:DecimalDoubleLiteral"/>
        <multiplicativeOperators xsi:type="operators:Division"/>
      </initialValue>
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * A constant holding a Not-a-Number (NaN) value of type&#xA;     * &lt;code>double&lt;/code>. It is equivalent to the value returned by&#xA;     * &lt;code>Double.longBitsToDouble(0x7ff8000000000000L)&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MAX_VALUE">
      <initialValue xsi:type="literals:DecimalDoubleLiteral" decimalValue="1.7976931348623157E308"/>
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A constant holding the largest positive finite value of type&#xA;     * &lt;code>double&lt;/code>,&#xA;     * (2-2&lt;sup>-52&lt;/sup>)&amp;middot;2&lt;sup>1023&lt;/sup>.  It is equal to&#xA;     * the hexadecimal floating-point literal&#xA;     * &lt;code>0x1.fffffffffffffP+1023&lt;/code> and also equal to&#xA;     * &lt;code>Double.longBitsToDouble(0x7fefffffffffffffL)&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MIN_VALUE">
      <initialValue xsi:type="literals:DecimalDoubleLiteral" decimalValue="4.9E-324"/>
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// 0x1.fffffffffffffP+1023</comments>
        <comments>/**&#xA;     * A constant holding the smallest positive nonzero value of type&#xA;     * &lt;code>double&lt;/code>, 2&lt;sup>-1074&lt;/sup>. It is equal to the&#xA;     * hexadecimal floating-point literal&#xA;     * &lt;code>0x0.0000000000001P-1022&lt;/code> and also equal to&#xA;     * &lt;code>Double.longBitsToDouble(0x1L)&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SIZE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="64"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// 0x0.0000000000001P-1022</comments>
        <comments>/**&#xA;     * The number of bits used to represent a &lt;tt>double&lt;/tt> value.&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="TYPE">
      <initialValue xsi:type="expressions:CastExpression">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Class" href="Class.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <child xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Class.class.xmi#//@classifiers.0/@members.92"/>
            <arguments xsi:type="references:StringReference" value="double"/>
          </next>
          <target xsi:type="classifiers:Class" href="Class.class.xmi#//@classifiers.0"/>
        </child>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Class" href="Class.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The &lt;code>Class&lt;/code> instance representing the primitive type&#xA;     * &lt;code>double&lt;/code>.&#xA;     *&#xA;     * @since JDK1.1 &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string representation of the &lt;code>double&lt;/code> &#xA;     * argument. All characters mentioned below are ASCII characters.&#xA;     * &lt;ul>&#xA;     * &lt;li>If the argument is NaN, the result is the string&#xA;     *     &amp;quot;&lt;code>NaN&lt;/code>&amp;quot;.&#xA;     * &lt;li>Otherwise, the result is a string that represents the sign and &#xA;     * magnitude (absolute value) of the argument. If the sign is negative, &#xA;     * the first character of the result is '&lt;code>-&lt;/code>' &#xA;     * (&lt;code>'&amp;#92;u002D'&lt;/code>); if the sign is positive, no sign character &#xA;     * appears in the result. As for the magnitude &lt;i>m&lt;/i>:&#xA;     * &lt;ul>&#xA;     * &lt;li>If &lt;i>m&lt;/i> is infinity, it is represented by the characters &#xA;     * &lt;code>&quot;Infinity&quot;&lt;/code>; thus, positive infinity produces the result &#xA;     * &lt;code>&quot;Infinity&quot;&lt;/code> and negative infinity produces the result &#xA;     * &lt;code>&quot;-Infinity&quot;&lt;/code>.&#xA;     *&#xA;     * &lt;li>If &lt;i>m&lt;/i> is zero, it is represented by the characters &#xA;     * &lt;code>&quot;0.0&quot;&lt;/code>; thus, negative zero produces the result &#xA;     * &lt;code>&quot;-0.0&quot;&lt;/code> and positive zero produces the result &#xA;     * &lt;code>&quot;0.0&quot;&lt;/code>. &#xA;     *&#xA;     * &lt;li>If &lt;i>m&lt;/i> is greater than or equal to 10&lt;sup>-3&lt;/sup> but less &#xA;     * than 10&lt;sup>7&lt;/sup>, then it is represented as the integer part of &#xA;     * &lt;i>m&lt;/i>, in decimal form with no leading zeroes, followed by &#xA;     * '&lt;code>.&lt;/code>' (&lt;code>'&amp;#92;u002E'&lt;/code>), followed by one or &#xA;     * more decimal digits representing the fractional part of &lt;i>m&lt;/i>. &#xA;     *&#xA;     * &lt;li>If &lt;i>m&lt;/i> is less than 10&lt;sup>-3&lt;/sup> or greater than or&#xA;     * equal to 10&lt;sup>7&lt;/sup>, then it is represented in so-called&#xA;     * &quot;computerized scientific notation.&quot; Let &lt;i>n&lt;/i> be the unique&#xA;     * integer such that 10&lt;sup>&lt;i>n&lt;/i>&lt;/sup> &amp;lt;= &lt;i>m&lt;/i> &amp;lt;&#xA;     * 10&lt;sup>&lt;i>n&lt;/i>+1&lt;/sup>; then let &lt;i>a&lt;/i> be the&#xA;     * mathematically exact quotient of &lt;i>m&lt;/i> and&#xA;     * 10&lt;sup>&lt;i>n&lt;/i>&lt;/sup> so that 1 &amp;lt;= &lt;i>a&lt;/i> &amp;lt; 10. The&#xA;     * magnitude is then represented as the integer part of &lt;i>a&lt;/i>,&#xA;     * as a single decimal digit, followed by '&lt;code>.&lt;/code>'&#xA;     * (&lt;code>'&amp;#92;u002E'&lt;/code>), followed by decimal digits&#xA;     * representing the fractional part of &lt;i>a&lt;/i>, followed by the&#xA;     * letter '&lt;code>E&lt;/code>' (&lt;code>'&amp;#92;u0045'&lt;/code>), followed&#xA;     * by a representation of &lt;i>n&lt;/i> as a decimal integer, as&#xA;     * produced by the method {@link Integer#toString(int)}.&#xA;     * &lt;/ul>&#xA;     * &lt;/ul>&#xA;     * How many digits must be printed for the fractional part of &#xA;     * &lt;i>m&lt;/i> or &lt;i>a&lt;/i>? There must be at least one digit to represent &#xA;     * the fractional part, and beyond that as many, but only as many, more &#xA;     * digits as are needed to uniquely distinguish the argument value from&#xA;     * adjacent values of type &lt;code>double&lt;/code>. That is, suppose that &#xA;     * &lt;i>x&lt;/i> is the exact mathematical value represented by the decimal &#xA;     * representation produced by this method for a finite nonzero argument &#xA;     * &lt;i>d&lt;/i>. Then &lt;i>d&lt;/i> must be the &lt;code>double&lt;/code> value nearest &#xA;     * to &lt;i>x&lt;/i>; or if two &lt;code>double&lt;/code> values are equally close &#xA;     * to &lt;i>x&lt;/i>, then &lt;i>d&lt;/i> must be one of them and the least&#xA;     * significant bit of the significand of &lt;i>d&lt;/i> must be &lt;code>0&lt;/code>.&#xA;     * &lt;p>&#xA;     * To create localized string representations of a floating-point&#xA;     * value, use subclasses of {@link java.text.NumberFormat}.&#xA;     *&#xA;     * @param   d   the &lt;code>double&lt;/code> to be converted.&#xA;     * @return a string representation of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0/@members.66"/>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toHexString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a hexadecimal string representation of the&#xA;     * &lt;code>double&lt;/code> argument. All characters mentioned below&#xA;     * are ASCII characters.&#xA;     *&#xA;     * &lt;ul>&#xA;     * &lt;li>If the argument is NaN, the result is the string&#xA;     *     &amp;quot;&lt;code>NaN&lt;/code>&amp;quot;.&#xA;     * &lt;li>Otherwise, the result is a string that represents the sign&#xA;     * and magnitude of the argument. If the sign is negative, the&#xA;     * first character of the result is '&lt;code>-&lt;/code>'&#xA;     * (&lt;code>'&amp;#92;u002D'&lt;/code>); if the sign is positive, no sign&#xA;     * character appears in the result. As for the magnitude &lt;i>m&lt;/i>:&#xA;     *&#xA;     * &lt;ul> &#xA;     * &lt;li>If &lt;i>m&lt;/i> is infinity, it is represented by the string&#xA;     * &lt;code>&quot;Infinity&quot;&lt;/code>; thus, positive infinity produces the&#xA;     * result &lt;code>&quot;Infinity&quot;&lt;/code> and negative infinity produces&#xA;     * the result &lt;code>&quot;-Infinity&quot;&lt;/code>.&#xA;     *&#xA;     * &lt;li>If &lt;i>m&lt;/i> is zero, it is represented by the string&#xA;     * &lt;code>&quot;0x0.0p0&quot;&lt;/code>; thus, negative zero produces the result&#xA;     * &lt;code>&quot;-0x0.0p0&quot;&lt;/code> and positive zero produces the result&#xA;     * &lt;code>&quot;0x0.0p0&quot;&lt;/code>.&#xA;     *&#xA;     * &lt;li>If &lt;i>m&lt;/i> is a &lt;code>double&lt;/code> value with a&#xA;     * normalized representation, substrings are used to represent the&#xA;     * significand and exponent fields.  The significand is&#xA;     * represented by the characters &lt;code>&amp;quot;0x1.&amp;quot;&lt;/code>&#xA;     * followed by a lowercase hexadecimal representation of the rest&#xA;     * of the significand as a fraction.  Trailing zeros in the&#xA;     * hexadecimal representation are removed unless all the digits&#xA;     * are zero, in which case a single zero is used. Next, the&#xA;     * exponent is represented by &lt;code>&amp;quot;p&amp;quot;&lt;/code> followed&#xA;     * by a decimal string of the unbiased exponent as if produced by&#xA;     * a call to {@link Integer#toString(int) Integer.toString} on the&#xA;     * exponent value.&#xA;     *&#xA;     * &lt;li>If &lt;i>m&lt;/i> is a &lt;code>double&lt;/code> value with a subnormal&#xA;     * representation, the significand is represented by the&#xA;     * characters &lt;code>&amp;quot;0x0.&amp;quot;&lt;/code> followed by a&#xA;     * hexadecimal representation of the rest of the significand as a&#xA;     * fraction.  Trailing zeros in the hexadecimal representation are&#xA;     * removed. Next, the exponent is represented by&#xA;     * &lt;code>&amp;quot;p-1022&amp;quot;&lt;/code>.  Note that there must be at&#xA;     * least one nonzero digit in a subnormal significand.&#xA;     *&#xA;     * &lt;/ul>&#xA;     * &#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;table border>&#xA;     * &lt;caption>&lt;h3>Examples&lt;/h3>&lt;/caption>&#xA;     * &lt;tr>&lt;th>Floating-point Value&lt;/th>&lt;th>Hexadecimal String&lt;/th>&#xA;     * &lt;tr>&lt;td>&lt;code>1.0&lt;/code>&lt;/td>&#x9;&lt;td>&lt;code>0x1.0p0&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>-1.0&lt;/code>&lt;/td>&#x9;&lt;td>&lt;code>-0x1.0p0&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>2.0&lt;/code>&lt;/td>&#x9;&lt;td>&lt;code>0x1.0p1&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>3.0&lt;/code>&lt;/td>&#x9;&lt;td>&lt;code>0x1.8p1&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>0.5&lt;/code>&lt;/td>&#x9;&lt;td>&lt;code>0x1.0p-1&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>0.25&lt;/code>&lt;/td>&#x9;&lt;td>&lt;code>0x1.0p-2&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>Double.MAX_VALUE&lt;/code>&lt;/td>&#xA;     *     &lt;td>&lt;code>0x1.fffffffffffffp1023&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>Minimum Normal Value&lt;/code>&lt;/td>&#xA;     *     &lt;td>&lt;code>0x1.0p-1022&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>Maximum Subnormal Value&lt;/code>&lt;/td>&#xA;     *     &lt;td>&lt;code>0x0.fffffffffffffp-1022&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>Double.MIN_VALUE&lt;/code>&lt;/td>&#xA;     *     &lt;td>&lt;code>0x0.0000000000001p-1022&lt;/code>&lt;/td>&#xA;     * &lt;/table>&#xA;     * @param   d   the &lt;code>double&lt;/code> to be converted.&#xA;     * @return a hex string representation of the argument.&#xA;     * @since 1.5&#xA;     * @author Joseph D. Darcy&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <comments>/*&#xA;&#x9; * Modeled after the &quot;a&quot; conversion specifier in C99, section&#xA;&#x9; * 7.19.6.1; however, the output of this method is more&#xA;&#x9; * tightly specified.&#xA;&#x9; */</comments>
        <statement xsi:type="statements:Return">
          <comments>// For infinity and NaN, use the decimal output.</comments>
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
            </next>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0/@members.10"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
          </child>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="answer">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <comments>// Initialized to maximum size of output.</comments>
                  <target xsi:type="classifiers:Class" href="StringBuffer.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="StringBuffer.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="24"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.0/@variable">
                <comments>// value is negative,</comments>
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="references:StringReference" value="-"/>
                </next>
              </expression>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0/@members.8"/>
                  <arguments xsi:type="literals:DecimalDoubleLiteral" decimalValue="1.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
              </children>
              <children xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalDoubleLiteral" decimalValue="1.0"/>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.0/@variable">
              <comments>// so append sign info</comments>
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:StringReference" value="0x"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Math.class.xmi#//@classifiers.0/@members.32"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="Math.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="references:StringReference" value="0.0p0"/>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
              <children xsi:type="literals:DecimalDoubleLiteral"/>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="subnormal">
                  <typeReference xsi:type="types:Boolean"/>
                  <initialValue xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
                      <children xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="../../sun/misc/DoubleConsts.class.xmi#//@classifiers.0/@members.5"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="../../sun/misc/DoubleConsts.class.xmi#//@classifiers.0"/>
                      </children>
                      <relationOperators xsi:type="operators:LessThan"/>
                    </expression>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="signifBits">
                  <typeReference xsi:type="types:Long">
                    <comments>// Isolate significand bits and OR in a high-order bit</comments>
                    <comments>// so that the string representation has a known</comments>
                    <comments>// length.</comments>
                  </typeReference>
                  <initialValue xsi:type="expressions:InclusiveOrExpression">
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:AndExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0">
                          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
                          </next>
                        </children>
                        <children xsi:type="references:IdentifierReference">
                          <next xsi:type="references:IdentifierReference">
                            <target xsi:type="members:Field" href="../../sun/misc/DoubleConsts.class.xmi#//@classifiers.0/@members.13"/>
                          </next>
                          <target xsi:type="classifiers:Class" href="../../sun/misc/DoubleConsts.class.xmi#//@classifiers.0"/>
                        </children>
                      </expression>
                    </children>
                    <children xsi:type="literals:HexLongLiteral" hexValue="1152921504606846976"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.0/@variable">
                  <comments>// Subnormal values have a 0 implicit bit; normal</comments>
                  <comments>// values have a a 1 implicit bit.</comments>
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="expressions:ConditionalExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.4/@elseStatement/@statements.0/@variable"/>
                      <expressionIf xsi:type="references:StringReference" value="0."/>
                      <expressionElse xsi:type="references:StringReference" value="1."/>
                    </arguments>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="signif">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <comments>// Isolate the low-order 13 digits of the hex</comments>
                      <comments>// representation.  If all the digits are zero,</comments>
                      <comments>// replace with a single 0; otherwise, remove all</comments>
                      <comments>// trailing zeros.</comments>
                      <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <initialValue xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.56"/>
                        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                      </next>
                      <target xsi:type="members:ClassMethod" href="Long.class.xmi#//@classifiers.0/@members.7"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.4/@elseStatement/@statements.1/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Long.class.xmi#//@classifiers.0"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="expressions:ConditionalExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.4/@elseStatement/@statements.3/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.33"/>
                          <arguments xsi:type="references:StringReference" value="0000000000000"/>
                        </next>
                      </child>
                      <expressionIf xsi:type="references:StringReference" value="0">
                        <comments>// 13 zeros</comments>
                      </expressionIf>
                      <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.4/@elseStatement/@statements.3/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.62"/>
                          <arguments xsi:type="references:StringReference" value="0{1,12}$"/>
                          <arguments xsi:type="references:StringReference" value=""/>
                        </next>
                      </expressionElse>
                    </arguments>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.0/@variable">
                  <comments>// If the value is subnormal, use the E_min exponent</comments>
                  <comments>// value for double; otherwise, extract and report d's</comments>
                  <comments>// exponent (the representation of a subnormal uses</comments>
                  <comments>// E_min -1).</comments>
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:StringReference" value="p"/>
                      <children xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:ConditionalExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.4/@elseStatement/@statements.0/@variable"/>
                          <expressionIf xsi:type="references:IdentifierReference">
                            <next xsi:type="references:IdentifierReference">
                              <target xsi:type="members:Field" href="../../sun/misc/DoubleConsts.class.xmi#//@classifiers.0/@members.8"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="../../sun/misc/DoubleConsts.class.xmi#//@classifiers.0"/>
                          </expressionIf>
                          <expressionElse xsi:type="references:IdentifierReference">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0/@members.4"/>
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
                          </expressionElse>
                        </expression>
                      </children>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                  </next>
                </expression>
              </statements>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@elseStatement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
              </next>
            </returnValue>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NumberFormatException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>Double&lt;/code> object holding the&#xA;     * &lt;code>double&lt;/code> value represented by the argument string&#xA;     * &lt;code>s&lt;/code>.&#xA;     * &#xA;     * &lt;p>If &lt;code>s&lt;/code> is &lt;code>null&lt;/code>, then a &#xA;     * &lt;code>NullPointerException&lt;/code> is thrown.&#xA;     *&#xA;     * &lt;p>Leading and trailing whitespace characters in &lt;code>s&lt;/code>&#xA;     * are ignored.  Whitespace is removed as if by the {@link&#xA;     * String#trim} method; that is, both ASCII space and control&#xA;     * characters are removed. The rest of &lt;code>s&lt;/code> should&#xA;     * constitute a &lt;i>FloatValue&lt;/i> as described by the lexical&#xA;     * syntax rules:&#xA;     *&#xA;     * &lt;blockquote>&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;i>FloatValue:&lt;/i>&#xA;     * &lt;dd>&lt;i>Sign&lt;sub>opt&lt;/sub>&lt;/i> &lt;code>NaN&lt;/code>&#xA;     * &lt;dd>&lt;i>Sign&lt;sub>opt&lt;/sub>&lt;/i> &lt;code>Infinity&lt;/code>&#xA;     * &lt;dd>&lt;i>Sign&lt;sub>opt&lt;/sub> FloatingPointLiteral&lt;/i>&#xA;     * &lt;dd>&lt;i>Sign&lt;sub>opt&lt;/sub> HexFloatingPointLiteral&lt;/i>&#xA;     * &lt;dd>&lt;i>SignedInteger&lt;/i>&#xA;     * &lt;/dl>&#xA;     *&#xA;     * &lt;p>&#xA;     *&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;i>HexFloatingPointLiteral&lt;/i>:&#xA;     * &lt;dd> &lt;i>HexSignificand BinaryExponent FloatTypeSuffix&lt;sub>opt&lt;/sub>&lt;/i>&#xA;     * &lt;/dl>&#xA;     *&#xA;     * &lt;p>&#xA;     *&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;i>HexSignificand:&lt;/i>&#xA;     * &lt;dd>&lt;i>HexNumeral&lt;/i>&#xA;     * &lt;dd>&lt;i>HexNumeral&lt;/i> &lt;code>.&lt;/code>&#xA;     * &lt;dd>&lt;code>0x&lt;/code> &lt;i>HexDigits&lt;sub>opt&lt;/sub> &#xA;     *     &lt;/i>&lt;code>.&lt;/code>&lt;i> HexDigits&lt;/i>&#xA;     * &lt;dd>&lt;code>0X&lt;/code>&lt;i> HexDigits&lt;sub>opt&lt;/sub> &#xA;     *     &lt;/i>&lt;code>.&lt;/code> &lt;i>HexDigits&lt;/i>&#xA;     * &lt;/dl>&#xA;     *&#xA;     * &lt;p>&#xA;     *&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;i>BinaryExponent:&lt;/i>&#xA;     * &lt;dd>&lt;i>BinaryExponentIndicator SignedInteger&lt;/i>&#xA;     * &lt;/dl>&#xA;     *&#xA;     * &lt;p>&#xA;     *&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;i>BinaryExponentIndicator:&lt;/i>&#xA;     * &lt;dd>&lt;code>p&lt;/code>&#xA;     * &lt;dd>&lt;code>P&lt;/code>&#xA;     * &lt;/dl>&#xA;     *&#xA;     * &lt;/blockquote>&#xA;     *&#xA;     * where &lt;i>Sign&lt;/i>, &lt;i>FloatingPointLiteral&lt;/i>,&#xA;     * &lt;i>HexNumeral&lt;/i>, &lt;i>HexDigits&lt;/i>, &lt;i>SignedInteger&lt;/i> and&#xA;     * &lt;i>FloatTypeSuffix&lt;/i> are as defined in the lexical structure&#xA;     * sections of the of the &lt;a&#xA;     * href=&quot;http://java.sun.com/docs/books/jls/html/&quot;>Java Language&#xA;     * Specification&lt;/a>. If &lt;code>s&lt;/code> does not have the form of&#xA;     * a &lt;i>FloatValue&lt;/i>, then a &lt;code>NumberFormatException&lt;/code>&#xA;     * is thrown. Otherwise, &lt;code>s&lt;/code> is regarded as&#xA;     * representing an exact decimal value in the usual&#xA;     * &amp;quot;computerized scientific notation&amp;quot; or as an exact&#xA;     * hexadecimal value; this exact numerical value is then&#xA;     * conceptually converted to an &amp;quot;infinitely precise&amp;quot;&#xA;     * binary value that is then rounded to type &lt;code>double&lt;/code>&#xA;     * by the usual round-to-nearest rule of IEEE 754 floating-point&#xA;     * arithmetic, which includes preserving the sign of a zero&#xA;     * value. Finally, a &lt;code>Double&lt;/code> object representing this&#xA;     * &lt;code>double&lt;/code> value is returned.&#xA;     *&#xA;     * &lt;p> To interpret localized string representations of a&#xA;     * floating-point value, use subclasses of {@link&#xA;     * java.text.NumberFormat}.&#xA;     *&#xA;     * &lt;p>Note that trailing format specifiers, specifiers that&#xA;     * determine the type of a floating-point literal&#xA;     * (&lt;code>1.0f&lt;/code> is a &lt;code>float&lt;/code> value;&#xA;     * &lt;code>1.0d&lt;/code> is a &lt;code>double&lt;/code> value), do&#xA;     * &lt;em>not&lt;/em> influence the results of this method.  In other&#xA;     * words, the numerical value of the input string is converted&#xA;     * directly to the target floating-point type.  The two-step&#xA;     * sequence of conversions, string to &lt;code>float&lt;/code> followed&#xA;     * by &lt;code>float&lt;/code> to &lt;code>double&lt;/code>, is &lt;em>not&lt;/em>&#xA;     * equivalent to converting a string directly to&#xA;     * &lt;code>double&lt;/code>. For example, the &lt;code>float&lt;/code>&#xA;     * literal &lt;code>0.1f&lt;/code> is equal to the &lt;code>double&lt;/code>&#xA;     * value &lt;code>0.10000000149011612&lt;/code>; the &lt;code>float&lt;/code>&#xA;     * literal &lt;code>0.1f&lt;/code> represents a different numerical&#xA;     * value than the &lt;code>double&lt;/code> literal&#xA;     * &lt;code>0.1&lt;/code>. (The numerical value 0.1 cannot be exactly&#xA;     * represented in a binary floating-point number.)&#xA;     *&#xA;     * &lt;p>To avoid calling this method on a invalid string and having&#xA;     * a &lt;code>NumberFormatException&lt;/code> be thrown, the regular&#xA;     * expression below can be used to screen the input string:&#xA;     *&#xA;     * &lt;code>&#xA;     * &lt;pre>&#xA;     *&#x9;final String Digits&#x9;= &quot;(\\p{Digit}+)&quot;;&#xA;     *  final String HexDigits  = &quot;(\\p{XDigit}+)&quot;;&#xA;     *&#x9;// an exponent is 'e' or 'E' followed by an optionally &#xA;     *&#x9;// signed decimal integer.&#xA;     *&#x9;final String Exp&#x9;= &quot;[eE][+-]?&quot;+Digits;&#xA;     *&#x9;final String fpRegex&#x9;=&#xA;     *&#x9;    (&quot;[\\x00-\\x20]*&quot;+&#x9;// Optional leading &amp;quot;whitespace&amp;quot;&#xA;     *&#x9;     &quot;[+-]?(&quot; +&#x9;// Optional sign character&#xA;     *&#x9;     &quot;NaN|&quot; +&#x9;&#x9;// &quot;NaN&quot; string&#xA;     *&#x9;     &quot;Infinity|&quot; +&#x9;// &quot;Infinity&quot; string&#xA;     *&#xA;     *&#x9;     // A decimal floating-point string representing a finite positive&#xA;     *&#x9;     // number without a leading sign has at most five basic pieces:&#xA;     *&#x9;     // Digits . Digits ExponentPart FloatTypeSuffix&#xA;     *&#x9;     // &#xA;     *&#x9;     // Since this method allows integer-only strings as input&#xA;     *&#x9;     // in addition to strings of floating-point literals, the&#xA;     *&#x9;     // two sub-patterns below are simplifications of the grammar&#xA;     *&#x9;     // productions from the Java Language Specification, 2nd &#xA;     *&#x9;     // edition, section 3.10.2.&#xA;     *&#xA;     *&#x9;     // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt&#xA;     *&#x9;     &quot;(((&quot;+Digits+&quot;(\\.)?(&quot;+Digits+&quot;?)(&quot;+Exp+&quot;)?)|&quot;+&#xA;     *&#xA;     *&#x9;     // . Digits ExponentPart_opt FloatTypeSuffix_opt&#xA;     *&#x9;     &quot;(\\.(&quot;+Digits+&quot;)(&quot;+Exp+&quot;)?)|&quot;+&#xA;     *&#xA;     *       // Hexadecimal strings&#xA;     *       &quot;((&quot; +&#xA;     *        // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt&#xA;     *        &quot;(0[xX]&quot; + HexDigits + &quot;(\\.)?)|&quot; +&#xA;     *&#xA;     *        // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt&#xA;     *        &quot;(0[xX]&quot; + HexDigits + &quot;?(\\.)&quot; + HexDigits + &quot;)&quot; +&#xA;     *&#xA;     *        &quot;)[pP][+-]?&quot; + Digits + &quot;))&quot; +&#xA;     *&#x9;     &quot;[fFdD]?))&quot; +&#xA;     *&#x9;     &quot;[\\x00-\\x20]*&quot;);// Optional trailing &amp;quot;whitespace&amp;quot;&#xA;     *&#x9;    &#xA;     *  if (Pattern.matches(fpRegex, myString))&#xA;     *&#x9;    Double.valueOf(myString); // Will not throw NumberFormatException&#xA;     *&#x9;else {&#xA;     *&#x9;    // Perform suitable alternative action&#xA;     *&#x9;}&#xA;     * &lt;/pre>&#xA;     * &lt;/code>&#xA;     *&#xA;     * @param      s   the string to be parsed.&#xA;     * @return     a &lt;code>Double&lt;/code> object holding the value&#xA;     *             represented by the &lt;code>String&lt;/code> argument.&#xA;     * @exception  NumberFormatException  if the string does not contain a&#xA;     *               parsable number.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0/@members.70"/>
              </next>
              <target xsi:type="members:ClassMethod" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0/@members.69"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>Double&lt;/tt> instance representing the specified&#xA;     * &lt;tt>double&lt;/tt> value.&#xA;     * If a new &lt;tt>Double&lt;/tt> instance is not required, this method&#xA;     * should generally be used in preference to the constructor&#xA;     * {@link #Double(double)}, as this method is likely to yield&#xA;     * significantly better space and time performance by caching&#xA;     * frequently requested values.&#xA;     *&#xA;     * @param  d a double value.&#xA;     * @return a &lt;tt>Double&lt;/tt> instance representing &lt;tt>d&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="parseDouble">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NumberFormatException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a new &lt;code>double&lt;/code> initialized to the value&#xA;     * represented by the specified &lt;code>String&lt;/code>, as performed&#xA;     * by the &lt;code>valueOf&lt;/code> method of class&#xA;     * &lt;code>Double&lt;/code>.&#xA;     *&#xA;     * @param      s   the string to be parsed.&#xA;     * @return the &lt;code>double&lt;/code> value represented by the string&#xA;     *         argument.&#xA;     * @exception NumberFormatException if the string does not contain&#xA;     *            a parsable &lt;code>double&lt;/code>.&#xA;     * @see        java.lang.Double#valueOf(String)&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0/@members.70"/>
            </next>
            <target xsi:type="members:ClassMethod" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0/@members.69"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isNaN">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if the specified number is a&#xA;     * Not-a-Number (NaN) value, &lt;code>false&lt;/code> otherwise.&#xA;     *&#xA;     * @param   v   the value to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the value of the argument is NaN;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isInfinite">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if the specified number is infinitely&#xA;     * large in magnitude, &lt;code>false&lt;/code> otherwise.&#xA;     *&#xA;     * @param   v   the value to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the value of the argument is positive&#xA;     *          infinity or negative infinity; &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </expression>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="value">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The value of the Double.&#xA;     *&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="Double">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a newly allocated &lt;code>Double&lt;/code> object that&#xA;     * represents the primitive &lt;code>double&lt;/code> argument.&#xA;     *&#xA;     * @param   value   the value to be represented by the &lt;code>Double&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Double">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.9">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.25"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          </arguments>
          <callTarget xsi:type="literals:This">
            <comments>// REMIND: this is inefficient</comments>
          </callTarget>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NumberFormatException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a newly allocated &lt;code>Double&lt;/code> object that&#xA;     * represents the floating-point value of type &lt;code>double&lt;/code>&#xA;     * represented by the string. The string is converted to a&#xA;     * &lt;code>double&lt;/code> value as if by the &lt;code>valueOf&lt;/code> method.&#xA;     *&#xA;     * @param      s   a string to be converted to a &lt;code>Double&lt;/code>.&#xA;     * @exception  NumberFormatException  if the string does not contain a&#xA;     *               parsable number.&#xA;     * @see        java.lang.Double#valueOf(java.lang.String)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="isNaN">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if this &lt;code>Double&lt;/code> value is&#xA;     * a Not-a-Number (NaN), &lt;code>false&lt;/code> otherwise.&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if the value represented by this object is&#xA;     *          NaN; &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isInfinite">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if this &lt;code>Double&lt;/code> value is&#xA;     * infinitely large in magnitude, &lt;code>false&lt;/code> otherwise.&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if the value represented by this object is&#xA;     *          positive infinity or negative infinity;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string representation of this &lt;code>Double&lt;/code> object.&#xA;     * The primitive &lt;code>double&lt;/code> value represented by this&#xA;     * object is converted to a string exactly as if by the method&#xA;     * &lt;code>toString&lt;/code> of one argument.&#xA;     *&#xA;     * @return  a &lt;code>String&lt;/code> representation of this object.&#xA;     * @see java.lang.Double#toString(double)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.86"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
          </next>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="byteValue">
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of this &lt;code>Double&lt;/code> as a &lt;code>byte&lt;/code> (by&#xA;     * casting to a &lt;code>byte&lt;/code>).&#xA;     *&#xA;     * @return  the &lt;code>double&lt;/code> value represented by this object&#xA;     *          converted to type &lt;code>byte&lt;/code>&#xA;     * @since JDK1.1 &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Byte"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="shortValue">
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of this &lt;code>Double&lt;/code> as a&#xA;     * &lt;code>short&lt;/code> (by casting to a &lt;code>short&lt;/code>).&#xA;     *&#xA;     * @return  the &lt;code>double&lt;/code> value represented by this object&#xA;     *          converted to type &lt;code>short&lt;/code>&#xA;     * @since JDK1.1 &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Short"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="intValue">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of this &lt;code>Double&lt;/code> as an&#xA;     * &lt;code>int&lt;/code> (by casting to type &lt;code>int&lt;/code>).&#xA;     *&#xA;     * @return  the &lt;code>double&lt;/code> value represented by this object&#xA;     *          converted to type &lt;code>int&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Int"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="longValue">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of this &lt;code>Double&lt;/code> as a&#xA;     * &lt;code>long&lt;/code> (by casting to type &lt;code>long&lt;/code>).&#xA;     *&#xA;     * @return  the &lt;code>double&lt;/code> value represented by this object&#xA;     *          converted to type &lt;code>long&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Long"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="floatValue">
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>float&lt;/code> value of this&#xA;     * &lt;code>Double&lt;/code> object.&#xA;     *&#xA;     * @return  the &lt;code>double&lt;/code> value represented by this object&#xA;     *          converted to type &lt;code>float&lt;/code>&#xA;     * @since JDK1.0 &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Float"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="doubleValue">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>double&lt;/code> value of this&#xA;     * &lt;code>Double&lt;/code> object.&#xA;     *&#xA;     * @return the &lt;code>double&lt;/code> value represented by this object&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Double"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a hash code for this &lt;code>Double&lt;/code> object. The&#xA;     * result is the exclusive OR of the two halves of the&#xA;     * &lt;code>long&lt;/code> integer bit representation, exactly as&#xA;     * produced by the method {@link #doubleToLongBits(double)}, of&#xA;     * the primitive &lt;code>double&lt;/code> value represented by this&#xA;     * &lt;code>Double&lt;/code> object. That is, the hash code is the value&#xA;     * of the expression:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * (int)(v^(v&amp;gt;&amp;gt;&amp;gt;32))&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * where &lt;code>v&lt;/code> is defined by: &#xA;     * &lt;blockquote>&lt;pre>&#xA;     * long v = Double.doubleToLongBits(this.doubleValue());&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @return  a &lt;code>hash code&lt;/code> value for this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bits">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Int"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ExclusiveOrExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="32"/>
                  <shiftOperators xsi:type="operators:UnsignedRightShift"/>
                </expression>
              </children>
            </expression>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares this object against the specified object.  The result&#xA;     * is &lt;code>true&lt;/code> if and only if the argument is not&#xA;     * &lt;code>null&lt;/code> and is a &lt;code>Double&lt;/code> object that&#xA;     * represents a &lt;code>double&lt;/code> that has the same value as the&#xA;     * &lt;code>double&lt;/code> represented by this object. For this&#xA;     * purpose, two &lt;code>double&lt;/code> values are considered to be&#xA;     * the same if and only if the method {@link&#xA;     * #doubleToLongBits(double)} returns the identical&#xA;     * &lt;code>long&lt;/code> value when applied to each.&#xA;     * &lt;p>&#xA;     * Note that in most cases, for two instances of class&#xA;     * &lt;code>Double&lt;/code>, &lt;code>d1&lt;/code> and &lt;code>d2&lt;/code>, the&#xA;     * value of &lt;code>d1.equals(d2)&lt;/code> is &lt;code>true&lt;/code> if and&#xA;     * only if&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *   d1.doubleValue()&amp;nbsp;== d2.doubleValue()&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;p>&#xA;     * also has the value &lt;code>true&lt;/code>. However, there are two&#xA;     * exceptions:&#xA;     * &lt;ul>&#xA;     * &lt;li>If &lt;code>d1&lt;/code> and &lt;code>d2&lt;/code> both represent&#xA;     *     &lt;code>Double.NaN&lt;/code>, then the &lt;code>equals&lt;/code> method&#xA;     *     returns &lt;code>true&lt;/code>, even though&#xA;     *     &lt;code>Double.NaN==Double.NaN&lt;/code> has the value&#xA;     *     &lt;code>false&lt;/code>.&#xA;     * &lt;li>If &lt;code>d1&lt;/code> represents &lt;code>+0.0&lt;/code> while&#xA;     *     &lt;code>d2&lt;/code> represents &lt;code>-0.0&lt;/code>, or vice versa,&#xA;     *     the &lt;code>equal&lt;/code> test has the value &lt;code>false&lt;/code>,&#xA;     *     even though &lt;code>+0.0==-0.0&lt;/code> has the value &lt;code>true&lt;/code>.&#xA;     * &lt;/ul>&#xA;     * This definition allows hash tables to operate properly.&#xA;     * @param   obj   the object to compare with.&#xA;     * @return  &lt;code>true&lt;/code> if the objects are the same;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see java.lang.Double#doubleToLongBits(double)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
                <arguments xsi:type="expressions:NestedExpression">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
                  <expression xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0"/>
                    </typeReference>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
                  </expression>
                </arguments>
              </children>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
              </children>
            </expression>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="doubleToLongBits">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a representation of the specified floating-point value&#xA;     * according to the IEEE 754 floating-point &quot;double&#xA;     * format&quot; bit layout.&#xA;     * &lt;p>&#xA;     * Bit 63 (the bit that is selected by the mask &#xA;     * &lt;code>0x8000000000000000L&lt;/code>) represents the sign of the &#xA;     * floating-point number. Bits &#xA;     * 62-52 (the bits that are selected by the mask &#xA;     * &lt;code>0x7ff0000000000000L&lt;/code>) represent the exponent. Bits 51-0 &#xA;     * (the bits that are selected by the mask &#xA;     * &lt;code>0x000fffffffffffffL&lt;/code>) represent the significand &#xA;     * (sometimes called the mantissa) of the floating-point number. &#xA;     * &lt;p>&#xA;     * If the argument is positive infinity, the result is&#xA;     * &lt;code>0x7ff0000000000000L&lt;/code>.&#xA;     * &lt;p>&#xA;     * If the argument is negative infinity, the result is&#xA;     * &lt;code>0xfff0000000000000L&lt;/code>.&#xA;     * &lt;p>&#xA;     * If the argument is NaN, the result is &#xA;     * &lt;code>0x7ff8000000000000L&lt;/code>. &#xA;     * &lt;p>&#xA;     * In all cases, the result is a &lt;code>long&lt;/code> integer that, when &#xA;     * given to the {@link #longBitsToDouble(long)} method, will produce a &#xA;     * floating-point value the same as the argument to &#xA;     * &lt;code>doubleToLongBits&lt;/code> (except all NaN values are&#xA;     * collapsed to a single &amp;quot;canonical&amp;quot; NaN value).&#xA;     *&#xA;     * @param   value   a &lt;code>double&lt;/code> precision floating-point number.&#xA;     * @return the bits that represent the floating-point number.  &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="doubleToRawLongBits">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a representation of the specified floating-point value&#xA;     * according to the IEEE 754 floating-point &quot;double&#xA;     * format&quot; bit layout, preserving Not-a-Number (NaN) values.&#xA;     * &lt;p>&#xA;     * Bit 63 (the bit that is selected by the mask &#xA;     * &lt;code>0x8000000000000000L&lt;/code>) represents the sign of the &#xA;     * floating-point number. Bits &#xA;     * 62-52 (the bits that are selected by the mask &#xA;     * &lt;code>0x7ff0000000000000L&lt;/code>) represent the exponent. Bits 51-0 &#xA;     * (the bits that are selected by the mask &#xA;     * &lt;code>0x000fffffffffffffL&lt;/code>) represent the significand &#xA;     * (sometimes called the mantissa) of the floating-point number. &#xA;     * &lt;p>&#xA;     * If the argument is positive infinity, the result is&#xA;     * &lt;code>0x7ff0000000000000L&lt;/code>.&#xA;     * &lt;p>&#xA;     * If the argument is negative infinity, the result is&#xA;     * &lt;code>0xfff0000000000000L&lt;/code>.&#xA;     * &lt;p>&#xA;     * If the argument is NaN, the result is the &lt;code>long&lt;/code>&#xA;     * integer representing the actual NaN value.  Unlike the&#xA;     * &lt;code>doubleToLongBits&lt;/code> method,&#xA;     * &lt;code>doubleToRawLongBits&lt;/code> does not collapse all the bit&#xA;     * patterns encoding a NaN to a single &amp;quot;canonical&amp;quot; NaN&#xA;     * value.&#xA;     * &lt;p>&#xA;     * In all cases, the result is a &lt;code>long&lt;/code> integer that,&#xA;     * when given to the {@link #longBitsToDouble(long)} method, will&#xA;     * produce a floating-point value the same as the argument to&#xA;     * &lt;code>doubleToRawLongBits&lt;/code>.&#xA;     *&#xA;     * @param   value   a &lt;code>double&lt;/code> precision floating-point number.&#xA;     * @return the bits that represent the floating-point number.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="longBitsToDouble">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bits">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>double&lt;/code> value corresponding to a given&#xA;     * bit representation.&#xA;     * The argument is considered to be a representation of a&#xA;     * floating-point value according to the IEEE 754 floating-point&#xA;     * &quot;double format&quot; bit layout.&#xA;     * &lt;p>&#xA;     * If the argument is &lt;code>0x7ff0000000000000L&lt;/code>, the result &#xA;     * is positive infinity. &#xA;     * &lt;p>&#xA;     * If the argument is &lt;code>0xfff0000000000000L&lt;/code>, the result &#xA;     * is negative infinity. &#xA;     * &lt;p>&#xA;     * If the argument is any value in the range&#xA;     * &lt;code>0x7ff0000000000001L&lt;/code> through&#xA;     * &lt;code>0x7fffffffffffffffL&lt;/code> or in the range&#xA;     * &lt;code>0xfff0000000000001L&lt;/code> through&#xA;     * &lt;code>0xffffffffffffffffL&lt;/code>, the result is a NaN.  No IEEE&#xA;     * 754 floating-point operation provided by Java can distinguish&#xA;     * between two NaN values of the same type with different bit&#xA;     * patterns.  Distinct values of NaN are only distinguishable by&#xA;     * use of the &lt;code>Double.doubleToRawLongBits&lt;/code> method.&#xA;     * &lt;p>&#xA;     * In all other cases, let &lt;i>s&lt;/i>, &lt;i>e&lt;/i>, and &lt;i>m&lt;/i> be three &#xA;     * values that can be computed from the argument: &#xA;     * &lt;blockquote>&lt;pre>&#xA;     * int s = ((bits &amp;gt;&amp;gt; 63) == 0) ? 1 : -1;&#xA;     * int e = (int)((bits &amp;gt;&amp;gt; 52) &amp; 0x7ffL);&#xA;     * long m = (e == 0) ?&#xA;     *                 (bits &amp; 0xfffffffffffffL) &amp;lt;&amp;lt; 1 :&#xA;     *                 (bits &amp; 0xfffffffffffffL) | 0x10000000000000L;&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * Then the floating-point result equals the value of the mathematical &#xA;     * expression &lt;i>s&lt;/i>&amp;middot;&lt;i>m&lt;/i>&amp;middot;2&lt;sup>&lt;i>e&lt;/i>-1075&lt;/sup>.&#xA;     *&lt;p>&#xA;     * Note that this method may not be able to return a&#xA;     * &lt;code>double&lt;/code> NaN with exactly same bit pattern as the&#xA;     * &lt;code>long&lt;/code> argument.  IEEE 754 distinguishes between two&#xA;     * kinds of NaNs, quiet NaNs and &lt;i>signaling NaNs&lt;/i>.  The&#xA;     * differences between the two kinds of NaN are generally not&#xA;     * visible in Java.  Arithmetic operations on signaling NaNs turn&#xA;     * them into quiet NaNs with a different, but often similar, bit&#xA;     * pattern.  However, on some processors merely copying a&#xA;     * signaling NaN also performs that conversion.  In particular,&#xA;     * copying a signaling NaN to return it to the calling method&#xA;     * may perform this conversion.  So &lt;code>longBitsToDouble&lt;/code>&#xA;     * may not be able to return a &lt;code>double&lt;/code> with a&#xA;     * signaling NaN bit pattern.  Consequently, for some&#xA;     * &lt;code>long&lt;/code> values,&#xA;     * &lt;code>doubleToRawLongBits(longBitsToDouble(start))&lt;/code> may&#xA;     * &lt;i>not&lt;/i> equal &lt;code>start&lt;/code>.  Moreover, which&#xA;     * particular bit patterns represent signaling NaNs is platform&#xA;     * dependent; although all NaN bit patterns, quiet or signaling,&#xA;     * must be in the NaN range identified above.&#xA;     *&#xA;     * @param   bits   any &lt;code>long&lt;/code> integer.&#xA;     * @return  the &lt;code>double&lt;/code> floating-point value with the same&#xA;     *          bit pattern.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="anotherDouble">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares two &lt;code>Double&lt;/code> objects numerically.  There&#xA;     * are two ways in which comparisons performed by this method&#xA;     * differ from those performed by the Java language numerical&#xA;     * comparison operators (&lt;code>&amp;lt;, &amp;lt;=, ==, &amp;gt;= &amp;gt;&lt;/code>)&#xA;     * when applied to primitive &lt;code>double&lt;/code> values:&#xA;     * &lt;ul>&lt;li>&#xA;     *&#x9;&#x9;&lt;code>Double.NaN&lt;/code> is considered by this method&#xA;     *&#x9;&#x9;to be equal to itself and greater than all other&#xA;     *&#x9;&#x9;&lt;code>double&lt;/code> values (including&#xA;     *&#x9;&#x9;&lt;code>Double.POSITIVE_INFINITY&lt;/code>).&#xA;     * &lt;li>&#xA;     *&#x9;&#x9;&lt;code>0.0d&lt;/code> is considered by this method to be greater&#xA;     *&#x9;&#x9;than &lt;code>-0.0d&lt;/code>.&#xA;     * &lt;/ul>&#xA;     * This ensures that the &lt;i>natural ordering&lt;/i> of&#xA;     * &lt;tt>Double&lt;/tt> objects imposed by this method is &lt;i>consistent&#xA;     * with equals&lt;/i>.&#xA;     *&#xA;     * @param   anotherDouble   the &lt;code>Double&lt;/code> to be compared.&#xA;     * @return  the value &lt;code>0&lt;/code> if &lt;code>anotherDouble&lt;/code> is&#xA;     *&#x9;&#x9;numerically equal to this &lt;code>Double&lt;/code>; a value&#xA;     *&#x9;&#x9;less than &lt;code>0&lt;/code> if this &lt;code>Double&lt;/code>&#xA;     *&#x9;&#x9;is numerically less than &lt;code>anotherDouble&lt;/code>;&#xA;     *&#x9;&#x9;and a value greater than &lt;code>0&lt;/code> if this&#xA;     *&#x9;&#x9;&lt;code>Double&lt;/code> is numerically greater than&#xA;     *&#x9;&#x9;&lt;code>anotherDouble&lt;/code>.&#xA;     *&#x9;&#x9;&#xA;     * @since   1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.32">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compare">
      <comments>// (0.0, -0.0) or (NaN, !NaN)</comments>
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d1">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d2">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares the two specified &lt;code>double&lt;/code> values. The sign&#xA;     * of the integer value returned is the same as that of the&#xA;     * integer that would be returned by the call:&#xA;     * &lt;pre>&#xA;     *    new Double(d1).compareTo(new Double(d2))&#xA;     * &lt;/pre>&#xA;     *&#xA;     * @param   d1        the first &lt;code>double&lt;/code> to compare&#xA;     * @param   d2        the second &lt;code>double&lt;/code> to compare&#xA;     * @return  the value &lt;code>0&lt;/code> if &lt;code>d1&lt;/code> is&#xA;     *&#x9;&#x9;numerically equal to &lt;code>d2&lt;/code>; a value less than&#xA;     *          &lt;code>0&lt;/code> if &lt;code>d1&lt;/code> is numerically less than&#xA;     *&#x9;&#x9;&lt;code>d2&lt;/code>; and a value greater than &lt;code>0&lt;/code>&#xA;     *&#x9;&#x9;if &lt;code>d1&lt;/code> is numerically greater than&#xA;     *&#x9;&#x9;&lt;code>d2&lt;/code>.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.1"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Neither val is NaN, thisVal is smaller</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="thisBits">
          <typeReference xsi:type="types:Long">
            <comments>// Neither val is NaN, thisVal is larger</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="anotherBits">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.1"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.3/@variable"/>
            </child>
            <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <expressionElse xsi:type="expressions:NestedExpression">
              <comments>// Values are equal</comments>
              <expression xsi:type="expressions:ConditionalExpression">
                <child xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.2/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.3/@variable"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </child>
                <expressionIf xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Subtraction"/>
                  <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </expressionIf>
                <expressionElse xsi:type="literals:DecimalIntegerLiteral" decimalValue="1">
                  <comments>// (-0.0, 0.0) or (!NaN, NaN)</comments>
                </expressionElse>
              </expression>
            </expressionElse>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="9172774392245257468"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** use serialVersionUID from JDK 1.0.2 for interoperability */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>Double&lt;/code> class wraps a value of the primitive type&#xA; * &lt;code>double&lt;/code> in an object. An object of type&#xA; * &lt;code>Double&lt;/code> contains a single field whose type is&#xA; * &lt;code>double&lt;/code>.&#xA; * &lt;p>&#xA; * In addition, this class provides several methods for converting a&#xA; * &lt;code>double&lt;/code> to a &lt;code>String&lt;/code> and a&#xA; * &lt;code>String&lt;/code> to a &lt;code>double&lt;/code>, as well as other&#xA; * constants and methods useful when dealing with a&#xA; * &lt;code>double&lt;/code>.&#xA; *&#xA; * @author  Lee Boynton&#xA; * @author  Arthur van Hoff&#xA; * @author  Joseph D. Darcy&#xA; * @version 1.94, 05/11/04&#xA; * @since JDK1.0&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Final"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="Comparable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="Number.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
