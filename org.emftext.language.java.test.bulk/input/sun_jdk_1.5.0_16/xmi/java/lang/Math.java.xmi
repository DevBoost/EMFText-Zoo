<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="Math.java">
  <comments>/*&#xA; * @(#)Math.java&#x9;1.69 04/06/14&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>lang</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Random.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Math">
    <members xsi:type="members:Constructor" name="Math">
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Don't let anyone instantiate this class.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="E">
      <initialValue xsi:type="literals:DecimalDoubleLiteral" decimalValue="2.718281828459045"/>
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The &lt;code>double&lt;/code> value that is closer than any other to&#xA;     * &lt;i>e&lt;/i>, the base of the natural logarithms.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="PI">
      <initialValue xsi:type="literals:DecimalDoubleLiteral" decimalValue="3.141592653589793"/>
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The &lt;code>double&lt;/code> value that is closer than any other to&#xA;     * &lt;i>pi&lt;/i>, the ratio of the circumference of a circle to its&#xA;     * diameter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="sin">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the trigonometric sine of an angle.  Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN or an infinity, then the &#xA;     * result is NaN.&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&lt;/ul>&#xA;     * &#xA;     * &lt;p>The computed result must be within 1 ulp of the exact result.&#xA;     * Results must be semi-monotonic.&#xA;     *&#xA;     * @param   a   an angle, in radians.&#xA;     * @return  the sine of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="cos">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the trigonometric cosine of an angle. Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN or an infinity, then the &#xA;     * result is NaN.&lt;/ul>&#xA;     * &#xA;     * &lt;p>The computed result must be within 1 ulp of the exact result.&#xA;     * Results must be semi-monotonic.&#xA;     *&#xA;     * @param   a   an angle, in radians.&#xA;     * @return  the cosine of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.7"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="tan">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the trigonometric tangent of an angle.  Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN or an infinity, then the result &#xA;     * is NaN.&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&lt;/ul>&#xA;     * &#xA;     * &lt;p>The computed result must be within 1 ulp of the exact result.&#xA;     * Results must be semi-monotonic.&#xA;     *&#xA;     * @param   a   an angle, in radians.&#xA;     * @return  the tangent of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.8"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="asin">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the arc sine of an angle, in the range of -&lt;i>pi&lt;/i>/2 through&#xA;     * &lt;i>pi&lt;/i>/2. Special cases: &#xA;     * &lt;ul>&lt;li>If the argument is NaN or its absolute value is greater &#xA;     * than 1, then the result is NaN.&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&lt;/ul>&#xA;     * &#xA;     * &lt;p>The computed result must be within 1 ulp of the exact result.&#xA;     * Results must be semi-monotonic.&#xA;     *&#xA;     * @param   a   the value whose arc sine is to be returned.&#xA;     * @return  the arc sine of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.9"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="acos">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the arc cosine of an angle, in the range of 0.0 through&#xA;     * &lt;i>pi&lt;/i>.  Special case:&#xA;     * &lt;ul>&lt;li>If the argument is NaN or its absolute value is greater &#xA;     * than 1, then the result is NaN.&lt;/ul>&#xA;     * &#xA;     * &lt;p>The computed result must be within 1 ulp of the exact result.&#xA;     * Results must be semi-monotonic.&#xA;     *&#xA;     * @param   a   the value whose arc cosine is to be returned.&#xA;     * @return  the arc cosine of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.10"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="atan">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the arc tangent of an angle, in the range of -&lt;i>pi&lt;/i>/2&#xA;     * through &lt;i>pi&lt;/i>/2.  Special cases: &#xA;     * &lt;ul>&lt;li>If the argument is NaN, then the result is NaN.&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&lt;/ul>&#xA;     * &#xA;     * &lt;p>The computed result must be within 1 ulp of the exact result.&#xA;     * Results must be semi-monotonic.&#xA;     *&#xA;     * @param   a   the value whose arc tangent is to be returned.&#xA;     * @return  the arc tangent of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.11"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toRadians">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="angdeg">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts an angle measured in degrees to an approximately&#xA;     * equivalent angle measured in radians.  The conversion from&#xA;     * degrees to radians is generally inexact.&#xA;     *&#xA;     * @param   angdeg   an angle, in degrees&#xA;     * @return  the measurement of the angle &lt;code>angdeg&lt;/code>&#xA;     *          in radians.&#xA;     * @since   1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:MultiplicativeExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="180.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <multiplicativeOperators xsi:type="operators:Division"/>
          <multiplicativeOperators xsi:type="operators:Multiplication"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toDegrees">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="angrad">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts an angle measured in radians to an approximately&#xA;     * equivalent angle measured in degrees.  The conversion from&#xA;     * radians to degrees is generally inexact; users should&#xA;     * &lt;i>not&lt;/i> expect &lt;code>cos(toRadians(90.0))&lt;/code> to exactly&#xA;     * equal &lt;code>0.0&lt;/code>.&#xA;     *&#xA;     * @param   angrad   an angle, in radians&#xA;     * @return  the measurement of the angle &lt;code>angrad&lt;/code>&#xA;     *          in degrees.&#xA;     * @since   1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:MultiplicativeExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="180.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <multiplicativeOperators xsi:type="operators:Multiplication"/>
          <multiplicativeOperators xsi:type="operators:Division"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="exp">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns Euler's number &lt;i>e&lt;/i> raised to the power of a&#xA;     * &lt;code>double&lt;/code> value.  Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN, the result is NaN.&#xA;     * &lt;li>If the argument is positive infinity, then the result is &#xA;     * positive infinity.&#xA;     * &lt;li>If the argument is negative infinity, then the result is &#xA;     * positive zero.&lt;/ul>&#xA;     * &#xA;     * &lt;p>The computed result must be within 1 ulp of the exact result.&#xA;     * Results must be semi-monotonic.&#xA;     *&#xA;     * @param   a   the exponent to raise &lt;i>e&lt;/i> to.&#xA;     * @return  the value &lt;i>e&lt;/i>&lt;sup>&lt;code>a&lt;/code>&lt;/sup>, &#xA;     *          where &lt;i>e&lt;/i> is the base of the natural logarithms.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="log">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the natural logarithm (base &lt;i>e&lt;/i>) of a &lt;code>double&lt;/code>&#xA;     * value.  Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN or less than zero, then the result &#xA;     * is NaN.&#xA;     * &lt;li>If the argument is positive infinity, then the result is &#xA;     * positive infinity.&#xA;     * &lt;li>If the argument is positive zero or negative zero, then the &#xA;     * result is negative infinity.&lt;/ul>&#xA;     * &#xA;     * &lt;p>The computed result must be within 1 ulp of the exact result.&#xA;     * Results must be semi-monotonic.&#xA;     *&#xA;     * @param   a   a value&#xA;     * @return  the value ln&amp;nbsp;&lt;code>a&lt;/code>, the natural logarithm of&#xA;     *          &lt;code>a&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.15"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="log10">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the base 10 logarithm of a &lt;code>double&lt;/code> value.&#xA;     * Special cases:&#xA;     *&#xA;     * &lt;ul>&lt;li>If the argument is NaN or less than zero, then the result &#xA;     * is NaN.&#xA;     * &lt;li>If the argument is positive infinity, then the result is &#xA;     * positive infinity.&#xA;     * &lt;li>If the argument is positive zero or negative zero, then the &#xA;     * result is negative infinity.&#xA;     * &lt;li> If the argument is equal to 10&lt;sup>&lt;i>n&lt;/i>&lt;/sup> for&#xA;     * integer &lt;i>n&lt;/i>, then the result is &lt;i>n&lt;/i>.&#xA;     * &lt;/ul>&#xA;     * &#xA;     * &lt;p>The computed result must be within 1 ulp of the exact result.&#xA;     * Results must be semi-monotonic.&#xA;     *&#xA;     * @param   a   a value&#xA;     * @return  the base 10 logarithm of  &lt;code>a&lt;/code>.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.16"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="sqrt">
      <comments>// default impl. delegates to StrictMath</comments>
      <comments>// Note that hardware sqrt instructions</comments>
      <comments>// frequently can be directly used by JITs</comments>
      <comments>// and should be much faster than doing</comments>
      <comments>// Math.sqrt in software.</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the correctly rounded positive square root of a &#xA;     * &lt;code>double&lt;/code> value.&#xA;     * Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN or less than zero, then the result &#xA;     * is NaN. &#xA;     * &lt;li>If the argument is positive infinity, then the result is positive &#xA;     * infinity. &#xA;     * &lt;li>If the argument is positive zero or negative zero, then the &#xA;     * result is the same as the argument.&lt;/ul>&#xA;     * Otherwise, the result is the &lt;code>double&lt;/code> value closest to &#xA;     * the true mathematical square root of the argument value.&#xA;     * &#xA;     * @param   a   a value.&#xA;     * @return  the positive square root of &lt;code>a&lt;/code>.&#xA;     *          If the argument is NaN or less than zero, the result is NaN.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.17"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="cbrt">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the cube root of a &lt;code>double&lt;/code> value.  For&#xA;     * positive finite &lt;code>x&lt;/code>, &lt;code>cbrt(-x) ==&#xA;     * -cbrt(x)&lt;/code>; that is, the cube root of a negative value is&#xA;     * the negative of the cube root of that value's magnitude.&#xA;     * &#xA;     * Special cases: &#xA;     *&#xA;     * &lt;ul>&#xA;     * &#xA;     * &lt;li>If the argument is NaN, then the result is NaN.&#xA;     *&#xA;     * &lt;li>If the argument is infinite, then the result is an infinity&#xA;     * with the same sign as the argument.&#xA;     *&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&#xA;     * &#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>The computed result must be within 1 ulp of the exact result.&#xA;     * &#xA;     * @param   a   a value.&#xA;     * @return  the cube root of &lt;code>a&lt;/code>.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.18"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="IEEEremainder">
      <comments>// delegate to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f1">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f2">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Computes the remainder operation on two arguments as prescribed &#xA;     * by the IEEE 754 standard.&#xA;     * The remainder value is mathematically equal to &#xA;     * &lt;code>f1&amp;nbsp;-&amp;nbsp;f2&lt;/code>&amp;nbsp;&amp;times;&amp;nbsp;&lt;i>n&lt;/i>,&#xA;     * where &lt;i>n&lt;/i> is the mathematical integer closest to the exact &#xA;     * mathematical value of the quotient &lt;code>f1/f2&lt;/code>, and if two &#xA;     * mathematical integers are equally close to &lt;code>f1/f2&lt;/code>, &#xA;     * then &lt;i>n&lt;/i> is the integer that is even. If the remainder is &#xA;     * zero, its sign is the same as the sign of the first argument. &#xA;     * Special cases:&#xA;     * &lt;ul>&lt;li>If either argument is NaN, or the first argument is infinite, &#xA;     * or the second argument is positive zero or negative zero, then the &#xA;     * result is NaN.&#xA;     * &lt;li>If the first argument is finite and the second argument is &#xA;     * infinite, then the result is the same as the first argument.&lt;/ul>&#xA;     *&#xA;     * @param   f1   the dividend.&#xA;     * @param   f2   the divisor.&#xA;     * @return  the remainder when &lt;code>f1&lt;/code> is divided by&#xA;     *          &lt;code>f2&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="ceil">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the smallest (closest to negative infinity)&#xA;     * &lt;code>double&lt;/code> value that is greater than or equal to the&#xA;     * argument and is equal to a mathematical integer. Special cases:&#xA;     * &lt;ul>&lt;li>If the argument value is already equal to a&#xA;     * mathematical integer, then the result is the same as the&#xA;     * argument.  &lt;li>If the argument is NaN or an infinity or&#xA;     * positive zero or negative zero, then the result is the same as&#xA;     * the argument.  &lt;li>If the argument value is less than zero but&#xA;     * greater than -1.0, then the result is negative zero.&lt;/ul> Note&#xA;     * that the value of &lt;code>Math.ceil(x)&lt;/code> is exactly the&#xA;     * value of &lt;code>-Math.floor(-x)&lt;/code>.&#xA;     *&#xA;     *&#xA;     * @param   a   a value.&#xA;     * @return  the smallest (closest to negative infinity) &#xA;     *          floating-point value that is greater than or equal to &#xA;     *          the argument and is equal to a mathematical integer. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="floor">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the largest (closest to positive infinity)&#xA;     * &lt;code>double&lt;/code> value that is less than or equal to the&#xA;     * argument and is equal to a mathematical integer. Special cases:&#xA;     * &lt;ul>&lt;li>If the argument value is already equal to a&#xA;     * mathematical integer, then the result is the same as the&#xA;     * argument.  &lt;li>If the argument is NaN or an infinity or&#xA;     * positive zero or negative zero, then the result is the same as&#xA;     * the argument.&lt;/ul>&#xA;     *&#xA;     * @param   a   a value.&#xA;     * @return  the largest (closest to positive infinity) &#xA;     *          floating-point value that less than or equal to the argument&#xA;     *          and is equal to a mathematical integer. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.21"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="rint">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>double&lt;/code> value that is closest in value&#xA;     * to the argument and is equal to a mathematical integer. If two&#xA;     * &lt;code>double&lt;/code> values that are mathematical integers are&#xA;     * equally close, the result is the integer value that is&#xA;     * even. Special cases:&#xA;     * &lt;ul>&lt;li>If the argument value is already equal to a mathematical &#xA;     * integer, then the result is the same as the argument. &#xA;     * &lt;li>If the argument is NaN or an infinity or positive zero or negative &#xA;     * zero, then the result is the same as the argument.&lt;/ul>&#xA;     *&#xA;     * @param   a   a &lt;code>double&lt;/code> value.&#xA;     * @return  the closest floating-point value to &lt;code>a&lt;/code> that is&#xA;     *          equal to a mathematical integer.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.22"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="atan2">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts rectangular coordinates (&lt;code>x&lt;/code>,&amp;nbsp;&lt;code>y&lt;/code>)&#xA;     * to polar (r,&amp;nbsp;&lt;i>theta&lt;/i>).&#xA;     * This method computes the phase &lt;i>theta&lt;/i> by computing an arc tangent&#xA;     * of &lt;code>y/x&lt;/code> in the range of -&lt;i>pi&lt;/i> to &lt;i>pi&lt;/i>. Special &#xA;     * cases:&#xA;     * &lt;ul>&lt;li>If either argument is NaN, then the result is NaN. &#xA;     * &lt;li>If the first argument is positive zero and the second argument &#xA;     * is positive, or the first argument is positive and finite and the &#xA;     * second argument is positive infinity, then the result is positive &#xA;     * zero. &#xA;     * &lt;li>If the first argument is negative zero and the second argument &#xA;     * is positive, or the first argument is negative and finite and the &#xA;     * second argument is positive infinity, then the result is negative zero. &#xA;     * &lt;li>If the first argument is positive zero and the second argument &#xA;     * is negative, or the first argument is positive and finite and the &#xA;     * second argument is negative infinity, then the result is the &#xA;     * &lt;code>double&lt;/code> value closest to &lt;i>pi&lt;/i>. &#xA;     * &lt;li>If the first argument is negative zero and the second argument &#xA;     * is negative, or the first argument is negative and finite and the &#xA;     * second argument is negative infinity, then the result is the &#xA;     * &lt;code>double&lt;/code> value closest to -&lt;i>pi&lt;/i>. &#xA;     * &lt;li>If the first argument is positive and the second argument is &#xA;     * positive zero or negative zero, or the first argument is positive &#xA;     * infinity and the second argument is finite, then the result is the &#xA;     * &lt;code>double&lt;/code> value closest to &lt;i>pi&lt;/i>/2. &#xA;     * &lt;li>If the first argument is negative and the second argument is &#xA;     * positive zero or negative zero, or the first argument is negative &#xA;     * infinity and the second argument is finite, then the result is the &#xA;     * &lt;code>double&lt;/code> value closest to -&lt;i>pi&lt;/i>/2. &#xA;     * &lt;li>If both arguments are positive infinity, then the result is the &#xA;     * &lt;code>double&lt;/code> value closest to &lt;i>pi&lt;/i>/4. &#xA;     * &lt;li>If the first argument is positive infinity and the second argument &#xA;     * is negative infinity, then the result is the &lt;code>double&lt;/code> &#xA;     * value closest to 3*&lt;i>pi&lt;/i>/4. &#xA;     * &lt;li>If the first argument is negative infinity and the second argument &#xA;     * is positive infinity, then the result is the &lt;code>double&lt;/code> value &#xA;     * closest to -&lt;i>pi&lt;/i>/4. &#xA;     * &lt;li>If both arguments are negative infinity, then the result is the &#xA;     * &lt;code>double&lt;/code> value closest to -3*&lt;i>pi&lt;/i>/4.&lt;/ul>&#xA;     * &#xA;     * &lt;p>The computed result must be within 2 ulps of the exact result.&#xA;     * Results must be semi-monotonic.&#xA;     *&#xA;     * @param   y   the ordinate coordinate&#xA;     * @param   x   the abscissa coordinate&#xA;     * @return  the &lt;i>theta&lt;/i> component of the point&#xA;     *          (&lt;i>r&lt;/i>,&amp;nbsp;&lt;i>theta&lt;/i>)&#xA;     *          in polar coordinates that corresponds to the point&#xA;     *          (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in Cartesian coordinates.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.23"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="pow">
      <comments>// default impl. delegates to StrictMath</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of the first argument raised to the power of the&#xA;     * second argument. Special cases:&#xA;     *&#xA;     * &lt;ul>&lt;li>If the second argument is positive or negative zero, then the &#xA;     * result is 1.0. &#xA;     * &lt;li>If the second argument is 1.0, then the result is the same as the &#xA;     * first argument.&#xA;     * &lt;li>If the second argument is NaN, then the result is NaN. &#xA;     * &lt;li>If the first argument is NaN and the second argument is nonzero, &#xA;     * then the result is NaN. &#xA;     *&#xA;     * &lt;li>If&#xA;     * &lt;ul>&#xA;     * &lt;li>the absolute value of the first argument is greater than 1&#xA;     * and the second argument is positive infinity, or&#xA;     * &lt;li>the absolute value of the first argument is less than 1 and&#xA;     * the second argument is negative infinity,&#xA;     * &lt;/ul>&#xA;     * then the result is positive infinity. &#xA;     *&#xA;     * &lt;li>If &#xA;     * &lt;ul>&#xA;     * &lt;li>the absolute value of the first argument is greater than 1 and &#xA;     * the second argument is negative infinity, or &#xA;     * &lt;li>the absolute value of the &#xA;     * first argument is less than 1 and the second argument is positive &#xA;     * infinity,&#xA;     * &lt;/ul>&#xA;     * then the result is positive zero. &#xA;     *&#xA;     * &lt;li>If the absolute value of the first argument equals 1 and the &#xA;     * second argument is infinite, then the result is NaN. &#xA;     *&#xA;     * &lt;li>If &#xA;     * &lt;ul>&#xA;     * &lt;li>the first argument is positive zero and the second argument&#xA;     * is greater than zero, or&#xA;     * &lt;li>the first argument is positive infinity and the second&#xA;     * argument is less than zero,&#xA;     * &lt;/ul>&#xA;     * then the result is positive zero. &#xA;     *&#xA;     * &lt;li>If &#xA;     * &lt;ul>&#xA;     * &lt;li>the first argument is positive zero and the second argument&#xA;     * is less than zero, or&#xA;     * &lt;li>the first argument is positive infinity and the second&#xA;     * argument is greater than zero,&#xA;     * &lt;/ul>&#xA;     * then the result is positive infinity.&#xA;     *&#xA;     * &lt;li>If &#xA;     * &lt;ul>&#xA;     * &lt;li>the first argument is negative zero and the second argument&#xA;     * is greater than zero but not a finite odd integer, or&#xA;     * &lt;li>the first argument is negative infinity and the second&#xA;     * argument is less than zero but not a finite odd integer,&#xA;     * &lt;/ul>&#xA;     * then the result is positive zero. &#xA;     *&#xA;     * &lt;li>If &#xA;     * &lt;ul>&#xA;     * &lt;li>the first argument is negative zero and the second argument&#xA;     * is a positive finite odd integer, or&#xA;     * &lt;li>the first argument is negative infinity and the second&#xA;     * argument is a negative finite odd integer,&#xA;     * &lt;/ul>&#xA;     * then the result is negative zero. &#xA;     *&#xA;     * &lt;li>If&#xA;     * &lt;ul>&#xA;     * &lt;li>the first argument is negative zero and the second argument&#xA;     * is less than zero but not a finite odd integer, or&#xA;     * &lt;li>the first argument is negative infinity and the second&#xA;     * argument is greater than zero but not a finite odd integer,&#xA;     * &lt;/ul>&#xA;     * then the result is positive infinity. &#xA;     *&#xA;     * &lt;li>If &#xA;     * &lt;ul>&#xA;     * &lt;li>the first argument is negative zero and the second argument&#xA;     * is a negative finite odd integer, or&#xA;     * &lt;li>the first argument is negative infinity and the second&#xA;     * argument is a positive finite odd integer,&#xA;     * &lt;/ul>&#xA;     * then the result is negative infinity. &#xA;     *&#xA;     * &lt;li>If the first argument is finite and less than zero&#xA;     * &lt;ul>&#xA;     * &lt;li> if the second argument is a finite even integer, the&#xA;     * result is equal to the result of raising the absolute value of&#xA;     * the first argument to the power of the second argument&#xA;     *&#xA;     * &lt;li>if the second argument is a finite odd integer, the result&#xA;     * is equal to the negative of the result of raising the absolute&#xA;     * value of the first argument to the power of the second&#xA;     * argument&#xA;     *&#xA;     * &lt;li>if the second argument is finite and not an integer, then&#xA;     * the result is NaN.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;li>If both arguments are integers, then the result is exactly equal &#xA;     * to the mathematical result of raising the first argument to the power &#xA;     * of the second argument if that result can in fact be represented &#xA;     * exactly as a &lt;code>double&lt;/code> value.&lt;/ul>&#xA;     * &#xA;     * &lt;p>(In the foregoing descriptions, a floating-point value is&#xA;     * considered to be an integer if and only if it is finite and a&#xA;     * fixed point of the method {@link #ceil &lt;tt>ceil&lt;/tt>} or,&#xA;     * equivalently, a fixed point of the method {@link #floor&#xA;     * &lt;tt>floor&lt;/tt>}. A value is a fixed point of a one-argument&#xA;     * method if and only if the result of applying the method to the&#xA;     * value is equal to the value.)&#xA;     *&#xA;     * &lt;p>The computed result must be within 1 ulp of the exact result.&#xA;     * Results must be semi-monotonic.&#xA;     *&#xA;     * @param   a   the base.&#xA;     * @param   b   the exponent.&#xA;     * @return  the value &lt;code>a&lt;sup>b&lt;/sup>&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.24"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="round">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the closest &lt;code>int&lt;/code> to the argument. The &#xA;     * result is rounded to an integer by adding 1/2, taking the &#xA;     * floor of the result, and casting the result to type &lt;code>int&lt;/code>. &#xA;     * In other words, the result is equal to the value of the expression:&#xA;     * &lt;p>&lt;pre>(int)Math.floor(a + 0.5f)&lt;/pre>&#xA;     * &lt;p>&#xA;     * Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN, the result is 0.&#xA;     * &lt;li>If the argument is negative infinity or any value less than or &#xA;     * equal to the value of &lt;code>Integer.MIN_VALUE&lt;/code>, the result is &#xA;     * equal to the value of &lt;code>Integer.MIN_VALUE&lt;/code>. &#xA;     * &lt;li>If the argument is positive infinity or any value greater than or &#xA;     * equal to the value of &lt;code>Integer.MAX_VALUE&lt;/code>, the result is &#xA;     * equal to the value of &lt;code>Integer.MAX_VALUE&lt;/code>.&lt;/ul> &#xA;     *&#xA;     * @param   a   a floating-point value to be rounded to an integer.&#xA;     * @return  the value of the argument rounded to the nearest&#xA;     *          &lt;code>int&lt;/code> value.&#xA;     * @see     java.lang.Integer#MAX_VALUE&#xA;     * @see     java.lang.Integer#MIN_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Int"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
              <children xsi:type="literals:DecimalFloatLiteral" decimalValue="0.5"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="round">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the closest &lt;code>long&lt;/code> to the argument. The result &#xA;     * is rounded to an integer by adding 1/2, taking the floor of the &#xA;     * result, and casting the result to type &lt;code>long&lt;/code>. In other &#xA;     * words, the result is equal to the value of the expression:&#xA;     * &lt;p>&lt;pre>(long)Math.floor(a + 0.5d)&lt;/pre>&#xA;     * &lt;p>&#xA;     * Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN, the result is 0.&#xA;     * &lt;li>If the argument is negative infinity or any value less than or &#xA;     * equal to the value of &lt;code>Long.MIN_VALUE&lt;/code>, the result is &#xA;     * equal to the value of &lt;code>Long.MIN_VALUE&lt;/code>. &#xA;     * &lt;li>If the argument is positive infinity or any value greater than or &#xA;     * equal to the value of &lt;code>Long.MAX_VALUE&lt;/code>, the result is &#xA;     * equal to the value of &lt;code>Long.MAX_VALUE&lt;/code>.&lt;/ul> &#xA;     *&#xA;     * @param   a   a floating-point value to be rounded to a &#xA;     *&#x9;&#x9;&lt;code>long&lt;/code>.&#xA;     * @return  the value of the argument rounded to the nearest&#xA;     *          &lt;code>long&lt;/code> value.&#xA;     * @see     java.lang.Long#MAX_VALUE&#xA;     * @see     java.lang.Long#MIN_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Long"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
              <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="0.5"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="randomNumberGenerator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Random.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="initRNG">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../util/Random.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="random">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>double&lt;/code> value with a positive sign, greater &#xA;     * than or equal to &lt;code>0.0&lt;/code> and less than &lt;code>1.0&lt;/code>. &#xA;     * Returned values are chosen pseudorandomly with (approximately) &#xA;     * uniform distribution from that range. &#xA;     * &#xA;     * &lt;p>When this method is first called, it creates a single new&#xA;     * pseudorandom-number generator, exactly as if by the expression&#xA;     * &lt;blockquote>&lt;pre>new java.util.Random&lt;/pre>&lt;/blockquote> This&#xA;     * new pseudorandom-number generator is used thereafter for all&#xA;     * calls to this method and is used nowhere else.&#xA;     * &#xA;     * &lt;p>This method is properly synchronized to allow correct use by&#xA;     * more than one thread. However, if many threads need to generate&#xA;     * pseudorandom numbers at a great rate, it may reduce contention&#xA;     * for each thread to have its own pseudorandom-number generator.&#xA;     *  &#xA;     * @return  a pseudorandom &lt;code>double&lt;/code> greater than or equal &#xA;     * to &lt;code>0.0&lt;/code> and less than &lt;code>1.0&lt;/code>.&#xA;     * @see     java.util.Random#nextDouble()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.25"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../util/Random.class.xmi#//@classifiers.0/@members.21"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="abs">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the absolute value of an &lt;code>int&lt;/code> value.&#xA;     * If the argument is not negative, the argument is returned.&#xA;     * If the argument is negative, the negation of the argument is returned. &#xA;     * &#xA;     * &lt;p>Note that if the argument is equal to the value of&#xA;     * &lt;code>Integer.MIN_VALUE&lt;/code>, the most negative representable&#xA;     * &lt;code>int&lt;/code> value, the result is that same value, which is&#xA;     * negative.&#xA;     *&#xA;     * @param   a   the argument whose absolute value is to be determined&#xA;     * @return  the absolute value of the argument.&#xA;     * @see     java.lang.Integer#MIN_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </child>
          <expressionIf xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
          </expressionIf>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="abs">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the absolute value of a &lt;code>long&lt;/code> value.&#xA;     * If the argument is not negative, the argument is returned.&#xA;     * If the argument is negative, the negation of the argument is returned. &#xA;     * &#xA;     * &lt;p>Note that if the argument is equal to the value of&#xA;     * &lt;code>Long.MIN_VALUE&lt;/code>, the most negative representable&#xA;     * &lt;code>long&lt;/code> value, the result is that same value, which&#xA;     * is negative.&#xA;     *&#xA;     * @param   a   the argument whose absolute value is to be determined&#xA;     * @return  the absolute value of the argument.&#xA;     * @see     java.lang.Long#MIN_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </child>
          <expressionIf xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
          </expressionIf>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="abs">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the absolute value of a &lt;code>float&lt;/code> value.&#xA;     * If the argument is not negative, the argument is returned.&#xA;     * If the argument is negative, the negation of the argument is returned.&#xA;     * Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is positive zero or negative zero, the &#xA;     * result is positive zero. &#xA;     * &lt;li>If the argument is infinite, the result is positive infinity. &#xA;     * &lt;li>If the argument is NaN, the result is NaN.&lt;/ul>&#xA;     * In other words, the result is the same as the value of the expression: &#xA;     * &lt;p>&lt;pre>Float.intBitsToFloat(0x7fffffff &amp; Float.floatToIntBits(a))&lt;/pre>&#xA;     *&#xA;     * @param   a   the argument whose absolute value is to be determined&#xA;     * @return  the absolute value of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
              <children xsi:type="literals:DecimalFloatLiteral"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="expressions:AdditiveExpression">
            <children xsi:type="literals:DecimalFloatLiteral"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </expressionIf>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="abs">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the absolute value of a &lt;code>double&lt;/code> value.&#xA;     * If the argument is not negative, the argument is returned.&#xA;     * If the argument is negative, the negation of the argument is returned.&#xA;     * Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is positive zero or negative zero, the result &#xA;     * is positive zero. &#xA;     * &lt;li>If the argument is infinite, the result is positive infinity. &#xA;     * &lt;li>If the argument is NaN, the result is NaN.&lt;/ul>&#xA;     * In other words, the result is the same as the value of the expression: &#xA;     * &lt;p>&lt;code>Double.longBitsToDouble((Double.doubleToLongBits(a)&amp;lt;&amp;lt;1)&amp;gt;&amp;gt;&amp;gt;1)&lt;/code> &#xA;     *&#xA;     * @param   a   the argument whose absolute value is to be determined&#xA;     * @return  the absolute value of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
              <children xsi:type="literals:DecimalDoubleLiteral"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="expressions:AdditiveExpression">
            <children xsi:type="literals:DecimalDoubleLiteral"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </expressionIf>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="max">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the greater of two &lt;code>int&lt;/code> values. That is, the &#xA;     * result is the argument closer to the value of &#xA;     * &lt;code>Integer.MAX_VALUE&lt;/code>. If the arguments have the same value, &#xA;     * the result is that same value.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the larger of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     * @see     java.lang.Long#MAX_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="max">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the greater of two &lt;code>long&lt;/code> values. That is, the &#xA;     * result is the argument closer to the value of &#xA;     * &lt;code>Long.MAX_VALUE&lt;/code>. If the arguments have the same value, &#xA;     * the result is that same value. &#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the larger of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     * @see     java.lang.Long#MAX_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="negativeZeroFloatBits">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Float.class.xmi#//@classifiers.0/@members.30"/>
          <arguments xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalFloatLiteral"/>
          </arguments>
        </next>
        <target xsi:type="classifiers:Class" href="Float.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="negativeZeroDoubleBits">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Double.class.xmi#//@classifiers.0/@members.29"/>
          <arguments xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalDoubleLiteral"/>
          </arguments>
        </next>
        <target xsi:type="classifiers:Class" href="Double.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="max">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the greater of two &lt;code>float&lt;/code> values.  That is,&#xA;     * the result is the argument closer to positive infinity. If the&#xA;     * arguments have the same value, the result is that same&#xA;     * value. If either value is NaN, then the result is NaN.  Unlike&#xA;     * the numerical comparison operators, this method considers&#xA;     * negative zero to be strictly smaller than positive zero. If one&#xA;     * argument is positive zero and the other negative zero, the&#xA;     * result is positive zero.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the larger of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// a is NaN</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
              <children xsi:type="literals:DecimalFloatLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
              <children xsi:type="literals:DecimalFloatLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Float.class.xmi#//@classifiers.0/@members.30"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="Float.class.xmi#//@classifiers.0"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="max">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the greater of two &lt;code>double&lt;/code> values.  That&#xA;     * is, the result is the argument closer to positive infinity. If&#xA;     * the arguments have the same value, the result is that same&#xA;     * value. If either value is NaN, then the result is NaN.  Unlike&#xA;     * the numerical comparison operators, this method considers&#xA;     * negative zero to be strictly smaller than positive zero. If one&#xA;     * argument is positive zero and the other negative zero, the&#xA;     * result is positive zero.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the larger of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// a is NaN</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
              <children xsi:type="literals:DecimalDoubleLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
              <children xsi:type="literals:DecimalDoubleLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Double.class.xmi#//@classifiers.0/@members.29"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="Double.class.xmi#//@classifiers.0"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="min">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the smaller of two &lt;code>int&lt;/code> values. That is,&#xA;     * the result the argument closer to the value of&#xA;     * &lt;code>Integer.MIN_VALUE&lt;/code>.  If the arguments have the same&#xA;     * value, the result is that same value.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the smaller of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     * @see     java.lang.Long#MIN_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.1"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="min">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the smaller of two &lt;code>long&lt;/code> values. That is,&#xA;     * the result is the argument closer to the value of&#xA;     * &lt;code>Long.MIN_VALUE&lt;/code>. If the arguments have the same&#xA;     * value, the result is that same value.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the smaller of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     * @see     java.lang.Long#MIN_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.1"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="min">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the smaller of two &lt;code>float&lt;/code> values.  That is,&#xA;     * the result is the value closer to negative infinity. If the&#xA;     * arguments have the same value, the result is that same&#xA;     * value. If either value is NaN, then the result is NaN.  Unlike&#xA;     * the numerical comparison operators, this method considers&#xA;     * negative zero to be strictly smaller than positive zero.  If&#xA;     * one argument is positive zero and the other is negative zero,&#xA;     * the result is negative zero.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the smaller of &lt;code>a&lt;/code> and &lt;code>b.&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// a is NaN</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
              <children xsi:type="literals:DecimalFloatLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
              <children xsi:type="literals:DecimalFloatLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Float.class.xmi#//@classifiers.0/@members.30"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="Float.class.xmi#//@classifiers.0"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="min">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the smaller of two &lt;code>double&lt;/code> values.  That&#xA;     * is, the result is the value closer to negative infinity. If the&#xA;     * arguments have the same value, the result is that same&#xA;     * value. If either value is NaN, then the result is NaN.  Unlike&#xA;     * the numerical comparison operators, this method considers&#xA;     * negative zero to be strictly smaller than positive zero. If one&#xA;     * argument is positive zero and the other is negative zero, the&#xA;     * result is negative zero.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the smaller of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// a is NaN</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
              <children xsi:type="literals:DecimalDoubleLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
              <children xsi:type="literals:DecimalDoubleLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Double.class.xmi#//@classifiers.0/@members.29"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="Double.class.xmi#//@classifiers.0"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="ulp">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the size of an ulp of the argument.  An ulp of a&#xA;     * &lt;code>double&lt;/code> value is the positive distance between this&#xA;     * floating-point value and the &lt;code>double&lt;/code> value next&#xA;     * larger in magnitude.  Note that for non-NaN &lt;i>x&lt;/i>,&#xA;     * &lt;code>ulp(-&lt;i>x&lt;/i>) == ulp(&lt;i>x&lt;/i>)&lt;/code>.&#xA;     * &#xA;     * &lt;p>Special Cases:&#xA;     * &lt;ul>&#xA;     * &lt;li> If the argument is NaN, then the result is NaN.&#xA;     * &lt;li> If the argument is positive or negative infinity, then the&#xA;     * result is positive infinity.&#xA;     * &lt;li> If the argument is positive or negative zero, then the result is&#xA;     * &lt;code>Double.MIN_VALUE&lt;/code>.&#xA;     * &lt;li> If the argument is &amp;plusmn;&lt;code>Double.MAX_VALUE&lt;/code>, then&#xA;     * the result is equal to 2&lt;sup>971&lt;/sup>.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param d the floating-point value whose ulp is to be returned&#xA;     * @return the size of an ulp of the argument&#xA;     * @author Joseph D. Darcy&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0/@members.30"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
            </next>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="ulp">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the size of an ulp of the argument.  An ulp of a&#xA;     * &lt;code>float&lt;/code> value is the positive distance between this&#xA;     * floating-point value and the &lt;code>float&lt;/code> value next&#xA;     * larger in magnitude.  Note that for non-NaN &lt;i>x&lt;/i>,&#xA;     * &lt;code>ulp(-&lt;i>x&lt;/i>) == ulp(&lt;i>x&lt;/i>)&lt;/code>.&#xA;     * &#xA;     * &lt;p>Special Cases:&#xA;     * &lt;ul>&#xA;     * &lt;li> If the argument is NaN, then the result is NaN.&#xA;     * &lt;li> If the argument is positive or negative infinity, then the&#xA;     * result is positive infinity.&#xA;     * &lt;li> If the argument is positive or negative zero, then the result is&#xA;     * &lt;code>Float.MIN_VALUE&lt;/code>.&#xA;     * &lt;li> If the argument is &amp;plusmn;&lt;code>Float.MAX_VALUE&lt;/code>, then&#xA;     * the result is equal to 2&lt;sup>104&lt;/sup>.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param f the floating-point value whose ulp is to be returned&#xA;     * @return the size of an ulp of the argument&#xA;     * @author Joseph D. Darcy&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0/@members.31"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
            </next>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="signum">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the signum function of the argument; zero if the argument&#xA;     * is zero, 1.0 if the argument is greater than zero, -1.0 if the&#xA;     * argument is less than zero.&#xA;     *&#xA;     * &lt;p>Special Cases:&#xA;     * &lt;ul>&#xA;     * &lt;li> If the argument is NaN, then the result is NaN.&#xA;     * &lt;li> If the argument is positive zero or negative zero, then the&#xA;     *      result is the same as the argument.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param d the floating-point value whose signum is to be returned&#xA;     * @return the signum function of the argument&#xA;     * @author Joseph D. Darcy&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
            </next>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="signum">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the signum function of the argument; zero if the argument&#xA;     * is zero, 1.0f if the argument is greater than zero, -1.0f if the&#xA;     * argument is less than zero.&#xA;     *&#xA;     * &lt;p>Special Cases:&#xA;     * &lt;ul>&#xA;     * &lt;li> If the argument is NaN, then the result is NaN.&#xA;     * &lt;li> If the argument is positive zero or negative zero, then the&#xA;     *      result is the same as the argument.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param f the floating-point value whose signum is to be returned&#xA;     * @return the signum function of the argument&#xA;     * @author Joseph D. Darcy&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
            </next>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="sinh">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the hyperbolic sine of a &lt;code>double&lt;/code> value.&#xA;     * The hyperbolic sine of &lt;i>x&lt;/i> is defined to be&#xA;     * (&lt;i>e&lt;sup>x&lt;/sup>&amp;nbsp;-&amp;nbsp;e&lt;sup>-x&lt;/sup>&lt;/i>)/2&#xA;     * where &lt;i>e&lt;/i> is {@linkplain Math#E Euler's number}.&#xA;     *&#xA;     * &lt;p>Special cases:&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>If the argument is NaN, then the result is NaN.&#xA;     *&#xA;     * &lt;li>If the argument is infinite, then the result is an infinity&#xA;     * with the same sign as the argument.&#xA;     *&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>The computed result must be within 2.5 ulps of the exact result.&#xA;     *&#xA;     * @param   x The number whose hyperbolic sine is to be returned.&#xA;     * @return  The hyperbolic sine of &lt;code>x&lt;/code>.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.45"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="cosh">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the hyperbolic cosine of a &lt;code>double&lt;/code> value.&#xA;     * The hyperbolic cosine of &lt;i>x&lt;/i> is defined to be&#xA;     * (&lt;i>e&lt;sup>x&lt;/sup>&amp;nbsp;+&amp;nbsp;e&lt;sup>-x&lt;/sup>&lt;/i>)/2&#xA;     * where &lt;i>e&lt;/i> is {@linkplain Math#E Euler's number}.&#xA;     *&#xA;     * &lt;p>Special cases:&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>If the argument is NaN, then the result is NaN.&#xA;     *&#xA;     * &lt;li>If the argument is infinite, then the result is positive&#xA;     * infinity.&#xA;     *&#xA;     * &lt;li>If the argument is zero, then the result is &lt;code>1.0&lt;/code>.&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>The computed result must be within 2.5 ulps of the exact result.&#xA;     *&#xA;     * @param   x The number whose hyperbolic cosine is to be returned.&#xA;     * @return  The hyperbolic cosine of &lt;code>x&lt;/code>.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.46"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="tanh">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the hyperbolic tangent of a &lt;code>double&lt;/code> value.&#xA;     * The hyperbolic tangent of &lt;i>x&lt;/i> is defined to be&#xA;     * (&lt;i>e&lt;sup>x&lt;/sup>&amp;nbsp;-&amp;nbsp;e&lt;sup>-x&lt;/sup>&lt;/i>)/(&lt;i>e&lt;sup>x&lt;/sup>&amp;nbsp;+&amp;nbsp;e&lt;sup>-x&lt;/sup>&lt;/i>),&#xA;     * in other words, {@linkplain Math#sinh&#xA;     * sinh(&lt;i>x&lt;/i>)}/{@linkplain Math#cosh cosh(&lt;i>x&lt;/i>)}.  Note&#xA;     * that the absolute value of the exact tanh is always less than&#xA;     * 1.&#xA;     *&#xA;     * &lt;p>Special cases:&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>If the argument is NaN, then the result is NaN.&#xA;     *&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&#xA;     *&#xA;     * &lt;li>If the argument is positive infinity, then the result is&#xA;     * &lt;code>+1.0&lt;/code>.&#xA;     *&#xA;     * &lt;li>If the argument is negative infinity, then the result is&#xA;     * &lt;code>-1.0&lt;/code>.&#xA;     *  &#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>The computed result must be within 2.5 ulps of the exact result.&#xA;     * The result of &lt;code>tanh&lt;/code> for any finite input must have&#xA;     * an absolute value less than or equal to 1.  Note that once the&#xA;     * exact result of tanh is within 1/2 of an ulp of the limit value&#xA;     * of &amp;plusmn;1, correctly signed &amp;plusmn;&lt;code>1.0&lt;/code> should&#xA;     * be returned.&#xA;     *&#xA;     * @param   x The number whose hyperbolic tangent is to be returned.&#xA;     * @return  The hyperbolic tangent of &lt;code>x&lt;/code>.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.47"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hypot">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns sqrt(&lt;i>x&lt;/i>&lt;sup>2&lt;/sup>&amp;nbsp;+&lt;i>y&lt;/i>&lt;sup>2&lt;/sup>)&#xA;     * without intermediate overflow or underflow.&#xA;     *&#xA;     * &lt;p>Special cases:&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li> If either argument is infinite, then the result&#xA;     * is positive infinity.&#xA;     *&#xA;     * &lt;li> If either argument is NaN and neither argument is infinite,&#xA;     * then the result is NaN.&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>The computed result must be within 1 ulp of the exact&#xA;     * result.  If one parameter is held constant, the results must be&#xA;     * semi-monotonic in the other parameter.&#xA;     *&#xA;     * @param x a value&#xA;     * @param y a value&#xA;     * @return sqrt(&lt;i>x&lt;/i>&lt;sup>2&lt;/sup>&amp;nbsp;+&lt;i>y&lt;/i>&lt;sup>2&lt;/sup>)&#xA;     * without intermediate overflow or underflow&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.48"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="expm1">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;i>e&lt;/i>&lt;sup>x&lt;/sup>&amp;nbsp;-1.  Note that for values of&#xA;     * &lt;i>x&lt;/i> near 0, the exact sum of&#xA;     * &lt;code>expm1(x)&lt;/code>&amp;nbsp;+&amp;nbsp;1 is much closer to the true&#xA;     * result of &lt;i>e&lt;/i>&lt;sup>x&lt;/sup> than &lt;code>exp(x)&lt;/code>.&#xA;     *&#xA;     * &lt;p>Special cases:&#xA;     * &lt;ul>&#xA;     * &lt;li>If the argument is NaN, the result is NaN.&#xA;     *&#xA;     * &lt;li>If the argument is positive infinity, then the result is&#xA;     * positive infinity.&#xA;     *&#xA;     * &lt;li>If the argument is negative infinity, then the result is&#xA;     * -1.0.&#xA;     *&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>The computed result must be within 1 ulp of the exact result.&#xA;     * Results must be semi-monotonic.  The result of&#xA;     * &lt;code>expm1&lt;/code> for any finite input must be greater than or&#xA;     * equal to &lt;code>-1.0&lt;/code>.  Note that once the exact result of&#xA;     * &lt;i>e&lt;/i>&lt;sup>&lt;code>x&lt;/code>&lt;/sup>&amp;nbsp;-&amp;nbsp;1 is within 1/2&#xA;     * ulp of the limit value -1, &lt;code>-1.0&lt;/code> should be&#xA;     * returned.&#xA;     *&#xA;     * @param   x   the exponent to raise &lt;i>e&lt;/i> to in the computation of&#xA;     *              &lt;i>e&lt;/i>&lt;sup>&lt;code>x&lt;/code>&lt;/sup>&amp;nbsp;-1.&#xA;     * @return  the value &lt;i>e&lt;/i>&lt;sup>&lt;code>x&lt;/code>&lt;/sup>&amp;nbsp;-&amp;nbsp;1.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.49"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="log1p">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the natural logarithm of the sum of the argument and 1.&#xA;     * Note that for small values &lt;code>x&lt;/code>, the result of&#xA;     * &lt;code>log1p(x)&lt;/code> is much closer to the true result of ln(1&#xA;     * + &lt;code>x&lt;/code>) than the floating-point evaluation of&#xA;     * &lt;code>log(1.0+x)&lt;/code>.&#xA;     *&#xA;     * &lt;p>Special cases:&#xA;     *&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>If the argument is NaN or less than -1, then the result is&#xA;     * NaN.&#xA;     *&#xA;     * &lt;li>If the argument is positive infinity, then the result is&#xA;     * positive infinity.&#xA;     *&#xA;     * &lt;li>If the argument is negative one, then the result is&#xA;     * negative infinity.&#xA;     *&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>The computed result must be within 1 ulp of the exact result.&#xA;     * Results must be semi-monotonic.&#xA;     *&#xA;     * @param   x   a value&#xA;     * @return the value ln(&lt;code>x&lt;/code>&amp;nbsp;+&amp;nbsp;1), the natural&#xA;     * log of &lt;code>x&lt;/code>&amp;nbsp;+&amp;nbsp;1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StrictMath.class.xmi#//@classifiers.0/@members.50"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="StrictMath.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The class &lt;code>Math&lt;/code> contains methods for performing basic&#xA; * numeric operations such as the elementary exponential, logarithm,&#xA; * square root, and trigonometric functions.&#xA; * &#xA; * &lt;p>Unlike some of the numeric methods of class&#xA; * &lt;code>StrictMath&lt;/code>, all implementations of the equivalent&#xA; * functions of class &lt;code>Math&lt;/code> are not defined to return the&#xA; * bit-for-bit same results.  This relaxation permits&#xA; * better-performing implementations where strict reproducibility is&#xA; * not required.&#xA; * &#xA; * &lt;p>By default many of the &lt;code>Math&lt;/code> methods simply call&#xA; * the equivalent method in &lt;code>StrictMath&lt;/code> for their&#xA; * implementation.  Code generators are encouraged to use&#xA; * platform-specific native libraries or microprocessor instructions,&#xA; * where available, to provide higher-performance implementations of&#xA; * &lt;code>Math&lt;/code> methods.  Such higher-performance&#xA; * implementations still must conform to the specification for&#xA; * &lt;code>Math&lt;/code>.&#xA; * &#xA; * &lt;p>The quality of implementation specifications concern two&#xA; * properties, accuracy of the returned result and monotonicity of the&#xA; * method.  Accuracy of the floating-point &lt;code>Math&lt;/code> methods&#xA; * is measured in terms of &lt;i>ulps&lt;/i>, units in the last place.  For&#xA; * a given floating-point format, an ulp of a specific real number&#xA; * value is the distance between the two floating-point values&#xA; * bracketing that numerical value.  When discussing the accuracy of a&#xA; * method as a whole rather than at a specific argument, the number of&#xA; * ulps cited is for the worst-case error at any argument.  If a&#xA; * method always has an error less than 0.5 ulps, the method always&#xA; * returns the floating-point number nearest the exact result; such a&#xA; * method is &lt;i>correctly rounded&lt;/i>.  A correctly rounded method is&#xA; * generally the best a floating-point approximation can be; however,&#xA; * it is impractical for many floating-point methods to be correctly&#xA; * rounded.  Instead, for the &lt;code>Math&lt;/code> class, a larger error&#xA; * bound of 1 or 2 ulps is allowed for certain methods.  Informally,&#xA; * with a 1 ulp error bound, when the exact result is a representable&#xA; * number, the exact result should be returned as the computed result;&#xA; * otherwise, either of the two floating-point values which bracket&#xA; * the exact result may be returned.  For exact results large in&#xA; * magnitude, one of the endpoints of the bracket may be infinite.&#xA; * Besides accuracy at individual arguments, maintaining proper&#xA; * relations between the method at different arguments is also&#xA; * important.  Therefore, most methods with more than 0.5 ulp errors&#xA; * are required to be &lt;i>semi-monotonic&lt;/i>: whenever the mathematical&#xA; * function is non-decreasing, so is the floating-point approximation,&#xA; * likewise, whenever the mathematical function is non-increasing, so&#xA; * is the floating-point approximation.  Not all approximations that&#xA; * have 1 ulp accuracy will automatically meet the monotonicity&#xA; * requirements.&#xA; * &#xA; * @author  unascribed&#xA; * @author  Joseph D. Darcy&#xA; * @version 1.69, 06/14/04&#xA; * @since   JDK1.0&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Final"/>
  </classifiers>
</containers:CompilationUnit>
