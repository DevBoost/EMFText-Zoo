<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="Float.java">
  <comments>/*&#xA; * @(#)Float.java&#x9;1.94 04/05/11&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>lang</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>misc</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>misc</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>misc</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/misc/FloatConsts.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>misc</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/misc/DoubleConsts.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Float">
    <members xsi:type="members:Field" name="POSITIVE_INFINITY">
      <initialValue xsi:type="expressions:MultiplicativeExpression">
        <children xsi:type="literals:DecimalFloatLiteral" decimalValue="1.0"/>
        <children xsi:type="literals:DecimalFloatLiteral"/>
        <multiplicativeOperators xsi:type="operators:Division"/>
      </initialValue>
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A constant holding the positive infinity of type&#xA;     * &lt;code>float&lt;/code>. It is equal to the value returned by&#xA;     * &lt;code>Float.intBitsToFloat(0x7f800000)&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="NEGATIVE_INFINITY">
      <initialValue xsi:type="expressions:MultiplicativeExpression">
        <children xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalFloatLiteral" decimalValue="1.0"/>
        </children>
        <children xsi:type="literals:DecimalFloatLiteral"/>
        <multiplicativeOperators xsi:type="operators:Division"/>
      </initialValue>
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A constant holding the negative infinity of type&#xA;     * &lt;code>float&lt;/code>. It is equal to the value returned by&#xA;     * &lt;code>Float.intBitsToFloat(0xff800000)&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="NaN">
      <initialValue xsi:type="expressions:MultiplicativeExpression">
        <children xsi:type="literals:DecimalFloatLiteral"/>
        <children xsi:type="literals:DecimalFloatLiteral"/>
        <multiplicativeOperators xsi:type="operators:Division"/>
      </initialValue>
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * A constant holding a Not-a-Number (NaN) value of type&#xA;     * &lt;code>float&lt;/code>.  It is equivalent to the value returned by&#xA;     * &lt;code>Float.intBitsToFloat(0x7fc00000)&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MAX_VALUE">
      <initialValue xsi:type="literals:DecimalFloatLiteral" decimalValue="3.4028235E38"/>
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A constant holding the largest positive finite value of type&#xA;     * &lt;code>float&lt;/code>, (2-2&lt;sup>-23&lt;/sup>)&amp;middot;2&lt;sup>127&lt;/sup>.&#xA;     * It is equal to the hexadecimal floating-point literal&#xA;     * &lt;code>0x1.fffffeP+127f&lt;/code> and also equal to&#xA;     * &lt;code>Float.intBitsToFloat(0x7f7fffff)&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MIN_VALUE">
      <initialValue xsi:type="literals:DecimalFloatLiteral" decimalValue="1.4E-45"/>
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// 0x1.fffffeP+127f</comments>
        <comments>/**&#xA;     * A constant holding the smallest positive nonzero value of type&#xA;     * &lt;code>float&lt;/code>, 2&lt;sup>-149&lt;/sup>. It is equal to the&#xA;     * hexadecimal floating-point literal &lt;code>0x0.000002P-126f&lt;/code>&#xA;     * and also equal to &lt;code>Float.intBitsToFloat(0x1)&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SIZE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="32"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// 0x0.000002P-126f</comments>
        <comments>/**&#xA;     * The number of bits used to represent a &lt;tt>float&lt;/tt> value.&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="TYPE">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Class.class.xmi#//@classifiers.0/@members.92"/>
          <arguments xsi:type="references:StringReference" value="float"/>
        </next>
        <target xsi:type="classifiers:Class" href="Class.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Class" href="Class.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The &lt;code>Class&lt;/code> instance representing the primitive type&#xA;     * &lt;code>float&lt;/code>.&#xA;     *&#xA;     * @since JDK1.1 &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string representation of the &lt;code>float&lt;/code>&#xA;     * argument. All characters mentioned below are ASCII characters.&#xA;     * &lt;ul>&#xA;     * &lt;li>If the argument is NaN, the result is the string&#xA;     * &amp;quot;&lt;code>NaN&lt;/code>&amp;quot;.&#xA;     * &lt;li>Otherwise, the result is a string that represents the sign and &#xA;     *     magnitude (absolute value) of the argument. If the sign is&#xA;     *     negative, the first character of the result is&#xA;     *     '&lt;code>-&lt;/code>' (&lt;code>'&amp;#92;u002D'&lt;/code>); if the sign is&#xA;     *     positive, no sign character appears in the result. As for&#xA;     *     the magnitude &lt;i>m&lt;/i>:&#xA;     * &lt;ul>&#xA;     * &lt;li>If &lt;i>m&lt;/i> is infinity, it is represented by the characters &#xA;     *     &lt;code>&quot;Infinity&quot;&lt;/code>; thus, positive infinity produces&#xA;     *     the result &lt;code>&quot;Infinity&quot;&lt;/code> and negative infinity&#xA;     *     produces the result &lt;code>&quot;-Infinity&quot;&lt;/code>.&#xA;     * &lt;li>If &lt;i>m&lt;/i> is zero, it is represented by the characters &#xA;     *     &lt;code>&quot;0.0&quot;&lt;/code>; thus, negative zero produces the result&#xA;     *     &lt;code>&quot;-0.0&quot;&lt;/code> and positive zero produces the result&#xA;     *     &lt;code>&quot;0.0&quot;&lt;/code>.&#xA;     * &lt;li> If &lt;i>m&lt;/i> is greater than or equal to 10&lt;sup>-3&lt;/sup> but &#xA;     *      less than 10&lt;sup>7&lt;/sup>, then it is represented as the&#xA;     *      integer part of &lt;i>m&lt;/i>, in decimal form with no leading&#xA;     *      zeroes, followed by '&lt;code>.&lt;/code>'&#xA;     *      (&lt;code>'&amp;#92;u002E'&lt;/code>), followed by one or more&#xA;     *      decimal digits representing the fractional part of&#xA;     *      &lt;i>m&lt;/i>.&#xA;     * &lt;li> If &lt;i>m&lt;/i> is less than 10&lt;sup>-3&lt;/sup> or greater than or&#xA;     *      equal to 10&lt;sup>7&lt;/sup>, then it is represented in&#xA;     *      so-called &quot;computerized scientific notation.&quot; Let &lt;i>n&lt;/i>&#xA;     *      be the unique integer such that 10&lt;sup>&lt;i>n&lt;/i> &lt;/sup>&amp;lt;= &#xA;     *      &lt;i>m&lt;/i> &amp;lt; 10&lt;sup>&lt;i>n&lt;/i>+1&lt;/sup>; then let &lt;i>a&lt;/i> &#xA;     *      be the mathematically exact quotient of &lt;i>m&lt;/i> and &#xA;     *      10&lt;sup>&lt;i>n&lt;/i>&lt;/sup> so that 1 &amp;lt;= &lt;i>a&lt;/i> &amp;lt; 10.&#xA;     *      The magnitude is then represented as the integer part of&#xA;     *      &lt;i>a&lt;/i>, as a single decimal digit, followed by&#xA;     *      '&lt;code>.&lt;/code>' (&lt;code>'&amp;#92;u002E'&lt;/code>), followed by&#xA;     *      decimal digits representing the fractional part of&#xA;     *      &lt;i>a&lt;/i>, followed by the letter '&lt;code>E&lt;/code>'&#xA;     *      (&lt;code>'&amp;#92;u0045'&lt;/code>), followed by a representation&#xA;     *      of &lt;i>n&lt;/i> as a decimal integer, as produced by the&#xA;     *      method &lt;code>{@link&#xA;     *      java.lang.Integer#toString(int)}&lt;/code>.&#xA;     * &lt;/ul>&#xA;     * &lt;/ul>&#xA;     * How many digits must be printed for the fractional part of&#xA;     * &lt;i>m&lt;/i> or &lt;i>a&lt;/i>? There must be at least one digit&#xA;     * to represent the fractional part, and beyond that as many, but&#xA;     * only as many, more digits as are needed to uniquely distinguish&#xA;     * the argument value from adjacent values of type&#xA;     * &lt;code>float&lt;/code>. That is, suppose that &lt;i>x&lt;/i> is the&#xA;     * exact mathematical value represented by the decimal&#xA;     * representation produced by this method for a finite nonzero&#xA;     * argument &lt;i>f&lt;/i>. Then &lt;i>f&lt;/i> must be the &lt;code>float&lt;/code>&#xA;     * value nearest to &lt;i>x&lt;/i>; or, if two &lt;code>float&lt;/code> values are&#xA;     * equally close to &lt;i>x&lt;/i>, then &lt;i>f&lt;/i> must be one of&#xA;     * them and the least significant bit of the significand of&#xA;     * &lt;i>f&lt;/i> must be &lt;code>0&lt;/code>.&#xA;     * &lt;p>&#xA;     * To create localized string representations of a floating-point&#xA;     * value, use subclasses of {@link java.text.NumberFormat}.&#xA;     *&#xA;     * @param   f   the float to be converted.&#xA;     * @return a string representation of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0/@members.66"/>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toHexString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a hexadecimal string representation of the&#xA;     * &lt;code>float&lt;/code> argument. All characters mentioned below are&#xA;     * ASCII characters.&#xA;     *&#xA;     * &lt;ul>&#xA;     * &lt;li>If the argument is NaN, the result is the string&#xA;     *     &amp;quot;&lt;code>NaN&lt;/code>&amp;quot;.&#xA;     * &lt;li>Otherwise, the result is a string that represents the sign and &#xA;     * magnitude (absolute value) of the argument. If the sign is negative, &#xA;     * the first character of the result is '&lt;code>-&lt;/code>' &#xA;     * (&lt;code>'&amp;#92;u002D'&lt;/code>); if the sign is positive, no sign character &#xA;     * appears in the result. As for the magnitude &lt;i>m&lt;/i>:&#xA;     *&#xA;     * &lt;ul> &#xA;     * &lt;li>If &lt;i>m&lt;/i> is infinity, it is represented by the string&#xA;     * &lt;code>&quot;Infinity&quot;&lt;/code>; thus, positive infinity produces the&#xA;     * result &lt;code>&quot;Infinity&quot;&lt;/code> and negative infinity produces&#xA;     * the result &lt;code>&quot;-Infinity&quot;&lt;/code>.&#xA;     *&#xA;     * &lt;li>If &lt;i>m&lt;/i> is zero, it is represented by the string&#xA;     * &lt;code>&quot;0x0.0p0&quot;&lt;/code>; thus, negative zero produces the result&#xA;     * &lt;code>&quot;-0x0.0p0&quot;&lt;/code> and positive zero produces the result&#xA;     * &lt;code>&quot;0x0.0p0&quot;&lt;/code>.&#xA;     *&#xA;     * &lt;li>If &lt;i>m&lt;/i> is a &lt;code>float&lt;/code> value with a&#xA;     * normalized representation, substrings are used to represent the&#xA;     * significand and exponent fields.  The significand is&#xA;     * represented by the characters &lt;code>&amp;quot;0x1.&amp;quot;&lt;/code>&#xA;     * followed by a lowercase hexadecimal representation of the rest&#xA;     * of the significand as a fraction.  Trailing zeros in the&#xA;     * hexadecimal representation are removed unless all the digits&#xA;     * are zero, in which case a single zero is used. Next, the&#xA;     * exponent is represented by &lt;code>&amp;quot;p&amp;quot;&lt;/code> followed&#xA;     * by a decimal string of the unbiased exponent as if produced by&#xA;     * a call to {@link Integer#toString(int) Integer.toString} on the&#xA;     * exponent value.&#xA;     *&#xA;     * &lt;li>If &lt;i>m&lt;/i> is a &lt;code>float&lt;/code> value with a subnormal&#xA;     * representation, the significand is represented by the&#xA;     * characters &lt;code>&amp;quot;0x0.&amp;quot;&lt;/code> followed by a&#xA;     * hexadecimal representation of the rest of the significand as a&#xA;     * fraction.  Trailing zeros in the hexadecimal representation are&#xA;     * removed. Next, the exponent is represented by&#xA;     * &lt;code>&amp;quot;p-126&amp;quot;&lt;/code>.  Note that there must be at&#xA;     * least one nonzero digit in a subnormal significand.&#xA;     *&#xA;     * &lt;/ul>&#xA;     * &#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;table border>&#xA;     * &lt;caption>&lt;h3>Examples&lt;/h3>&lt;/caption>&#xA;     * &lt;tr>&lt;th>Floating-point Value&lt;/th>&lt;th>Hexadecimal String&lt;/th>&#xA;     * &lt;tr>&lt;td>&lt;code>1.0&lt;/code>&lt;/td>&#x9;&lt;td>&lt;code>0x1.0p0&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>-1.0&lt;/code>&lt;/td>&#x9;&lt;td>&lt;code>-0x1.0p0&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>2.0&lt;/code>&lt;/td>&#x9;&lt;td>&lt;code>0x1.0p1&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>3.0&lt;/code>&lt;/td>&#x9;&lt;td>&lt;code>0x1.8p1&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>0.5&lt;/code>&lt;/td>&#x9;&lt;td>&lt;code>0x1.0p-1&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>0.25&lt;/code>&lt;/td>&#x9;&lt;td>&lt;code>0x1.0p-2&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>Float.MAX_VALUE&lt;/code>&lt;/td>&#xA;     *     &lt;td>&lt;code>0x1.fffffep127&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>Minimum Normal Value&lt;/code>&lt;/td>&#xA;     *     &lt;td>&lt;code>0x1.0p-126&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>Maximum Subnormal Value&lt;/code>&lt;/td>&#xA;     *     &lt;td>&lt;code>0x0.fffffep-126&lt;/code>&lt;/td>&#xA;     * &lt;tr>&lt;td>&lt;code>Float.MIN_VALUE&lt;/code>&lt;/td>&#xA;     *     &lt;td>&lt;code>0x0.000002p-126&lt;/code>&lt;/td>&#xA;     * &lt;/table>&#xA;     * @param   f   the &lt;code>float&lt;/code> to be converted.&#xA;     * @return a hex string representation of the argument.&#xA;     * @since 1.5&#xA;     * @author Joseph D. Darcy&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="s">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <comments>// float subnormal</comments>
                  <comments>// Adjust exponent to create subnormal double, then</comments>
                  <comments>// replace subnormal double exponent with subnormal float</comments>
                  <comments>// exponent</comments>
                  <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Double.class.xmi#//@classifiers.0/@members.10"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0/@members.20"/>
                      <arguments xsi:type="expressions:CastExpression">
                        <typeReference xsi:type="types:Double"/>
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
                      </arguments>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference">
                          <comments>/* -1022+126 */</comments>
                          <next xsi:type="references:IdentifierReference">
                            <target xsi:type="members:Field" href="../../sun/misc/DoubleConsts.class.xmi#//@classifiers.0/@members.8"/>
                          </next>
                          <target xsi:type="classifiers:Class" href="../../sun/misc/DoubleConsts.class.xmi#//@classifiers.0"/>
                        </children>
                        <children xsi:type="references:IdentifierReference">
                          <next xsi:type="references:IdentifierReference">
                            <target xsi:type="members:Field" href="../../sun/misc/FloatConsts.class.xmi#//@classifiers.0/@members.8"/>
                          </next>
                          <target xsi:type="classifiers:Class" href="../../sun/misc/FloatConsts.class.xmi#//@classifiers.0"/>
                        </children>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="Double.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.62"/>
                <arguments xsi:type="references:StringReference" value="p-1022$"/>
                <arguments xsi:type="references:StringReference" value="p-126"/>
              </next>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Math.class.xmi#//@classifiers.0/@members.31"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="Math.class.xmi#//@classifiers.0"/>
            </children>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../../sun/misc/FloatConsts.class.xmi#//@classifiers.0/@members.5"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../sun/misc/FloatConsts.class.xmi#//@classifiers.0"/>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
            <children xsi:type="literals:DecimalFloatLiteral"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Return">
          <comments>// double string will be the same as float string</comments>
          <returnValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Double.class.xmi#//@classifiers.0/@members.10"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="Double.class.xmi#//@classifiers.0"/>
          </returnValue>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NumberFormatException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>Float&lt;/code> object holding the&#xA;     * &lt;code>float&lt;/code> value represented by the argument string&#xA;     * &lt;code>s&lt;/code>.&#xA;     * &#xA;     * &lt;p>If &lt;code>s&lt;/code> is &lt;code>null&lt;/code>, then a&#xA;     * &lt;code>NullPointerException&lt;/code> is thrown.&#xA;     * &#xA;     * &lt;p>Leading and trailing whitespace characters in &lt;code>s&lt;/code>&#xA;     * are ignored.  Whitespace is removed as if by the {@link&#xA;     * String#trim} method; that is, both ASCII space and control&#xA;     * characters are removed. The rest of &lt;code>s&lt;/code> should&#xA;     * constitute a &lt;i>FloatValue&lt;/i> as described by the lexical&#xA;     * syntax rules:&#xA;     *&#xA;     * &lt;blockquote>&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;i>FloatValue:&lt;/i>&#xA;     * &lt;dd>&lt;i>Sign&lt;sub>opt&lt;/sub>&lt;/i> &lt;code>NaN&lt;/code>&#xA;     * &lt;dd>&lt;i>Sign&lt;sub>opt&lt;/sub>&lt;/i> &lt;code>Infinity&lt;/code>&#xA;     * &lt;dd>&lt;i>Sign&lt;sub>opt&lt;/sub> FloatingPointLiteral&lt;/i>&#xA;     * &lt;dd>&lt;i>Sign&lt;sub>opt&lt;/sub> HexFloatingPointLiteral&lt;/i>&#xA;     * &lt;dd>&lt;i>SignedInteger&lt;/i>&#xA;     * &lt;/dl>&#xA;     *&#xA;     * &lt;p>&#xA;     *&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;i>HexFloatingPointLiteral&lt;/i>:&#xA;     * &lt;dd> &lt;i>HexSignificand BinaryExponent FloatTypeSuffix&lt;sub>opt&lt;/sub>&lt;/i>&#xA;     * &lt;/dl>&#xA;     *&#xA;     * &lt;p>&#xA;     *&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;i>HexSignificand:&lt;/i>&#xA;     * &lt;dd>&lt;i>HexNumeral&lt;/i>&#xA;     * &lt;dd>&lt;i>HexNumeral&lt;/i> &lt;code>.&lt;/code>&#xA;     * &lt;dd>&lt;code>0x&lt;/code> &lt;i>HexDigits&lt;sub>opt&lt;/sub> &#xA;     *     &lt;/i>&lt;code>.&lt;/code>&lt;i> HexDigits&lt;/i>&#xA;     * &lt;dd>&lt;code>0X&lt;/code>&lt;i> HexDigits&lt;sub>opt&lt;/sub> &#xA;     *     &lt;/i>&lt;code>.&lt;/code> &lt;i>HexDigits&lt;/i>&#xA;     * &lt;/dl>&#xA;     *&#xA;     * &lt;p>&#xA;     *&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;i>BinaryExponent:&lt;/i>&#xA;     * &lt;dd>&lt;i>BinaryExponentIndicator SignedInteger&lt;/i>&#xA;     * &lt;/dl>&#xA;     *&#xA;     * &lt;p>&#xA;     *&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;i>BinaryExponentIndicator:&lt;/i>&#xA;     * &lt;dd>&lt;code>p&lt;/code>&#xA;     * &lt;dd>&lt;code>P&lt;/code>&#xA;     * &lt;/dl>&#xA;     *&#xA;     * &lt;/blockquote>&#xA;     *&#xA;     * where &lt;i>Sign&lt;/i>, &lt;i>FloatingPointLiteral&lt;/i>,&#xA;     * &lt;i>HexNumeral&lt;/i>, &lt;i>HexDigits&lt;/i>, &lt;i>SignedInteger&lt;/i> and&#xA;     * &lt;i>FloatTypeSuffix&lt;/i> are as defined in the lexical structure&#xA;     * sections of the of the &lt;a&#xA;     * href=&quot;http://java.sun.com/docs/books/jls/html/&quot;>Java Language&#xA;     * Specification&lt;/a>. If &lt;code>s&lt;/code> does not have the form of&#xA;     * a &lt;i>FloatValue&lt;/i>, then a &lt;code>NumberFormatException&lt;/code>&#xA;     * is thrown. Otherwise, &lt;code>s&lt;/code> is regarded as&#xA;     * representing an exact decimal value in the usual&#xA;     * &amp;quot;computerized scientific notation&amp;quot; or as an exact&#xA;     * hexadecimal value; this exact numerical value is then&#xA;     * conceptually converted to an &amp;quot;infinitely precise&amp;quot;&#xA;     * binary value that is then rounded to type &lt;code>float&lt;/code>&#xA;     * by the usual round-to-nearest rule of IEEE 754 floating-point&#xA;     * arithmetic, which includes preserving the sign of a zero&#xA;     * value. Finally, a &lt;code>Float&lt;/code> object representing this&#xA;     * &lt;code>float&lt;/code> value is returned.&#xA;     * &#xA;     * &lt;p>To interpret localized string representations of a&#xA;     * floating-point value, use subclasses of {@link&#xA;     * java.text.NumberFormat}.&#xA;     *&#xA;     * &lt;p>Note that trailing format specifiers, specifiers that&#xA;     * determine the type of a floating-point literal&#xA;     * (&lt;code>1.0f&lt;/code> is a &lt;code>float&lt;/code> value;&#xA;     * &lt;code>1.0d&lt;/code> is a &lt;code>double&lt;/code> value), do&#xA;     * &lt;em>not&lt;/em> influence the results of this method.  In other&#xA;     * words, the numerical value of the input string is converted&#xA;     * directly to the target floating-point type.  In general, the&#xA;     * two-step sequence of conversions, string to &lt;code>double&lt;/code>&#xA;     * followed by &lt;code>double&lt;/code> to &lt;code>float&lt;/code>, is&#xA;     * &lt;em>not&lt;/em> equivalent to converting a string directly to&#xA;     * &lt;code>float&lt;/code>.  For example, if first converted to an&#xA;     * intermediate &lt;code>double&lt;/code> and then to&#xA;     * &lt;code>float&lt;/code>, the string&lt;br>&#xA;     * &lt;code>&quot;1.00000017881393421514957253748434595763683319091796875001d&quot;&lt;/code>&lt;br>&#xA;     * results in the &lt;code>float&lt;/code> value&#xA;     * &lt;code>1.0000002f&lt;/code>; if the string is converted directly to&#xA;     * &lt;code>float&lt;/code>, &lt;code>1.000000&lt;b>1&lt;/b>f&lt;/code> results.&#xA;     *&#xA;     * &lt;p>To avoid calling this method on a invalid string and having&#xA;     * a &lt;code>NumberFormatException&lt;/code> be thrown, the documentation&#xA;     * for {@link Double#valueOf Double.valueOf} lists a regular&#xA;     * expression which can be used to screen the input.&#xA;     *&#xA;     * @param      s   the string to be parsed.&#xA;     * @return     a &lt;code>Float&lt;/code> object holding the value&#xA;     *             represented by the &lt;code>String&lt;/code> argument.&#xA;     * @exception  NumberFormatException  if the string does not contain a&#xA;     *               parsable number.  &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0/@members.71"/>
              </next>
              <target xsi:type="members:ClassMethod" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0/@members.69"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>Float&lt;/tt> instance representing the specified&#xA;     * &lt;tt>float&lt;/tt> value.&#xA;     * If a new &lt;tt>Float&lt;/tt> instance is not required, this method&#xA;     * should generally be used in preference to the constructor&#xA;     * {@link #Float(float)}, as this method is likely to yield&#xA;     * significantly better space and time performance by caching&#xA;     * frequently requested values.&#xA;     *&#xA;     * @param  f a float value.&#xA;     * @return a &lt;tt>Float&lt;/tt> instance representing &lt;tt>f&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="parseFloat">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NumberFormatException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a new &lt;code>float&lt;/code> initialized to the value&#xA;     * represented by the specified &lt;code>String&lt;/code>, as performed&#xA;     * by the &lt;code>valueOf&lt;/code> method of class &lt;code>Float&lt;/code>.&#xA;     *&#xA;     * @param      s   the string to be parsed.&#xA;     * @return the &lt;code>float&lt;/code> value represented by the string&#xA;     *         argument.&#xA;     * @exception  NumberFormatException  if the string does not contain a&#xA;     *               parsable &lt;code>float&lt;/code>.&#xA;     * @see        java.lang.Float#valueOf(String)&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0/@members.71"/>
            </next>
            <target xsi:type="members:ClassMethod" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0/@members.69"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isNaN">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if the specified number is a&#xA;     * Not-a-Number (NaN) value, &lt;code>false&lt;/code> otherwise.&#xA;     *&#xA;     * @param   v   the value to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the argument is NaN;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isInfinite">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if the specified number is infinitely&#xA;     * large in magnitude, &lt;code>false&lt;/code> otherwise.&#xA;     *&#xA;     * @param   v   the value to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the argument is positive infinity or&#xA;     *          negative infinity; &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </expression>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="value">
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The value of the Float.&#xA;     *&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="Float">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a newly allocated &lt;code>Float&lt;/code> object that&#xA;     * represents the primitive &lt;code>float&lt;/code> argument.&#xA;     *&#xA;     * @param   value   the value to be represented by the &lt;code>Float&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Float">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Float"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a newly allocated &lt;code>Float&lt;/code> object that&#xA;     * represents the argument converted to type &lt;code>float&lt;/code>.&#xA;     *&#xA;     * @param   value   the value to be represented by the &lt;code>Float&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Float">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.9">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.25"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
          </arguments>
          <callTarget xsi:type="literals:This">
            <comments>// REMIND: this is inefficient</comments>
          </callTarget>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NumberFormatException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a newly allocated &lt;code>Float&lt;/code> object that &#xA;     * represents the floating-point value of type &lt;code>float&lt;/code> &#xA;     * represented by the string. The string is converted to a &#xA;     * &lt;code>float&lt;/code> value as if by the &lt;code>valueOf&lt;/code> method. &#xA;     *&#xA;     * @param      s   a string to be converted to a &lt;code>Float&lt;/code>.&#xA;     * @exception  NumberFormatException  if the string does not contain a&#xA;     *               parsable number.&#xA;     * @see        java.lang.Float#valueOf(java.lang.String)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="isNaN">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if this &lt;code>Float&lt;/code> value is a&#xA;     * Not-a-Number (NaN), &lt;code>false&lt;/code> otherwise.&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if the value represented by this object is&#xA;     *          NaN; &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isInfinite">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if this &lt;code>Float&lt;/code> value is&#xA;     * infinitely large in magnitude, &lt;code>false&lt;/code> otherwise.&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if the value represented by this object is&#xA;     *          positive infinity or negative infinity;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string representation of this &lt;code>Float&lt;/code> object.&#xA;     * The primitive &lt;code>float&lt;/code> value represented by this object&#xA;     * is converted to a &lt;code>String&lt;/code> exactly as if by the method&#xA;     * &lt;code>toString&lt;/code> of one argument.&#xA;     *&#xA;     * @return  a &lt;code>String&lt;/code> representation of this object.&#xA;     * @see java.lang.Float#toString(float)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.85"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
          </next>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="byteValue">
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of this &lt;code>Float&lt;/code> as a&#xA;     * &lt;code>byte&lt;/code> (by casting to a &lt;code>byte&lt;/code>).&#xA;     *&#xA;     * @return  the &lt;code>float&lt;/code> value represented by this object&#xA;     *          converted to type &lt;code>byte&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Byte"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="shortValue">
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of this &lt;code>Float&lt;/code> as a&#xA;     * &lt;code>short&lt;/code> (by casting to a &lt;code>short&lt;/code>).&#xA;     *&#xA;     * @return  the &lt;code>float&lt;/code> value represented by this object&#xA;     *          converted to type &lt;code>short&lt;/code>&#xA;     * @since JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Short"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="intValue">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of this &lt;code>Float&lt;/code> as an&#xA;     * &lt;code>int&lt;/code> (by casting to type &lt;code>int&lt;/code>).&#xA;     *&#xA;     * @return  the &lt;code>float&lt;/code> value represented by this object&#xA;     *          converted to type &lt;code>int&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Int"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="longValue">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns value of this &lt;code>Float&lt;/code> as a &lt;code>long&lt;/code>&#xA;     * (by casting to type &lt;code>long&lt;/code>).&#xA;     *&#xA;     * @return  the &lt;code>float&lt;/code> value represented by this object&#xA;     *          converted to type &lt;code>long&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Long"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="floatValue">
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>float&lt;/code> value of this &lt;code>Float&lt;/code>&#xA;     * object.&#xA;     *&#xA;     * @return the &lt;code>float&lt;/code> value represented by this object &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="doubleValue">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>double&lt;/code> value of this&#xA;     * &lt;code>Float&lt;/code> object.&#xA;     * &#xA;     * @return the &lt;code>float&lt;/code> value represented by this &#xA;     *         object is converted to type &lt;code>double&lt;/code> and the &#xA;     *         result of the conversion is returned.  &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Double"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a hash code for this &lt;code>Float&lt;/code> object. The&#xA;     * result is the integer bit representation, exactly as produced&#xA;     * by the method {@link #floatToIntBits(float)}, of the primitive&#xA;     * &lt;code>float&lt;/code> value represented by this &lt;code>Float&lt;/code>&#xA;     * object.&#xA;     *&#xA;     * @return a hash code value for this object.  &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.29">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#xA;     * Compares this object against the specified object.  The result&#xA;     * is &lt;code>true&lt;/code> if and only if the argument is not&#xA;     * &lt;code>null&lt;/code> and is a &lt;code>Float&lt;/code> object that&#xA;     * represents a &lt;code>float&lt;/code> with the same value as the&#xA;     * &lt;code>float&lt;/code> represented by this object. For this&#xA;     * purpose, two &lt;code>float&lt;/code> values are considered to be the&#xA;     * same if and only if the method {@link #floatToIntBits(float)}&#xA;     * returns the identical &lt;code>int&lt;/code> value when applied to&#xA;     * each.&#xA;     * &lt;p>&#xA;     * Note that in most cases, for two instances of class&#xA;     * &lt;code>Float&lt;/code>, &lt;code>f1&lt;/code> and &lt;code>f2&lt;/code>, the value&#xA;     * of &lt;code>f1.equals(f2)&lt;/code> is &lt;code>true&lt;/code> if and only if&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *   f1.floatValue() == f2.floatValue()&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;p>&#xA;     * also has the value &lt;code>true&lt;/code>. However, there are two exceptions:&#xA;     * &lt;ul>&#xA;     * &lt;li>If &lt;code>f1&lt;/code> and &lt;code>f2&lt;/code> both represent&#xA;     *     &lt;code>Float.NaN&lt;/code>, then the &lt;code>equals&lt;/code> method returns&#xA;     *     &lt;code>true&lt;/code>, even though &lt;code>Float.NaN==Float.NaN&lt;/code>&#xA;     *     has the value &lt;code>false&lt;/code>.&#xA;     * &lt;li>If &lt;code>f1&lt;/code> represents &lt;code>+0.0f&lt;/code> while&#xA;     *     &lt;code>f2&lt;/code> represents &lt;code>-0.0f&lt;/code>, or vice&#xA;     *     versa, the &lt;code>equal&lt;/code> test has the value&#xA;     *     &lt;code>false&lt;/code>, even though &lt;code>0.0f==-0.0f&lt;/code>&#xA;     *     has the value &lt;code>true&lt;/code>.&#xA;     * &lt;/ul>&#xA;     * This definition allows hash tables to operate properly.&#xA;     *&#xA;     * @param obj the object to be compared&#xA;     * @return  &lt;code>true&lt;/code> if the objects are the same;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see java.lang.Float#floatToIntBits(float)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.29">
                <arguments xsi:type="expressions:NestedExpression">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
                  <expression xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0"/>
                    </typeReference>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
                  </expression>
                </arguments>
              </children>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.29">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
              </children>
            </expression>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="floatToIntBits">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a representation of the specified floating-point value&#xA;     * according to the IEEE 754 floating-point &quot;single format&quot; bit&#xA;     * layout.&#xA;     * &lt;p>&#xA;     * Bit 31 (the bit that is selected by the mask &#xA;     * &lt;code>0x80000000&lt;/code>) represents the sign of the floating-point &#xA;     * number. &#xA;     * Bits 30-23 (the bits that are selected by the mask &#xA;     * &lt;code>0x7f800000&lt;/code>) represent the exponent. &#xA;     * Bits 22-0 (the bits that are selected by the mask &#xA;     * &lt;code>0x007fffff&lt;/code>) represent the significand (sometimes called &#xA;     * the mantissa) of the floating-point number. &#xA;     * &lt;p>If the argument is positive infinity, the result is &#xA;     * &lt;code>0x7f800000&lt;/code>. &#xA;     * &lt;p>If the argument is negative infinity, the result is &#xA;     * &lt;code>0xff800000&lt;/code>. &#xA;     * &lt;p>If the argument is NaN, the result is &lt;code>0x7fc00000&lt;/code>. &#xA;     * &lt;p>&#xA;     * In all cases, the result is an integer that, when given to the &#xA;     * {@link #intBitsToFloat(int)} method, will produce a floating-point &#xA;     * value the same as the argument to &lt;code>floatToIntBits&lt;/code>&#xA;     * (except all NaN values are collapsed to a single&#xA;     * &amp;quot;canonical&amp;quot; NaN value).&#xA;     * &#xA;     * @param   value   a floating-point number.&#xA;     * @return the bits that represent the floating-point number.  &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="floatToRawIntBits">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a representation of the specified floating-point value&#xA;     * according to the IEEE 754 floating-point &quot;single format&quot; bit&#xA;     * layout, preserving Not-a-Number (NaN) values.&#xA;     * &lt;p>&#xA;     * Bit 31 (the bit that is selected by the mask &#xA;     * &lt;code>0x80000000&lt;/code>) represents the sign of the floating-point &#xA;     * number. &#xA;     * Bits 30-23 (the bits that are selected by the mask &#xA;     * &lt;code>0x7f800000&lt;/code>) represent the exponent. &#xA;     * Bits 22-0 (the bits that are selected by the mask &#xA;     * &lt;code>0x007fffff&lt;/code>) represent the significand (sometimes called &#xA;     * the mantissa) of the floating-point number. &#xA;     * &lt;p>If the argument is positive infinity, the result is &#xA;     * &lt;code>0x7f800000&lt;/code>. &#xA;     * &lt;p>If the argument is negative infinity, the result is &#xA;     * &lt;code>0xff800000&lt;/code>.&#xA;     * &lt;p>&#xA;     * If the argument is NaN, the result is the integer representing&#xA;     * the actual NaN value.  Unlike the &lt;code>floatToIntBits&lt;/code>&#xA;     * method, &lt;code>intToRawIntBits&lt;/code> does not collapse all the&#xA;     * bit patterns encoding a NaN to a single &amp;quot;canonical&amp;quot;&#xA;     * NaN value.&#xA;     * &lt;p>&#xA;     * In all cases, the result is an integer that, when given to the&#xA;     * {@link #intBitsToFloat(int)} method, will produce a&#xA;     * floating-point value the same as the argument to&#xA;     * &lt;code>floatToRawIntBits&lt;/code>.&#xA;     * @param   value   a floating-point number.&#xA;     * @return the bits that represent the floating-point number.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="intBitsToFloat">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bits">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>float&lt;/code> value corresponding to a given&#xA;     * bit representation.&#xA;     * The argument is considered to be a representation of a&#xA;     * floating-point value according to the IEEE 754 floating-point&#xA;     * &quot;single format&quot; bit layout.&#xA;     * &lt;p>&#xA;     * If the argument is &lt;code>0x7f800000&lt;/code>, the result is positive&#xA;     * infinity.&#xA;     * &lt;p>&#xA;     * If the argument is &lt;code>0xff800000&lt;/code>, the result is negative&#xA;     * infinity.&#xA;     * &lt;p>&#xA;     * If the argument is any value in the range&#xA;     * &lt;code>0x7f800001&lt;/code> through &lt;code>0x7fffffff&lt;/code> or in&#xA;     * the range &lt;code>0xff800001&lt;/code> through&#xA;     * &lt;code>0xffffffff&lt;/code>, the result is a NaN.  No IEEE 754&#xA;     * floating-point operation provided by Java can distinguish&#xA;     * between two NaN values of the same type with different bit&#xA;     * patterns.  Distinct values of NaN are only distinguishable by&#xA;     * use of the &lt;code>Float.floatToRawIntBits&lt;/code> method.&#xA;     * &lt;p>&#xA;     * In all other cases, let &lt;i>s&lt;/i>, &lt;i>e&lt;/i>, and &lt;i>m&lt;/i> be three &#xA;     * values that can be computed from the argument: &#xA;     * &lt;blockquote>&lt;pre>&#xA;     * int s = ((bits &amp;gt;&amp;gt; 31) == 0) ? 1 : -1;&#xA;     * int e = ((bits &amp;gt;&amp;gt; 23) &amp; 0xff);&#xA;     * int m = (e == 0) ?&#xA;     *                 (bits &amp; 0x7fffff) &amp;lt;&amp;lt; 1 :&#xA;     *                 (bits &amp; 0x7fffff) | 0x800000;&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * Then the floating-point result equals the value of the mathematical &#xA;     * expression &lt;i>s&lt;/i>&amp;middot;&lt;i>m&lt;/i>&amp;middot;2&lt;sup>&lt;i>e&lt;/i>-150&lt;/sup>.&#xA;     *&lt;p>&#xA;     * Note that this method may not be able to return a&#xA;     * &lt;code>float&lt;/code> NaN with exactly same bit pattern as the&#xA;     * &lt;code>int&lt;/code> argument.  IEEE 754 distinguishes between two&#xA;     * kinds of NaNs, quiet NaNs and &lt;i>signaling NaNs&lt;/i>.  The&#xA;     * differences between the two kinds of NaN are generally not&#xA;     * visible in Java.  Arithmetic operations on signaling NaNs turn&#xA;     * them into quiet NaNs with a different, but often similar, bit&#xA;     * pattern.  However, on some processors merely copying a&#xA;     * signaling NaN also performs that conversion.  In particular,&#xA;     * copying a signaling NaN to return it to the calling method may&#xA;     * perform this conversion.  So &lt;code>intBitsToFloat&lt;/code> may&#xA;     * not be able to return a &lt;code>float&lt;/code> with a signaling NaN&#xA;     * bit pattern.  Consequently, for some &lt;code>int&lt;/code> values,&#xA;     * &lt;code>floatToRawIntBits(intBitsToFloat(start))&lt;/code> may&#xA;     * &lt;i>not&lt;/i> equal &lt;code>start&lt;/code>.  Moreover, which&#xA;     * particular bit patterns represent signaling NaNs is platform&#xA;     * dependent; although all NaN bit patterns, quiet or signaling,&#xA;     * must be in the NaN range identified above.&#xA;     *&#xA;     * @param   bits   an integer.&#xA;     * @return  the &lt;code>float&lt;/code> floating-point value with the same bit&#xA;     *          pattern.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="anotherFloat">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares two &lt;code>Float&lt;/code> objects numerically.  There are&#xA;     * two ways in which comparisons performed by this method differ&#xA;     * from those performed by the Java language numerical comparison&#xA;     * operators (&lt;code>&amp;lt;, &amp;lt;=, ==, &amp;gt;= &amp;gt;&lt;/code>) when&#xA;     * applied to primitive &lt;code>float&lt;/code> values:&#xA;     * &lt;ul>&lt;li>&#xA;     *&#x9;&#x9;&lt;code>Float.NaN&lt;/code> is considered by this method to&#xA;     *&#x9;&#x9;be equal to itself and greater than all other&#xA;     *&#x9;&#x9;&lt;code>float&lt;/code> values&#xA;     *&#x9;&#x9;(including &lt;code>Float.POSITIVE_INFINITY&lt;/code>).&#xA;     * &lt;li>&#xA;     *&#x9;&#x9;&lt;code>0.0f&lt;/code> is considered by this method to be greater&#xA;     *&#x9;&#x9;than &lt;code>-0.0f&lt;/code>.&#xA;     * &lt;/ul>&#xA;     * This ensures that the &lt;i>natural ordering&lt;/i> of &lt;tt>Float&lt;/tt>&#xA;     * objects imposed by this method is &lt;i>consistent with equals&lt;/i>.&#xA;     *&#xA;     * @param   anotherFloat   the &lt;code>Float&lt;/code> to be compared.&#xA;     * @return  the value &lt;code>0&lt;/code> if &lt;code>anotherFloat&lt;/code> is&#xA;     *&#x9;&#x9;numerically equal to this &lt;code>Float&lt;/code>; a value&#xA;     *&#x9;&#x9;less than &lt;code>0&lt;/code> if this &lt;code>Float&lt;/code>&#xA;     *&#x9;&#x9;is numerically less than &lt;code>anotherFloat&lt;/code>;&#xA;     *&#x9;&#x9;and a value greater than &lt;code>0&lt;/code> if this&#xA;     *&#x9;&#x9;&lt;code>Float&lt;/code> is numerically greater than&#xA;     *&#x9;&#x9;&lt;code>anotherFloat&lt;/code>.&#xA;     *&#x9;&#x9;&#xA;     * @since   1.2&#xA;     * @see Comparable#compareTo(Object)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.33">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compare">
      <comments>// (0.0, -0.0) or (NaN, !NaN)</comments>
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f1">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f2">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares the two specified &lt;code>float&lt;/code> values. The sign&#xA;     * of the integer value returned is the same as that of the&#xA;     * integer that would be returned by the call:&#xA;     * &lt;pre>&#xA;     *    new Float(f1).compareTo(new Float(f2))&#xA;     * &lt;/pre>&#xA;     *&#xA;     * @param   f1        the first &lt;code>float&lt;/code> to compare.&#xA;     * @param   f2        the second &lt;code>float&lt;/code> to compare.&#xA;     * @return  the value &lt;code>0&lt;/code> if &lt;code>f1&lt;/code> is&#xA;     *&#x9;&#x9;numerically equal to &lt;code>f2&lt;/code>; a value less than&#xA;     *          &lt;code>0&lt;/code> if &lt;code>f1&lt;/code> is numerically less than&#xA;     *&#x9;&#x9;&lt;code>f2&lt;/code>; and a value greater than &lt;code>0&lt;/code>&#xA;     *&#x9;&#x9;if &lt;code>f1&lt;/code> is numerically greater than&#xA;     *&#x9;&#x9;&lt;code>f2&lt;/code>.&#xA;     * @since 1.4 &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.1"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Neither val is NaN, thisVal is smaller</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="thisBits">
          <typeReference xsi:type="types:Int">
            <comments>// Neither val is NaN, thisVal is larger</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.29">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="anotherBits">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.29">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.1"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.3/@variable"/>
            </child>
            <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <expressionElse xsi:type="expressions:NestedExpression">
              <comments>// Values are equal</comments>
              <expression xsi:type="expressions:ConditionalExpression">
                <child xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.2/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.3/@variable"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </child>
                <expressionIf xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Subtraction"/>
                  <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </expressionIf>
                <expressionElse xsi:type="literals:DecimalIntegerLiteral" decimalValue="1">
                  <comments>// (-0.0, 0.0) or (!NaN, NaN)</comments>
                </expressionElse>
              </expression>
            </expressionElse>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="2671257302660747028"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** use serialVersionUID from JDK 1.0.2 for interoperability */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>Float&lt;/code> class wraps a value of primitive type&#xA; * &lt;code>float&lt;/code> in an object. An object of type&#xA; * &lt;code>Float&lt;/code> contains a single field whose type is&#xA; * &lt;code>float&lt;/code>.&#xA; * &lt;p>&#xA; * In addition, this class provides several methods for converting a&#xA; * &lt;code>float&lt;/code> to a &lt;code>String&lt;/code> and a&#xA; * &lt;code>String&lt;/code> to a &lt;code>float&lt;/code>, as well as other&#xA; * constants and methods useful when dealing with a&#xA; * &lt;code>float&lt;/code>.&#xA; *&#xA; * @author  Lee Boynton&#xA; * @author  Arthur van Hoff&#xA; * @author  Joseph D. Darcy&#xA; * @version 1.94, 05/11/04&#xA; * @since JDK1.0 &#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Final"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="Comparable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="Number.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
