<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="AbstractStringBuilder.java">
  <comments>/*&#xA; * @(#)AbstractStringBuilder.java&#x9;1.14 05/09/26&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>lang</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>misc</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="AbstractStringBuilder">
    <members xsi:type="members:Field" name="value">
      <typeReference xsi:type="types:Char">
        <comments>/**&#xA;     * The value is used for character storage.&#xA;     */</comments>
      </typeReference>
      <arrayDimensionsAfter/>
    </members>
    <members xsi:type="members:Field" name="count">
      <typeReference xsi:type="types:Int">
        <comments>/** &#xA;     * The count is the number of characters used.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Constructor" name="AbstractStringBuilder">
      <comments>/** &#xA;     * This no-arg constructor is necessary for serialization of subclasses.&#xA;     */</comments>
    </members>
    <members xsi:type="members:Constructor" name="AbstractStringBuilder">
      <comments>/** &#xA;     * Creates an AbstractStringBuilder of the specified capacity.&#xA;     */</comments>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="capacity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:ClassMethod" name="length">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the length (character count).&#xA;     *&#xA;     * @return  the length of the sequence of characters currently &#xA;     *          represented by this object&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="capacity">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current capacity. The capacity is the amount of storage &#xA;     * available for newly inserted characters, beyond which an allocation &#xA;     * will occur.&#xA;     *&#xA;     * @return  the current capacity&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:IdentifierReference"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="ensureCapacity">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="minimumCapacity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Ensures that the capacity is at least equal to the specified minimum.&#xA;     * If the current capacity is less than the argument, then a new internal&#xA;     * array is allocated with greater capacity. The new capacity is the &#xA;     * larger of: &#xA;     * &lt;ul>&#xA;     * &lt;li>The &lt;code>minimumCapacity&lt;/code> argument. &#xA;     * &lt;li>Twice the old capacity, plus &lt;code>2&lt;/code>. &#xA;     * &lt;/ul>&#xA;     * If the &lt;code>minimumCapacity&lt;/code> argument is nonpositive, this&#xA;     * method takes no action and simply returns.&#xA;     *&#xA;     * @param   minimumCapacity   the minimum desired capacity.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="expandCapacity">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * This implements the expansion semantics of ensureCapacity with no&#xA;     * size check or synchronization.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="minimumCapacity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCapacity">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </expression>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
            <multiplicativeOperators xsi:type="operators:Multiplication"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Integer.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="Integer.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newValue">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="trimToSize">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Attempts to reduce storage used for the character sequence.&#xA;     * If the buffer is larger than necessary to hold its current sequence of &#xA;     * characters, then it may be resized to become more space efficient. &#xA;     * Calling this method may, but is not required to, affect the value &#xA;     * returned by a subsequent call to the {@link #capacity()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="newValue">
              <typeReference xsi:type="types:Char"/>
              <arrayDimensionsBefore/>
              <initialValue xsi:type="arrays:ArrayInstantiationBySize">
                <typeReference xsi:type="types:Char"/>
                <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@statement/@statements.0/@variable"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@statement/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setLength">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newLength">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the length of the character sequence.&#xA;     * The sequence is changed to a new character sequence &#xA;     * whose length is specified by the argument. For every nonnegative &#xA;     * index &lt;i>k&lt;/i> less than &lt;code>newLength&lt;/code>, the character at &#xA;     * index &lt;i>k&lt;/i> in the new character sequence is the same as the &#xA;     * character at index &lt;i>k&lt;/i> in the old sequence if &lt;i>k&lt;/i> is less &#xA;     * than the length of the old character sequence; otherwise, it is the &#xA;     * null character &lt;code>'&amp;#92;u0000'&lt;/code>. &#xA;     *  &#xA;     * In other words, if the &lt;code>newLength&lt;/code> argument is less than &#xA;     * the current length, the length is changed to the specified length.&#xA;     * &lt;p>&#xA;     * If the &lt;code>newLength&lt;/code> argument is greater than or equal &#xA;     * to the current length, sufficient null characters &#xA;     * (&lt;code>'&amp;#92;u0000'&lt;/code>) are appended so that &#xA;     * length becomes the &lt;code>newLength&lt;/code> argument. &#xA;     * &lt;p>&#xA;     * The &lt;code>newLength&lt;/code> argument must be greater than or equal &#xA;     * to &lt;code>0&lt;/code>. &#xA;     *&#xA;     * @param      newLength   the new length&#xA;     * @throws     IndexOutOfBoundsException  if the&#xA;     *               &lt;code>newLength&lt;/code> argument is negative.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                  </arraySelectors>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:CharacterLiteral"/>
              </expression>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
            </expression>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="charAt">
      <typeReference xsi:type="types:Char"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>char&lt;/code> value in this sequence at the specified index.&#xA;     * The first &lt;code>char&lt;/code> value is at index &lt;code>0&lt;/code>, the next at index&#xA;     * &lt;code>1&lt;/code>, and so on, as in array indexing.&#xA;     * &lt;p>&#xA;     * The index argument must be greater than or equal to&#xA;     * &lt;code>0&lt;/code>, and less than the length of this sequence.&#xA;     *&#xA;     * &lt;p>If the &lt;code>char&lt;/code> value specified by the index is a&#xA;     * &lt;a href=&quot;Character.html#unicode&quot;>surrogate&lt;/a>, the surrogate&#xA;     * value is returned.&#xA;     *&#xA;     * @param      index   the index of the desired &lt;code>char&lt;/code> value.&#xA;     * @return     the &lt;code>char&lt;/code> value at the specified index.&#xA;     * @throws     IndexOutOfBoundsException  if &lt;code>index&lt;/code> is &#xA;     *             negative or greater than or equal to &lt;code>length()&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <arraySelectors>
            <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          </arraySelectors>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointAt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the character (Unicode code point) at the specified&#xA;     * index. The index refers to &lt;code>char&lt;/code> values&#xA;     * (Unicode code units) and ranges from &lt;code>0&lt;/code> to&#xA;     * {@link #length()}&lt;code> - 1&lt;/code>.&#xA;     *&#xA;     * &lt;p> If the &lt;code>char&lt;/code> value specified at the given index&#xA;     * is in the high-surrogate range, the following index is less&#xA;     * than the length of this sequence, and the&#xA;     * &lt;code>char&lt;/code> value at the following index is in the&#xA;     * low-surrogate range, then the supplementary code point&#xA;     * corresponding to this surrogate pair is returned. Otherwise,&#xA;     * the &lt;code>char&lt;/code> value at the given index is returned.&#xA;     *&#xA;     * @param      index the index to the &lt;code>char&lt;/code> values&#xA;     * @return     the code point value of the character at the&#xA;     *             &lt;code>index&lt;/code>&#xA;     * @exception  IndexOutOfBoundsException  if the &lt;code>index&lt;/code>&#xA;     *             argument is negative or not less than the length of this&#xA;     *             sequence.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.86"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointBefore">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the character (Unicode code point) before the specified&#xA;     * index. The index refers to &lt;code>char&lt;/code> values&#xA;     * (Unicode code units) and ranges from &lt;code>1&lt;/code> to {@link&#xA;     * #length()}.&#xA;     *&#xA;     * &lt;p> If the &lt;code>char&lt;/code> value at &lt;code>(index - 1)&lt;/code>&#xA;     * is in the low-surrogate range, &lt;code>(index - 2)&lt;/code> is not&#xA;     * negative, and the &lt;code>char&lt;/code> value at &lt;code>(index -&#xA;     * 2)&lt;/code> is in the high-surrogate range, then the&#xA;     * supplementary code point value of the surrogate pair is&#xA;     * returned. If the &lt;code>char&lt;/code> value at &lt;code>index -&#xA;     * 1&lt;/code> is an unpaired low-surrogate or a high-surrogate, the&#xA;     * surrogate value is returned.&#xA;     *&#xA;     * @param     index the index following the code point that should be returned&#xA;     * @return    the Unicode code point value before the given index.&#xA;     * @exception IndexOutOfBoundsException if the &lt;code>index&lt;/code>&#xA;     *            argument is less than 1 or greater than the length&#xA;     *            of this sequence.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.90"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointCount">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="beginIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="endIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the number of Unicode code points in the specified text&#xA;     * range of this sequence. The text range begins at the specified&#xA;     * &lt;code>beginIndex&lt;/code> and extends to the &lt;code>char&lt;/code> at&#xA;     * index &lt;code>endIndex - 1&lt;/code>. Thus the length (in&#xA;     * &lt;code>char&lt;/code>s) of the text range is&#xA;     * &lt;code>endIndex-beginIndex&lt;/code>. Unpaired surrogates within&#xA;     * this sequence count as one code point each.&#xA;     *&#xA;     * @param beginIndex the index to the first &lt;code>char&lt;/code> of&#xA;     * the text range.&#xA;     * @param endIndex the index after the last &lt;code>char&lt;/code> of&#xA;     * the text range.&#xA;     * @return the number of Unicode code points in the specified text&#xA;     * range&#xA;     * @exception IndexOutOfBoundsException if the&#xA;     * &lt;code>beginIndex&lt;/code> is negative, or &lt;code>endIndex&lt;/code>&#xA;     * is larger than the length of this sequence, or&#xA;     * &lt;code>beginIndex&lt;/code> is larger than &lt;code>endIndex&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.98"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="offsetByCodePoints">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePointOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this sequence that is offset from the&#xA;     * given &lt;code>index&lt;/code> by &lt;code>codePointOffset&lt;/code> code&#xA;     * points. Unpaired surrogates within the text range given by&#xA;     * &lt;code>index&lt;/code> and &lt;code>codePointOffset&lt;/code> count as&#xA;     * one code point each.&#xA;     *&#xA;     * @param index the index to be offset&#xA;     * @param codePointOffset the offset in code points&#xA;     * @return the index within this sequence&#xA;     * @exception IndexOutOfBoundsException if &lt;code>index&lt;/code>&#xA;     *   is negative or larger then the length of this sequence,&#xA;     *   or if &lt;code>codePointOffset&lt;/code> is positive and the subsequence&#xA;     *   starting with &lt;code>index&lt;/code> has fewer than&#xA;     *   &lt;code>codePointOffset&lt;/code> code points,&#xA;     *   or if &lt;code>codePointOffset&lt;/code> is negative and the subsequence&#xA;     *   before &lt;code>index&lt;/code> has fewer than the absolute value of&#xA;     *   &lt;code>codePointOffset&lt;/code> code points.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.101"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getChars">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="srcBegin">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="srcEnd">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dstBegin">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Characters are copied from this sequence into the &#xA;     * destination character array &lt;code>dst&lt;/code>. The first character to &#xA;     * be copied is at index &lt;code>srcBegin&lt;/code>; the last character to &#xA;     * be copied is at index &lt;code>srcEnd-1&lt;/code>. The total number of &#xA;     * characters to be copied is &lt;code>srcEnd-srcBegin&lt;/code>. The &#xA;     * characters are copied into the subarray of &lt;code>dst&lt;/code> starting &#xA;     * at index &lt;code>dstBegin&lt;/code> and ending at index:&#xA;     * &lt;p>&lt;blockquote>&lt;pre>&#xA;     * dstbegin + (srcEnd-srcBegin) - 1&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @param      srcBegin   start copying at this offset.&#xA;     * @param      srcEnd     stop copying at this offset.&#xA;     * @param      dst        the array to copy the data into.&#xA;     * @param      dstBegin   offset into &lt;code>dst&lt;/code>.&#xA;     * @throws     NullPointerException if &lt;code>dst&lt;/code> is &#xA;     *             &lt;code>null&lt;/code>.&#xA;     * @throws     IndexOutOfBoundsException  if any of the following is true:&#xA;     *             &lt;ul>&#xA;     *             &lt;li>&lt;code>srcBegin&lt;/code> is negative&#xA;     *             &lt;li>&lt;code>dstBegin&lt;/code> is negative&#xA;     *             &lt;li>the &lt;code>srcBegin&lt;/code> argument is greater than &#xA;     *             the &lt;code>srcEnd&lt;/code> argument.&#xA;     *             &lt;li>&lt;code>srcEnd&lt;/code> is greater than &#xA;     *             &lt;code>this.length()&lt;/code>.&#xA;     *             &lt;li>&lt;code>dstBegin+srcEnd-srcBegin&lt;/code> is greater than &#xA;     *             &lt;code>dst.length&lt;/code>&#xA;     *             &lt;/ul>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="srcBegin > srcEnd"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.3"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setCharAt">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The character at the specified index is set to &lt;code>ch&lt;/code>. This &#xA;     * sequence is altered to represent a new character sequence that is &#xA;     * identical to the old character sequence, except that it contains the &#xA;     * character &lt;code>ch&lt;/code> at position &lt;code>index&lt;/code>. &#xA;     * &lt;p>&#xA;     * The index argument must be greater than or equal to &#xA;     * &lt;code>0&lt;/code>, and less than the length of this sequence. &#xA;     *&#xA;     * @param      index   the index of the character to modify.&#xA;     * @param      ch      the new character.&#xA;     * @throws     IndexOutOfBoundsException  if &lt;code>index&lt;/code> is &#xA;     *             negative or greater than or equal to &lt;code>length()&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the string representation of the &lt;code>Object&lt;/code> &#xA;     * argument.&#xA;     * &lt;p>&#xA;     * The argument is converted to a string as if by the method &#xA;     * &lt;code>String.valueOf&lt;/code>, and the characters of that &#xA;     * string are then appended to this sequence.&#xA;     *&#xA;     * @param   obj   an &lt;code>Object&lt;/code>.&#xA;     * @return  a reference to this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.76"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the specified string to this character sequence.&#xA;     * &lt;p>&#xA;     * The characters of the &lt;code>String&lt;/code> argument are appended, in &#xA;     * order, increasing the length of this sequence by the length of the &#xA;     * argument. If &lt;code>str&lt;/code> is &lt;code>null&lt;/code>, then the four &#xA;     * characters &lt;code>&quot;null&quot;&lt;/code> are appended.&#xA;     * &lt;p>&#xA;     * Let &lt;i>n&lt;/i> be the length of this character sequence just prior to &#xA;     * execution of the &lt;code>append&lt;/code> method. Then the character at &#xA;     * index &lt;i>k&lt;/i> in the new character sequence is equal to the character &#xA;     * at index &lt;i>k&lt;/i> in the old character sequence, if &lt;i>k&lt;/i> is less &#xA;     * than &lt;i>n&lt;/i>; otherwise, it is equal to the character at index &#xA;     * &lt;i>k-n&lt;/i> in the argument &lt;code>str&lt;/code>.&#xA;     *&#xA;     * @param   str   a string.&#xA;     * @return  a reference to this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:StringReference" value="null"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCount">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.29"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sb">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Documentation in subclasses because of synchro difference</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
            <arguments xsi:type="references:StringReference" value="null"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="StringBuffer.class.xmi#//@classifiers.0/@members.6"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCount">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StringBuffer.class.xmi#//@classifiers.0/@members.16"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Documentation in subclasses because of synchro difference</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:StringReference" value="null"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
              <arguments xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
              </arguments>
            </next>
            <self xsi:type="literals:This"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
              <arguments xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="StringBuffer.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
              </arguments>
            </next>
            <self xsi:type="literals:This"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.21">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </arguments>
          </next>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="end">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends a subsequence of the specified &lt;code>CharSequence&lt;/code> to this&#xA;     * sequence.&#xA;     * &lt;p>&#xA;     * Characters of the argument &lt;code>s&lt;/code>, starting at&#xA;     * index &lt;code>start&lt;/code>, are appended, in order, to the contents of&#xA;     * this sequence up to the (exclusive) index &lt;code>end&lt;/code>. The length&#xA;     * of this sequence is increased by the value of &lt;code>end - start&lt;/code>.&#xA;     * &lt;p>&#xA;     * Let &lt;i>n&lt;/i> be the length of this character sequence just prior to&#xA;     * execution of the &lt;code>append&lt;/code> method. Then the character at&#xA;     * index &lt;i>k&lt;/i> in this character sequence becomes equal to the&#xA;     * character at index &lt;i>k&lt;/i> in this sequence, if &lt;i>k&lt;/i> is less than&#xA;     * &lt;i>n&lt;/i>; otherwise, it is equal to the character at index &#xA;     * &lt;i>k+start-n&lt;/i> in the argument &lt;code>s&lt;/code>.&#xA;     * &lt;p>&#xA;     * If &lt;code>s&lt;/code> is &lt;code>null&lt;/code>, then this method appends&#xA;     * characters as if the s parameter was a sequence containing the four&#xA;     * characters &lt;code>&quot;null&quot;&lt;/code>.&#xA;     *&#xA;     * @param   s the sequence to append.&#xA;     * @param   start   the starting index of the subsequence to be appended.&#xA;     * @param   end     the end index of the subsequence to be appended.&#xA;     * @return  a reference to this object.&#xA;     * @throws     IndexOutOfBoundsException if&#xA;     *                  &lt;code>start&lt;/code> or &lt;code>end&lt;/code> are negative, or&#xA;     *             &lt;code>start&lt;/code> is greater than &lt;code>end&lt;/code> or&#xA;     *             &lt;code>end&lt;/code> is greater than &lt;code>s.length()&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:StringReference" value="null"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="start "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
              <children xsi:type="references:StringReference" value=", end "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
              <children xsi:type="references:StringReference" value=", s.length() "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </children>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.2/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCount">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.2/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.4/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.4/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <arraySelectors>
                <position xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </position>
              </arraySelectors>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.1"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.6/@init"/>
              </next>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.6/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.6/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.4/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the string representation of the &lt;code>char&lt;/code> array &#xA;     * argument to this sequence. &#xA;     * &lt;p>&#xA;     * The characters of the array argument are appended, in order, to &#xA;     * the contents of this sequence. The length of this sequence&#xA;     * increases by the length of the argument. &#xA;     * &lt;p>&#xA;     * The overall effect is exactly as if the argument were converted to &#xA;     * a string by the method {@link String#valueOf(char[])} and the &#xA;     * characters of that string were then {@link #append(String) appended} &#xA;     * to this character sequence.&#xA;     *&#xA;     * @param   str   the characters to be appended.&#xA;     * @return  a reference to this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCount">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
              <next xsi:type="references:IdentifierReference"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the string representation of a subarray of the&#xA;     * &lt;code>char&lt;/code> array argument to this sequence.&#xA;     * &lt;p>&#xA;     * Characters of the &lt;code>char&lt;/code> array &lt;code>str&lt;/code>, starting at&#xA;     * index &lt;code>offset&lt;/code>, are appended, in order, to the contents&#xA;     * of this sequence. The length of this sequence increases&#xA;     * by the value of &lt;code>len&lt;/code>.&#xA;     * &lt;p>&#xA;     * The overall effect is exactly as if the arguments were converted to&#xA;     * a string by the method {@link String#valueOf(char[],int,int)} and the&#xA;     * characters of that string were then {@link #append(String) appended}&#xA;     * to this character sequence.&#xA;     *&#xA;     * @param   str      the characters to be appended.&#xA;     * @param   offset   the index of the first &lt;code>char&lt;/code> to append.&#xA;     * @param   len      the number of &lt;code>char&lt;/code>s to append.&#xA;     * @return  a reference to this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCount">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the string representation of the &lt;code>boolean&lt;/code> &#xA;     * argument to the sequence.&#xA;     * &lt;p>&#xA;     * The argument is converted to a string as if by the method &#xA;     * &lt;code>String.valueOf&lt;/code>, and the characters of that &#xA;     * string are then appended to this sequence. &#xA;     *&#xA;     * @param   b   a &lt;code>boolean&lt;/code>.&#xA;     * @return  a reference to this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="newCount">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@statement/@statements.0/@variable"/>
              </expression>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:CharacterLiteral" value="116"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:CharacterLiteral" value="114"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:CharacterLiteral" value="117"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:CharacterLiteral" value="101"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="newCount">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@elseStatement/@statements.0/@variable"/>
              </expression>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@elseStatement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:CharacterLiteral" value="102"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:CharacterLiteral" value="97"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:CharacterLiteral" value="108"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:CharacterLiteral" value="115"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:CharacterLiteral" value="101"/>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the string representation of the &lt;code>char&lt;/code> &#xA;     * argument to this sequence. &#xA;     * &lt;p>&#xA;     * The argument is appended to the contents of this sequence. &#xA;     * The length of this sequence increases by &lt;code>1&lt;/code>. &#xA;     * &lt;p>&#xA;     * The overall effect is exactly as if the argument were converted to &#xA;     * a string by the method {@link String#valueOf(char)} and the character &#xA;     * in that string were then {@link #append(String) appended} to this &#xA;     * character sequence.&#xA;     *&#xA;     * @param   c   a &lt;code>char&lt;/code>.&#xA;     * @return  a reference to this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCount">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <arraySelectors>
              <position xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <operator xsi:type="operators:PlusPlus"/>
              </position>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the string representation of the &lt;code>int&lt;/code> &#xA;     * argument to this sequence. &#xA;     * &lt;p>&#xA;     * The argument is converted to a string as if by the method &#xA;     * &lt;code>String.valueOf&lt;/code>, and the characters of that &#xA;     * string are then appended to this sequence. &#xA;     *&#xA;     * @param   i   an &lt;code>int&lt;/code>.&#xA;     * @return  a reference to this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
              <arguments xsi:type="references:StringReference" value="-2147483648"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Integer.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="Integer.class.xmi#//@classifiers.0"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="appendedLength">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </expression>
            </child>
            <expressionIf xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
                <arguments xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Subtraction"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
                </arguments>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </expressionIf>
            <expressionElse xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
            </expressionElse>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="spaceNeeded">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.1/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.2/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.2/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Integer.class.xmi#//@classifiers.0/@members.16"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.2/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="Integer.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.2/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="sizeTable">
      <initialValue xsi:type="arrays:ArrayInstantiationByValues">
        <arrayInitializer>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="99"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="999"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="9999"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="99999"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="999999"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="9999999"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="99999999"/>
          <initialValues xsi:type="literals:DecimalIntegerLiteral" decimalValue="999999999"/>
          <initialValues xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Integer.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="Integer.class.xmi#//@classifiers.0"/>
          </initialValues>
        </arrayInitializer>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="stringSizeOfInt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>// Requires positive x</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@init"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </returnValue>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@init"/>
              </arraySelectors>
            </children>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </condition>
        </statement>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the string representation of the &lt;code>long&lt;/code> &#xA;     * argument to this sequence.&#xA;     * &lt;p>&#xA;     * The argument is converted to a string as if by the method &#xA;     * &lt;code>String.valueOf&lt;/code>, and the characters of that &#xA;     * string are then appended to this sequence.&#xA;     *&#xA;     * @param   l   a &lt;code>long&lt;/code>.&#xA;     * @return  a reference to this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
              <arguments xsi:type="references:StringReference" value="-9223372036854775808"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Long.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="Long.class.xmi#//@classifiers.0"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="appendedLength">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </expression>
            </child>
            <expressionIf xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.30">
                <arguments xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Subtraction"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
                </arguments>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </expressionIf>
            <expressionElse xsi:type="references:MethodCall" target="//@classifiers.0/@members.30">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
            </expressionElse>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="spaceNeeded">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.2/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.2/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Long.class.xmi#//@classifiers.0/@members.12"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.2/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="Long.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.2/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="stringSizeOfLong">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>// Requires positive x</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.1/@init"/>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.1/@init"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="19"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.1/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="19"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the string representation of the &lt;code>float&lt;/code> &#xA;     * argument to this sequence.&#xA;     * &lt;p>&#xA;     * The argument is converted to a string as if by the method &#xA;     * &lt;code>String.valueOf&lt;/code>, and the characters of that &#xA;     * string are then appended to this string sequence.&#xA;     *&#xA;     * @param   f   a &lt;code>float&lt;/code>.&#xA;     * @return  a reference to this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0/@members.68"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the string representation of the &lt;code>double&lt;/code> &#xA;     * argument to this sequence.&#xA;     * &lt;p>&#xA;     * The argument is converted to a string as if by the method &#xA;     * &lt;code>String.valueOf&lt;/code>, and the characters of that &#xA;     * string are then appended to this sequence.&#xA;     *&#xA;     * @param   d   a &lt;code>double&lt;/code>.&#xA;     * @return  a reference to this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../sun/misc/FloatingDecimal.class.xmi#//@classifiers.0/@members.68"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="delete">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="end">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes the characters in a substring of this sequence.&#xA;     * The substring begins at the specified &lt;code>start&lt;/code> and extends to&#xA;     * the character at index &lt;code>end - 1&lt;/code> or to the end of the&#xA;     * sequence if no such character exists. If&#xA;     * &lt;code>start&lt;/code> is equal to &lt;code>end&lt;/code>, no changes are made.&#xA;     *&#xA;     * @param      start  The beginning index, inclusive.&#xA;     * @param      end    The ending index, exclusive.&#xA;     * @return     This object.&#xA;     * @throws     StringIndexOutOfBoundsException  if &lt;code>start&lt;/code>&#xA;     *             is negative, greater than &lt;code>length()&lt;/code>, or&#xA;     *&#x9;&#x9;   greater than &lt;code>end&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.1"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.3/@variable"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.1"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:AssignmentMinus"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.3/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.3/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendCodePoint">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the string representation of the &lt;code>codePoint&lt;/code>&#xA;     * argument to this sequence.&#xA;     *&#xA;     * &lt;p> The argument is appended to the contents of this sequence.&#xA;     * The length of this sequence increases by&#xA;     * {@link Character#charCount(int) Character.charCount(codePoint)}.&#xA;     *&#xA;     * &lt;p> The overall effect is exactly as if the argument were&#xA;     * converted to a &lt;code>char&lt;/code> array by the method {@link&#xA;     * Character#toChars(int)} and the character in that array were&#xA;     * then {@link #append(char[]) appended} to this character&#xA;     * sequence.&#xA;     *&#xA;     * @param   codePoint   a Unicode code point&#xA;     * @return  a reference to this object.&#xA;     * @exception IllegalArgumentException if the specified&#xA;     * &lt;code>codePoint&lt;/code> isn't a valid Unicode code point&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.78"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.62"/>
            </next>
            <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCount">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.3/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.3/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Char"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.95"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:AssignmentPlus"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable"/>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="deleteCharAt">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes the &lt;code>char&lt;/code> at the specified position in this&#xA;     * sequence. This sequence is shortened by one &lt;code>char&lt;/code>.&#xA;     *&#xA;     * &lt;p>Note: If the character at the given index is a supplementary&#xA;     * character, this method does not remove the entire character. If&#xA;     * correct handling of supplementary characters is required,&#xA;     * determine the number of &lt;code>char&lt;/code>s to remove by calling&#xA;     * &lt;code>Character.charCount(thisSequence.codePointAt(index))&lt;/code>,&#xA;     * where &lt;code>thisSequence&lt;/code> is this sequence.&#xA;     *&#xA;     * @param       index  Index of &lt;code>char&lt;/code> to remove&#xA;     * @return      This object.&#xA;     * @throws      StringIndexOutOfBoundsException  if the &lt;code>index&lt;/code>&#xA;     *&#x9;&#x9;    is negative or greater than or equal to&#xA;     *&#x9;&#x9;    &lt;code>length()&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <operator xsi:type="operators:MinusMinus"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="replace">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="end">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Replaces the characters in a substring of this sequence&#xA;     * with characters in the specified &lt;code>String&lt;/code>. The substring&#xA;     * begins at the specified &lt;code>start&lt;/code> and extends to the character&#xA;     * at index &lt;code>end - 1&lt;/code> or to the end of the&#xA;     * sequence if no such character exists. First the&#xA;     * characters in the substring are removed and then the specified&#xA;     * &lt;code>String&lt;/code> is inserted at &lt;code>start&lt;/code>. (This &#xA;     * sequence will be lengthened to accommodate the&#xA;     * specified String if necessary.)&#xA;     * &#xA;     * @param      start    The beginning index, inclusive.&#xA;     * @param      end      The ending index, exclusive.&#xA;     * @param      str   String that will replace previous contents.&#xA;     * @return     This object.&#xA;     * @throws     StringIndexOutOfBoundsException  if &lt;code>start&lt;/code>&#xA;     *             is negative, greater than &lt;code>length()&lt;/code>, or&#xA;     *&#x9;&#x9;   greater than &lt;code>end&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="start > length()"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="start > end"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.2">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCount">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.5/@variable"/>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </expression>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.6/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.6/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.5/@variable"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.2">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.28"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.6/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="substring">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a new &lt;code>String&lt;/code> that contains a subsequence of&#xA;     * characters currently contained in this character sequence. The &#xA;     * substring begins at the specified index and extends to the end of&#xA;     * this sequence.&#xA;     * &#xA;     * @param      start    The beginning index, inclusive.&#xA;     * @return     The new string.&#xA;     * @throws     StringIndexOutOfBoundsException  if &lt;code>start&lt;/code> is&#xA;     *             less than zero, or greater than the length of this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.39">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="subSequence">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="end">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a new character sequence that is a subsequence of this sequence.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form&#xA;     *&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * sb.subSequence(begin,&amp;nbsp;end)&lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * behaves in exactly the same way as the invocation&#xA;     *&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * sb.substring(begin,&amp;nbsp;end)&lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * This method is provided so that this class can&#xA;     * implement the {@link CharSequence} interface. &lt;/p>&#xA;     *&#xA;     * @param      start   the start index, inclusive.&#xA;     * @param      end     the end index, exclusive.&#xA;     * @return     the specified subsequence.&#xA;     *&#xA;     * @throws  IndexOutOfBoundsException&#xA;     *          if &lt;tt>start&lt;/tt> or &lt;tt>end&lt;/tt> are negative,&#xA;     *          if &lt;tt>end&lt;/tt> is greater than &lt;tt>length()&lt;/tt>,&#xA;     *          or if &lt;tt>start&lt;/tt> is greater than &lt;tt>end&lt;/tt>&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.39">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="substring">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="end">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a new &lt;code>String&lt;/code> that contains a subsequence of&#xA;     * characters currently contained in this sequence. The &#xA;     * substring begins at the specified &lt;code>start&lt;/code> and &#xA;     * extends to the character at index &lt;code>end - 1&lt;/code>.&#xA;     *&#xA;     * @param      start    The beginning index, inclusive.&#xA;     * @param      end      The ending index, exclusive.&#xA;     * @return     The new string.&#xA;     * @throws     StringIndexOutOfBoundsException  if &lt;code>start&lt;/code>&#xA;     *             or &lt;code>end&lt;/code> are negative or greater than&#xA;     *&#x9;&#x9;   &lt;code>length()&lt;/code>, or &lt;code>start&lt;/code> is&#xA;     *&#x9;&#x9;   greater than &lt;code>end&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="insert">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts the string representation of a subarray of the &lt;code>str&lt;/code>&#xA;     * array argument into this sequence. The subarray begins at the&#xA;     * specified &lt;code>offset&lt;/code> and extends &lt;code>len&lt;/code> &lt;code>char&lt;/code>s.&#xA;     * The characters of the subarray are inserted into this sequence at&#xA;     * the position indicated by &lt;code>index&lt;/code>. The length of this&#xA;     * sequence increases by &lt;code>len&lt;/code> &lt;code>char&lt;/code>s.&#xA;     *&#xA;     * @param      index    position at which to insert subarray.&#xA;     * @param      str       A &lt;code>char&lt;/code> array.&#xA;     * @param      offset   the index of the first &lt;code>char&lt;/code> in subarray to&#xA;     *             be inserted.&#xA;     * @param      len      the number of &lt;code>char&lt;/code>s in the subarray to&#xA;     *             be inserted.&#xA;     * @return     This object&#xA;     * @throws     StringIndexOutOfBoundsException  if &lt;code>index&lt;/code>&#xA;     *             is negative or greater than &lt;code>length()&lt;/code>, or&#xA;     *             &lt;code>offset&lt;/code> or &lt;code>len&lt;/code> are negative, or&#xA;     *             &lt;code>(offset+len)&lt;/code> is greater than&#xA;     *             &lt;code>str.length&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="offset "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.2"/>
              <children xsi:type="references:StringReference" value=", len "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.3"/>
              <children xsi:type="references:StringReference" value=", str.length "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.2"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.3"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.2"/>
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.3"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCount">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.3"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.2/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.2/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.3"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.3"/>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.2/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="insert">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts the string representation of the &lt;code>Object&lt;/code> &#xA;     * argument into this character sequence.&#xA;     * &lt;p>&#xA;     * The second argument is converted to a string as if by the method &#xA;     * &lt;code>String.valueOf&lt;/code>, and the characters of that &#xA;     * string are then inserted into this sequence at the indicated &#xA;     * offset. &#xA;     * &lt;p>&#xA;     * The offset argument must be greater than or equal to &#xA;     * &lt;code>0&lt;/code>, and less than or equal to the length of this &#xA;     * sequence.&#xA;     *&#xA;     * @param      offset   the offset.&#xA;     * @param      obj      an &lt;code>Object&lt;/code>.&#xA;     * @return     a reference to this object.&#xA;     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.76"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="insert">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts the string into this character sequence.&#xA;     * &lt;p>&#xA;     * The characters of the &lt;code>String&lt;/code> argument are inserted, in &#xA;     * order, into this sequence at the indicated offset, moving up any &#xA;     * characters originally above that position and increasing the length &#xA;     * of this sequence by the length of the argument. If &#xA;     * &lt;code>str&lt;/code> is &lt;code>null&lt;/code>, then the four characters &#xA;     * &lt;code>&quot;null&quot;&lt;/code> are inserted into this sequence.&#xA;     * &lt;p>&#xA;     * The character at index &lt;i>k&lt;/i> in the new character sequence is &#xA;     * equal to:&#xA;     * &lt;ul>&#xA;     * &lt;li>the character at index &lt;i>k&lt;/i> in the old character sequence, if &#xA;     * &lt;i>k&lt;/i> is less than &lt;code>offset&lt;/code> &#xA;     * &lt;li>the character at index &lt;i>k&lt;/i>&lt;code>-offset&lt;/code> in the &#xA;     * argument &lt;code>str&lt;/code>, if &lt;i>k&lt;/i> is not less than &#xA;     * &lt;code>offset&lt;/code> but is less than &lt;code>offset+str.length()&lt;/code> &#xA;     * &lt;li>the character at index &lt;i>k&lt;/i>&lt;code>-str.length()&lt;/code> in the &#xA;     * old character sequence, if &lt;i>k&lt;/i> is not less than &#xA;     * &lt;code>offset+str.length()&lt;/code>&#xA;     * &lt;/ul>&lt;p>&#xA;     * The offset argument must be greater than or equal to &#xA;     * &lt;code>0&lt;/code>, and less than or equal to the length of this &#xA;     * sequence.&#xA;     *&#xA;     * @param      offset   the offset.&#xA;     * @param      str      a string.&#xA;     * @return     a reference to this object.&#xA;     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.1"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:StringReference" value="null"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCount">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.2/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.3/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.3/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.2/@variable"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.28"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.3/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="insert">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts the string representation of the &lt;code>char&lt;/code> array &#xA;     * argument into this sequence.&#xA;     * &lt;p>&#xA;     * The characters of the array argument are inserted into the &#xA;     * contents of this sequence at the position indicated by &#xA;     * &lt;code>offset&lt;/code>. The length of this sequence increases by &#xA;     * the length of the argument. &#xA;     * &lt;p>&#xA;     * The overall effect is exactly as if the argument were converted to &#xA;     * a string by the method {@link String#valueOf(char[])} and the &#xA;     * characters of that string were then &#xA;     * {@link #insert(int,String) inserted} into this &#xA;     * character sequence at the position indicated by&#xA;     * &lt;code>offset&lt;/code>.&#xA;     *&#xA;     * @param      offset   the offset.&#xA;     * @param      str      a character array.&#xA;     * @return     a reference to this object.&#xA;     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.1">
            <next xsi:type="references:IdentifierReference"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCount">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.1/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.2/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.2/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.1/@variable"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.1"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.1/@variable"/>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.2/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="insert">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dstOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts the specified &lt;code>CharSequence&lt;/code> into this sequence.&#xA;     * &lt;p>&#xA;     * The characters of the &lt;code>CharSequence&lt;/code> argument are inserted,&#xA;     * in order, into this sequence at the indicated offset, moving up&#xA;     * any characters originally above that position and increasing the length &#xA;     * of this sequence by the length of the argument s.&#xA;     * &lt;p>&#xA;     * The result of this method is exactly the same as if it were an&#xA;     * invocation of this object's insert(dstOffset, s, 0, s.length()) method.&#xA;     *&#xA;     * &lt;p>If &lt;code>s&lt;/code> is &lt;code>null&lt;/code>, then the four characters &#xA;     * &lt;code>&quot;null&quot;&lt;/code> are inserted into this sequence.&#xA;     *&#xA;     * @param      dstOffset   the offset.&#xA;     * @param      s the sequence to be inserted&#xA;     * @return     a reference to this object.&#xA;     * @throws     IndexOutOfBoundsException  if the offset is invalid.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.1"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:StringReference" value="null"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.42">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
              <arguments xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.1"/>
              </arguments>
            </next>
            <self xsi:type="literals:This"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.1"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.45">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.1"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </arguments>
          </next>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="insert">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dstOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="end">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts a subsequence of the specified &lt;code>CharSequence&lt;/code> into&#xA;     * this sequence.&#xA;     * &lt;p>&#xA;     * The subsequence of the argument &lt;code>s&lt;/code> specified by&#xA;     * &lt;code>start&lt;/code> and &lt;code>end&lt;/code> are inserted,&#xA;     * in order, into this sequence at the specified destination offset, moving&#xA;     * up any characters originally above that position. The length of this&#xA;     * sequence is increased by &lt;code>end - start&lt;/code>.&#xA;     * &lt;p>&#xA;     * The character at index &lt;i>k&lt;/i> in this sequence becomes equal to:&#xA;     * &lt;ul>&#xA;     * &lt;li>the character at index &lt;i>k&lt;/i> in this sequence, if&#xA;     * &lt;i>k&lt;/i> is less than &lt;code>dstOffset&lt;/code>&#xA;     * &lt;li>the character at index &lt;i>k&lt;/i>&lt;code>+start-dstOffset&lt;/code> in&#xA;     * the argument &lt;code>s&lt;/code>, if &lt;i>k&lt;/i> is greater than or equal to&#xA;     * &lt;code>dstOffset&lt;/code> but is less than &lt;code>dstOffset+end-start&lt;/code>&#xA;     * &lt;li>the character at index &lt;i>k&lt;/i>&lt;code>-(end-start)&lt;/code> in this&#xA;     * sequence, if &lt;i>k&lt;/i> is greater than or equal to&#xA;     * &lt;code>dstOffset+end-start&lt;/code>&#xA;     * &lt;/ul>&lt;p>&#xA;     * The dstOffset argument must be greater than or equal to&#xA;     * &lt;code>0&lt;/code>, and less than or equal to the length of this&#xA;     * sequence.&#xA;     * &lt;p>The start argument must be nonnegative, and not greater than&#xA;     * &lt;code>end&lt;/code>.&#xA;     * &lt;p>The end argument must be greater than or equal to&#xA;     * &lt;code>start&lt;/code>, and less than or equal to the length of s.&#xA;     *&#xA;     * &lt;p>If &lt;code>s&lt;/code> is &lt;code>null&lt;/code>, then this method inserts&#xA;     * characters as if the s parameter was a sequence containing the four&#xA;     * characters &lt;code>&quot;null&quot;&lt;/code>.&#xA;     *&#xA;     * @param      dstOffset   the offset in this sequence.&#xA;     * @param      s       the sequence to be inserted.&#xA;     * @param      start   the starting index of the subsequence to be inserted.&#xA;     * @param      end     the end index of the subsequence to be inserted.&#xA;     * @return     a reference to this object.&#xA;     * @throws     IndexOutOfBoundsException  if &lt;code>dstOffset&lt;/code>&#xA;     *             is negative or greater than &lt;code>this.length()&lt;/code>, or&#xA;     *              &lt;code>start&lt;/code> or &lt;code>end&lt;/code> are negative, or&#xA;     *              &lt;code>start&lt;/code> is greater than &lt;code>end&lt;/code> or&#xA;     *              &lt;code>end&lt;/code> is greater than &lt;code>s.length()&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.1"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:StringReference" value="null"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="dstOffset "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
              <children xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
                <self xsi:type="literals:This"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="start "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.2"/>
              <children xsi:type="references:StringReference" value=", end "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.3"/>
              <children xsi:type="references:StringReference" value=", s.length() "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </children>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.2"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.3"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.2"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.3"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.3"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.3"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.2"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.3/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCount">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.3/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.5/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.5/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.3/@variable"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <arraySelectors>
                <position xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </position>
              </arraySelectors>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.1"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.8/@init"/>
              </next>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.8/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.3"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.2"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.8/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.5/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="insert">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts the string representation of the &lt;code>boolean&lt;/code> &#xA;     * argument into this sequence. &#xA;     * &lt;p>&#xA;     * The second argument is converted to a string as if by the method &#xA;     * &lt;code>String.valueOf&lt;/code>, and the characters of that &#xA;     * string are then inserted into this sequence at the indicated &#xA;     * offset. &#xA;     * &lt;p>&#xA;     * The offset argument must be greater than or equal to &#xA;     * &lt;code>0&lt;/code>, and less than or equal to the length of this &#xA;     * sequence. &#xA;     *&#xA;     * @param      offset   the offset.&#xA;     * @param      b        a &lt;code>boolean&lt;/code>.&#xA;     * @return     a reference to this object.&#xA;     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.81"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="insert">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts the string representation of the &lt;code>char&lt;/code> &#xA;     * argument into this sequence. &#xA;     * &lt;p>&#xA;     * The second argument is inserted into the contents of this sequence&#xA;     * at the position indicated by &lt;code>offset&lt;/code>. The length &#xA;     * of this sequence increases by one. &#xA;     * &lt;p>&#xA;     * The overall effect is exactly as if the argument were converted to &#xA;     * a string by the method {@link String#valueOf(char)} and the character &#xA;     * in that string were then {@link #insert(int, String) inserted} into &#xA;     * this character sequence at the position indicated by&#xA;     * &lt;code>offset&lt;/code>.&#xA;     * &lt;p>&#xA;     * The offset argument must be greater than or equal to &#xA;     * &lt;code>0&lt;/code>, and less than or equal to the length of this &#xA;     * sequence. &#xA;     *&#xA;     * @param      offset   the offset.&#xA;     * @param      c        a &lt;code>char&lt;/code>.&#xA;     * @return     a reference to this object.&#xA;     * @throws     IndexOutOfBoundsException  if the offset is invalid.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCount">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.0/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.0/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="insert">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts the string representation of the second &lt;code>int&lt;/code> &#xA;     * argument into this sequence. &#xA;     * &lt;p>&#xA;     * The second argument is converted to a string as if by the method &#xA;     * &lt;code>String.valueOf&lt;/code>, and the characters of that &#xA;     * string are then inserted into this sequence at the indicated &#xA;     * offset. &#xA;     * &lt;p>&#xA;     * The offset argument must be greater than or equal to &#xA;     * &lt;code>0&lt;/code>, and less than or equal to the length of this &#xA;     * sequence. &#xA;     *&#xA;     * @param      offset   the offset.&#xA;     * @param      i        an &lt;code>int&lt;/code>.&#xA;     * @return     a reference to this object.&#xA;     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.83"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="insert">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts the string representation of the &lt;code>long&lt;/code> &#xA;     * argument into this sequence. &#xA;     * &lt;p>&#xA;     * The second argument is converted to a string as if by the method &#xA;     * &lt;code>String.valueOf&lt;/code>, and the characters of that &#xA;     * string are then inserted into this sequence at the position &#xA;     * indicated by &lt;code>offset&lt;/code>. &#xA;     * &lt;p>&#xA;     * The offset argument must be greater than or equal to &#xA;     * &lt;code>0&lt;/code>, and less than or equal to the length of this &#xA;     * sequence. &#xA;     *&#xA;     * @param      offset   the offset.&#xA;     * @param      l        a &lt;code>long&lt;/code>.&#xA;     * @return     a reference to this object.&#xA;     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.84"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="insert">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts the string representation of the &lt;code>float&lt;/code> &#xA;     * argument into this sequence. &#xA;     * &lt;p>&#xA;     * The second argument is converted to a string as if by the method &#xA;     * &lt;code>String.valueOf&lt;/code>, and the characters of that &#xA;     * string are then inserted into this sequence at the indicated &#xA;     * offset. &#xA;     * &lt;p>&#xA;     * The offset argument must be greater than or equal to &#xA;     * &lt;code>0&lt;/code>, and less than or equal to the length of this &#xA;     * sequence. &#xA;     *&#xA;     * @param      offset   the offset.&#xA;     * @param      f        a &lt;code>float&lt;/code>.&#xA;     * @return     a reference to this object.&#xA;     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.85"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="insert">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts the string representation of the &lt;code>double&lt;/code> &#xA;     * argument into this sequence.&#xA;     * &lt;p>&#xA;     * The second argument is converted to a string as if by the method &#xA;     * &lt;code>String.valueOf&lt;/code>, and the characters of that &#xA;     * string are then inserted into this sequence at the indicated &#xA;     * offset. &#xA;     * &lt;p>&#xA;     * The offset argument must be greater than or equal to &#xA;     * &lt;code>0&lt;/code>, and less than or equal to the length of this &#xA;     * sequence.&#xA;     *&#xA;     * @param      offset   the offset.&#xA;     * @param      d        a &lt;code>double&lt;/code>.&#xA;     * @return     a reference to this object.&#xA;     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.86"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@parameters.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="indexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this string of the first occurrence of the&#xA;     * specified substring. The integer returned is the smallest value &#xA;     * &lt;i>k&lt;/i> such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * this.toString().startsWith(str, &lt;i>k&lt;/i>)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * is &lt;code>true&lt;/code>.&#xA;     *&#xA;     * @param   str   any string.&#xA;     * @return  if the string argument occurs as a substring within this&#xA;     *          object, then the index of the first character of the first&#xA;     *          such substring is returned; if it does not occur as a&#xA;     *          substring, &lt;code>-1&lt;/code> is returned.&#xA;     * @throws  java.lang.NullPointerException if &lt;code>str&lt;/code> is &#xA;     *          &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.53">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="indexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this string of the first occurrence of the&#xA;     * specified substring, starting at the specified index.  The integer&#xA;     * returned is the smallest value &lt;tt>k&lt;/tt> for which:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *     k >= Math.min(fromIndex, str.length()) &amp;&amp;&#xA;     *                   this.toString().startsWith(str, k)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * If no such value of &lt;i>k&lt;/i> exists, then -1 is returned.&#xA;     *&#xA;     * @param   str         the substring for which to search.&#xA;     * @param   fromIndex   the index from which to start the search.&#xA;     * @return  the index within this string of the first occurrence of the&#xA;     *          specified substring, starting at the specified index.&#xA;     * @throws  java.lang.NullPointerException if &lt;code>str&lt;/code> is&#xA;     *            &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.51"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.73"/>
              </next>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.22"/>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lastIndexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this string of the rightmost occurrence&#xA;     * of the specified substring.  The rightmost empty string &quot;&quot; is&#xA;     * considered to occur at the index value &lt;code>this.length()&lt;/code>. &#xA;     * The returned index is the largest value &lt;i>k&lt;/i> such that &#xA;     * &lt;blockquote>&lt;pre>&#xA;     * this.toString().startsWith(str, k)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * is true.&#xA;     *&#xA;     * @param   str   the substring to search for.&#xA;     * @return  if the string argument occurs one or more times as a substring&#xA;     *          within this object, then the index of the first character of&#xA;     *          the last such substring is returned. If it does not occur as&#xA;     *          a substring, &lt;code>-1&lt;/code> is returned.&#xA;     * @throws  java.lang.NullPointerException  if &lt;code>str&lt;/code> is &#xA;     *          &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lastIndexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this string of the last occurrence of the&#xA;     * specified substring. The integer returned is the largest value &lt;i>k&lt;/i>&#xA;     * such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *     k &lt;= Math.min(fromIndex, str.length()) &amp;&amp;&#xA;     *                   this.toString().startsWith(str, k)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * If no such value of &lt;i>k&lt;/i> exists, then -1 is returned.&#xA;     * &#xA;     * @param   str         the substring to search for.&#xA;     * @param   fromIndex   the index to start the search from.&#xA;     * @return  the index within this sequence of the last occurrence of the&#xA;     *          specified substring.&#xA;     * @throws  java.lang.NullPointerException if &lt;code>str&lt;/code> is &#xA;     *          &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.54"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.73"/>
              </next>
            </arguments>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.22"/>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="reverse">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Causes this character sequence to be replaced by the reverse of&#xA;     * the sequence. If there are any surrogate pairs included in the&#xA;     * sequence, these are treated as single characters for the&#xA;     * reverse operation. Thus, the order of the high-low surrogates&#xA;     * is never reversed.&#xA;     *&#xA;     * Let &lt;i>n&lt;/i> be the character length of this character sequence&#xA;     * (not the length in &lt;code>char&lt;/code> values) just prior to&#xA;     * execution of the &lt;code>reverse&lt;/code> method. Then the&#xA;     * character at index &lt;i>k&lt;/i> in the new character sequence is&#xA;     * equal to the character at index &lt;i>n-k-1&lt;/i> in the old&#xA;     * character sequence.&#xA;     *&#xA;     * &lt;p>Note that the reverse operation may result in producing&#xA;     * surrogate pairs that were unpaired low-surrogates and&#xA;     * high-surrogates before the operation. For example, reversing&#xA;     * &quot;&amp;#92;uDC00&amp;#92;uD800&quot; produces &quot;&amp;#92;uD800&amp;#92;uDC00&quot; which is&#xA;     * a valid surrogate pair.&#xA;     *&#xA;     * @return  a reference to this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="hasSurrogate">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="temp">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@init"/>
                </arraySelectors>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="temp2">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@init"/>
                    <additiveOperators xsi:type="operators:Subtraction"/>
                  </position>
                </arraySelectors>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:ConditionalOrExpression">
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:ConditionalAndExpression">
                        <children xsi:type="expressions:RelationExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@statement/@statements.0/@variable"/>
                          <children xsi:type="references:IdentifierReference">
                            <next xsi:type="references:IdentifierReference">
                              <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.60"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                          </children>
                          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                        </children>
                        <children xsi:type="expressions:RelationExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@statement/@statements.0/@variable"/>
                          <children xsi:type="references:IdentifierReference">
                            <next xsi:type="references:IdentifierReference">
                              <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.61"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                          </children>
                          <relationOperators xsi:type="operators:LessThanOrEqual"/>
                        </children>
                      </expression>
                    </children>
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:ConditionalAndExpression">
                        <children xsi:type="expressions:RelationExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@statement/@statements.1/@variable"/>
                          <children xsi:type="references:IdentifierReference">
                            <next xsi:type="references:IdentifierReference">
                              <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.60"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                          </children>
                          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                        </children>
                        <children xsi:type="expressions:RelationExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@statement/@statements.1/@variable"/>
                          <children xsi:type="references:IdentifierReference">
                            <next xsi:type="references:IdentifierReference">
                              <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.61"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                          </children>
                          <relationOperators xsi:type="operators:LessThanOrEqual"/>
                        </children>
                      </expression>
                    </children>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.0/@variable"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@init"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@statement/@statements.1/@variable"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <arraySelectors>
                  <position xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@init"/>
                    <additiveOperators xsi:type="operators:Subtraction"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@statement/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@init"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="j">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:ShiftExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </expression>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <shiftOperators xsi:type="operators:RightShift"/>
          </initialValue>
        </init>
        <updates xsi:type="expressions:PrefixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@init"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ForLoop">
            <comments>// Reverse back all valid surrogate pairs</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="c2">
                  <typeReference xsi:type="types:Char"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.3/@statement/@statements.0/@init"/>
                    </arraySelectors>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="c1">
                      <typeReference xsi:type="types:Char"/>
                      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                        <arraySelectors>
                          <position xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.3/@statement/@statements.0/@init"/>
                            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                          </position>
                        </arraySelectors>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                            <arraySelectors>
                              <position xsi:type="expressions:SuffixUnaryModificationExpression">
                                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.3/@statement/@statements.0/@init"/>
                                <operator xsi:type="operators:PlusPlus"/>
                              </position>
                            </arraySelectors>
                          </child>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.3/@statement/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable"/>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                            <arraySelectors>
                              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.3/@statement/@statements.0/@init"/>
                            </arraySelectors>
                          </child>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.3/@statement/@statements.0/@statement/@statements.0/@variable"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.80"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.3/@statement/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.81"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.3/@statement/@statements.0/@statement/@statements.0/@variable"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.3/@statement/@statements.0/@init"/>
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.3/@statement/@statements.0/@init"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.0/@variable"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string representing the data in this sequence.&#xA;     * A new &lt;code>String&lt;/code> object is allocated and initialized to &#xA;     * contain the character sequence currently represented by this &#xA;     * object. This &lt;code>String&lt;/code> is then returned. Subsequent &#xA;     * changes to this sequence do not affect the contents of the &#xA;     * &lt;code>String&lt;/code>.&#xA;     *&#xA;     * @return  a string representation of this sequence of characters.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getValue">
      <typeReference xsi:type="types:Char"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Needed by &lt;tt>String&lt;/tt> for the contentEquals method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Abstract">
      <comments>/**&#xA; * A mutable sequence of characters.&#xA; * &lt;p>&#xA; * Implements a modifiable string. At any point in time it contains some &#xA; * particular sequence of characters, but the length and content of the &#xA; * sequence can be changed through certain method calls.&#xA; *&#xA; * @author&#x9;Michael McCloskey&#xA; * @version &#x9;1.14, 09/26/05&#xA; * @since&#x9;1.5&#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Appendable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
