<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="ClassFileTransformer.java">
  <comments>/*&#xA; * @(#)ClassFileTransformer.java&#x9;1.5 04/05/05&#xA; *&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. &#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>lang</namespaces>
  <namespaces>instrument</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../security/ProtectionDomain.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="ClassFileTransformer">
    <members xsi:type="members:InterfaceMethod" name="transform">
      <typeReference xsi:type="types:Byte">
        <comments>/**&#xA;     * The implementation of this method may transform the supplied class file and &#xA;     * return a new replacement class file.&#xA;     *&#xA;     * &lt;P>&#xA;     * Once a transformer has been registered with&#xA;     * {@link java.lang.instrument.Instrumentation#addTransformer Instrumentation.addTransformer},&#xA;     * the transformer will be called for every new class definition and every class redefinition.&#xA;     * The request for a new class definition is made with&#xA;     * {@link java.lang.ClassLoader#defineClass ClassLoader.defineClass}.&#xA;     * The request for a class redefinition is made with&#xA;     * {@link java.lang.instrument.Instrumentation#redefineClasses Instrumentation.redefineClasses}&#xA;     * or its native equivalents.&#xA;     * The transformer is called during the processing of the request, before the class file bytes&#xA;     * have been verified or applied.&#xA;     *&#xA;     * &lt;P>&#xA;     * If the implementing method determines that no transformations are needed,&#xA;     * it should return &lt;code>null&lt;/code>. &#xA;     * Otherwise, it should create a new &lt;code>byte[]&lt;/code> array,&#xA;     * copy the input &lt;code>classfileBuffer&lt;/code> into it,&#xA;     * along with all desired transformations, and return the new array. &#xA;     * The input &lt;code>classfileBuffer&lt;/code> must not be modified.&#xA;     *&#xA;     * &lt;P>&#xA;     * In the redefine case, the transformer must support the redefinition semantics.&#xA;     * If a class that the transformer changed during initial definition is later redefined, the&#xA;     * transformer must insure that the second class output class file is a legal&#xA;     * redefinition of the first output class file.&#xA;     *&#xA;     * &lt;P>&#xA;     * If the transformer believes the &lt;code>classFileBuffer&lt;/code> does not&#xA;     * represent a validly formatted class file, it should throw&#xA;     * an &lt;code>IllegalClassFormatException&lt;/code>.  Subsequent transformers&#xA;     * will still be called and the load or redefine will still&#xA;     * be attempted.  Throwing an &lt;code>IllegalClassFormatException&lt;/code> thus&#xA;     * has the same effect as returning null but facilitates the&#xA;     * logging or debugging of format corruptions.&#xA;     *&#xA;     * @param loader                the defining loader of the class to be transformed,&#xA;     *                              may be &lt;code>null&lt;/code> if the bootstrap loader&#xA;     * @param className             the name of the class in the internal form of fully&#xA;     *                              qualified class and interface names as defined in&#xA;     *                              &lt;i>The Java Virtual Machine Specification&lt;/i>.  &#xA;     *                              For example, &lt;code>&quot;java/util/List&quot;&lt;/code>.&#xA;     * @param classBeingRedefined   if this is a redefine, the class being redefined, &#xA;     *                              otherwise &lt;code>null&lt;/code>&#xA;     * @param protectionDomain      the protection domain of the class being defined or redefined&#xA;     * @param classfileBuffer       the input byte buffer in class file format - must not be modified&#xA;     *&#xA;     * @throws IllegalClassFormatException if the input does not represent a well-formed class file&#xA;     * @return  a well-formed class file buffer (the result of the transform), &#xA;                or &lt;code>null&lt;/code> if no transform is performed.&#xA;     * @see Instrumentation#redefineClasses&#xA;     */</comments>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="loader">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ClassLoader.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="className">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="classBeingRedefined">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Class" href="../Class.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="protectionDomain">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../security/ProtectionDomain.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="classfileBuffer">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IllegalClassFormatException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/*&#xA; * Copyright 2003 Wily Technology, Inc.&#xA; */</comments>
      <comments>/**&#xA; * An agent provides an implementation of this interface in order&#xA; * to transform class files.  &#xA; * The transformation occurs before the class is defined by the JVM.&#xA; * &lt;P>&#xA; * Note the term &lt;i>class file&lt;/i> is used as defined in the chapter&#xA; * &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#80959&quot;>The class File Format&lt;/a>&#xA; * of &lt;i>The Java Virtual Machine Specification&lt;/i>, to mean a sequence&#xA; * of bytes in class file format, whether or not they reside in a file.&#xA; *&#xA; * @see     java.lang.instrument.Instrumentation&#xA; * @see     java.lang.instrument.Instrumentation#addTransformer&#xA; * @see     java.lang.instrument.Instrumentation#removeTransformer&#xA; * @since   JDK1.5&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
