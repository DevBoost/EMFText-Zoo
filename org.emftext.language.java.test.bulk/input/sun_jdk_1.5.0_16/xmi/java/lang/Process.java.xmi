<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/types ../../java.ecore#/16" name="Process.java">
  <comments>/*&#xA; * @(#)Process.java&#x9;1.23 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>lang</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Process">
    <members xsi:type="members:InterfaceMethod" name="getOutputStream">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/OutputStream.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Gets the output stream of the subprocess.&#xA;     * Output to the stream is piped into the standard input stream of &#xA;     * the process represented by this &lt;code>Process&lt;/code> object. &#xA;     * &lt;p>&#xA;     * Implementation note: It is a good idea for the output stream to &#xA;     * be buffered.&#xA;     *&#xA;     * @return  the output stream connected to the normal input of the&#xA;     *          subprocess.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getInputStream">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/InputStream.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Gets the input stream of the subprocess.&#xA;     * The stream obtains data piped from the standard output stream &#xA;     * of the process represented by this &lt;code>Process&lt;/code> object. &#xA;     * &lt;p>&#xA;     * Implementation note: It is a good idea for the input stream to &#xA;     * be buffered.&#xA;     *&#xA;     * @return  the input stream connected to the normal output of the&#xA;     *          subprocess.&#xA;     * @see ProcessBuilder#redirectErrorStream()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getErrorStream">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/InputStream.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Gets the error stream of the subprocess.&#xA;     * The stream obtains data piped from the error output stream of the &#xA;     * process represented by this &lt;code>Process&lt;/code> object. &#xA;     * &lt;p>&#xA;     * Implementation note: It is a good idea for the input stream to be &#xA;     * buffered.&#xA;     *&#xA;     * @return  the input stream connected to the error stream of the&#xA;     *          subprocess.&#xA;     * @see ProcessBuilder#redirectErrorStream()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="waitFor">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * causes the current thread to wait, if necessary, until the &#xA;     * process represented by this &lt;code>Process&lt;/code> object has &#xA;     * terminated. This method returns &#xA;     * immediately if the subprocess has already terminated. If the&#xA;     * subprocess has not yet terminated, the calling thread will be&#xA;     * blocked until the subprocess exits.&#xA;     *&#xA;     * @return     the exit value of the process. By convention, &#xA;     *             &lt;code>0&lt;/code> indicates normal termination.&#xA;     * @exception  InterruptedException  if the current thread is &#xA;     *             {@link Thread#interrupt() interrupted} by another thread &#xA;     *             while it is waiting, then the wait is ended and an &#xA;     *             {@link InterruptedException} is thrown.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="exitValue">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Returns the exit value for the subprocess.&#xA;     *&#xA;     * @return  the exit value of the subprocess represented by this &#xA;     *          &lt;code>Process&lt;/code> object. by convention, the value &#xA;     *          &lt;code>0&lt;/code> indicates normal termination.&#xA;     * @exception  IllegalThreadStateException  if the subprocess represented &#xA;     *             by this &lt;code>Process&lt;/code> object has not yet terminated.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="destroy">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Kills the subprocess. The subprocess represented by this &#xA;     * &lt;code>Process&lt;/code> object is forcibly terminated.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The {@link ProcessBuilder#start()} and&#xA; * {@link Runtime#exec(String[],String[],File) Runtime.exec}&#xA; * methods create a native process and&#xA; * return an instance of a subclass of &lt;code>Process&lt;/code> that can&#xA; * be used to control the process and obtain information about it.&#xA; * The class &lt;code>Process&lt;/code> provides methods for performing&#xA; * input from the process, performing output to the process, waiting&#xA; * for the process to complete, checking the exit status of the process,&#xA; * and destroying (killing) the process.&#xA; *&#xA; * &lt;p>&#xA; * The methods that create processes may not work well for special&#xA; * processes on certain native platforms, such as native windowing&#xA; * processes, daemon processes, Win16/DOS processes on Microsoft Windows, or shell&#xA; * scripts. The created subprocess does not have its own terminal or&#xA; * console. All its standard io (i.e. stdin, stdout, stderr)  operations&#xA; * will be redirected to the parent process through three streams&#xA; * ({@link #getOutputStream()},&#xA; * {@link #getInputStream()},&#xA; * {@link #getErrorStream()}).&#xA; * The parent process uses these streams to feed input to and get output&#xA; * from the subprocess. Because some native platforms only provide&#xA; * limited buffer size for standard input and output streams, failure&#xA; * to promptly write the input stream or read the output stream of&#xA; * the subprocess may cause the subprocess to block, and even deadlock.&#xA; *&#xA; * &lt;p>&#xA; * The subprocess is not killed when there are no more references to &#xA; * the &lt;code>Process&lt;/code> object, but rather the subprocess &#xA; * continues executing asynchronously.&#xA; *&#xA; * &lt;p>&#xA; * There is no requirement that a process represented by a &lt;code>Process&lt;/code> &#xA; * object execute asynchronously or concurrently with respect to the Java &#xA; * process that owns the &lt;code>Process&lt;/code> object.&#xA; *&#xA; * @author  unascribed&#xA; * @version 1.23, 12/19/03&#xA; * @see     ProcessBuilder&#xA; * @see     Runtime#exec(String[], String[], File)&#xA; * @since   JDK1.0&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
