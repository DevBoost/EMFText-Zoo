<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:annotations="http://www.emftext.org/java/annotations" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/annotations ../../java.ecore#/0 http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="String.java">
  <comments>/*&#xA; * @(#)String.java&#x9;1.189 05/10/21&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>lang</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/ObjectStreamClass.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/ObjectStreamField.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/UnsupportedEncodingException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/ArrayList.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../util/Comparator.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Formatter.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <namespaces>regex</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/regex/Matcher.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <namespaces>regex</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/regex/Pattern.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <namespaces>regex</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/regex/PatternSyntaxException.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="String">
    <members xsi:type="members:Field" name="value">
      <typeReference xsi:type="types:Char"/>
      <arrayDimensionsAfter/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** The value is used for character storage. */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="offset">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** The offset is the first index of the storage that is used. */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="count">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** The count is the number of characters in the String. */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="hash">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** Cache the hash code for the string */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="6849794470754667710"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Default to 0</comments>
        <comments>/** use serialVersionUID from JDK 1.0.2 for interoperability */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="serialPersistentFields">
      <initialValue xsi:type="arrays:ArrayInstantiationBySize">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/ObjectStreamField.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/ObjectStreamField.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Class String is special cased within the Serialization Stream Protocol.&#xA;     *&#xA;     * A String instance is written initially into an ObjectOutputStream in the&#xA;     * following format:&#xA;     * &lt;pre>&#xA;     *      &lt;code>TC_STRING&lt;/code> (utf String)&#xA;     * &lt;/pre>&#xA;     * The String is written by method &lt;code>DataOutput.writeUTF&lt;/code>.&#xA;     * A new handle is generated to  refer to all future references to the&#xA;     * string instance within the stream.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </value>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Initializes a newly created &lt;code>String&lt;/code> object so that it&#xA;     * represents an empty character sequence.  Note that use of this &#xA;     * constructor is unnecessary since Strings are immutable. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="size">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="originalValue">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable">
                <comments>// The array representing the String is bigger than the new</comments>
                <comments>// String itself.  Perhaps this constructor is being called</comments>
                <comments>// in order to trim the baggage, so make a copy of the array.</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="arrays:ArrayInstantiationBySize">
                <typeReference xsi:type="types:Char"/>
                <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.1/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable"/>
              </next>
              <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.1/@variable">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable">
                <comments>// The array representing the String is the same</comments>
                <comments>// size as the String, so no point in making a copy.</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.1/@variable"/>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.2/@variable"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="original">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Initializes a newly created &lt;code>String&lt;/code> object so that it&#xA;     * represents the same sequence of characters as the argument; in other&#xA;     * words, the newly created string is a copy of the argument string. Unless &#xA;     * an explicit copy of &lt;code>original&lt;/code> is needed, use of this &#xA;     * constructor is unnecessary since Strings are immutable. &#xA;     *&#xA;     * @param   original   a &lt;code>String&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="size">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allocates a new &lt;code>String&lt;/code> so that it represents the&#xA;     * sequence of characters currently contained in the character array&#xA;     * argument. The contents of the character array are copied; subsequent&#xA;     * modification of the character array does not affect the newly created&#xA;     * string.&#xA;     *&#xA;     * @param  value   the initial value of the string.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.2"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.2"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Note: offset or count might be near -1>>>1.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.2"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1"/>
          <children xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.2"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.2"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.3/@variable"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.2"/>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.3/@variable"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allocates a new &lt;code>String&lt;/code> that contains characters from&#xA;     * a subarray of the character array argument. The &lt;code>offset&lt;/code>&#xA;     * argument is the index of the first character of the subarray and&#xA;     * the &lt;code>count&lt;/code> argument specifies the length of the&#xA;     * subarray. The contents of the subarray are copied; subsequent&#xA;     * modification of the character array does not affect the newly&#xA;     * created string.&#xA;     *&#xA;     * @param      value    array that is the source of characters.&#xA;     * @param      offset   the initial offset.&#xA;     * @param      count    the length.&#xA;     * @exception  IndexOutOfBoundsException  if the &lt;code>offset&lt;/code>&#xA;     *               and &lt;code>count&lt;/code> arguments index characters outside&#xA;     *               the bounds of the &lt;code>value&lt;/code> array.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.2"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.2"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Note: offset or count might be near -1>>>1.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.2"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1"/>
          <children xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.2"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="expansion">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="margin">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.2"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.4/@variable"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </sizes>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="x">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="j">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="c">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.6/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="IllegalArgumentException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.8/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.3/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="expressions:MultiplicativeExpression">
                        <children xsi:type="expressions:NestedExpression">
                          <expression xsi:type="expressions:ShiftExpression">
                            <children xsi:type="expressions:NestedExpression">
                              <expression xsi:type="expressions:MultiplicativeExpression">
                                <children xsi:type="expressions:NestedExpression">
                                  <expression xsi:type="expressions:AdditiveExpression">
                                    <children xsi:type="expressions:UnaryExpression">
                                      <operators xsi:type="operators:Subtraction"/>
                                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.4/@variable"/>
                                    </children>
                                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                                    <additiveOperators xsi:type="operators:Addition"/>
                                  </expression>
                                </children>
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.2"/>
                                <multiplicativeOperators xsi:type="operators:Multiplication"/>
                              </expression>
                            </children>
                            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
                            <shiftOperators xsi:type="operators:LeftShift"/>
                          </expression>
                        </children>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.8/@init"/>
                        <multiplicativeOperators xsi:type="operators:Division"/>
                      </value>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.3/@variable"/>
                      <assignmentOperator xsi:type="operators:AssignmentRightShift"/>
                      <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.3/@variable"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.3/@variable"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <relationOperators xsi:type="operators:LessThanOrEqual"/>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.3/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </condition>
                <elseStatement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.3/@variable"/>
                      <assignmentOperator xsi:type="operators:AssignmentMultiplication"/>
                      <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                    </expression>
                  </statements>
                </elseStatement>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="tmp">
                  <typeReference xsi:type="types:Char"/>
                  <arrayDimensionsBefore/>
                  <initialValue xsi:type="arrays:ArrayInstantiationBySize">
                    <typeReference xsi:type="types:Char"/>
                    <sizes xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="Math.class.xmi#//@classifiers.0/@members.37"/>
                        <arguments xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.5/@variable">
                            <next xsi:type="references:IdentifierReference"/>
                          </children>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.3/@variable"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                        </arguments>
                        <arguments xsi:type="expressions:MultiplicativeExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.2"/>
                          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                          <multiplicativeOperators xsi:type="operators:Multiplication"/>
                        </arguments>
                      </next>
                      <target xsi:type="classifiers:Class" href="Math.class.xmi#//@classifiers.0"/>
                    </sizes>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.4/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.8/@statement/@statements.2/@statement/@statements.1/@variable">
                          <next xsi:type="references:IdentifierReference"/>
                        </children>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.5/@variable">
                          <next xsi:type="references:IdentifierReference"/>
                        </children>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </expression>
                    </children>
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.2"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.8/@init"/>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </expression>
                    </children>
                    <additiveOperators xsi:type="operators:Subtraction"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.5/@variable"/>
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.8/@statement/@statements.2/@statement/@statements.1/@variable"/>
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.7/@variable"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.5/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.8/@statement/@statements.2/@statement/@statements.1/@variable"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.4/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.7/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.5/@variable">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.5/@variable">
                    <arraySelectors>
                      <position xsi:type="expressions:SuffixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.7/@variable"/>
                        <operator xsi:type="operators:PlusPlus"/>
                      </position>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:Char"/>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.8/@statement/@statements.0/@variable"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.8/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.62"/>
                </next>
                <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <elseStatement xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.95"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.8/@statement/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.5/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.7/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.7/@variable"/>
                    <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                    <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.4/@variable"/>
                    <operator xsi:type="operators:MinusMinus"/>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.8/@statement/@statements.0/@variable"/>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.64"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                </children>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </condition>
              <elseStatement xsi:type="statements:Block">
                <statements xsi:type="statements:Throw">
                  <throwable xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="IllegalArgumentException.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                  </throwable>
                </statements>
              </elseStatement>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.8/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.8/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.5/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.7/@variable"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoints">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allocates a new &lt;code>String&lt;/code> that contains characters&#xA;     * from a subarray of the Unicode code point array argument. The&#xA;     * &lt;code>offset&lt;/code> argument is the index of the first code&#xA;     * point of the subarray and the &lt;code>count&lt;/code> argument&#xA;     * specifies the length of the subarray. The contents of the&#xA;     * subarray are converted to &lt;code>char&lt;/code>s; subsequent&#xA;     * modification of the &lt;code>int&lt;/code> array does not affect the&#xA;     * newly created string.&#xA;     *&#xA;     * @param codePoints array that is the source of Unicode code points.&#xA;     * @param offset     the initial offset.&#xA;     * @param count      the length.&#xA;     * @exception IllegalArgumentException if any invalid Unicode code point&#xA;     * is found in &lt;code>codePoints&lt;/code>&#xA;     * @exception  IndexOutOfBoundsException  if the &lt;code>offset&lt;/code>&#xA;     *               and &lt;code>count&lt;/code> arguments index characters outside&#xA;     *               the bounds of the &lt;code>codePoints&lt;/code> array.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.3"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="value">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.3"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.1/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.2/@statement/@statements.0/@init"/>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:Char"/>
                    <child xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:AndExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0">
                          <arraySelectors>
                            <position xsi:type="expressions:AdditiveExpression">
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.2/@statement/@statements.0/@init"/>
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.2"/>
                              <additiveOperators xsi:type="operators:Addition"/>
                            </position>
                          </arraySelectors>
                        </children>
                        <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
                      </expression>
                    </child>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.2/@statement/@statements.0/@init"/>
                <operator xsi:type="operators:MinusMinus"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.3"/>
            </init>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
              <assignmentOperator xsi:type="operators:AssignmentLeftShift"/>
              <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.1/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.2/@elseStatement/@statements.1/@init"/>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:Char"/>
                    <child xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:InclusiveOrExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
                        <children xsi:type="expressions:NestedExpression">
                          <expression xsi:type="expressions:AndExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0">
                              <arraySelectors>
                                <position xsi:type="expressions:AdditiveExpression">
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.2/@elseStatement/@statements.1/@init"/>
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.2"/>
                                  <additiveOperators xsi:type="operators:Addition"/>
                                </position>
                              </arraySelectors>
                            </children>
                            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
                          </expression>
                        </children>
                      </expression>
                    </child>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.2/@elseStatement/@statements.1/@init"/>
                <operator xsi:type="operators:MinusMinus"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.3"/>
            </init>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.3"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.1/@variable"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ascii">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hibyte">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Allocates a new &lt;code>String&lt;/code> constructed from a subarray&#xA;     * of an array of 8-bit integer values.&#xA;     * &lt;p>&#xA;     * The &lt;code>offset&lt;/code> argument is the index of the first byte&#xA;     * of the subarray, and the &lt;code>count&lt;/code> argument specifies the&#xA;     * length of the subarray.&#xA;     * &lt;p>&#xA;     * Each &lt;code>byte&lt;/code> in the subarray is converted to a&#xA;     * &lt;code>char&lt;/code> as specified in the method above.&#xA;     *&#xA;     * @deprecated This method does not properly convert bytes into characters.&#xA;     * As of JDK&amp;nbsp;1.1, the preferred way to do this is via the&#xA;     * &lt;code>String&lt;/code> constructors that take a charset name or that use&#xA;     * the platform's default charset.&#xA;     *&#xA;     * @param      ascii     the bytes to be converted to characters.&#xA;     * @param      hibyte    the top 8 bits of each 16-bit Unicode character.&#xA;     * @param      offset    the initial offset.&#xA;     * @param      count     the length.&#xA;     * @exception  IndexOutOfBoundsException  if the &lt;code>offset&lt;/code>&#xA;     *               or &lt;code>count&lt;/code> argument is invalid.&#xA;     * @see        java.lang.String#String(byte[], int)&#xA;     * @see        java.lang.String#String(byte[], int, int, java.lang.String)&#xA;     * @see        java.lang.String#String(byte[], int, int)&#xA;     * @see        java.lang.String#String(byte[], java.lang.String)&#xA;     * @see        java.lang.String#String(byte[])&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ascii">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hibyte">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Allocates a new &lt;code>String&lt;/code> containing characters&#xA;     * constructed from an array of 8-bit integer values. Each character&#xA;     * &lt;i>c&lt;/i>in the resulting string is constructed from the&#xA;     * corresponding component &lt;i>b&lt;/i> in the byte array such that:&#xA;     * &lt;p>&lt;blockquote>&lt;pre>&#xA;     *     &lt;b>&lt;i>c&lt;/i>&lt;/b> == (char)(((hibyte &amp;amp; 0xff) &amp;lt;&amp;lt; 8)&#xA;     *                         | (&lt;b>&lt;i>b&lt;/i>&lt;/b> &amp;amp; 0xff))&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @deprecated This method does not properly convert bytes into characters.&#xA;     * As of JDK&amp;nbsp;1.1, the preferred way to do this is via the&#xA;     * &lt;code>String&lt;/code> constructors that take a charset name or&#xA;     * that use the platform's default charset.&#xA;     *&#xA;     * @param      ascii    the bytes to be converted to characters.&#xA;     * @param      hibyte   the top 8 bits of each 16-bit Unicode character.&#xA;     * @see        java.lang.String#String(byte[], int, int, java.lang.String)&#xA;     * @see        java.lang.String#String(byte[], int, int)&#xA;     * @see        java.lang.String#String(byte[], java.lang.String)&#xA;     * @see        java.lang.String#String(byte[])&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="checkBounds">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bytes">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/* Common private utility method used to bounds check the byte array&#xA;     * and requested offset &amp; length values used by the String(byte[],..)&#xA;     * constructors.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
          <children xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="charsetName"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.3"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="StringCoding.class.xmi#//@classifiers.0/@members.11"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.3"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.2"/>
            </next>
            <target xsi:type="classifiers:Class" href="StringCoding.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.2/@variable">
            <next xsi:type="references:IdentifierReference"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.2/@variable"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bytes">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="charsetName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/UnsupportedEncodingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new &lt;tt>String&lt;/tt> by decoding the specified subarray of&#xA;     * bytes using the specified charset.  The length of the new&#xA;     * &lt;tt>String&lt;/tt> is a function of the charset, and hence may not be equal&#xA;     * to the length of the subarray.&#xA;     *&#xA;     * &lt;p> The behavior of this constructor when the given bytes are not valid&#xA;     * in the given charset is unspecified.  The {@link&#xA;     * java.nio.charset.CharsetDecoder} class should be used when more control&#xA;     * over the decoding process is required.&#xA;     *&#xA;     * @param  bytes   the bytes to be decoded into characters&#xA;     * @param  offset  the index of the first byte to decode&#xA;     * @param  length  the number of bytes to decode&#xA;     * @param  charsetName  the name of a supported&#xA;     *                 {@link java.nio.charset.Charset &lt;/code>charset&lt;code>}&#xA;     * @throws  UnsupportedEncodingException&#xA;     *          if the named charset is not supported&#xA;     * @throws  IndexOutOfBoundsException&#xA;     *          if the &lt;tt>offset&lt;/tt> and &lt;tt>length&lt;/tt> arguments&#xA;     *          index characters outside the bounds of the &lt;tt>bytes&lt;/tt>&#xA;     *          array&#xA;     * @since JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bytes">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="charsetName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/UnsupportedEncodingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new &lt;tt>String&lt;/tt> by decoding the specified array of&#xA;     * bytes using the specified charset.  The length of the new&#xA;     * &lt;tt>String&lt;/tt> is a function of the charset, and hence may not be equal&#xA;     * to the length of the byte array.&#xA;     *&#xA;     * &lt;p> The behavior of this constructor when the given bytes are not valid&#xA;     * in the given charset is unspecified.  The {@link&#xA;     * java.nio.charset.CharsetDecoder} class should be used when more control&#xA;     * over the decoding process is required.&#xA;     *&#xA;     * @param  bytes   the bytes to be decoded into characters&#xA;     * @param  charsetName  the name of a supported&#xA;     *                 {@link java.nio.charset.Charset &lt;/code>charset&lt;code>}&#xA;     *&#xA;     * @exception  UnsupportedEncodingException&#xA;     *             If the named charset is not supported&#xA;     * @since      JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="StringCoding.class.xmi#//@classifiers.0/@members.12"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.2"/>
            </next>
            <target xsi:type="classifiers:Class" href="StringCoding.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.1/@variable">
            <next xsi:type="references:IdentifierReference"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.1/@variable"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bytes">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new &lt;tt>String&lt;/tt> by decoding the specified subarray of&#xA;     * bytes using the platform's default charset.  The length of the new&#xA;     * &lt;tt>String&lt;/tt> is a function of the charset, and hence may not be equal&#xA;     * to the length of the subarray.&#xA;     *&#xA;     * &lt;p> The behavior of this constructor when the given bytes are not valid&#xA;     * in the default charset is unspecified.  The {@link&#xA;     * java.nio.charset.CharsetDecoder} class should be used when more control&#xA;     * over the decoding process is required.&#xA;     *&#xA;     * @param  bytes   the bytes to be decoded into characters&#xA;     * @param  offset  the index of the first byte to decode&#xA;     * @param  length  the number of bytes to decode&#xA;     * @throws IndexOutOfBoundsException&#xA;     *         if the &lt;code>offset&lt;/code> and the &lt;code>length&lt;/code>&#xA;     *         arguments index characters outside the bounds of the&#xA;     *         &lt;code>bytes&lt;/code> array&#xA;     * @since  JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bytes">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new &lt;tt>String&lt;/tt> by decoding the specified array of&#xA;     * bytes using the platform's default charset.  The length of the new&#xA;     * &lt;tt>String&lt;/tt> is a function of the charset, and hence may not be equal&#xA;     * to the length of the byte array.&#xA;     *&#xA;     * &lt;p> The behavior of this constructor when the given bytes are not valid&#xA;     * in the default charset is unspecified.  The {@link&#xA;     * java.nio.charset.CharsetDecoder} class should be used when more control&#xA;     * over the decoding process is required.&#xA;     *&#xA;     * @param  bytes   the bytes to be decoded into characters&#xA;     * @since  JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buffer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allocates a new string that contains the sequence of characters&#xA;     * currently contained in the string buffer argument. The contents of&#xA;     * the string buffer are copied; subsequent modification of the string&#xA;     * buffer does not affect the newly created string.&#xA;     *&#xA;     * @param   buffer   a &lt;code>StringBuffer&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="StringBuilder.class.xmi#//@classifiers.0/@members.40"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="builder">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="StringBuilder.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Allocates a new string that contains the sequence of characters&#xA;     * currently contained in the string builder argument. The contents of&#xA;     * the string builder are copied; subsequent modification of the string&#xA;     * builder does not affect the newly created string.&#xA;     *&#xA;     * &lt;p>This constructor is provided to ease migration to&#xA;     * &lt;code>StringBuilder&lt;/code>. Obtaining a string from a string builder&#xA;     * via the &lt;code>toString&lt;/code> method is likely to run faster and is&#xA;     * generally preferred.&#xA;     *&#xA;     * @param   builder   a &lt;code>StringBuilder&lt;/code>&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="String">
      <comments>// Package private constructor which shares value array for speed.</comments>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
    </members>
    <members xsi:type="members:ClassMethod" name="length">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the length of this string.&#xA;     * The length is equal to the number of 16-bit&#xA;     * Unicode characters in the string.&#xA;     *&#xA;     * @return  the length of the sequence of characters represented by this&#xA;     *          object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="charAt">
      <typeReference xsi:type="types:Char"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>char&lt;/code> value at the&#xA;     * specified index. An index ranges from &lt;code>0&lt;/code> to&#xA;     * &lt;code>length() - 1&lt;/code>. The first &lt;code>char&lt;/code> value of the sequence&#xA;     * is at index &lt;code>0&lt;/code>, the next at index &lt;code>1&lt;/code>,&#xA;     * and so on, as for array indexing.&#xA;     *&#xA;     * &lt;p>If the &lt;code>char&lt;/code> value specified by the index is a&#xA;     * &lt;a href=&quot;Character.html#unicode&quot;>surrogate&lt;/a>, the surrogate&#xA;     * value is returned.&#xA;     *&#xA;     * @param      index   the index of the &lt;code>char&lt;/code> value.&#xA;     * @return     the &lt;code>char&lt;/code> value at the specified index of this string.&#xA;     *             The first &lt;code>char&lt;/code> value is at index &lt;code>0&lt;/code>.&#xA;     * @exception  IndexOutOfBoundsException  if the &lt;code>index&lt;/code>&#xA;     *             argument is negative or not less than the length of this&#xA;     *             string.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <arraySelectors>
            <position xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </position>
          </arraySelectors>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointAt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the character (Unicode code point) at the specified&#xA;     * index. The index refers to &lt;code>char&lt;/code> values&#xA;     * (Unicode code units) and ranges from &lt;code>0&lt;/code> to&#xA;     * {@link #length()}&lt;code> - 1&lt;/code>.&#xA;     *&#xA;     * &lt;p> If the &lt;code>char&lt;/code> value specified at the given index&#xA;     * is in the high-surrogate range, the following index is less&#xA;     * than the length of this &lt;code>String&lt;/code>, and the&#xA;     * &lt;code>char&lt;/code> value at the following index is in the&#xA;     * low-surrogate range, then the supplementary code point&#xA;     * corresponding to this surrogate pair is returned. Otherwise,&#xA;     * the &lt;code>char&lt;/code> value at the given index is returned.&#xA;     *&#xA;     * @param      index the index to the &lt;code>char&lt;/code> values&#xA;     * @return     the code point value of the character at the&#xA;     *             &lt;code>index&lt;/code>&#xA;     * @exception  IndexOutOfBoundsException  if the &lt;code>index&lt;/code>&#xA;     *             argument is negative or not less than the length of this&#xA;     *             string.&#xA;     * @since      1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.88"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointBefore">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the character (Unicode code point) before the specified&#xA;     * index. The index refers to &lt;code>char&lt;/code> values&#xA;     * (Unicode code units) and ranges from &lt;code>1&lt;/code> to {@link&#xA;     * CharSequence#length() length}.&#xA;     *&#xA;     * &lt;p> If the &lt;code>char&lt;/code> value at &lt;code>(index - 1)&lt;/code>&#xA;     * is in the low-surrogate range, &lt;code>(index - 2)&lt;/code> is not&#xA;     * negative, and the &lt;code>char&lt;/code> value at &lt;code>(index -&#xA;     * 2)&lt;/code> is in the high-surrogate range, then the&#xA;     * supplementary code point value of the surrogate pair is&#xA;     * returned. If the &lt;code>char&lt;/code> value at &lt;code>index -&#xA;     * 1&lt;/code> is an unpaired low-surrogate or a high-surrogate, the&#xA;     * surrogate value is returned.&#xA;     *&#xA;     * @param     index the index following the code point that should be returned&#xA;     * @return    the Unicode code point value before the given index.&#xA;     * @exception IndexOutOfBoundsException if the &lt;code>index&lt;/code>&#xA;     *            argument is less than 1 or greater than the length&#xA;     *            of this string.&#xA;     * @since     1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.92"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointCount">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="beginIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="endIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the number of Unicode code points in the specified text&#xA;     * range of this &lt;code>String&lt;/code>. The text range begins at the&#xA;     * specified &lt;code>beginIndex&lt;/code> and extends to the&#xA;     * &lt;code>char&lt;/code> at index &lt;code>endIndex - 1&lt;/code>. Thus the&#xA;     * length (in &lt;code>char&lt;/code>s) of the text range is&#xA;     * &lt;code>endIndex-beginIndex&lt;/code>. Unpaired surrogates within&#xA;     * the text range count as one code point each.&#xA;     *&#xA;     * @param beginIndex the index to the first &lt;code>char&lt;/code> of&#xA;     * the text range.&#xA;     * @param endIndex the index after the last &lt;code>char&lt;/code> of&#xA;     * the text range.&#xA;     * @return the number of Unicode code points in the specified text&#xA;     * range&#xA;     * @exception IndexOutOfBoundsException if the&#xA;     * &lt;code>beginIndex&lt;/code> is negative, or &lt;code>endIndex&lt;/code>&#xA;     * is larger than the length of this &lt;code>String&lt;/code>, or&#xA;     * &lt;code>beginIndex&lt;/code> is larger than &lt;code>endIndex&lt;/code>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.98"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="offsetByCodePoints">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePointOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this &lt;code>String&lt;/code> that is&#xA;     * offset from the given &lt;code>index&lt;/code> by&#xA;     * &lt;code>codePointOffset&lt;/code> code points. Unpaired surrogates&#xA;     * within the text range given by &lt;code>index&lt;/code> and&#xA;     * &lt;code>codePointOffset&lt;/code> count as one code point each.&#xA;     *&#xA;     * @param index the index to be offset&#xA;     * @param codePointOffset the offset in code points&#xA;     * @return the index within this &lt;code>String&lt;/code>&#xA;     * @exception IndexOutOfBoundsException if &lt;code>index&lt;/code>&#xA;     *   is negative or larger then the length of this&#xA;     *   &lt;code>String&lt;/code>, or if &lt;code>codePointOffset&lt;/code> is positive&#xA;     *   and the substring starting with &lt;code>index&lt;/code> has fewer&#xA;     *   than &lt;code>codePointOffset&lt;/code> code points,&#xA;     *   or if &lt;code>codePointOffset&lt;/code> is negative and the substring&#xA;     *   before &lt;code>index&lt;/code> has fewer than the absolute value&#xA;     *   of &lt;code>codePointOffset&lt;/code> code points.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.101"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.1"/>
          </next>
          <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getChars">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Copy characters from this string into dst starting at dstBegin.&#xA;     * This method doesn't perform any range checking.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dstBegin">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getChars">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="srcBegin">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="srcEnd">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dstBegin">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Copies characters from this string into the destination character&#xA;     * array.&#xA;     * &lt;p>&#xA;     * The first character to be copied is at index &lt;code>srcBegin&lt;/code>;&#xA;     * the last character to be copied is at index &lt;code>srcEnd-1&lt;/code>&#xA;     * (thus the total number of characters to be copied is&#xA;     * &lt;code>srcEnd-srcBegin&lt;/code>). The characters are copied into the&#xA;     * subarray of &lt;code>dst&lt;/code> starting at index &lt;code>dstBegin&lt;/code>&#xA;     * and ending at index:&#xA;     * &lt;p>&lt;blockquote>&lt;pre>&#xA;     *     dstbegin + (srcEnd-srcBegin) - 1&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @param      srcBegin   index of the first character in the string&#xA;     *                        to copy.&#xA;     * @param      srcEnd     index after the last character in the string&#xA;     *                        to copy.&#xA;     * @param      dst        the destination array.&#xA;     * @param      dstBegin   the start offset in the destination array.&#xA;     * @exception IndexOutOfBoundsException If any of the following&#xA;     *            is true:&#xA;     *            &lt;ul>&lt;li>&lt;code>srcBegin&lt;/code> is negative.&#xA;     *            &lt;li>&lt;code>srcBegin&lt;/code> is greater than &lt;code>srcEnd&lt;/code>&#xA;     *            &lt;li>&lt;code>srcEnd&lt;/code> is greater than the length of this&#xA;     *                string&#xA;     *            &lt;li>&lt;code>dstBegin&lt;/code> is negative&#xA;     *            &lt;li>&lt;code>dstBegin+(srcEnd-srcBegin)&lt;/code> is larger than&#xA;     *                &lt;code>dst.length&lt;/code>&lt;/ul>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.3"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getBytes">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="srcBegin">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="srcEnd">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dstBegin">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Copies characters from this string into the destination byte&#xA;     * array. Each byte receives the 8 low-order bits of the&#xA;     * corresponding character. The eight high-order bits of each character&#xA;     * are not copied and do not participate in the transfer in any way.&#xA;     * &lt;p>&#xA;     * The first character to be copied is at index &lt;code>srcBegin&lt;/code>;&#xA;     * the last character to be copied is at index &lt;code>srcEnd-1&lt;/code>.&#xA;     * The total number of characters to be copied is&#xA;     * &lt;code>srcEnd-srcBegin&lt;/code>. The characters, converted to bytes,&#xA;     * are copied into the subarray of &lt;code>dst&lt;/code> starting at index&#xA;     * &lt;code>dstBegin&lt;/code> and ending at index:&#xA;     * &lt;p>&lt;blockquote>&lt;pre>&#xA;     *     dstbegin + (srcEnd-srcBegin) - 1&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @deprecated This method does not properly convert characters into bytes.&#xA;     * As of JDK&amp;nbsp;1.1, the preferred way to do this is via the&#xA;     * &lt;code>getBytes()&lt;/code> method, which uses the platform's default&#xA;     * charset.&#xA;     *&#xA;     * @param      srcBegin   index of the first character in the string&#xA;     *                        to copy.&#xA;     * @param      srcEnd     index after the last character in the string&#xA;     *                        to copy.&#xA;     * @param      dst        the destination array.&#xA;     * @param      dstBegin   the start offset in the destination array.&#xA;     * @exception IndexOutOfBoundsException if any of the following&#xA;     *            is true:&#xA;     *           &lt;ul>&lt;li>&lt;code>srcBegin&lt;/code> is negative&#xA;     *           &lt;li>&lt;code>srcBegin&lt;/code> is greater than &lt;code>srcEnd&lt;/code>&#xA;     *           &lt;li>&lt;code>srcEnd&lt;/code> is greater than the length of this&#xA;     *            String&#xA;     *           &lt;li>&lt;code>dstBegin&lt;/code> is negative&#xA;     *           &lt;li>&lt;code>dstBegin+(srcEnd-srcBegin)&lt;/code> is larger than&#xA;     *            &lt;code>dst.length&lt;/code>&lt;/ul>&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.1"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="j">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.3"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="val">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>/* avoid getfield opcode */</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.2">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.3/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Byte"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.6/@variable">
                  <arraySelectors>
                    <position xsi:type="expressions:SuffixUnaryModificationExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.5/@variable"/>
                      <operator xsi:type="operators:PlusPlus"/>
                    </position>
                  </arraySelectors>
                </child>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.5/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.4/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getBytes">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="charsetName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/UnsupportedEncodingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Encodes this &lt;tt>String&lt;/tt> into a sequence of bytes using the&#xA;     * named charset, storing the result into a new byte array.&#xA;     *&#xA;     * &lt;p> The behavior of this method when this string cannot be encoded in&#xA;     * the given charset is unspecified.  The {@link&#xA;     * java.nio.charset.CharsetEncoder} class should be used when more control&#xA;     * over the encoding process is required.&#xA;     *&#xA;     * @param  charsetName&#xA;     *         the name of a supported&#xA;     *         {@link java.nio.charset.Charset &lt;/code>charset&lt;code>}&#xA;     *&#xA;     * @return  The resultant byte array&#xA;     *&#xA;     * @exception  UnsupportedEncodingException&#xA;     *             If the named charset is not supported&#xA;     *&#xA;     * @since      JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StringCoding.class.xmi#//@classifiers.0/@members.13"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </next>
          <target xsi:type="classifiers:Class" href="StringCoding.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getBytes">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Encodes this &lt;tt>String&lt;/tt> into a sequence of bytes using the&#xA;     * platform's default charset, storing the result into a new byte array.&#xA;     *&#xA;     * &lt;p> The behavior of this method when this string cannot be encoded in&#xA;     * the default charset is unspecified.  The {@link&#xA;     * java.nio.charset.CharsetEncoder} class should be used when more control&#xA;     * over the encoding process is required.&#xA;     *&#xA;     * @return  The resultant byte array&#xA;     *&#xA;     * @since      JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="StringCoding.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </next>
          <target xsi:type="classifiers:Class" href="StringCoding.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="anObject">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares this string to the specified object.&#xA;     * The result is &lt;code>true&lt;/code> if and only if the argument is not&#xA;     * &lt;code>null&lt;/code> and is a &lt;code>String&lt;/code> object that represents&#xA;     * the same sequence of characters as this object.&#xA;     *&#xA;     * @param   anObject   the object to compare this &lt;code>String&lt;/code>&#xA;     *                     against.&#xA;     * @return  &lt;code>true&lt;/code> if the &lt;code>String &lt;/code>are equal;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.String#compareTo(java.lang.String)&#xA;     * @see     java.lang.String#equalsIgnoreCase(java.lang.String)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="anotherString">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="n">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="v1">
                  <typeReference xsi:type="types:Char"/>
                  <arrayDimensionsAfter/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                </variable>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="v2">
                  <typeReference xsi:type="types:Char"/>
                  <arrayDimensionsAfter/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.0/@variable">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="i">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                </variable>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="j">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.0/@variable">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:WhileLoop">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Return">
                      <returnValue xsi:type="literals:BooleanLiteral"/>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.2/@statement/@statements.0/@variable">
                        <arraySelectors>
                          <position xsi:type="expressions:SuffixUnaryModificationExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.2/@statement/@statements.2/@variable"/>
                            <operator xsi:type="operators:PlusPlus"/>
                          </position>
                        </arraySelectors>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.2/@statement/@statements.1/@variable">
                        <arraySelectors>
                          <position xsi:type="expressions:SuffixUnaryModificationExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.2/@statement/@statements.3/@variable"/>
                            <operator xsi:type="operators:PlusPlus"/>
                          </position>
                        </arraySelectors>
                      </children>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.1/@variable"/>
                    <operator xsi:type="operators:MinusMinus"/>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </condition>
              </statements>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="contentEquals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sb">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if and only if this &lt;tt>String&lt;/tt> represents&#xA;     * the same sequence of characters as the specified &lt;tt>StringBuffer&lt;/tt>.&#xA;     *&#xA;     * @param   sb         the &lt;tt>StringBuffer&lt;/tt> to compare to.&#xA;     * @return  &lt;tt>true&lt;/tt> if and only if this &lt;tt>String&lt;/tt> represents&#xA;     *          the same sequence of characters as the specified&#xA;     *          &lt;tt>StringBuffer&lt;/tt>, otherwise &lt;tt>false&lt;/tt>.&#xA;     * @throws NullPointerException if &lt;code>sb&lt;/code> is &lt;code>null&lt;/code>&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.34">
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
            </arguments>
          </returnValue>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="contentEquals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if and only if this &lt;tt>String&lt;/tt> represents&#xA;     * the same sequence of char values as the specified sequence.&#xA;     *&#xA;     * @param   cs         the sequence to compare to.&#xA;     * @return  &lt;tt>true&lt;/tt> if and only if this &lt;tt>String&lt;/tt> represents&#xA;     *          the same sequence of char values as the specified&#xA;     *          sequence, otherwise &lt;tt>false&lt;/tt>.&#xA;     * @throws NullPointerException if &lt;code>cs&lt;/code> is &lt;code>null&lt;/code>&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Argument is a StringBuffer, StringBuilder</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v1">
              <typeReference xsi:type="types:Char"/>
              <arrayDimensionsAfter/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v2">
              <typeReference xsi:type="types:Char"/>
              <arrayDimensionsAfter/>
              <initialValue xsi:type="expressions:NestedExpression">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="AbstractStringBuilder.class.xmi#//@classifiers.0/@members.58"/>
                </next>
                <expression xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="AbstractStringBuilder.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
                </expression>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="j">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="n">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            </variable>
          </statements>
          <statements xsi:type="statements:WhileLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Return">
                  <returnValue xsi:type="literals:BooleanLiteral"/>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@statement/@statements.0/@variable">
                    <arraySelectors>
                      <position xsi:type="expressions:SuffixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@statement/@statements.2/@variable"/>
                        <operator xsi:type="operators:PlusPlus"/>
                      </position>
                    </arraySelectors>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@statement/@statements.1/@variable">
                    <arraySelectors>
                      <position xsi:type="expressions:SuffixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@statement/@statements.3/@variable"/>
                        <operator xsi:type="operators:PlusPlus"/>
                      </position>
                    </arraySelectors>
                  </children>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@statement/@statements.4/@variable"/>
                <operator xsi:type="operators:MinusMinus"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="AbstractStringBuilder.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Argument is a String</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Object.class.xmi#//@classifiers.0/@members.4"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v1">
          <typeReference xsi:type="types:Char">
            <comments>// Argument is a generic CharSequence</comments>
          </typeReference>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="j">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="literals:BooleanLiteral"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.3/@variable">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.4/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.1"/>
                  <arguments xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.5/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </arguments>
                </next>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.6/@variable"/>
            <operator xsi:type="operators:MinusMinus"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equalsIgnoreCase">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="anotherString">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares this &lt;code>String&lt;/code> to another &lt;code>String&lt;/code>,&#xA;     * ignoring case considerations.  Two strings are considered equal&#xA;     * ignoring case if they are of the same length, and corresponding&#xA;     * characters in the two strings are equal ignoring case.&#xA;     * &lt;p>&#xA;     * Two characters &lt;code>c1&lt;/code> and &lt;code>c2&lt;/code> are considered&#xA;     * the same, ignoring case if at least one of the following is true:&#xA;     * &lt;ul>&lt;li>The two characters are the same (as compared by the&#xA;     * &lt;code>==&lt;/code> operator).&#xA;     * &lt;li>Applying the method {@link java.lang.Character#toUpperCase(char)}&#xA;     * to each character produces the same result.&#xA;     * &lt;li>Applying the method {@link java.lang.Character#toLowerCase(char)}&#xA;     * to each character produces the same result.&lt;/ul>&#xA;     *&#xA;     * @param   anotherString   the &lt;code>String&lt;/code> to compare this&#xA;     *                          &lt;code>String&lt;/code> against.&#xA;     * @return  &lt;code>true&lt;/code> if the argument is not &lt;code>null&lt;/code>&#xA;     *          and the &lt;code>String&lt;/code>s are equal,&#xA;     *          ignoring case; &lt;code>false&lt;/code> otherwise.&#xA;     * @see     #equals(Object)&#xA;     * @see     java.lang.Character#toLowerCase(char)&#xA;     * @see java.lang.Character#toUpperCase(char)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
            </expression>
          </child>
          <expressionIf xsi:type="literals:BooleanLiteral" value="true"/>
          <expressionElse xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
                <children xsi:type="literals:NullLiteral"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              </expression>
            </children>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.41">
              <arguments xsi:type="literals:BooleanLiteral" value="true"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            </children>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="anotherString">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares two strings lexicographically.&#xA;     * The comparison is based on the Unicode value of each character in&#xA;     * the strings. The character sequence represented by this&#xA;     * &lt;code>String&lt;/code> object is compared lexicographically to the&#xA;     * character sequence represented by the argument string. The result is&#xA;     * a negative integer if this &lt;code>String&lt;/code> object&#xA;     * lexicographically precedes the argument string. The result is a&#xA;     * positive integer if this &lt;code>String&lt;/code> object lexicographically&#xA;     * follows the argument string. The result is zero if the strings&#xA;     * are equal; &lt;code>compareTo&lt;/code> returns &lt;code>0&lt;/code> exactly when&#xA;     * the {@link #equals(Object)} method would return &lt;code>true&lt;/code>.&#xA;     * &lt;p>&#xA;     * This is the definition of lexicographic ordering. If two strings are&#xA;     * different, then either they have different characters at some index&#xA;     * that is a valid index for both strings, or their lengths are different,&#xA;     * or both. If they have different characters at one or more index&#xA;     * positions, let &lt;i>k&lt;/i> be the smallest such index; then the string&#xA;     * whose character at position &lt;i>k&lt;/i> has the smaller value, as&#xA;     * determined by using the &amp;lt; operator, lexicographically precedes the&#xA;     * other string. In this case, &lt;code>compareTo&lt;/code> returns the&#xA;     * difference of the two character values at position &lt;code>k&lt;/code> in&#xA;     * the two string -- that is, the value:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * this.charAt(k)-anotherString.charAt(k)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * If there is no index position at which they differ, then the shorter&#xA;     * string lexicographically precedes the longer string. In this case,&#xA;     * &lt;code>compareTo&lt;/code> returns the difference of the lengths of the&#xA;     * strings -- that is, the value:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * this.length()-anotherString.length()&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @param   anotherString   the &lt;code>String&lt;/code> to be compared.&#xA;     * @return  the value &lt;code>0&lt;/code> if the argument string is equal to&#xA;     *          this string; a value less than &lt;code>0&lt;/code> if this string&#xA;     *          is lexicographically less than the string argument; and a&#xA;     *          value greater than &lt;code>0&lt;/code> if this string is&#xA;     *          lexicographically greater than the string argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len1">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len2">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Math.class.xmi#//@classifiers.0/@members.37"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.1/@variable"/>
            </next>
            <target xsi:type="classifiers:Class" href="Math.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v1">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v2">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="j">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="k">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.5/@variable"/>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="lim">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.5/@variable"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:WhileLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="c1">
                  <typeReference xsi:type="types:Char"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.3/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@statement/@statements.0/@variable"/>
                    </arraySelectors>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="c2">
                  <typeReference xsi:type="types:Char"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.4/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@statement/@statements.0/@variable"/>
                    </arraySelectors>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Return">
                    <returnValue xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@statement/@statements.2/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@statement/@statements.2/@statement/@statements.1/@variable"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </returnValue>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@statement/@statements.2/@statement/@statements.0/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@statement/@statements.2/@statement/@statements.1/@variable"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@statement/@statements.0/@variable"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@statement/@statements.1/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.5/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.6/@variable"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:WhileLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="c1">
                  <typeReference xsi:type="types:Char"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.3/@variable">
                    <arraySelectors>
                      <position xsi:type="expressions:SuffixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.5/@variable"/>
                        <operator xsi:type="operators:PlusPlus"/>
                      </position>
                    </arraySelectors>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="c2">
                  <typeReference xsi:type="types:Char"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.4/@variable">
                    <arraySelectors>
                      <position xsi:type="expressions:SuffixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.6/@variable"/>
                        <operator xsi:type="operators:PlusPlus"/>
                      </position>
                    </arraySelectors>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Return">
                    <returnValue xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@elseStatement/@statements.0/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@elseStatement/@statements.0/@statement/@statements.1/@variable"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </returnValue>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@elseStatement/@statements.0/@statement/@statements.0/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.7/@elseStatement/@statements.0/@statement/@statements.1/@variable"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.2/@variable"/>
                <operator xsi:type="operators:MinusMinus"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.1/@variable"/>
          <additiveOperators xsi:type="operators:Subtraction"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="CASE_INSENSITIVE_ORDER">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.38"/>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../util/Comparator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A Comparator that orders &lt;code>String&lt;/code> objects as by&#xA;     * &lt;code>compareToIgnoreCase&lt;/code>. This comparator is serializable.&#xA;     * &lt;p>&#xA;     * Note that this Comparator does &lt;em>not&lt;/em> take locale into account,&#xA;     * and will result in an unsatisfactory ordering for certain locales.&#xA;     * The java.text package provides &lt;em>Collators&lt;/em> to allow&#xA;     * locale-sensitive ordering.&#xA;     *&#xA;     * @see     java.text.Collator#compare(String, String)&#xA;     * @since   1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="classifiers:Class" name="CaseInsensitiveComparator">
      <members xsi:type="members:Field" name="serialVersionUID">
        <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="8575799808933029326"/>
        <typeReference xsi:type="types:Long"/>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// use serialVersionUID from JDK 1.2.2 for interoperability</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:ClassMethod" name="compare">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s1">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s2">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="n1">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.21"/>
            </initialValue>
            <additionalLocalVariables name="n2">
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@parameters.1">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.21"/>
              </initialValue>
            </additionalLocalVariables>
          </variable>
        </statements>
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="c1">
                <typeReference xsi:type="types:Char"/>
                <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@parameters.0">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@init"/>
                  </next>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="c2">
                <typeReference xsi:type="types:Char"/>
                <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@parameters.1">
                  <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@init/@additionalLocalVariables.0"/>
                  </next>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.0/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.130"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.0/@variable"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                    </value>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.1/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.130"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.1/@variable"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                    </value>
                  </expression>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.0/@variable"/>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="references:IdentifierReference">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.128"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.0/@variable"/>
                          </next>
                          <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                        </value>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.1/@variable"/>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="references:IdentifierReference">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.128"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.1/@variable"/>
                          </next>
                          <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                        </value>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:Condition">
                      <statement xsi:type="statements:Block">
                        <statements xsi:type="statements:Return">
                          <returnValue xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.0/@variable"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.1/@variable"/>
                            <additiveOperators xsi:type="operators:Subtraction"/>
                          </returnValue>
                        </statements>
                      </statement>
                      <condition xsi:type="expressions:EqualityExpression">
                        <equalityOperators xsi:type="operators:NotEqual"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.0/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.1/@variable"/>
                      </condition>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.0/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.1/@variable"/>
                  </condition>
                </statements>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.0/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@statement/@statements.1/@variable"/>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </children>
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@init/@additionalLocalVariables.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.0/@variable/@additionalLocalVariables.0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </children>
          </condition>
          <init xsi:type="variables:LocalVariable" name="i1">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <additionalLocalVariables name="i2">
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </additionalLocalVariables>
          </init>
          <updates xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@init"/>
            <operator xsi:type="operators:PlusPlus"/>
          </updates>
          <updates xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.1/@init/@additionalLocalVariables.0"/>
            <operator xsi:type="operators:PlusPlus"/>
          </updates>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@members.1/@statements.0/@variable/@additionalLocalVariables.0"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <implements xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../util/Comparator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </implements>
      <implements xsi:type="types:NamespaceClassifierReference">
        <namespaces>java</namespaces>
        <namespaces>io</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../io/Serializable.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </implements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareToIgnoreCase">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares two strings lexicographically, ignoring case&#xA;     * differences. This method returns an integer whose sign is that of&#xA;     * calling &lt;code>compareTo&lt;/code> with normalized versions of the strings&#xA;     * where case differences have been eliminated by calling&#xA;     * &lt;code>Character.toLowerCase(Character.toUpperCase(character))&lt;/code> on&#xA;     * each character.&#xA;     * &lt;p>&#xA;     * Note that this method does &lt;em>not&lt;/em> take locale into account,&#xA;     * and will result in an unsatisfactory ordering for certain locales.&#xA;     * The java.text package provides &lt;em>collators&lt;/em> to allow&#xA;     * locale-sensitive ordering.&#xA;     *&#xA;     * @param   str   the &lt;code>String&lt;/code> to be compared.&#xA;     * @return  a negative integer, zero, or a positive integer as the&#xA;     *&#x9;&#x9;specified String is greater than, equal to, or less&#xA;     *&#x9;&#x9;than this String, ignoring case considerations.&#xA;     * @see     java.text.Collator#compare(String, String)&#xA;     * @since   1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../util/Comparator.class.xmi#//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="regionMatches">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="other">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ooffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if two string regions are equal.&#xA;     * &lt;p>&#xA;     * A substring of this &lt;tt>String&lt;/tt> object is compared to a substring&#xA;     * of the argument other. The result is true if these substrings&#xA;     * represent identical character sequences. The substring of this&#xA;     * &lt;tt>String&lt;/tt> object to be compared begins at index &lt;tt>toffset&lt;/tt>&#xA;     * and has length &lt;tt>len&lt;/tt>. The substring of other to be compared&#xA;     * begins at index &lt;tt>ooffset&lt;/tt> and has length &lt;tt>len&lt;/tt>. The&#xA;     * result is &lt;tt>false&lt;/tt> if and only if at least one of the following&#xA;     * is true:&#xA;     * &lt;ul>&lt;li>&lt;tt>toffset&lt;/tt> is negative.&#xA;     * &lt;li>&lt;tt>ooffset&lt;/tt> is negative.&#xA;     * &lt;li>&lt;tt>toffset+len&lt;/tt> is greater than the length of this&#xA;     * &lt;tt>String&lt;/tt> object.&#xA;     * &lt;li>&lt;tt>ooffset+len&lt;/tt> is greater than the length of the other&#xA;     * argument.&#xA;     * &lt;li>There is some nonnegative integer &lt;i>k&lt;/i> less than &lt;tt>len&lt;/tt>&#xA;     * such that:&#xA;     * &lt;tt>this.charAt(toffset+&lt;i>k&lt;/i>)&amp;nbsp;!=&amp;nbsp;other.charAt(ooffset+&lt;i>k&lt;/i>)&lt;/tt>&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   toffset   the starting offset of the subregion in this string.&#xA;     * @param   other     the string argument.&#xA;     * @param   ooffset   the starting offset of the subregion in the string&#xA;     *                    argument.&#xA;     * @param   len       the number of characters to compare.&#xA;     * @return  &lt;code>true&lt;/code> if the specified subregion of this string&#xA;     *          exactly matches the specified subregion of the string argument;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ta">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="to">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="pa">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="po">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Note: toffset, ooffset, or len might be near -1>>>1.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.2"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Long"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.3"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.2"/>
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Long"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  </child>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.3"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@variable">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.1/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.2/@variable">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.3/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.3"/>
            <operator xsi:type="operators:MinusMinus"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="regionMatches">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ignoreCase">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="other">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ooffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if two string regions are equal.&#xA;     * &lt;p>&#xA;     * A substring of this &lt;tt>String&lt;/tt> object is compared to a substring&#xA;     * of the argument &lt;tt>other&lt;/tt>. The result is &lt;tt>true&lt;/tt> if these&#xA;     * substrings represent character sequences that are the same, ignoring&#xA;     * case if and only if &lt;tt>ignoreCase&lt;/tt> is true. The substring of&#xA;     * this &lt;tt>String&lt;/tt> object to be compared begins at index&#xA;     * &lt;tt>toffset&lt;/tt> and has length &lt;tt>len&lt;/tt>. The substring of&#xA;     * &lt;tt>other&lt;/tt> to be compared begins at index &lt;tt>ooffset&lt;/tt> and&#xA;     * has length &lt;tt>len&lt;/tt>. The result is &lt;tt>false&lt;/tt> if and only if&#xA;     * at least one of the following is true:&#xA;     * &lt;ul>&lt;li>&lt;tt>toffset&lt;/tt> is negative.&#xA;     * &lt;li>&lt;tt>ooffset&lt;/tt> is negative.&#xA;     * &lt;li>&lt;tt>toffset+len&lt;/tt> is greater than the length of this&#xA;     * &lt;tt>String&lt;/tt> object.&#xA;     * &lt;li>&lt;tt>ooffset+len&lt;/tt> is greater than the length of the other&#xA;     * argument.&#xA;     * &lt;li>&lt;tt>ignoreCase&lt;/tt> is &lt;tt>false&lt;/tt> and there is some nonnegative&#xA;     * integer &lt;i>k&lt;/i> less than &lt;tt>len&lt;/tt> such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * this.charAt(toffset+k) != other.charAt(ooffset+k)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;li>&lt;tt>ignoreCase&lt;/tt> is &lt;tt>true&lt;/tt> and there is some nonnegative&#xA;     * integer &lt;i>k&lt;/i> less than &lt;tt>len&lt;/tt> such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * Character.toLowerCase(this.charAt(toffset+k)) !=&#xA;               Character.toLowerCase(other.charAt(ooffset+k))&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * and:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * Character.toUpperCase(this.charAt(toffset+k)) !=&#xA;     *         Character.toUpperCase(other.charAt(ooffset+k))&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   ignoreCase   if &lt;code>true&lt;/code>, ignore case when comparing&#xA;     *                       characters.&#xA;     * @param   toffset      the starting offset of the subregion in this&#xA;     *                       string.&#xA;     * @param   other        the string argument.&#xA;     * @param   ooffset      the starting offset of the subregion in the string&#xA;     *                       argument.&#xA;     * @param   len          the number of characters to compare.&#xA;     * @return  &lt;code>true&lt;/code> if the specified subregion of this string&#xA;     *          matches the specified subregion of the string argument;&#xA;     *          &lt;code>false&lt;/code> otherwise. Whether the matching is exact&#xA;     *          or case insensitive depends on the &lt;code>ignoreCase&lt;/code>&#xA;     *          argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ta">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="to">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="pa">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.2">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="po">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.2">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.3"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Note: toffset, ooffset, or len might be near -1>>>1.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.3"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Long"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.4"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.3"/>
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Long"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.2">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  </child>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.4"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="c1">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.0/@variable">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.1/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="c2">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.2/@variable">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Continue"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.5/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.5/@statement/@statements.1/@variable"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="u1">
                  <typeReference xsi:type="types:Char">
                    <comments>// If characters don't match but case may be ignored,</comments>
                    <comments>// try converting both characters to uppercase.</comments>
                    <comments>// If the results match, then the comparison scan should</comments>
                    <comments>// continue.</comments>
                  </typeReference>
                  <initialValue xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.130"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.5/@statement/@statements.0/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="u2">
                  <typeReference xsi:type="types:Char"/>
                  <initialValue xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.130"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.5/@statement/@statements.1/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Continue"/>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.5/@statement/@statements.3/@statement/@statements.0/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.5/@statement/@statements.3/@statement/@statements.1/@variable"/>
                </condition>
              </statements>
              <statements xsi:type="statements:Condition">
                <comments>// Unfortunately, conversion to uppercase does not work properly</comments>
                <comments>// for the Georgian alphabet, which has strange rules about case</comments>
                <comments>// conversion.  So we need to make one last check before</comments>
                <comments>// exiting.</comments>
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Continue"/>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.128"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.5/@statement/@statements.3/@statement/@statements.0/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </children>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.128"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.5/@statement/@statements.3/@statement/@statements.1/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </children>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0"/>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.4"/>
            <operator xsi:type="operators:MinusMinus"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="startsWith">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if this string starts with the specified prefix beginning&#xA;     * a specified index.&#xA;     *&#xA;     * @param   prefix    the prefix.&#xA;     * @param   toffset   where to begin looking in the string.&#xA;     * @return  &lt;code>true&lt;/code> if the character sequence represented by the&#xA;     *          argument is a prefix of the substring of this object starting&#xA;     *          at index &lt;code>toffset&lt;/code>; &lt;code>false&lt;/code> otherwise.&#xA;     *          The result is &lt;code>false&lt;/code> if &lt;code>toffset&lt;/code> is&#xA;     *          negative or greater than the length of this&#xA;     *          &lt;code>String&lt;/code> object; otherwise the result is the same&#xA;     *          as the result of the expression&#xA;     *          &lt;pre>&#xA;     *          this.substring(toffset).startsWith(prefix)&#xA;     *          &lt;/pre>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ta">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="to">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="pa">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="po">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="pc">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Note: toffset might be near -1>>>1.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.1"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.1"/>
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.4/@variable"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.0/@variable">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.1/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.2/@variable">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.3/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:PrefixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.4/@variable"/>
            <operator xsi:type="operators:MinusMinus"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="startsWith">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if this string starts with the specified prefix.&#xA;     *&#xA;     * @param   prefix   the prefix.&#xA;     * @return  &lt;code>true&lt;/code> if the character sequence represented by the&#xA;     *          argument is a prefix of the character sequence represented by&#xA;     *          this string; &lt;code>false&lt;/code> otherwise.&#xA;     *          Note also that &lt;code>true&lt;/code> will be returned if the&#xA;     *          argument is an empty string or is equal to this&#xA;     *          &lt;code>String&lt;/code> object as determined by the&#xA;     *          {@link #equals(Object)} method.&#xA;     * @since   1. 0&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="endsWith">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="suffix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if this string ends with the specified suffix.&#xA;     *&#xA;     * @param   suffix   the suffix.&#xA;     * @return  &lt;code>true&lt;/code> if the character sequence represented by the&#xA;     *          argument is a suffix of the character sequence represented by&#xA;     *          this object; &lt;code>false&lt;/code> otherwise. Note that the&#xA;     *          result will be &lt;code>true&lt;/code> if the argument is the&#xA;     *          empty string or is equal to this &lt;code>String&lt;/code> object&#xA;     *          as determined by the {@link #equals(Object)} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.42">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            </children>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a hash code for this string. The hash code for a&#xA;     * &lt;code>String&lt;/code> object is computed as&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * using &lt;code>int&lt;/code> arithmetic, where &lt;code>s[i]&lt;/code> is the&#xA;     * &lt;i>i&lt;/i>th character of the string, &lt;code>n&lt;/code> is the length of&#xA;     * the string, and &lt;code>^&lt;/code> indicates exponentiation.&#xA;     * (The hash value of the empty string is zero.)&#xA;     *&#xA;     * @return  a hash code value for this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="h">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="off">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="val">
              <typeReference xsi:type="types:Char"/>
              <arrayDimensionsAfter/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="len">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            </variable>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="expressions:MultiplicativeExpression">
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="31"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@variable"/>
                      <multiplicativeOperators xsi:type="operators:Multiplication"/>
                    </children>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.1/@statement/@statements.1/@variable">
                      <arraySelectors>
                        <position xsi:type="expressions:SuffixUnaryModificationExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.1/@statement/@statements.0/@variable"/>
                          <operator xsi:type="operators:PlusPlus"/>
                        </position>
                      </arraySelectors>
                    </children>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.1/@statement/@statements.3/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.1/@statement/@statements.2/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.1/@statement/@statements.3/@init"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="indexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this string of the first occurrence of&#xA;     * the specified character. If a character with value&#xA;     * &lt;code>ch&lt;/code> occurs in the character sequence represented by&#xA;     * this &lt;code>String&lt;/code> object, then the index (in Unicode&#xA;     * code units) of the first such occurrence is returned. For&#xA;     * values of &lt;code>ch&lt;/code> in the range from 0 to 0xFFFF&#xA;     * (inclusive), this is the smallest value &lt;i>k&lt;/i> such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * this.charAt(&lt;i>k&lt;/i>) == ch&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * is true. For other values of &lt;code>ch&lt;/code>, it is the&#xA;     * smallest value &lt;i>k&lt;/i> such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * this.codePointAt(&lt;i>k&lt;/i>) == ch&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * is true. In either case, if no such character occurs in this&#xA;     * string, then &lt;code>-1&lt;/code> is returned.&#xA;     *&#xA;     * @param   ch   a character (Unicode code point).&#xA;     * @return  the index of the first occurrence of the character in the&#xA;     *          character sequence represented by this object, or&#xA;     *          &lt;code>-1&lt;/code> if the character does not occur.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.47">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="indexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this string of the first occurrence of the&#xA;     * specified character, starting the search at the specified index.&#xA;     * &lt;p>&#xA;     * If a character with value &lt;code>ch&lt;/code> occurs in the&#xA;     * character sequence represented by this &lt;code>String&lt;/code>&#xA;     * object at an index no smaller than &lt;code>fromIndex&lt;/code>, then&#xA;     * the index of the first such occurrence is returned. For values&#xA;     * of &lt;code>ch&lt;/code> in the range from 0 to 0xFFFF (inclusive),&#xA;     * this is the smallest value &lt;i>k&lt;/i> such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * (this.charAt(&lt;i>k&lt;/i>) == ch) &amp;&amp; (&lt;i>k&lt;/i> &amp;gt;= fromIndex)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * is true. For other values of &lt;code>ch&lt;/code>, it is the&#xA;     * smallest value &lt;i>k&lt;/i> such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * (this.codePointAt(&lt;i>k&lt;/i>) == ch) &amp;&amp; (&lt;i>k&lt;/i> &amp;gt;= fromIndex)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * is true. In either case, if no such character occurs in this&#xA;     * string at or after position &lt;code>fromIndex&lt;/code>, then&#xA;     * &lt;code>-1&lt;/code> is returned.&#xA;     *&#xA;     * &lt;p>&#xA;     * There is no restriction on the value of &lt;code>fromIndex&lt;/code>. If it&#xA;     * is negative, it has the same effect as if it were zero: this entire&#xA;     * string may be searched. If it is greater than the length of this&#xA;     * string, it has the same effect as if it were equal to the length of&#xA;     * this string: &lt;code>-1&lt;/code> is returned.&#xA;     *&#xA;     * &lt;p>All indices are specified in &lt;code>char&lt;/code> values&#xA;     * (Unicode code units).&#xA;     *&#xA;     * @param   ch          a character (Unicode code point).&#xA;     * @param   fromIndex   the index to start the search from.&#xA;     * @return  the index of the first occurrence of the character in the&#xA;     *          character sequence represented by this object that is greater&#xA;     *          than or equal to &lt;code>fromIndex&lt;/code>, or &lt;code>-1&lt;/code>&#xA;     *          if the character does not occur.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="max">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Return">
              <comments>// Note: fromIndex might be near -1>>>1.</comments>
              <returnValue xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </returnValue>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ForLoop">
            <comments>// handle most cases here (ch is a BMP code point or a</comments>
            <comments>// negative value (invalid code point))</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Return">
                    <returnValue xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.3/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </returnValue>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.1/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.3/@variable"/>
                    </arraySelectors>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.3/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.3/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.62"/>
            </next>
            <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="surrogates">
              <typeReference xsi:type="types:Char">
                <comments>// handle supplementary characters here</comments>
              </typeReference>
              <arrayDimensionsBefore/>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.94"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:Break"/>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.3/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.0/@variable"/>
                    </condition>
                  </statements>
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:Return">
                        <returnValue xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.3/@variable"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                          <additiveOperators xsi:type="operators:Subtraction"/>
                        </returnValue>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.1/@variable">
                        <arraySelectors>
                          <position xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.3/@variable"/>
                            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                          </position>
                        </arraySelectors>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.5/@statement/@statements.0/@variable">
                        <arraySelectors>
                          <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        </arraySelectors>
                      </children>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.1/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.3/@variable"/>
                    </arraySelectors>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.5/@statement/@statements.0/@variable">
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    </arraySelectors>
                  </children>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.3/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.3/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.64"/>
            </next>
            <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
          </children>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lastIndexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this string of the last occurrence of&#xA;     * the specified character. For values of &lt;code>ch&lt;/code> in the&#xA;     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code&#xA;     * units) returned is the largest value &lt;i>k&lt;/i> such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * this.charAt(&lt;i>k&lt;/i>) == ch&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * is true. For other values of &lt;code>ch&lt;/code>, it is the&#xA;     * largest value &lt;i>k&lt;/i> such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * this.codePointAt(&lt;i>k&lt;/i>) == ch&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * is true.  In either case, if no such character occurs in this&#xA;     * string, then &lt;code>-1&lt;/code> is returned.  The&#xA;     * &lt;code>String&lt;/code> is searched backwards starting at the last&#xA;     * character.&#xA;     *&#xA;     * @param   ch   a character (Unicode code point).&#xA;     * @return  the index of the last occurrence of the character in the&#xA;     *          character sequence represented by this object, or&#xA;     *          &lt;code>-1&lt;/code> if the character does not occur.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.49">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lastIndexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this string of the last occurrence of&#xA;     * the specified character, searching backward starting at the&#xA;     * specified index. For values of &lt;code>ch&lt;/code> in the range&#xA;     * from 0 to 0xFFFF (inclusive), the index returned is the largest&#xA;     * value &lt;i>k&lt;/i> such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * (this.charAt(&lt;i>k&lt;/i>) == ch) &amp;&amp; (&lt;i>k&lt;/i> &amp;lt;= fromIndex)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * is true. For other values of &lt;code>ch&lt;/code>, it is the&#xA;     * largest value &lt;i>k&lt;/i> such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * (this.codePointAt(&lt;i>k&lt;/i>) == ch) &amp;&amp; (&lt;i>k&lt;/i> &amp;lt;= fromIndex)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * is true. In either case, if no such character occurs in this&#xA;     * string at or before position &lt;code>fromIndex&lt;/code>, then&#xA;     * &lt;code>-1&lt;/code> is returned.&#xA;     *&#xA;     * &lt;p>All indices are specified in &lt;code>char&lt;/code> values&#xA;     * (Unicode code units).&#xA;     *&#xA;     * @param   ch          a character (Unicode code point).&#xA;     * @param   fromIndex   the index to start the search from. There is no&#xA;     *          restriction on the value of &lt;code>fromIndex&lt;/code>. If it is&#xA;     *          greater than or equal to the length of this string, it has&#xA;     *          the same effect as if it were equal to one less than the&#xA;     *          length of this string: this entire string may be searched.&#xA;     *          If it is negative, it has the same effect as if it were -1:&#xA;     *          -1 is returned.&#xA;     * @return  the index of the last occurrence of the character in the&#xA;     *          character sequence represented by this object that is less&#xA;     *          than or equal to &lt;code>fromIndex&lt;/code>, or &lt;code>-1&lt;/code>&#xA;     *          if the character does not occur before that point.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="min">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ConditionalExpression">
                <child xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.1"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                    <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                  </expression>
                </child>
                <expressionIf xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </expressionIf>
                <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.1"/>
              </expression>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ForLoop">
            <comments>// handle most cases here (ch is a BMP code point or a</comments>
            <comments>// negative value (invalid code point))</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Return">
                    <returnValue xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </returnValue>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable"/>
                    </arraySelectors>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </condition>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable"/>
              <operator xsi:type="operators:MinusMinus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.62"/>
            </next>
            <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="max">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="surrogates">
              <typeReference xsi:type="types:Char">
                <comments>// handle supplementary characters here</comments>
              </typeReference>
              <arrayDimensionsBefore/>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.94"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:Break"/>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.4/@variable"/>
                    </condition>
                  </statements>
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:Return">
                        <returnValue xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                          <additiveOperators xsi:type="operators:Subtraction"/>
                        </returnValue>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable">
                        <arraySelectors>
                          <position xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable"/>
                            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                          </position>
                        </arraySelectors>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.5/@statement/@statements.0/@variable">
                        <arraySelectors>
                          <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        </arraySelectors>
                      </children>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable"/>
                    </arraySelectors>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.5/@statement/@statements.0/@variable">
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    </arraySelectors>
                  </children>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </condition>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable"/>
              <operator xsi:type="operators:MinusMinus"/>
            </updates>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.64"/>
            </next>
            <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
          </children>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="indexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this string of the first occurrence of the&#xA;     * specified substring. The integer returned is the smallest value&#xA;     * &lt;i>k&lt;/i> such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * this.startsWith(str, &lt;i>k&lt;/i>)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * is &lt;code>true&lt;/code>.&#xA;     *&#xA;     * @param   str   any string.&#xA;     * @return  if the string argument occurs as a substring within this&#xA;     *          object, then the index of the first character of the first&#xA;     *          such substring is returned; if it does not occur as a&#xA;     *          substring, &lt;code>-1&lt;/code> is returned.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.51">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="indexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this string of the first occurrence of the&#xA;     * specified substring, starting at the specified index.  The integer&#xA;     * returned is the smallest value &lt;tt>k&lt;/tt> for which:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *     k &amp;gt;= Math.min(fromIndex, str.length()) &amp;&amp; this.startsWith(str, k)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * If no such value of &lt;i>k&lt;/i> exists, then -1 is returned.&#xA;     *&#xA;     * @param   str         the substring for which to search.&#xA;     * @param   fromIndex   the index from which to start the search.&#xA;     * @return  the index within this string of the first occurrence of the&#xA;     *          specified substring, starting at the specified index.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.52">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="indexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sourceOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sourceCount">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="target">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="targetOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="targetCount">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Code shared by String and StringBuffer to do searches. The&#xA;     * source is the character array being searched, and the target&#xA;     * is the string being searched for.&#xA;     *&#xA;     * @param   source       the characters being searched.&#xA;     * @param   sourceOffset offset of the source string.&#xA;     * @param   sourceCount  count of the source string.&#xA;     * @param   target       the characters being searched for.&#xA;     * @param   targetOffset offset of the target string.&#xA;     * @param   targetCount  count of the target string.&#xA;     * @param   fromIndex    the index to begin searching from.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ConditionalExpression">
                <child xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.5"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </child>
                <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.2"/>
                <expressionElse xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Subtraction"/>
                  <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </expressionElse>
              </expression>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.6"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.2"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.6"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.6"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.6"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.5"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="first">
          <typeReference xsi:type="types:Char"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.3">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.4"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="max">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.1"/>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.2"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.5"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </expression>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>/* Look for first character. */</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:WhileLoop">
                <statement xsi:type="statements:EmptyStatement"/>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:RelationExpression">
                    <children xsi:type="expressions:PrefixUnaryModificationExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@init"/>
                      <operator xsi:type="operators:PlusPlus"/>
                    </children>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.4/@variable"/>
                    <relationOperators xsi:type="operators:LessThanOrEqual"/>
                  </children>
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@init"/>
                      </arraySelectors>
                    </children>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.3/@variable"/>
                  </children>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@init"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.3/@variable"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>/* Found first character, now look at the rest of v2 */</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="j">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@init"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="end">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@statement/@statements.1/@statement/@statements.0/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.5"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Subtraction"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:ForLoop">
                <statement xsi:type="statements:EmptyStatement"/>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@statement/@statements.1/@statement/@statements.0/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@statement/@statements.1/@statement/@statements.1/@variable"/>
                    <relationOperators xsi:type="operators:LessThan"/>
                  </children>
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@statement/@statements.1/@statement/@statements.0/@variable"/>
                      </arraySelectors>
                    </children>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.3">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@statement/@statements.1/@statement/@statements.2/@init"/>
                      </arraySelectors>
                    </children>
                  </children>
                </condition>
                <init xsi:type="variables:LocalVariable" name="k">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.4"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </initialValue>
                </init>
                <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@statement/@statements.1/@statement/@statements.0/@variable"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </updates>
                <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@statement/@statements.1/@statement/@statements.2/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </updates>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Return">
                    <comments>/* Found whole string. */</comments>
                    <returnValue xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@init"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.1"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </returnValue>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@statement/@statements.1/@statement/@statements.0/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@statement/@statements.1/@statement/@statements.1/@variable"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.4/@variable"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.4/@variable"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.6"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.5/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lastIndexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this string of the rightmost occurrence&#xA;     * of the specified substring.  The rightmost empty string &quot;&quot; is&#xA;     * considered to occur at the index value &lt;code>this.length()&lt;/code>.&#xA;     * The returned index is the largest value &lt;i>k&lt;/i> such that&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * this.startsWith(str, k)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * is true.&#xA;     *&#xA;     * @param   str   the substring to search for.&#xA;     * @return  if the string argument occurs one or more times as a substring&#xA;     *          within this object, then the index of the first character of&#xA;     *          the last such substring is returned. If it does not occur as&#xA;     *          a substring, &lt;code>-1&lt;/code> is returned.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.54">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lastIndexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within this string of the last occurrence of the&#xA;     * specified substring, searching backward starting at the specified index.&#xA;     * The integer returned is the largest value &lt;i>k&lt;/i> such that:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *     k &amp;lt;= Math.min(fromIndex, str.length()) &amp;&amp; this.startsWith(str, k)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * If no such value of &lt;i>k&lt;/i> exists, then -1 is returned.&#xA;     * &#xA;     * @param   str         the substring to search for.&#xA;     * @param   fromIndex   the index to start the search from.&#xA;     * @return  the index within this string of the last occurrence of the&#xA;     *          specified substring.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lastIndexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="source">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sourceOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sourceCount">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="target">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="targetOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="targetCount">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Code shared by String and StringBuffer to do searches. The&#xA;     * source is the character array being searched, and the target&#xA;     * is the string being searched for.&#xA;     *&#xA;     * @param   source       the characters being searched.&#xA;     * @param   sourceOffset offset of the source string.&#xA;     * @param   sourceCount  count of the source string.&#xA;     * @param   target       the characters being searched for.&#xA;     * @param   targetOffset offset of the target string.&#xA;     * @param   targetCount  count of the target string.&#xA;     * @param   fromIndex    the index to begin searching from.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="rightIndex">
          <typeReference xsi:type="types:Int">
            <comments>/*&#xA;&#x9; * Check arguments; return immediately where possible. For&#xA;&#x9; * consistency, don't check for null str.&#xA;&#x9; */</comments>
          </typeReference>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.5"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.6"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.6"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.6"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>/* Empty string always matches. */</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.6"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.5"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="strLastIndex">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.4"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.5"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="strLastChar">
          <typeReference xsi:type="types:Char"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.3">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.4/@variable"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="min">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.5"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.6/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.6"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:JumpLabel" name="startSearchForLastChar">
        <statement xsi:type="statements:WhileLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:WhileLoop">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.7/@variable"/>
                    <operator xsi:type="operators:MinusMinus"/>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:ConditionalAndExpression">
                <children xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.7/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.6/@variable"/>
                  <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                </children>
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.0">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.7/@variable"/>
                    </arraySelectors>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.5/@variable"/>
                </children>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="expressions:UnaryExpression">
                    <operators xsi:type="operators:Subtraction"/>
                    <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  </returnValue>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.7/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.6/@variable"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </condition>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="j">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.7/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="start">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.8/@statement/@statement/@statements.2/@variable"/>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.5"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </expression>
                  </children>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="k">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.4/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:WhileLoop">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.7/@variable"/>
                        <operator xsi:type="operators:MinusMinus"/>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:Continue" target="//@classifiers.0/@members.55/@statements.8"/>
                  </statement>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.0">
                      <arraySelectors>
                        <position xsi:type="expressions:SuffixUnaryModificationExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.8/@statement/@statement/@statements.2/@variable"/>
                          <operator xsi:type="operators:MinusMinus"/>
                        </position>
                      </arraySelectors>
                    </children>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.3">
                      <arraySelectors>
                        <position xsi:type="expressions:SuffixUnaryModificationExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.8/@statement/@statement/@statements.4/@variable"/>
                          <operator xsi:type="operators:MinusMinus"/>
                        </position>
                      </arraySelectors>
                    </children>
                  </condition>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.8/@statement/@statement/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.8/@statement/@statement/@statements.3/@variable"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </condition>
            </statements>
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@statements.8/@statement/@statement/@statements.3/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.1"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </returnValue>
            </statements>
          </statement>
          <condition xsi:type="literals:BooleanLiteral" value="true"/>
        </statement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="substring">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="beginIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a new string that is a substring of this string. The&#xA;     * substring begins with the character at the specified index and&#xA;     * extends to the end of this string. &lt;p>&#xA;     * Examples:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * &quot;unhappy&quot;.substring(2) returns &quot;happy&quot;&#xA;     * &quot;Harbison&quot;.substring(3) returns &quot;bison&quot;&#xA;     * &quot;emptiness&quot;.substring(9) returns &quot;&quot; (an empty string)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @param      beginIndex   the beginning index, inclusive.&#xA;     * @return     the specified substring.&#xA;     * @exception  IndexOutOfBoundsException  if&#xA;     *             &lt;code>beginIndex&lt;/code> is negative or larger than the&#xA;     *             length of this &lt;code>String&lt;/code> object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.57">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="substring">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="beginIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="endIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a new string that is a substring of this string. The&#xA;     * substring begins at the specified &lt;code>beginIndex&lt;/code> and&#xA;     * extends to the character at index &lt;code>endIndex - 1&lt;/code>.&#xA;     * Thus the length of the substring is &lt;code>endIndex-beginIndex&lt;/code>.&#xA;     * &lt;p>&#xA;     * Examples:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * &quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot;&#xA;     * &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot;&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @param      beginIndex   the beginning index, inclusive.&#xA;     * @param      endIndex     the ending index, exclusive.&#xA;     * @return     the specified substring.&#xA;     * @exception  IndexOutOfBoundsException  if the&#xA;     *             &lt;code>beginIndex&lt;/code> is negative, or&#xA;     *             &lt;code>endIndex&lt;/code> is larger than the length of&#xA;     *             this &lt;code>String&lt;/code> object, or&#xA;     *             &lt;code>beginIndex&lt;/code> is larger than&#xA;     *             &lt;code>endIndex&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.1"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="StringIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.1"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                </expression>
              </children>
            </expression>
          </child>
          <expressionIf xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </expressionIf>
          <expressionElse xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="subSequence">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="beginIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="endIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a new character sequence that is a subsequence of this sequence.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form&#xA;     *&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * str.subSequence(begin,&amp;nbsp;end)&lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * behaves in exactly the same way as the invocation&#xA;     *&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * str.substring(begin,&amp;nbsp;end)&lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * This method is defined so that the &lt;tt>String&lt;/tt> class can implement&#xA;     * the {@link CharSequence} interface. &lt;/p>&#xA;     *&#xA;     * @param      beginIndex   the begin index, inclusive.&#xA;     * @param      endIndex     the end index, exclusive.&#xA;     * @return     the specified subsequence.&#xA;     *&#xA;     * @throws  IndexOutOfBoundsException&#xA;     *          if &lt;tt>beginIndex&lt;/tt> or &lt;tt>endIndex&lt;/tt> are negative,&#xA;     *          if &lt;tt>endIndex&lt;/tt> is greater than &lt;tt>length()&lt;/tt>,&#xA;     *          or if &lt;tt>beginIndex&lt;/tt> is greater than &lt;tt>startIndex&lt;/tt>&#xA;     *&#xA;     * @since 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.57">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58/@parameters.1"/>
          </next>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="concat">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Concatenates the specified string to the end of this string.&#xA;     * &lt;p>&#xA;     * If the length of the argument string is &lt;code>0&lt;/code>, then this&#xA;     * &lt;code>String&lt;/code> object is returned. Otherwise, a new&#xA;     * &lt;code>String&lt;/code> object is created, representing a character&#xA;     * sequence that is the concatenation of the character sequence&#xA;     * represented by this &lt;code>String&lt;/code> object and the character&#xA;     * sequence represented by the argument string.&lt;p>&#xA;     * Examples:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * &quot;cares&quot;.concat(&quot;s&quot;) returns &quot;caress&quot;&#xA;     * &quot;to&quot;.concat(&quot;get&quot;).concat(&quot;her&quot;) returns &quot;together&quot;&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @param   str   the &lt;code>String&lt;/code> that is concatenated to the end&#xA;     *                of this &lt;code>String&lt;/code>.&#xA;     * @return  a string that represents the concatenation of this object's&#xA;     *          characters followed by the string argument's characters.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="otherLen">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.21"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="buf">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.0/@variable"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </sizes>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.2/@variable"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.0">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.2/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.0/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.2/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="replace">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="oldChar">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newChar">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a new string resulting from replacing all occurrences of&#xA;     * &lt;code>oldChar&lt;/code> in this string with &lt;code>newChar&lt;/code>.&#xA;     * &lt;p>&#xA;     * If the character &lt;code>oldChar&lt;/code> does not occur in the&#xA;     * character sequence represented by this &lt;code>String&lt;/code> object,&#xA;     * then a reference to this &lt;code>String&lt;/code> object is returned.&#xA;     * Otherwise, a new &lt;code>String&lt;/code> object is created that&#xA;     * represents a character sequence identical to the character sequence&#xA;     * represented by this &lt;code>String&lt;/code> object, except that every&#xA;     * occurrence of &lt;code>oldChar&lt;/code> is replaced by an occurrence&#xA;     * of &lt;code>newChar&lt;/code>.&#xA;     * &lt;p>&#xA;     * Examples:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * &quot;mesquite in your cellar&quot;.replace('e', 'o')&#xA;     *         returns &quot;mosquito in your collar&quot;&#xA;     * &quot;the war of baronets&quot;.replace('r', 'y')&#xA;     *         returns &quot;the way of bayonets&quot;&#xA;     * &quot;sparring with a purple porpoise&quot;.replace('p', 't')&#xA;     *         returns &quot;starring with a turtle tortoise&quot;&#xA;     * &quot;JonL&quot;.replace('q', 'x') returns &quot;JonL&quot; (no change)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @param   oldChar   the old character.&#xA;     * @param   newChar   the new character.&#xA;     * @return  a string derived from this string by replacing every&#xA;     *          occurrence of &lt;code>oldChar&lt;/code> with &lt;code>newChar&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="len">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="val">
              <typeReference xsi:type="types:Char"/>
              <arrayDimensionsBefore/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="off">
              <typeReference xsi:type="types:Int">
                <comments>/* avoid getfield opcode */</comments>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </variable>
          </statements>
          <statements xsi:type="statements:WhileLoop">
            <comments>/* avoid getfield opcode */</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Break"/>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.2/@variable">
                    <arraySelectors>
                      <position xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.3/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.1/@variable"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </position>
                    </arraySelectors>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.0"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="expressions:PrefixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.1/@variable"/>
                <operator xsi:type="operators:PlusPlus"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="buf">
                  <typeReference xsi:type="types:Char"/>
                  <arrayDimensionsAfter/>
                  <initialValue xsi:type="arrays:ArrayInstantiationBySize">
                    <typeReference xsi:type="types:Char"/>
                    <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.0/@variable"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:ForLoop">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.5/@statement/@statements.0/@variable">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.5/@statement/@statements.1/@init"/>
                        </arraySelectors>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.2/@variable">
                        <arraySelectors>
                          <position xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.3/@variable"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.5/@statement/@statements.1/@init"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                          </position>
                        </arraySelectors>
                      </value>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.5/@statement/@statements.1/@init"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.1/@variable"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
                <init xsi:type="variables:LocalVariable" name="j">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </init>
                <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.5/@statement/@statements.1/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </updates>
              </statements>
              <statements xsi:type="statements:WhileLoop">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="c">
                      <typeReference xsi:type="types:Char"/>
                      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.2/@variable">
                        <arraySelectors>
                          <position xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.3/@variable"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.1/@variable"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                          </position>
                        </arraySelectors>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.5/@statement/@statements.0/@variable">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.1/@variable"/>
                        </arraySelectors>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="expressions:ConditionalExpression">
                        <child xsi:type="expressions:NestedExpression">
                          <expression xsi:type="expressions:EqualityExpression">
                            <equalityOperators xsi:type="operators:Equal"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.5/@statement/@statements.2/@statement/@statements.0/@variable"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.0"/>
                          </expression>
                        </child>
                        <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.1"/>
                        <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.5/@statement/@statements.2/@statement/@statements.0/@variable"/>
                      </value>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.1/@variable"/>
                      <operator xsi:type="operators:PlusPlus"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.1/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.0/@variable"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
              </statements>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0"/>
                  </typeReference>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.5/@statement/@statements.0/@variable"/>
                </returnValue>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@statements.0/@statement/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.1"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="matches">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="regex">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tells whether or not this string matches the given &lt;a&#xA;     * href=&quot;../util/regex/Pattern.html#sum&quot;>regular expression&lt;/a>.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form&#xA;     * &lt;i>str&lt;/i>&lt;tt>.matches(&lt;/tt>&lt;i>regex&lt;/i>&lt;tt>)&lt;/tt> yields exactly the&#xA;     * same result as the expression&#xA;     *&#xA;     * &lt;blockquote>&lt;tt> {@link java.util.regex.Pattern}.{@link&#xA;     * java.util.regex.Pattern#matches(String,CharSequence)&#xA;     * matches}(&lt;/tt>&lt;i>regex&lt;/i>&lt;tt>,&lt;/tt> &lt;i>str&lt;/i>&lt;tt>)&lt;/tt>&lt;/blockquote>&#xA;     *&#xA;     * @param   regex&#xA;     *          the regular expression to which this string is to be matched&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this string matches the&#xA;     *          given regular expression&#xA;     *&#xA;     * @throws  PatternSyntaxException&#xA;     *          if the regular expression's syntax is invalid&#xA;     *&#xA;     * @see java.util.regex.Pattern&#xA;     *&#xA;     * @since 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../util/regex/Pattern.class.xmi#//@classifiers.0/@members.36"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.0"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="../util/regex/Pattern.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="contains">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns true if and only if this string contains the specified&#xA;     * sequence of char values.&#xA;     *&#xA;     * @param s the sequence to search for&#xA;     * @return true if this string contains &lt;code>s&lt;/code>, false otherwise&#xA;     * @throws NullPointerException if &lt;code>s&lt;/code> is &lt;code>null&lt;/code>&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:RelationExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.50">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.3"/>
              </next>
            </arguments>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="replaceFirst">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="regex">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="replacement">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Replaces the first substring of this string that matches the given &lt;a&#xA;     * href=&quot;../util/regex/Pattern.html#sum&quot;>regular expression&lt;/a> with the&#xA;     * given replacement.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form&#xA;     * &lt;i>str&lt;/i>&lt;tt>.replaceFirst(&lt;/tt>&lt;i>regex&lt;/i>&lt;tt>,&lt;/tt> &lt;i>repl&lt;/i>&lt;tt>)&lt;/tt>&#xA;     * yields exactly the same result as the expression&#xA;     *&#xA;     * &lt;blockquote>&lt;tt>&#xA;     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#compile&#xA;     * compile}(&lt;/tt>&lt;i>regex&lt;/i>&lt;tt>).{@link&#xA;     * java.util.regex.Pattern#matcher(java.lang.CharSequence)&#xA;     * matcher}(&lt;/tt>&lt;i>str&lt;/i>&lt;tt>).{@link java.util.regex.Matcher#replaceFirst&#xA;     * replaceFirst}(&lt;/tt>&lt;i>repl&lt;/i>&lt;tt>)&lt;/tt>&lt;/blockquote>&#xA;     *&#xA;     * @param   regex&#xA;     *          the regular expression to which this string is to be matched&#xA;     *&#xA;     * @return  The resulting &lt;tt>String&lt;/tt>&#xA;     *&#xA;     * @throws  PatternSyntaxException&#xA;     *          if the regular expression's syntax is invalid&#xA;     *&#xA;     * @see java.util.regex.Pattern&#xA;     *&#xA;     * @since 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/regex/Matcher.class.xmi#//@classifiers.0/@members.39"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.1"/>
              </next>
              <target xsi:type="members:ClassMethod" href="../util/regex/Pattern.class.xmi#//@classifiers.0/@members.34"/>
              <arguments xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
            <target xsi:type="members:ClassMethod" href="../util/regex/Pattern.class.xmi#//@classifiers.0/@members.30"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="../util/regex/Pattern.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="replaceAll">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="regex">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="replacement">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Replaces each substring of this string that matches the given &lt;a&#xA;     * href=&quot;../util/regex/Pattern.html#sum&quot;>regular expression&lt;/a> with the&#xA;     * given replacement.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form&#xA;     * &lt;i>str&lt;/i>&lt;tt>.replaceAll(&lt;/tt>&lt;i>regex&lt;/i>&lt;tt>,&lt;/tt> &lt;i>repl&lt;/i>&lt;tt>)&lt;/tt>&#xA;     * yields exactly the same result as the expression&#xA;     *&#xA;     * &lt;blockquote>&lt;tt>&#xA;     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#compile&#xA;     * compile}(&lt;/tt>&lt;i>regex&lt;/i>&lt;tt>).{@link&#xA;     * java.util.regex.Pattern#matcher(java.lang.CharSequence)&#xA;     * matcher}(&lt;/tt>&lt;i>str&lt;/i>&lt;tt>).{@link java.util.regex.Matcher#replaceAll&#xA;     * replaceAll}(&lt;/tt>&lt;i>repl&lt;/i>&lt;tt>)&lt;/tt>&lt;/blockquote>&#xA;     *&#xA;     * @param   regex&#xA;     *          the regular expression to which this string is to be matched&#xA;     *&#xA;     * @return  The resulting &lt;tt>String&lt;/tt>&#xA;     *&#xA;     * @throws  PatternSyntaxException&#xA;     *          if the regular expression's syntax is invalid&#xA;     *&#xA;     * @see java.util.regex.Pattern&#xA;     *&#xA;     * @since 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/regex/Matcher.class.xmi#//@classifiers.0/@members.38"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.1"/>
              </next>
              <target xsi:type="members:ClassMethod" href="../util/regex/Pattern.class.xmi#//@classifiers.0/@members.34"/>
              <arguments xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
            <target xsi:type="members:ClassMethod" href="../util/regex/Pattern.class.xmi#//@classifiers.0/@members.30"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="../util/regex/Pattern.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="replace">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="target">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="replacement">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Replaces each substring of this string that matches the literal target&#xA;     * sequence with the specified literal replacement sequence. The &#xA;     * replacement proceeds from the beginning of the string to the end, for &#xA;     * example, replacing &quot;aa&quot; with &quot;b&quot; in the string &quot;aaa&quot; will result in &#xA;     * &quot;ba&quot; rather than &quot;ab&quot;.&#xA;     *&#xA;     * @param  target The sequence of char values to be replaced&#xA;     * @param  replacement The replacement sequence of char values&#xA;     * @return  The resulting string&#xA;     * @throws NullPointerException if &lt;code>target&lt;/code> or&#xA;     *         &lt;code>replacement&lt;/code> is &lt;code>null&lt;/code>.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/regex/Matcher.class.xmi#//@classifiers.0/@members.38"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../util/regex/Matcher.class.xmi#//@classifiers.0/@members.35"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@parameters.1">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.3"/>
                      </next>
                    </arguments>
                  </next>
                  <target xsi:type="classifiers:Class" href="../util/regex/Matcher.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
              <target xsi:type="members:ClassMethod" href="../util/regex/Pattern.class.xmi#//@classifiers.0/@members.34"/>
              <arguments xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
            <target xsi:type="members:ClassMethod" href="../util/regex/Pattern.class.xmi#//@classifiers.0/@members.31"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.3"/>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../util/regex/Pattern.class.xmi#//@classifiers.0/@members.4"/>
              </next>
              <target xsi:type="classifiers:Class" href="../util/regex/Pattern.class.xmi#//@classifiers.0"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="../util/regex/Pattern.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="split">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="regex">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="limit">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Splits this string around matches of the given &#xA;     * &lt;a href=&quot;../util/regex/Pattern.html#sum&quot;>regular expression&lt;/a>.&#xA;     *&#xA;     * &lt;p> The array returned by this method contains each substring of this&#xA;     * string that is terminated by another substring that matches the given&#xA;     * expression or is terminated by the end of the string.  The substrings in&#xA;     * the array are in the order in which they occur in this string.  If the&#xA;     * expression does not match any part of the input then the resulting array&#xA;     * has just one element, namely this string.&#xA;     *&#xA;     * &lt;p> The &lt;tt>limit&lt;/tt> parameter controls the number of times the&#xA;     * pattern is applied and therefore affects the length of the resulting&#xA;     * array.  If the limit &lt;i>n&lt;/i> is greater than zero then the pattern&#xA;     * will be applied at most &lt;i>n&lt;/i>&amp;nbsp;-&amp;nbsp;1 times, the array's&#xA;     * length will be no greater than &lt;i>n&lt;/i>, and the array's last entry&#xA;     * will contain all input beyond the last matched delimiter.  If &lt;i>n&lt;/i>&#xA;     * is non-positive then the pattern will be applied as many times as&#xA;     * possible and the array can have any length.  If &lt;i>n&lt;/i> is zero then&#xA;     * the pattern will be applied as many times as possible, the array can&#xA;     * have any length, and trailing empty strings will be discarded.&#xA;     *&#xA;     * &lt;p> The string &lt;tt>&quot;boo:and:foo&quot;&lt;/tt>, for example, yields the&#xA;     * following results with these parameters:&#xA;     *&#xA;     * &lt;blockquote>&lt;table cellpadding=1 cellspacing=0 summary=&quot;Split example showing regex, limit, and result&quot;>&#xA;     * &lt;tr>&#xA;     *     &lt;th>Regex&lt;/th>&#xA;     *     &lt;th>Limit&lt;/th>&#xA;     *     &lt;th>Result&lt;/th>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&lt;td align=center>:&lt;/td>&#xA;     *     &lt;td align=center>2&lt;/td>&#xA;     *     &lt;td>&lt;tt>{ &quot;boo&quot;, &quot;and:foo&quot; }&lt;/tt>&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td align=center>:&lt;/td>&#xA;     *     &lt;td align=center>5&lt;/td>&#xA;     *     &lt;td>&lt;tt>{ &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }&lt;/tt>&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td align=center>:&lt;/td>&#xA;     *     &lt;td align=center>-2&lt;/td>&#xA;     *     &lt;td>&lt;tt>{ &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }&lt;/tt>&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td align=center>o&lt;/td>&#xA;     *     &lt;td align=center>5&lt;/td>&#xA;     *     &lt;td>&lt;tt>{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }&lt;/tt>&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td align=center>o&lt;/td>&#xA;     *     &lt;td align=center>-2&lt;/td>&#xA;     *     &lt;td>&lt;tt>{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }&lt;/tt>&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td align=center>o&lt;/td>&#xA;     *     &lt;td align=center>0&lt;/td>&#xA;     *     &lt;td>&lt;tt>{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }&lt;/tt>&lt;/td>&lt;/tr>&#xA;     * &lt;/table>&lt;/blockquote>&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form&#xA;     * &lt;i>str.&lt;/i>&lt;tt>split(&lt;/tt>&lt;i>regex&lt;/i>&lt;tt>,&lt;/tt>&amp;nbsp;&lt;i>n&lt;/i>&lt;tt>)&lt;/tt>&#xA;     * yields the same result as the expression&#xA;     *&#xA;     * &lt;blockquote>&#xA;     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#compile&#xA;     * compile}&lt;tt>(&lt;/tt>&lt;i>regex&lt;/i>&lt;tt>)&lt;/tt>.{@link&#xA;     * java.util.regex.Pattern#split(java.lang.CharSequence,int)&#xA;     * split}&lt;tt>(&lt;/tt>&lt;i>str&lt;/i>&lt;tt>,&lt;/tt>&amp;nbsp;&lt;i>n&lt;/i>&lt;tt>)&lt;/tt>&#xA;     * &lt;/blockquote>&#xA;     *&#xA;     *&#xA;     * @param  regex&#xA;     *         the delimiting regular expression&#xA;     *&#xA;     * @param  limit&#xA;     *         the result threshold, as described above&#xA;     *&#xA;     * @return  the array of strings computed by splitting this string&#xA;     *          around matches of the given regular expression&#xA;     *&#xA;     * @throws  PatternSyntaxException&#xA;     *          if the regular expression's syntax is invalid&#xA;     *&#xA;     * @see java.util.regex.Pattern&#xA;     *&#xA;     * @since 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/regex/Pattern.class.xmi#//@classifiers.0/@members.37"/>
              <arguments xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.1"/>
            </next>
            <target xsi:type="members:ClassMethod" href="../util/regex/Pattern.class.xmi#//@classifiers.0/@members.30"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="../util/regex/Pattern.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="split">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="regex">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Splits this string around matches of the given &#xA;     * {@linkplain java.util.regex.Pattern#sum regular expression}.&#xA;     *&#xA;     * &lt;p> This method works as if by invoking the two-argument {@link&#xA;     * #split(String, int) split} method with the given expression and a limit&#xA;     * argument of zero.  Trailing empty strings are therefore not included in&#xA;     * the resulting array.&#xA;     *&#xA;     * &lt;p> The string &lt;tt>&quot;boo:and:foo&quot;&lt;/tt>, for example, yields the following&#xA;     * results with these expressions:&#xA;     *&#xA;     * &lt;blockquote>&lt;table cellpadding=1 cellspacing=0 summary=&quot;Split examples showing regex and result&quot;>&#xA;     * &lt;tr>&#xA;     *  &lt;th>Regex&lt;/th>&#xA;     *  &lt;th>Result&lt;/th>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&lt;td align=center>:&lt;/td>&#xA;     *     &lt;td>&lt;tt>{ &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }&lt;/tt>&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td align=center>o&lt;/td>&#xA;     *     &lt;td>&lt;tt>{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }&lt;/tt>&lt;/td>&lt;/tr>&#xA;     * &lt;/table>&lt;/blockquote>&#xA;     *&#xA;     *&#xA;     * @param  regex&#xA;     *         the delimiting regular expression&#xA;     *&#xA;     * @return  the array of strings computed by splitting this string&#xA;     *          around matches of the given regular expression&#xA;     *&#xA;     * @throws  PatternSyntaxException&#xA;     *          if the regular expression's syntax is invalid&#xA;     *&#xA;     * @see java.util.regex.Pattern&#xA;     *&#xA;     * @since 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.66">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toLowerCase">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="locale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts all of the characters in this &lt;code>String&lt;/code> to lower&#xA;     * case using the rules of the given &lt;code>Locale&lt;/code>.  Case mapping is based&#xA;     * on the Unicode Standard version specified by the {@link java.lang.Character Character}&#xA;     * class. Since case mappings are not always 1:1 char mappings, the resulting &#xA;     * &lt;code>String&lt;/code> may be a different length than the original &lt;code>String&lt;/code>.&#xA;     * &lt;p>&#xA;     * Examples of lowercase  mappings are in the following table:&#xA;     * &lt;table border=&quot;1&quot; summary=&quot;Lowercase mapping examples showing language code of locale, upper case, lower case, and description&quot;>&#xA;     * &lt;tr>&#xA;     *   &lt;th>Language Code of Locale&lt;/th>&#xA;     *   &lt;th>Upper Case&lt;/th>&#xA;     *   &lt;th>Lower Case&lt;/th>&#xA;     *   &lt;th>Description&lt;/th>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     *   &lt;td>tr (Turkish)&lt;/td>&#xA;     *   &lt;td>&amp;#92;u0130&lt;/td>&#xA;     *   &lt;td>&amp;#92;u0069&lt;/td>&#xA;     *   &lt;td>capital letter I with dot above -&amp;gt; small letter i&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     *   &lt;td>tr (Turkish)&lt;/td>&#xA;     *   &lt;td>&amp;#92;u0049&lt;/td>&#xA;     *   &lt;td>&amp;#92;u0131&lt;/td>&#xA;     *   &lt;td>capital letter I -&amp;gt; small letter dotless i &lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     *   &lt;td>(all)&lt;/td>&#xA;     *   &lt;td>French Fries&lt;/td>&#xA;     *   &lt;td>french fries&lt;/td>&#xA;     *   &lt;td>lowercased all chars in String&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     *   &lt;td>(all)&lt;/td>&#xA;     *   &lt;td>&lt;img src=&quot;doc-files/capiota.gif&quot; alt=&quot;capiota&quot;>&lt;img src=&quot;doc-files/capchi.gif&quot; alt=&quot;capchi&quot;>&#xA;     *       &lt;img src=&quot;doc-files/captheta.gif&quot; alt=&quot;captheta&quot;>&lt;img src=&quot;doc-files/capupsil.gif&quot; alt=&quot;capupsil&quot;>&#xA;     *       &lt;img src=&quot;doc-files/capsigma.gif&quot; alt=&quot;capsigma&quot;>&lt;/td>&#xA;     *   &lt;td>&lt;img src=&quot;doc-files/iota.gif&quot; alt=&quot;iota&quot;>&lt;img src=&quot;doc-files/chi.gif&quot; alt=&quot;chi&quot;>&#xA;     *       &lt;img src=&quot;doc-files/theta.gif&quot; alt=&quot;theta&quot;>&lt;img src=&quot;doc-files/upsilon.gif&quot; alt=&quot;upsilon&quot;>&#xA;     *       &lt;img src=&quot;doc-files/sigma1.gif&quot; alt=&quot;sigma&quot;>&lt;/td>&#xA;     *   &lt;td>lowercased all chars in String&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;/table>&#xA;     *&#xA;     * @param locale use the case transformation rules for this locale&#xA;     * @return the &lt;code>String&lt;/code>, converted to lowercase.&#xA;     * @see     java.lang.String#toLowerCase()&#xA;     * @see     java.lang.String#toUpperCase()&#xA;     * @see     java.lang.String#toUpperCase(Locale)&#xA;     * @since   1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="firstUpper">
          <typeReference xsi:type="types:Int"/>
        </variable>
      </statements>
      <statements xsi:type="statements:JumpLabel" name="scan">
        <comments>/* Now check if there are any characters that need to be changed. */</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="c">
                  <typeReference xsi:type="types:Char"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                    <arraySelectors>
                      <position xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </position>
                    </arraySelectors>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="supplChar">
                      <typeReference xsi:type="types:Int"/>
                      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable"/>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:Break" target="//@classifiers.0/@members.68/@statements.2"/>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.2/@statement/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.129"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.2/@statement/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                      </children>
                    </condition>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable"/>
                      <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                      <value xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.83"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.2/@statement/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                      </value>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.2/@statement/@statements.0/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.56"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                      </children>
                      <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                    </expression>
                  </children>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.2/@statement/@statements.0/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.57"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                      </children>
                      <relationOperators xsi:type="operators:LessThanOrEqual"/>
                    </expression>
                  </children>
                </condition>
                <elseStatement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:Break" target="//@classifiers.0/@members.68/@statements.2"/>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.2/@statement/@statements.0/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.128"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.2/@statement/@statements.0/@statement/@statements.0/@variable"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                      </children>
                    </condition>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable"/>
                      <operator xsi:type="operators:PlusPlus"/>
                    </expression>
                  </statements>
                </elseStatement>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="expressions:ExpressionList">
              <expressions xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </expressions>
            </init>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </returnValue>
          </statements>
        </statement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="resultOffset">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <comments>/* result may grow, so i+resultOffset&#xA;&#x9;&#x9;&#x9;&#x9;    * is the write location in result */</comments>
          <comments>/* Just copy the first few lowerCase characters. */</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.3/@variable"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable"/>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lang">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.40"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="localeDependent">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.6/@variable"/>
                <children xsi:type="references:StringReference" value="tr"/>
              </children>
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.6/@variable"/>
                <children xsi:type="references:StringReference" value="az"/>
              </children>
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.6/@variable"/>
                <children xsi:type="references:StringReference" value="lt"/>
              </children>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lowerCharArray">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lowerChar">
          <typeReference xsi:type="types:Int"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="srcChar">
          <typeReference xsi:type="types:Int"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="srcCount">
          <typeReference xsi:type="types:Int"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.10/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Int"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <arraySelectors>
                    <position xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@init"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </position>
                  </arraySelectors>
                </child>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.10/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@init"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.11/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.83"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.10/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Char"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.10/@variable"/>
                </children>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.56"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                </children>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Char"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.10/@variable"/>
                </children>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.57"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                </children>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </children>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.11/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </expression>
              </statements>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.9/@variable">
                    <comments>// GREEK CAPITAL LETTER SIGMA</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="ConditionalSpecialCasing.class.xmi#//@classifiers.0/@members.9"/>
                      <arguments xsi:type="references:SelfReference">
                        <self xsi:type="literals:This"/>
                      </arguments>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@init"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="ConditionalSpecialCasing.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.7/@variable"/>
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.10/@variable"/>
                <children xsi:type="literals:CharacterLiteral" value="92"/>
              </children>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.9/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.129"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.10/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.8/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="ConditionalSpecialCasing.class.xmi#//@classifiers.0/@members.11"/>
                          <arguments xsi:type="references:SelfReference">
                            <self xsi:type="literals:This"/>
                          </arguments>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@init"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@parameters.0"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="ConditionalSpecialCasing.class.xmi#//@classifiers.0"/>
                      </value>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.9/@variable"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.35"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </children>
                </condition>
                <elseStatement xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.4/@variable"/>
                        <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                        <value xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.93"/>
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.9/@variable"/>
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.3/@variable"/>
                              <arguments xsi:type="expressions:AdditiveExpression">
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@init"/>
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.4/@variable"/>
                                <additiveOperators xsi:type="operators:Addition"/>
                              </arguments>
                            </next>
                            <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                          </children>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.11/@variable"/>
                          <additiveOperators xsi:type="operators:Subtraction"/>
                        </value>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:Continue"/>
                  </statement>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.11/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                  </condition>
                  <elseStatement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.8/@variable"/>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="references:IdentifierReference">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.94"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.9/@variable"/>
                          </next>
                          <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                        </value>
                      </expression>
                    </statements>
                  </elseStatement>
                </elseStatement>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="mapLen">
                  <typeReference xsi:type="types:Int">
                    <comments>/* Grow result if needed */</comments>
                  </typeReference>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.8/@variable">
                    <next xsi:type="references:IdentifierReference"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="result2">
                      <typeReference xsi:type="types:Char"/>
                      <arrayDimensionsBefore/>
                      <initialValue xsi:type="arrays:ArrayInstantiationBySize">
                        <typeReference xsi:type="types:Char"/>
                        <sizes xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.3/@variable">
                            <next xsi:type="references:IdentifierReference"/>
                          </children>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@statement/@statements.3/@statement/@statements.1/@variable"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.11/@variable"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                          <additiveOperators xsi:type="operators:Subtraction"/>
                        </sizes>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.3/@variable"/>
                        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@statement/@statements.3/@statement/@statements.2/@statement/@statements.0/@variable"/>
                        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        <arguments xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@init"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.4/@variable"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                        </arguments>
                      </next>
                      <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.3/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@statement/@statements.3/@statement/@statements.2/@statement/@statements.0/@variable"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@statement/@statements.3/@statement/@statements.1/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.11/@variable"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ForLoop">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.3/@variable">
                        <arraySelectors>
                          <position xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@init"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.4/@variable"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@statement/@statements.3/@statement/@statements.3/@init"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                          </position>
                        </arraySelectors>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.8/@variable">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@statement/@statements.3/@statement/@statements.3/@init"/>
                        </arraySelectors>
                      </value>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@statement/@statements.3/@statement/@statements.3/@init"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@statement/@statements.3/@statement/@statements.1/@variable"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
                <init xsi:type="variables:LocalVariable" name="x">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </init>
                <updates xsi:type="expressions:PrefixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@statement/@statements.3/@statement/@statements.3/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </updates>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.4/@variable"/>
                  <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                  <value xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@statement/@statements.3/@statement/@statements.1/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.11/@variable"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </expression>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.9/@variable"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.35"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </children>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.9/@variable"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.62"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </children>
                  <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                </expression>
              </children>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.3/@variable">
                    <arraySelectors>
                      <position xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@init"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.4/@variable"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </position>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:Char"/>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.9/@variable"/>
                  </value>
                </expression>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable"/>
        </init>
        <updates xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.12/@init"/>
          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.11/@variable"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.4/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.3/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toLowerCase">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts all of the characters in this &lt;code>String&lt;/code> to lower&#xA;     * case using the rules of the default locale. This is equivalent to calling&#xA;     * &lt;code>toLowerCase(Locale.getDefault())&lt;/code>.&#xA;     * &lt;p>&#xA;     * @return  the &lt;code>String&lt;/code>, converted to lowercase.&#xA;     * @see     java.lang.String#toLowerCase(Locale)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.68">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toUpperCase">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="locale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts all of the characters in this &lt;code>String&lt;/code> to upper&#xA;     * case using the rules of the given &lt;code>Locale&lt;/code>. Case mapping is based&#xA;     * on the Unicode Standard version specified by the {@link java.lang.Character Character}&#xA;     * class. Since case mappings are not always 1:1 char mappings, the resulting &#xA;     * &lt;code>String&lt;/code> may be a different length than the original &lt;code>String&lt;/code>.&#xA;     * &lt;p>&#xA;     * Examples of locale-sensitive and 1:M case mappings are in the following table.&#xA;     * &lt;p>&#xA;     * &lt;table border=&quot;1&quot; summary=&quot;Examples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.&quot;>&#xA;     * &lt;tr>&#xA;     *   &lt;th>Language Code of Locale&lt;/th>&#xA;     *   &lt;th>Lower Case&lt;/th>&#xA;     *   &lt;th>Upper Case&lt;/th>&#xA;     *   &lt;th>Description&lt;/th>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     *   &lt;td>tr (Turkish)&lt;/td>&#xA;     *   &lt;td>&amp;#92;u0069&lt;/td>&#xA;     *   &lt;td>&amp;#92;u0130&lt;/td>&#xA;     *   &lt;td>small letter i -&amp;gt; capital letter I with dot above&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     *   &lt;td>tr (Turkish)&lt;/td>&#xA;     *   &lt;td>&amp;#92;u0131&lt;/td>&#xA;     *   &lt;td>&amp;#92;u0049&lt;/td>&#xA;     *   &lt;td>small letter dotless i -&amp;gt; capital letter I&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     *   &lt;td>(all)&lt;/td>&#xA;     *   &lt;td>&amp;#92;u00df&lt;/td>&#xA;     *   &lt;td>&amp;#92;u0053 &amp;#92;u0053&lt;/td>&#xA;     *   &lt;td>small letter sharp s -&amp;gt; two letters: SS&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;tr>&#xA;     *   &lt;td>(all)&lt;/td>&#xA;     *   &lt;td>Fahrvergn&amp;uuml;gen&lt;/td>&#xA;     *   &lt;td>FAHRVERGN&amp;Uuml;GEN&lt;/td>&#xA;     *   &lt;td>&lt;/td>&#xA;     * &lt;/tr>&#xA;     * &lt;/table>&#xA;     * @param locale use the case transformation rules for this locale&#xA;     * @return the &lt;code>String&lt;/code>, converted to uppercase.&#xA;     * @see     java.lang.String#toUpperCase()&#xA;     * @see     java.lang.String#toLowerCase()&#xA;     * @see     java.lang.String#toLowerCase(Locale)&#xA;     * @since   1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="firstLower">
          <typeReference xsi:type="types:Int"/>
        </variable>
      </statements>
      <statements xsi:type="statements:JumpLabel" name="scan">
        <comments>/* Now check if there are any characters that need to be changed. */</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="c">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:Int"/>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                      <arraySelectors>
                        <position xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@variable"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                        </position>
                      </arraySelectors>
                    </child>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="srcCount">
                  <typeReference xsi:type="types:Int"/>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.2/@statement/@statements.0/@statement/@statements.0/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@variable"/>
                      </value>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.2/@statement/@statements.0/@statement/@statements.1/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.83"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.2/@statement/@statements.0/@statement/@statements.0/@variable"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                      </value>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.2/@statement/@statements.0/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.56"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                      </children>
                      <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                    </expression>
                  </children>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.2/@statement/@statements.0/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.57"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                      </children>
                      <relationOperators xsi:type="operators:LessThanOrEqual"/>
                    </expression>
                  </children>
                </condition>
                <elseStatement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.2/@statement/@statements.0/@statement/@statements.1/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    </expression>
                  </statements>
                </elseStatement>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="upperCaseChar">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.153"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.2/@statement/@statements.0/@statement/@statements.0/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Break" target="//@classifiers.0/@members.70/@statements.2"/>
                </statement>
                <condition xsi:type="expressions:ConditionalOrExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.2/@statement/@statements.0/@statement/@statements.3/@variable"/>
                      <children xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.35"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                      </children>
                    </expression>
                  </children>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.2/@statement/@statements.0/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.2/@statement/@statements.0/@statement/@statements.3/@variable"/>
                    </expression>
                  </children>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.2/@statement/@statements.0/@statement/@statements.1/@variable"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="expressions:ExpressionList">
              <expressions xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </expressions>
            </init>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </returnValue>
          </statements>
        </statement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="resultOffset">
          <typeReference xsi:type="types:Int">
            <comments>/* may grow */</comments>
          </typeReference>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <comments>/* result may grow, so i+resultOffset&#xA;&#x9;&#x9;&#x9;&#x9;    * is the write location in result */</comments>
          <comments>/* Just copy the first few upperCase characters. */</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@variable"/>
          </next>
          <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lang">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.40"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="localeDependent">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.6/@variable"/>
                <children xsi:type="references:StringReference" value="tr"/>
              </children>
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.6/@variable"/>
                <children xsi:type="references:StringReference" value="az"/>
              </children>
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.6/@variable"/>
                <children xsi:type="references:StringReference" value="lt"/>
              </children>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="upperCharArray">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="upperChar">
          <typeReference xsi:type="types:Int"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="srcChar">
          <typeReference xsi:type="types:Int"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="srcCount">
          <typeReference xsi:type="types:Int"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.10/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Int"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <arraySelectors>
                    <position xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@init"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </position>
                  </arraySelectors>
                </child>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.10/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@init"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.11/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.83"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.10/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Char"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.10/@variable"/>
                </children>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.56"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                </children>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Char"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.10/@variable"/>
                </children>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.57"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                </children>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </children>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.11/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </expression>
              </statements>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.9/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="ConditionalSpecialCasing.class.xmi#//@classifiers.0/@members.10"/>
                      <arguments xsi:type="references:SelfReference">
                        <self xsi:type="literals:This"/>
                      </arguments>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@init"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="ConditionalSpecialCasing.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.7/@variable"/>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.9/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.153"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.10/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.8/@variable"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="references:IdentifierReference">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="ConditionalSpecialCasing.class.xmi#//@classifiers.0/@members.12"/>
                              <arguments xsi:type="references:SelfReference">
                                <self xsi:type="literals:This"/>
                              </arguments>
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@init"/>
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="ConditionalSpecialCasing.class.xmi#//@classifiers.0"/>
                          </value>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.7/@variable"/>
                    <elseStatement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.8/@variable"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="references:IdentifierReference">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.154"/>
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.10/@variable"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                          </value>
                        </expression>
                      </statements>
                    </elseStatement>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.9/@variable"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.35"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </children>
                </condition>
                <elseStatement xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.4/@variable"/>
                        <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                        <value xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.93"/>
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.9/@variable"/>
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable"/>
                              <arguments xsi:type="expressions:AdditiveExpression">
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@init"/>
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.4/@variable"/>
                                <additiveOperators xsi:type="operators:Addition"/>
                              </arguments>
                            </next>
                            <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                          </children>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.11/@variable"/>
                          <additiveOperators xsi:type="operators:Subtraction"/>
                        </value>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:Continue"/>
                  </statement>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.11/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                  </condition>
                  <elseStatement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.8/@variable"/>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="references:IdentifierReference">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="Character.class.xmi#//@classifiers.0/@members.94"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.9/@variable"/>
                          </next>
                          <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                        </value>
                      </expression>
                    </statements>
                  </elseStatement>
                </elseStatement>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="mapLen">
                  <typeReference xsi:type="types:Int">
                    <comments>/* Grow result if needed */</comments>
                  </typeReference>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.8/@variable">
                    <next xsi:type="references:IdentifierReference"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="result2">
                      <typeReference xsi:type="types:Char"/>
                      <arrayDimensionsBefore/>
                      <initialValue xsi:type="arrays:ArrayInstantiationBySize">
                        <typeReference xsi:type="types:Char"/>
                        <sizes xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                            <next xsi:type="references:IdentifierReference"/>
                          </children>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@statement/@statements.3/@statement/@statements.1/@variable"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.11/@variable"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                          <additiveOperators xsi:type="operators:Subtraction"/>
                        </sizes>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="System.class.xmi#//@classifiers.0/@members.20"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable"/>
                        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@statement/@statements.3/@statement/@statements.2/@statement/@statements.0/@variable"/>
                        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        <arguments xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@init"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.4/@variable"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                        </arguments>
                      </next>
                      <target xsi:type="classifiers:Class" href="System.class.xmi#//@classifiers.0"/>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@statement/@statements.3/@statement/@statements.2/@statement/@statements.0/@variable"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@statement/@statements.3/@statement/@statements.1/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.11/@variable"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ForLoop">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                        <arraySelectors>
                          <position xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@init"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.4/@variable"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@statement/@statements.3/@statement/@statements.3/@init"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                            <additiveOperators xsi:type="operators:Addition"/>
                          </position>
                        </arraySelectors>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.8/@variable">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@statement/@statements.3/@statement/@statements.3/@init"/>
                        </arraySelectors>
                      </value>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@statement/@statements.3/@statement/@statements.3/@init"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@statement/@statements.3/@statement/@statements.1/@variable"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
                <init xsi:type="variables:LocalVariable" name="x">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </init>
                <updates xsi:type="expressions:PrefixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@statement/@statements.3/@statement/@statements.3/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </updates>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.4/@variable"/>
                  <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                  <value xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@statement/@statements.3/@statement/@statements.1/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.11/@variable"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </expression>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.9/@variable"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.35"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </children>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.9/@variable"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="Character.class.xmi#//@classifiers.0/@members.62"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Character.class.xmi#//@classifiers.0"/>
                  </children>
                  <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                </expression>
              </children>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                    <arraySelectors>
                      <position xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@init"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.4/@variable"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </position>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:Char"/>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.9/@variable"/>
                  </value>
                </expression>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@variable"/>
        </init>
        <updates xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.12/@init"/>
          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.11/@variable"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.4/@variable"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toUpperCase">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts all of the characters in this &lt;code>String&lt;/code> to upper&#xA;     * case using the rules of the default locale. This method is equivalent to&#xA;     * &lt;code>toUpperCase(Locale.getDefault())&lt;/code>.&#xA;     * &lt;p>&#xA;     * @return  the &lt;code>String&lt;/code>, converted to uppercase.&#xA;     * @see     java.lang.String#toUpperCase(Locale)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.70">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="trim">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a copy of the string, with leading and trailing whitespace&#xA;     * omitted.&#xA;     * &lt;p>&#xA;     * If this &lt;code>String&lt;/code> object represents an empty character&#xA;     * sequence, or the first and last characters of character sequence&#xA;     * represented by this &lt;code>String&lt;/code> object both have codes&#xA;     * greater than &lt;code>'&amp;#92;u0020'&lt;/code> (the space character), then a&#xA;     * reference to this &lt;code>String&lt;/code> object is returned.&#xA;     * &lt;p>&#xA;     * Otherwise, if there is no character with a code greater than&#xA;     * &lt;code>'&amp;#92;u0020'&lt;/code> in the string, then a new&#xA;     * &lt;code>String&lt;/code> object representing an empty string is created&#xA;     * and returned.&#xA;     * &lt;p>&#xA;     * Otherwise, let &lt;i>k&lt;/i> be the index of the first character in the&#xA;     * string whose code is greater than &lt;code>'&amp;#92;u0020'&lt;/code>, and let&#xA;     * &lt;i>m&lt;/i> be the index of the last character in the string whose code&#xA;     * is greater than &lt;code>'&amp;#92;u0020'&lt;/code>. A new &lt;code>String&lt;/code>&#xA;     * object is created, representing the substring of this string that&#xA;     * begins with the character at index &lt;i>k&lt;/i> and ends with the&#xA;     * character at index &lt;i>m&lt;/i>-that is, the result of&#xA;     * &lt;code>this.substring(&lt;i>k&lt;/i>,&amp;nbsp;&lt;i>m&lt;/i>+1)&lt;/code>.&#xA;     * &lt;p>&#xA;     * This method may be used to trim whitespace (as defined above) from&#xA;     * the beginning and end of a string.&#xA;     *&#xA;     * @return  A copy of this string with leading and trailing white&#xA;     *          space removed, or this string if it has no leading or&#xA;     *          trailing white space.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="st">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="off">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="val">
          <typeReference xsi:type="types:Char">
            <comments>/* avoid getfield opcode */</comments>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>/* avoid getfield opcode */</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.1/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.3/@variable">
                <arraySelectors>
                  <position xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.2/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.1/@variable"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </position>
                </arraySelectors>
              </children>
              <children xsi:type="literals:CharacterLiteral" value="32"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.0/@variable"/>
              <operator xsi:type="operators:MinusMinus"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.3/@variable">
                <arraySelectors>
                  <position xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.2/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.0/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Subtraction"/>
                  </position>
                </arraySelectors>
              </children>
              <children xsi:type="literals:CharacterLiteral" value="32"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.1/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.0/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </expression>
              </children>
            </expression>
          </child>
          <expressionIf xsi:type="references:MethodCall" target="//@classifiers.0/@members.57">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.1/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.0/@variable"/>
          </expressionIf>
          <expressionElse xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * This object (which is already a string!) is itself returned.&#xA;     *&#xA;     * @return  the string itself.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toCharArray">
      <typeReference xsi:type="types:Char"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this string to a new character array.&#xA;     *&#xA;     * @return  a newly allocated character array whose length is the length&#xA;     *          of this string and whose contents are initialized to contain&#xA;     *          the character sequence represented by this string.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.0/@variable"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="format">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:VariableLengthParameter" name="args">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a formatted string using the specified format string and&#xA;     * arguments.&#xA;     *&#xA;     * &lt;p> The locale always used is the one returned by {@link&#xA;     * java.util.Locale#getDefault() Locale.getDefault()}.&#xA;     *&#xA;     * @param  format&#xA;     *         A &lt;a href=&quot;../util/Formatter.html#syntax&quot;>format string&lt;/a> &#xA;     *&#xA;     * @param  args&#xA;     *         Arguments referenced by the format specifiers in the format&#xA;     *         string.  If there are more arguments than format specifiers, the&#xA;     *         extra arguments are ignored.  The number of arguments is&#xA;     *         variable and may be zero.  The maximum number of arguments is&#xA;     *         limited by the maximum dimension of a Java array as defined by&#xA;     *         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;>Java&#xA;     *         Virtual Machine Specification&lt;/a>.  The behaviour on a&#xA;     *         &lt;tt>null&lt;/tt> argument depends on the &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>conversion&lt;/a>.&#xA;     *&#xA;     * @throws  IllegalFormatException&#xA;     *          If a format string contains an illegal syntax, a format&#xA;     *          specifier that is incompatible with the given arguments,&#xA;     *          insufficient arguments given the format string, or other&#xA;     *          illegal conditions.  For specification of all possible&#xA;     *          formatting errors, see the &lt;a&#xA;     *          href=&quot;../util/Formatter.html#detail&quot;>Details&lt;/a> section of the&#xA;     *          formatter class specification.&#xA;     *          &#xA;     * @throws  NullPointerException&#xA;     *          If the &lt;tt>format&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @return  A formatted string&#xA;     *&#xA;     * @see  java.util.Formatter&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../util/Formatter.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Formatter.class.xmi#//@classifiers.0/@members.26"/>
            </next>
            <target xsi:type="members:ClassMethod" href="../util/Formatter.class.xmi#//@classifiers.0/@members.31"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="format">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:VariableLengthParameter" name="args">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a formatted string using the specified locale, format string,&#xA;     * and arguments.&#xA;     *&#xA;     * @param  l&#xA;     *         The {@linkplain java.util.Locale locale} to apply during&#xA;     *         formatting.  If &lt;tt>l&lt;/tt> is &lt;tt>null&lt;/tt> then no localization&#xA;     *         is applied.&#xA;     *&#xA;     * @param  format&#xA;     *         A &lt;a href=&quot;../util/Formatter.html#syntax&quot;>format string&lt;/a> &#xA;     *&#xA;     * @param  args&#xA;     *         Arguments referenced by the format specifiers in the format&#xA;     *         string.  If there are more arguments than format specifiers, the&#xA;     *         extra arguments are ignored.  The number of arguments is&#xA;     *         variable and may be zero.  The maximum number of arguments is&#xA;     *         limited by the maximum dimension of a Java array as defined by&#xA;     *         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;>Java&#xA;     *         Virtual Machine Specification&lt;/a>.  The behaviour on a&#xA;     *         &lt;tt>null&lt;/tt> argument depends on the &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>conversion&lt;/a>.&#xA;     *&#xA;     * @throws  IllegalFormatException&#xA;     *          If a format string contains an illegal syntax, a format&#xA;     *          specifier that is incompatible with the given arguments,&#xA;     *          insufficient arguments given the format string, or other&#xA;     *          illegal conditions.  For specification of all possible&#xA;     *          formatting errors, see the &lt;a&#xA;     *          href=&quot;../util/Formatter.html#detail&quot;>Details&lt;/a> section of the&#xA;     *          formatter class specification&#xA;     *          &#xA;     * @throws  NullPointerException&#xA;     *          If the &lt;tt>format&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @return  A formatted string&#xA;     *&#xA;     * @see  java.util.Formatter&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../util/Formatter.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../util/Formatter.class.xmi#//@classifiers.0/@members.26"/>
            </next>
            <target xsi:type="members:ClassMethod" href="../util/Formatter.class.xmi#//@classifiers.0/@members.31"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.2"/>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the string representation of the &lt;code>Object&lt;/code> argument.&#xA;     *&#xA;     * @param   obj   an &lt;code>Object&lt;/code>.&#xA;     * @return  if the argument is &lt;code>null&lt;/code>, then a string equal to&#xA;     *          &lt;code>&quot;null&quot;&lt;/code>; otherwise, the value of&#xA;     *          &lt;code>obj.toString()&lt;/code> is returned.&#xA;     * @see     java.lang.Object#toString()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:StringReference" value="null"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Object.class.xmi#//@classifiers.0/@members.6"/>
            </next>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the string representation of the &lt;code>char&lt;/code> array&#xA;     * argument. The contents of the character array are copied; subsequent&#xA;     * modification of the character array does not affect the newly&#xA;     * created string.&#xA;     *&#xA;     * @param   data   a &lt;code>char&lt;/code> array.&#xA;     * @return  a newly allocated string representing the same sequence of&#xA;     *          characters contained in the character array argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the string representation of a specific subarray of the&#xA;     * &lt;code>char&lt;/code> array argument.&#xA;     * &lt;p>&#xA;     * The &lt;code>offset&lt;/code> argument is the index of the first&#xA;     * character of the subarray. The &lt;code>count&lt;/code> argument&#xA;     * specifies the length of the subarray. The contents of the subarray&#xA;     * are copied; subsequent modification of the character array does not&#xA;     * affect the newly created string.&#xA;     *&#xA;     * @param   data     the character array.&#xA;     * @param   offset   the initial offset into the value of the&#xA;     *                  &lt;code>String&lt;/code>.&#xA;     * @param   count    the length of the value of the &lt;code>String&lt;/code>.&#xA;     * @return  a string representing the sequence of characters contained &#xA;     *          in the subarray of the character array argument.&#xA;     * @exception IndexOutOfBoundsException if &lt;code>offset&lt;/code> is&#xA;     *          negative, or &lt;code>count&lt;/code> is negative, or&#xA;     *          &lt;code>offset+count&lt;/code> is larger than&#xA;     *          &lt;code>data.length&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@parameters.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="copyValueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a String that represents the character sequence in the&#xA;     * array specified.&#xA;     *&#xA;     * @param   data     the character array.&#xA;     * @param   offset   initial offset of the subarray.&#xA;     * @param   count    length of the subarray.&#xA;     * @return  a &lt;code>String&lt;/code> that contains the characters of the&#xA;     *          specified subarray of the character array.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <comments>// All public String constructors now copy the data.</comments>
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@parameters.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="copyValueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a String that represents the character sequence in the&#xA;     * array specified.&#xA;     *&#xA;     * @param   data   the character array.&#xA;     * @return  a &lt;code>String&lt;/code> that contains the characters of the&#xA;     *          character array.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the string representation of the &lt;code>boolean&lt;/code> argument.&#xA;     *&#xA;     * @param   b   a &lt;code>boolean&lt;/code>.&#xA;     * @return  if the argument is &lt;code>true&lt;/code>, a string equal to&#xA;     *          &lt;code>&quot;true&quot;&lt;/code> is returned; otherwise, a string equal to&#xA;     *          &lt;code>&quot;false&quot;&lt;/code> is returned.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@parameters.0"/>
          <expressionIf xsi:type="references:StringReference" value="true"/>
          <expressionElse xsi:type="references:StringReference" value="false"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the string representation of the &lt;code>char&lt;/code>&#xA;     * argument.&#xA;     *&#xA;     * @param   c   a &lt;code>char&lt;/code>.&#xA;     * @return  a string of length &lt;code>1&lt;/code> containing&#xA;     *          as its single character the argument &lt;code>c&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="data">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.83/@parameters.0"/>
            </arrayInitializer>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.83/@statements.0/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the string representation of the &lt;code>int&lt;/code> argument.&#xA;     * &lt;p>&#xA;     * The representation is exactly the one returned by the&#xA;     * &lt;code>Integer.toString&lt;/code> method of one argument.&#xA;     *&#xA;     * @param   i   an &lt;code>int&lt;/code>.&#xA;     * @return  a string representation of the &lt;code>int&lt;/code> argument.&#xA;     * @see     java.lang.Integer#toString(int, int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Integer.class.xmi#//@classifiers.0/@members.10"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@parameters.0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
          </next>
          <target xsi:type="classifiers:Class" href="Integer.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the string representation of the &lt;code>long&lt;/code> argument.&#xA;     * &lt;p>&#xA;     * The representation is exactly the one returned by the&#xA;     * &lt;code>Long.toString&lt;/code> method of one argument.&#xA;     *&#xA;     * @param   l   a &lt;code>long&lt;/code>.&#xA;     * @return  a string representation of the &lt;code>long&lt;/code> argument.&#xA;     * @see     java.lang.Long#toString(long)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Long.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85/@parameters.0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
          </next>
          <target xsi:type="classifiers:Class" href="Long.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the string representation of the &lt;code>float&lt;/code> argument.&#xA;     * &lt;p>&#xA;     * The representation is exactly the one returned by the&#xA;     * &lt;code>Float.toString&lt;/code> method of one argument.&#xA;     *&#xA;     * @param   f   a &lt;code>float&lt;/code>.&#xA;     * @return  a string representation of the &lt;code>float&lt;/code> argument.&#xA;     * @see     java.lang.Float#toString(float)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Float.class.xmi#//@classifiers.0/@members.9"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="Float.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the string representation of the &lt;code>double&lt;/code> argument.&#xA;     * &lt;p>&#xA;     * The representation is exactly the one returned by the&#xA;     * &lt;code>Double.toString&lt;/code> method of one argument.&#xA;     *&#xA;     * @param   d   a &lt;code>double&lt;/code>.&#xA;     * @return  a  string representation of the &lt;code>double&lt;/code> argument.&#xA;     * @see     java.lang.Double#toString(double)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Double.class.xmi#//@classifiers.0/@members.9"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.87/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="Double.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="intern">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a canonical representation for the string object.&#xA;     * &lt;p>&#xA;     * A pool of strings, initially empty, is maintained privately by the&#xA;     * class &lt;code>String&lt;/code>.&#xA;     * &lt;p>&#xA;     * When the intern method is invoked, if the pool already contains a&#xA;     * string equal to this &lt;code>String&lt;/code> object as determined by&#xA;     * the {@link #equals(Object)} method, then the string from the pool is&#xA;     * returned. Otherwise, this &lt;code>String&lt;/code> object is added to the&#xA;     * pool and a reference to this &lt;code>String&lt;/code> object is returned.&#xA;     * &lt;p>&#xA;     * It follows that for any two strings &lt;code>s&lt;/code> and &lt;code>t&lt;/code>,&#xA;     * &lt;code>s.intern()&amp;nbsp;==&amp;nbsp;t.intern()&lt;/code> is &lt;code>true&lt;/code>&#xA;     * if and only if &lt;code>s.equals(t)&lt;/code> is &lt;code>true&lt;/code>.&#xA;     * &lt;p>&#xA;     * All literal strings and string-valued constant expressions are&#xA;     * interned. String literals are defined in &amp;sect;3.10.5 of the&#xA;     * &lt;a href=&quot;http://java.sun.com/docs/books/jls/html/&quot;>Java Language&#xA;     * Specification&lt;/a>&#xA;     *&#xA;     * @return  a string that has the same contents as this string, but is&#xA;     *          guaranteed to be from a pool of unique strings.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>String&lt;/code> class represents character strings. All&#xA; * string literals in Java programs, such as &lt;code>&quot;abc&quot;&lt;/code>, are&#xA; * implemented as instances of this class.&#xA; * &lt;p>&#xA; * Strings are constant; their values cannot be changed after they&#xA; * are created. String buffers support mutable strings.&#xA; * Because String objects are immutable they can be shared. For example:&#xA; * &lt;p>&lt;blockquote>&lt;pre>&#xA; *     String str = &quot;abc&quot;;&#xA; * &lt;/pre>&lt;/blockquote>&lt;p>&#xA; * is equivalent to:&#xA; * &lt;p>&lt;blockquote>&lt;pre>&#xA; *     char data[] = {'a', 'b', 'c'};&#xA; *     String str = new String(data);&#xA; * &lt;/pre>&lt;/blockquote>&lt;p>&#xA; * Here are some more examples of how strings can be used:&#xA; * &lt;p>&lt;blockquote>&lt;pre>&#xA; *     System.out.println(&quot;abc&quot;);&#xA; *     String cde = &quot;cde&quot;;&#xA; *     System.out.println(&quot;abc&quot; + cde);&#xA; *     String c = &quot;abc&quot;.substring(2,3);&#xA; *     String d = cde.substring(1, 2);&#xA; * &lt;/pre>&lt;/blockquote>&#xA; * &lt;p>&#xA; * The class &lt;code>String&lt;/code> includes methods for examining&#xA; * individual characters of the sequence, for comparing strings, for&#xA; * searching strings, for extracting substrings, and for creating a&#xA; * copy of a string with all characters translated to uppercase or to&#xA; * lowercase. Case mapping is based on the Unicode Standard version &#xA; * specified by the {@link java.lang.Character Character} class.&#xA; * &lt;p>&#xA; * The Java language provides special support for the string&#xA; * concatenation operator (&amp;nbsp;+&amp;nbsp;), and for conversion of&#xA; * other objects to strings. String concatenation is implemented&#xA; * through the &lt;code>StringBuilder&lt;/code>(or &lt;code>StringBuffer&lt;/code>)&#xA; * class and its &lt;code>append&lt;/code> method.&#xA; * String conversions are implemented through the method&#xA; * &lt;code>toString&lt;/code>, defined by &lt;code>Object&lt;/code> and&#xA; * inherited by all classes in Java. For additional information on&#xA; * string concatenation and conversion, see Gosling, Joy, and Steele,&#xA; * &lt;i>The Java Language Specification&lt;/i>.&#xA; *&#xA; * &lt;p> Unless otherwise noted, passing a &lt;tt>null&lt;/tt> argument to a constructor&#xA; * or method in this class will cause a {@link NullPointerException} to be&#xA; * thrown.&#xA; *&#xA; * &lt;p>A &lt;code>String&lt;/code> represents a string in the UTF-16 format&#xA; * in which &lt;em>supplementary characters&lt;/em> are represented by &lt;em>surrogate&#xA; * pairs&lt;/em> (see the section &lt;a href=&quot;Character.html#unicode&quot;>Unicode&#xA; * Character Representations&lt;/a> in the &lt;code>Character&lt;/code> class for&#xA; * more information).&#xA; * Index values refer to &lt;code>char&lt;/code> code units, so a supplementary&#xA; * character uses two positions in a &lt;code>String&lt;/code>.&#xA; * &lt;p>The &lt;code>String&lt;/code> class provides methods for dealing with&#xA; * Unicode code points (i.e., characters), in addition to those for&#xA; * dealing with Unicode code units (i.e., &lt;code>char&lt;/code> values).&#xA; *&#xA; * @author  Lee Boynton&#xA; * @author  Arthur van Hoff&#xA; * @version 1.189, 10/21/05&#xA; * @see     java.lang.Object#toString()&#xA; * @see     java.lang.StringBuffer&#xA; * @see     java.lang.StringBuilder&#xA; * @see     java.nio.charset.Charset&#xA; * @since   JDK1.0&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Final"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <namespaces>java</namespaces>
      <namespaces>io</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../io/Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="Comparable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
