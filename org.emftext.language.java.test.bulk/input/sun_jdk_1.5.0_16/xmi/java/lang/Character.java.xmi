<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:annotations="http://www.emftext.org/java/annotations" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/annotations ../../java.ecore#/0 http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="Character.java">
  <comments>/*&#xA; * @(#)Character.java&#x9;1.31 04/09/14&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>lang</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/HashMap.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Character">
    <members xsi:type="members:Field" name="MIN_RADIX">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The minimum radix available for conversion to and from strings.&#xA;     * The constant value of this field is the smallest value permitted&#xA;     * for the radix argument in radix-conversion methods such as the&#xA;     * &lt;code>digit&lt;/code> method, the &lt;code>forDigit&lt;/code>&#xA;     * method, and the &lt;code>toString&lt;/code> method of class&#xA;     * &lt;code>Integer&lt;/code>.&#xA;     *&#xA;     * @see     java.lang.Character#digit(char, int)&#xA;     * @see     java.lang.Character#forDigit(int, int)&#xA;     * @see     java.lang.Integer#toString(int, int)&#xA;     * @see     java.lang.Integer#valueOf(java.lang.String)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MAX_RADIX">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="36"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The maximum radix available for conversion to and from strings.&#xA;     * The constant value of this field is the largest value permitted&#xA;     * for the radix argument in radix-conversion methods such as the&#xA;     * &lt;code>digit&lt;/code> method, the &lt;code>forDigit&lt;/code>&#xA;     * method, and the &lt;code>toString&lt;/code> method of class&#xA;     * &lt;code>Integer&lt;/code>.&#xA;     *&#xA;     * @see     java.lang.Character#digit(char, int)&#xA;     * @see     java.lang.Character#forDigit(int, int)&#xA;     * @see     java.lang.Integer#toString(int, int)&#xA;     * @see     java.lang.Integer#valueOf(java.lang.String)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MIN_VALUE">
      <initialValue xsi:type="literals:CharacterLiteral" value="92"/>
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The constant value of this field is the smallest value of type&#xA;     * &lt;code>char&lt;/code>, &lt;code>'&amp;#92;u0000'&lt;/code>.&#xA;     *&#xA;     * @since   1.0.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MAX_VALUE">
      <initialValue xsi:type="literals:CharacterLiteral" value="92"/>
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The constant value of this field is the largest value of type&#xA;     * &lt;code>char&lt;/code>, &lt;code>'&amp;#92;uFFFF'&lt;/code>.&#xA;     *&#xA;     * @since   1.0.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="TYPE">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Class.class.xmi#//@classifiers.0/@members.92"/>
          <arguments xsi:type="references:StringReference" value="char"/>
        </next>
        <target xsi:type="classifiers:Class" href="Class.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Class" href="Class.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The &lt;code>Class&lt;/code> instance representing the primitive type&#xA;     * &lt;code>char&lt;/code>.&#xA;     *&#xA;     * @since   1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="UNASSIGNED">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/*&#xA;    * Normative general types&#xA;    */</comments>
        <comments>/*&#xA;    * General character types&#xA;    */</comments>
        <comments>/**&#xA;    * General category &quot;Cn&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="UPPERCASE_LETTER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Lu&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="LOWERCASE_LETTER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Ll&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="TITLECASE_LETTER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Lt&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MODIFIER_LETTER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Lm&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="OTHER_LETTER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Lo&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="NON_SPACING_MARK">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Mn&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ENCLOSING_MARK">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Me&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="COMBINING_SPACING_MARK">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Mc&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DECIMAL_DIGIT_NUMBER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Nd&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="LETTER_NUMBER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Nl&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="OTHER_NUMBER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;No&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SPACE_SEPARATOR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Zs&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="LINE_SEPARATOR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Zl&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="PARAGRAPH_SEPARATOR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Zp&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="CONTROL">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Cc&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="FORMAT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Cf&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="PRIVATE_USE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="18"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Co&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SURROGATE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="19"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Cs&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DASH_PUNCTUATION">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="20"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Pd&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="START_PUNCTUATION">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="21"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Ps&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="END_PUNCTUATION">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="22"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Pe&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="CONNECTOR_PUNCTUATION">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="23"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Pc&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="OTHER_PUNCTUATION">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="24"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Po&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MATH_SYMBOL">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="25"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Sm&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="CURRENCY_SYMBOL">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="26"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Sc&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MODIFIER_SYMBOL">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="27"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Sk&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="OTHER_SYMBOL">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="28"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;So&quot; in the Unicode specification.&#xA;    * @since   1.1&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="INITIAL_QUOTE_PUNCTUATION">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="29"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Pi&quot; in the Unicode specification.&#xA;    * @since   1.4&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="FINAL_QUOTE_PUNCTUATION">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="30"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * General category &quot;Pf&quot; in the Unicode specification.&#xA;    * @since   1.4&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ERROR">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="4294967295"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Error flag. Use int (code point) to avoid confusion with U+FFFF.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_UNDEFINED">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      </initialValue>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Undefined bidirectional character type. Undefined &lt;code>char&lt;/code>&#xA;     * values have undefined directionality in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_LEFT_TO_RIGHT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Strong bidirectional character type &quot;L&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_RIGHT_TO_LEFT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Strong bidirectional character type &quot;R&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;    * Strong bidirectional character type &quot;AL&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_EUROPEAN_NUMBER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Weak bidirectional character type &quot;EN&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Weak bidirectional character type &quot;ES&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Weak bidirectional character type &quot;ET&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_ARABIC_NUMBER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Weak bidirectional character type &quot;AN&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_COMMON_NUMBER_SEPARATOR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Weak bidirectional character type &quot;CS&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_NONSPACING_MARK">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Weak bidirectional character type &quot;NSM&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_BOUNDARY_NEUTRAL">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Weak bidirectional character type &quot;BN&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_PARAGRAPH_SEPARATOR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Neutral bidirectional character type &quot;B&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_SEGMENT_SEPARATOR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Neutral bidirectional character type &quot;S&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_WHITESPACE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Neutral bidirectional character type &quot;WS&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_OTHER_NEUTRALS">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Neutral bidirectional character type &quot;ON&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Strong bidirectional character type &quot;LRE&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Strong bidirectional character type &quot;LRO&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Strong bidirectional character type &quot;RLE&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="17"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Strong bidirectional character type &quot;RLO&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DIRECTIONALITY_POP_DIRECTIONAL_FORMAT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="18"/>
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Weak bidirectional character type &quot;PDF&quot; in the Unicode specification.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MIN_HIGH_SURROGATE">
      <initialValue xsi:type="literals:CharacterLiteral" value="92"/>
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The minimum value of a Unicode high-surrogate code unit in the&#xA;     * UTF-16 encoding. A high-surrogate is also known as a&#xA;     * &lt;i>leading-surrogate&lt;/i>.&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MAX_HIGH_SURROGATE">
      <initialValue xsi:type="literals:CharacterLiteral" value="92"/>
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The maximum value of a Unicode high-surrogate code unit in the&#xA;     * UTF-16 encoding. A high-surrogate is also known as a&#xA;     * &lt;i>leading-surrogate&lt;/i>.&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MIN_LOW_SURROGATE">
      <initialValue xsi:type="literals:CharacterLiteral" value="92"/>
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The minimum value of a Unicode low-surrogate code unit in the&#xA;     * UTF-16 encoding. A low-surrogate is also known as a&#xA;     * &lt;i>trailing-surrogate&lt;/i>.&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MAX_LOW_SURROGATE">
      <initialValue xsi:type="literals:CharacterLiteral" value="92"/>
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The maximum value of a Unicode low-surrogate code unit in the&#xA;     * UTF-16 encoding. A low-surrogate is also known as a&#xA;     * &lt;i>trailing-surrogate&lt;/i>.&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MIN_SURROGATE">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The minimum value of a Unicode surrogate code unit in the UTF-16 encoding.&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MAX_SURROGATE">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59"/>
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The maximum value of a Unicode surrogate code unit in the UTF-16 encoding.&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MIN_SUPPLEMENTARY_CODE_POINT">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="65536"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The minimum value of a supplementary code point.&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MIN_CODE_POINT">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The minimum value of a Unicode code point.&#xA;     * &#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MAX_CODE_POINT">
      <initialValue xsi:type="literals:HexIntegerLiteral" hexValue="1114111"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The maximum value of a Unicode code point.&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="classifiers:Class" name="Subset">
      <members xsi:type="members:Field" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Constructor" name="Subset">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="NullPointerException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="name"/>
              </throwable>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.1/@parameters.0"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.1/@parameters.0"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="name">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected">
          <comments>/**&#xA;         * Constructs a new &lt;code>Subset&lt;/code> instance.&#xA;         *&#xA;         * @exception NullPointerException if name is &lt;code>null&lt;/code>&#xA;         * @param  name  The name of this subset&#xA;         */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:ClassMethod" name="equals">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Compares two &lt;code>Subset&lt;/code> objects for equality.&#xA;         * This method returns &lt;code>true&lt;/code> if and only if&#xA;         * &lt;code>this&lt;/code> and the argument refer to the same&#xA;         * object; since this method is &lt;code>final&lt;/code>, this&#xA;         * guarantee holds for all subclasses.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.2/@parameters.0"/>
            </expression>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="hashCode">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Returns the standard hash code as defined by the&#xA;         * &lt;code>{@link Object#hashCode}&lt;/code> method.  This method&#xA;         * is &lt;code>final&lt;/code> in order to ensure that the&#xA;         * &lt;code>equals&lt;/code> and &lt;code>hashCode&lt;/code> methods will&#xA;         * be consistent in all subclasses.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Object.class.xmi#//@classifiers.0/@members.3"/>
            </next>
            <self xsi:type="literals:Super"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="toString">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Returns the name of this subset.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0"/>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Instances of this class represent particular subsets of the Unicode&#xA;     * character set.  The only family of subsets defined in the&#xA;     * &lt;code>Character&lt;/code> class is &lt;code>{@link Character.UnicodeBlock&#xA;     * UnicodeBlock}&lt;/code>.  Other portions of the Java API may define other&#xA;     * subsets for their own purposes.&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="classifiers:Class" name="UnicodeBlock">
      <members xsi:type="members:Field" name="map">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../util/HashMap.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
      </members>
      <members xsi:type="members:Constructor" name="UnicodeBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.1/@parameters.0"/>
            <callTarget xsi:type="literals:Super"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../util/Map.class.xmi#//@classifiers.0/@members.5"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.1/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.69"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="../util/Locale.class.xmi#//@classifiers.0/@members.18"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
              </arguments>
              <arguments xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="idName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>/**&#xA;         * Create a UnicodeBlock with the given identifier name. &#xA;         * This name must be the same as the block identifier.&#xA;         */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:Constructor" name="UnicodeBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.2/@parameters.0"/>
            <callTarget xsi:type="literals:This"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../util/Map.class.xmi#//@classifiers.0/@members.5"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.2/@parameters.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.69"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="../util/Locale.class.xmi#//@classifiers.0/@members.18"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
              </arguments>
              <arguments xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="idName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="alias">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>/**&#xA;         * Create a UnicodeBlock with the given identifier name and&#xA;         * alias name.&#xA;         */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:Constructor" name="UnicodeBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.3/@parameters.0"/>
            <callTarget xsi:type="literals:This"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ForLoop">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="../util/Map.class.xmi#//@classifiers.0/@members.5"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.3/@parameters.1">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.69"/>
                          <arguments xsi:type="references:IdentifierReference">
                            <next xsi:type="references:IdentifierReference">
                              <target xsi:type="members:Field" href="../util/Locale.class.xmi#//@classifiers.0/@members.18"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
                          </arguments>
                        </next>
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.3/@statements.1/@statement/@statements.0/@init"/>
                        </arraySelectors>
                      </arguments>
                      <arguments xsi:type="references:SelfReference">
                        <self xsi:type="literals:This"/>
                      </arguments>
                    </next>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.3/@statements.1/@statement/@statements.0/@init"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.3/@parameters.1">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <relationOperators xsi:type="operators:LessThan"/>
              </condition>
              <init xsi:type="variables:LocalVariable" name="x">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </init>
              <updates xsi:type="expressions:PrefixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.3/@statements.1/@statement/@statements.0/@init"/>
                <operator xsi:type="operators:PlusPlus"/>
              </updates>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.3/@parameters.1"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="idName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="aliasName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>/** &#xA;         * Create a UnicodeBlock with the given identifier name and &#xA;         * alias names.&#xA;         */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:Field" name="BASIC_LATIN">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="BASIC_LATIN"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Basic Latin"/>
              <initialValues xsi:type="references:StringReference" value="BasicLatin"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Basic Latin&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="LATIN_1_SUPPLEMENT">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="LATIN_1_SUPPLEMENT"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Latin-1 Supplement"/>
              <initialValues xsi:type="references:StringReference" value="Latin-1Supplement"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Latin-1 Supplement&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="LATIN_EXTENDED_A">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="LATIN_EXTENDED_A"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Latin Extended-A"/>
              <initialValues xsi:type="references:StringReference" value="LatinExtended-A"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Latin Extended-A&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="LATIN_EXTENDED_B">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="LATIN_EXTENDED_B"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Latin Extended-B"/>
              <initialValues xsi:type="references:StringReference" value="LatinExtended-B"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Latin Extended-B&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="IPA_EXTENSIONS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="IPA_EXTENSIONS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="IPA Extensions"/>
              <initialValues xsi:type="references:StringReference" value="IPAExtensions"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;IPA Extensions&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SPACING_MODIFIER_LETTERS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="SPACING_MODIFIER_LETTERS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Spacing Modifier Letters"/>
              <initialValues xsi:type="references:StringReference" value="SpacingModifierLetters"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Spacing Modifier Letters&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="COMBINING_DIACRITICAL_MARKS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="COMBINING_DIACRITICAL_MARKS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Combining Diacritical Marks"/>
              <initialValues xsi:type="references:StringReference" value="CombiningDiacriticalMarks"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Combining Diacritical Marks&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="GREEK">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="GREEK"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Greek and Coptic"/>
              <initialValues xsi:type="references:StringReference" value="GreekandCoptic"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Greek and Coptic&quot; Unicode character block.&#xA;         * &lt;p>&#xA;         * This block was previously known as the &quot;Greek&quot; block.&#xA;         *&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CYRILLIC">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CYRILLIC"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Cyrillic&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="ARMENIAN">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="ARMENIAN"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Armenian&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="HEBREW">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="HEBREW"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Hebrew&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="ARABIC">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="ARABIC"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Arabic&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="DEVANAGARI">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="DEVANAGARI"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Devanagari&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="BENGALI">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="BENGALI"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Bengali&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="GURMUKHI">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="GURMUKHI"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Gurmukhi&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="GUJARATI">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="GUJARATI"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Gujarati&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="ORIYA">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="ORIYA"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Oriya&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="TAMIL">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="TAMIL"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Tamil&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="TELUGU">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="TELUGU"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Telugu&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="KANNADA">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="KANNADA"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Kannada&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="MALAYALAM">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="MALAYALAM"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Malayalam&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="THAI">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="THAI"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Thai&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="LAO">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="LAO"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Lao&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="TIBETAN">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="TIBETAN"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Tibetan&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="GEORGIAN">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="GEORGIAN"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Georgian&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="HANGUL_JAMO">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="HANGUL_JAMO"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Hangul Jamo"/>
              <initialValues xsi:type="references:StringReference" value="HangulJamo"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Hangul Jamo&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="LATIN_EXTENDED_ADDITIONAL">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="LATIN_EXTENDED_ADDITIONAL"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Latin Extended Additional"/>
              <initialValues xsi:type="references:StringReference" value="LatinExtendedAdditional"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Latin Extended Additional&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="GREEK_EXTENDED">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="GREEK_EXTENDED"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Greek Extended"/>
              <initialValues xsi:type="references:StringReference" value="GreekExtended"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Greek Extended&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="GENERAL_PUNCTUATION">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="GENERAL_PUNCTUATION"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="General Punctuation"/>
              <initialValues xsi:type="references:StringReference" value="GeneralPunctuation"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;General Punctuation&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SUPERSCRIPTS_AND_SUBSCRIPTS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="SUPERSCRIPTS_AND_SUBSCRIPTS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Superscripts and Subscripts"/>
              <initialValues xsi:type="references:StringReference" value="SuperscriptsandSubscripts"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Superscripts and Subscripts&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CURRENCY_SYMBOLS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CURRENCY_SYMBOLS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Currency Symbols"/>
              <initialValues xsi:type="references:StringReference" value="CurrencySymbols"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Currency Symbols&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="COMBINING_MARKS_FOR_SYMBOLS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="COMBINING_MARKS_FOR_SYMBOLS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Combining Diacritical Marks for Symbols"/>
              <initialValues xsi:type="references:StringReference" value="CombiningDiacriticalMarksforSymbols"/>
              <initialValues xsi:type="references:StringReference" value="Combining Marks for Symbols"/>
              <initialValues xsi:type="references:StringReference" value="CombiningMarksforSymbols"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Combining Diacritical Marks for Symbols&quot; Unicode character block.&#xA;         * &lt;p>&#xA;         * This block was previously known as &quot;Combining Marks for Symbols&quot;.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="LETTERLIKE_SYMBOLS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="LETTERLIKE_SYMBOLS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Letterlike Symbols"/>
              <initialValues xsi:type="references:StringReference" value="LetterlikeSymbols"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Letterlike Symbols&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="NUMBER_FORMS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="NUMBER_FORMS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Number Forms"/>
              <initialValues xsi:type="references:StringReference" value="NumberForms"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Number Forms&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="ARROWS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="ARROWS"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Arrows&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="MATHEMATICAL_OPERATORS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="MATHEMATICAL_OPERATORS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Mathematical Operators"/>
              <initialValues xsi:type="references:StringReference" value="MathematicalOperators"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Mathematical Operators&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="MISCELLANEOUS_TECHNICAL">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="MISCELLANEOUS_TECHNICAL"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Miscellaneous Technical"/>
              <initialValues xsi:type="references:StringReference" value="MiscellaneousTechnical"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Miscellaneous Technical&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CONTROL_PICTURES">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CONTROL_PICTURES"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Control Pictures"/>
              <initialValues xsi:type="references:StringReference" value="ControlPictures"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Control Pictures&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="OPTICAL_CHARACTER_RECOGNITION">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="OPTICAL_CHARACTER_RECOGNITION"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Optical Character Recognition"/>
              <initialValues xsi:type="references:StringReference" value="OpticalCharacterRecognition"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Optical Character Recognition&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="ENCLOSED_ALPHANUMERICS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="ENCLOSED_ALPHANUMERICS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Enclosed Alphanumerics"/>
              <initialValues xsi:type="references:StringReference" value="EnclosedAlphanumerics"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Enclosed Alphanumerics&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="BOX_DRAWING">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="BOX_DRAWING"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Box Drawing"/>
              <initialValues xsi:type="references:StringReference" value="BoxDrawing"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Box Drawing&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="BLOCK_ELEMENTS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="BLOCK_ELEMENTS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Block Elements"/>
              <initialValues xsi:type="references:StringReference" value="BlockElements"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Block Elements&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="GEOMETRIC_SHAPES">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="GEOMETRIC_SHAPES"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Geometric Shapes"/>
              <initialValues xsi:type="references:StringReference" value="GeometricShapes"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Geometric Shapes&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="MISCELLANEOUS_SYMBOLS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="MISCELLANEOUS_SYMBOLS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Miscellaneous Symbols"/>
              <initialValues xsi:type="references:StringReference" value="MiscellaneousSymbols"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Miscellaneous Symbols&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="DINGBATS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="DINGBATS"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Dingbats&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CJK_SYMBOLS_AND_PUNCTUATION">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CJK_SYMBOLS_AND_PUNCTUATION"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="CJK Symbols and Punctuation"/>
              <initialValues xsi:type="references:StringReference" value="CJKSymbolsandPunctuation"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;CJK Symbols and Punctuation&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="HIRAGANA">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="HIRAGANA"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Hiragana&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="KATAKANA">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="KATAKANA"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Katakana&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="BOPOMOFO">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="BOPOMOFO"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Bopomofo&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="HANGUL_COMPATIBILITY_JAMO">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="HANGUL_COMPATIBILITY_JAMO"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Hangul Compatibility Jamo"/>
              <initialValues xsi:type="references:StringReference" value="HangulCompatibilityJamo"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Hangul Compatibility Jamo&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="KANBUN">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="KANBUN"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Kanbun&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="ENCLOSED_CJK_LETTERS_AND_MONTHS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="ENCLOSED_CJK_LETTERS_AND_MONTHS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Enclosed CJK Letters and Months"/>
              <initialValues xsi:type="references:StringReference" value="EnclosedCJKLettersandMonths"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Enclosed CJK Letters and Months&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CJK_COMPATIBILITY">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CJK_COMPATIBILITY"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="CJK Compatibility"/>
              <initialValues xsi:type="references:StringReference" value="CJKCompatibility"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;CJK Compatibility&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CJK_UNIFIED_IDEOGRAPHS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CJK_UNIFIED_IDEOGRAPHS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="CJK Unified Ideographs"/>
              <initialValues xsi:type="references:StringReference" value="CJKUnifiedIdeographs"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;CJK Unified Ideographs&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="HANGUL_SYLLABLES">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="HANGUL_SYLLABLES"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Hangul Syllables"/>
              <initialValues xsi:type="references:StringReference" value="HangulSyllables"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Hangul Syllables&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="PRIVATE_USE_AREA">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="PRIVATE_USE_AREA"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Private Use Area"/>
              <initialValues xsi:type="references:StringReference" value="PrivateUseArea"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Private Use Area&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CJK_COMPATIBILITY_IDEOGRAPHS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CJK_COMPATIBILITY_IDEOGRAPHS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="CJK Compatibility Ideographs"/>
              <initialValues xsi:type="references:StringReference" value="CJKCompatibilityIdeographs"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;CJK Compatibility Ideographs&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="ALPHABETIC_PRESENTATION_FORMS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="ALPHABETIC_PRESENTATION_FORMS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Alphabetic Presentation Forms"/>
              <initialValues xsi:type="references:StringReference" value="AlphabeticPresentationForms"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Alphabetic Presentation Forms&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="ARABIC_PRESENTATION_FORMS_A">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="ARABIC_PRESENTATION_FORMS_A"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Arabic Presentation Forms-A"/>
              <initialValues xsi:type="references:StringReference" value="ArabicPresentationForms-A"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Arabic Presentation Forms-A&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="COMBINING_HALF_MARKS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="COMBINING_HALF_MARKS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Combining Half Marks"/>
              <initialValues xsi:type="references:StringReference" value="CombiningHalfMarks"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Combining Half Marks&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CJK_COMPATIBILITY_FORMS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CJK_COMPATIBILITY_FORMS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="CJK Compatibility Forms"/>
              <initialValues xsi:type="references:StringReference" value="CJKCompatibilityForms"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;CJK Compatibility Forms&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SMALL_FORM_VARIANTS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="SMALL_FORM_VARIANTS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Small Form Variants"/>
              <initialValues xsi:type="references:StringReference" value="SmallFormVariants"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Small Form Variants&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="ARABIC_PRESENTATION_FORMS_B">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="ARABIC_PRESENTATION_FORMS_B"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Arabic Presentation Forms-B"/>
              <initialValues xsi:type="references:StringReference" value="ArabicPresentationForms-B"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Arabic Presentation Forms-B&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="HALFWIDTH_AND_FULLWIDTH_FORMS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="HALFWIDTH_AND_FULLWIDTH_FORMS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Halfwidth and Fullwidth Forms"/>
              <initialValues xsi:type="references:StringReference" value="HalfwidthandFullwidthForms"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Halfwidth and Fullwidth Forms&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SPECIALS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="SPECIALS"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Specials&quot; Unicode character block.&#xA;         * @since 1.2&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SURROGATES_AREA">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="SURROGATES_AREA"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
          <comments>/**&#xA;         * @deprecated As of J2SE 5, use {@link #HIGH_SURROGATES},&#xA;         *             {@link #HIGH_PRIVATE_USE_SURROGATES}, and&#xA;         *             {@link #LOW_SURROGATES}. These new constants match &#xA;         *             the block definitions of the Unicode Standard.&#xA;         *             The {@link #of(char)} and {@link #of(int)} methods&#xA;         *             return the new constants, not SURROGATES_AREA.&#xA;         */</comments>
          <annotation xsi:type="classifiers:Annotation" href="Deprecated.class.xmi#//@classifiers.0"/>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SYRIAC">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="SYRIAC"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Syriac&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="THAANA">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="THAANA"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Thaana&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SINHALA">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="SINHALA"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/** &#xA;         * Constant for the &quot;Sinhala&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="MYANMAR">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="MYANMAR"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Myanmar&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="ETHIOPIC">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="ETHIOPIC"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Ethiopic&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CHEROKEE">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CHEROKEE"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Cherokee&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Unified Canadian Aboriginal Syllabics"/>
              <initialValues xsi:type="references:StringReference" value="UnifiedCanadianAboriginalSyllabics"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Unified Canadian Aboriginal Syllabics&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="OGHAM">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="OGHAM"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Ogham&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="RUNIC">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="RUNIC"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Runic&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="KHMER">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="KHMER"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Khmer&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="MONGOLIAN">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="MONGOLIAN"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Mongolian&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="BRAILLE_PATTERNS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="BRAILLE_PATTERNS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Braille Patterns"/>
              <initialValues xsi:type="references:StringReference" value="BraillePatterns"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Braille Patterns&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CJK_RADICALS_SUPPLEMENT">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CJK_RADICALS_SUPPLEMENT"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="CJK Radicals Supplement"/>
              <initialValues xsi:type="references:StringReference" value="CJKRadicalsSupplement"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;CJK Radicals Supplement&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="KANGXI_RADICALS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="KANGXI_RADICALS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Kangxi Radicals"/>
              <initialValues xsi:type="references:StringReference" value="KangxiRadicals"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Kangxi Radicals&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="IDEOGRAPHIC_DESCRIPTION_CHARACTERS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="IDEOGRAPHIC_DESCRIPTION_CHARACTERS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Ideographic Description Characters"/>
              <initialValues xsi:type="references:StringReference" value="IdeographicDescriptionCharacters"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Ideographic Description Characters&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="BOPOMOFO_EXTENDED">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="BOPOMOFO_EXTENDED"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Bopomofo Extended"/>
              <initialValues xsi:type="references:StringReference" value="BopomofoExtended"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Bopomofo Extended&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="CJK Unified Ideographs Extension A"/>
              <initialValues xsi:type="references:StringReference" value="CJKUnifiedIdeographsExtensionA"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;CJK Unified Ideographs Extension A&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="YI_SYLLABLES">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="YI_SYLLABLES"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Yi Syllables"/>
              <initialValues xsi:type="references:StringReference" value="YiSyllables"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Yi Syllables&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="YI_RADICALS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="YI_RADICALS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Yi Radicals"/>
              <initialValues xsi:type="references:StringReference" value="YiRadicals"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Yi Radicals&quot; Unicode character block.&#xA;         * @since 1.4&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CYRILLIC_SUPPLEMENTARY">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CYRILLIC_SUPPLEMENTARY"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Cyrillic Supplementary"/>
              <initialValues xsi:type="references:StringReference" value="CyrillicSupplementary"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Cyrillic Supplementary&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="TAGALOG">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="TAGALOG"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Tagalog&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="HANUNOO">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="HANUNOO"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Hanunoo&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="BUHID">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="BUHID"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Buhid&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="TAGBANWA">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="TAGBANWA"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Tagbanwa&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="LIMBU">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="LIMBU"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Limbu&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="TAI_LE">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="TAI_LE"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Tai Le"/>
              <initialValues xsi:type="references:StringReference" value="TaiLe"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Tai Le&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="KHMER_SYMBOLS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="KHMER_SYMBOLS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Khmer Symbols"/>
              <initialValues xsi:type="references:StringReference" value="KhmerSymbols"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Khmer Symbols&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="PHONETIC_EXTENSIONS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="PHONETIC_EXTENSIONS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Phonetic Extensions"/>
              <initialValues xsi:type="references:StringReference" value="PhoneticExtensions"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Phonetic Extensions&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Miscellaneous Mathematical Symbols-A"/>
              <initialValues xsi:type="references:StringReference" value="MiscellaneousMathematicalSymbols-A"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Miscellaneous Mathematical Symbols-A&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SUPPLEMENTAL_ARROWS_A">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="SUPPLEMENTAL_ARROWS_A"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Supplemental Arrows-A"/>
              <initialValues xsi:type="references:StringReference" value="SupplementalArrows-A"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Supplemental Arrows-A&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SUPPLEMENTAL_ARROWS_B">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="SUPPLEMENTAL_ARROWS_B"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Supplemental Arrows-B"/>
              <initialValues xsi:type="references:StringReference" value="SupplementalArrows-B"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Supplemental Arrows-B&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Miscellaneous Mathematical Symbols-B"/>
              <initialValues xsi:type="references:StringReference" value="MiscellaneousMathematicalSymbols-B"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Miscellaneous Mathematical Symbols-B&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SUPPLEMENTAL_MATHEMATICAL_OPERATORS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="SUPPLEMENTAL_MATHEMATICAL_OPERATORS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Supplemental Mathematical Operators"/>
              <initialValues xsi:type="references:StringReference" value="SupplementalMathematicalOperators"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Supplemental Mathematical Operators&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="MISCELLANEOUS_SYMBOLS_AND_ARROWS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="MISCELLANEOUS_SYMBOLS_AND_ARROWS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Miscellaneous Symbols and Arrows"/>
              <initialValues xsi:type="references:StringReference" value="MiscellaneousSymbolsandArrows"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Miscellaneous Symbols and Arrows&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="KATAKANA_PHONETIC_EXTENSIONS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="KATAKANA_PHONETIC_EXTENSIONS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Katakana Phonetic Extensions"/>
              <initialValues xsi:type="references:StringReference" value="KatakanaPhoneticExtensions"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Katakana Phonetic Extensions&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="YIJING_HEXAGRAM_SYMBOLS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="YIJING_HEXAGRAM_SYMBOLS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Yijing Hexagram Symbols"/>
              <initialValues xsi:type="references:StringReference" value="YijingHexagramSymbols"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Yijing Hexagram Symbols&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="VARIATION_SELECTORS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="VARIATION_SELECTORS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Variation Selectors"/>
              <initialValues xsi:type="references:StringReference" value="VariationSelectors"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Variation Selectors&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="LINEAR_B_SYLLABARY">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="LINEAR_B_SYLLABARY"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Linear B Syllabary"/>
              <initialValues xsi:type="references:StringReference" value="LinearBSyllabary"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Linear B Syllabary&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="LINEAR_B_IDEOGRAMS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="LINEAR_B_IDEOGRAMS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Linear B Ideograms"/>
              <initialValues xsi:type="references:StringReference" value="LinearBIdeograms"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Linear B Ideograms&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="AEGEAN_NUMBERS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="AEGEAN_NUMBERS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Aegean Numbers"/>
              <initialValues xsi:type="references:StringReference" value="AegeanNumbers"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Aegean Numbers&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="OLD_ITALIC">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="OLD_ITALIC"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Old Italic"/>
              <initialValues xsi:type="references:StringReference" value="OldItalic"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Old Italic&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="GOTHIC">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="GOTHIC"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Gothic&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="UGARITIC">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="UGARITIC"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Ugaritic&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="DESERET">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="DESERET"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Deseret&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SHAVIAN">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="SHAVIAN"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Shavian&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="OSMANYA">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="OSMANYA"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Osmanya&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CYPRIOT_SYLLABARY">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CYPRIOT_SYLLABARY"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Cypriot Syllabary"/>
              <initialValues xsi:type="references:StringReference" value="CypriotSyllabary"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Cypriot Syllabary&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="BYZANTINE_MUSICAL_SYMBOLS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="BYZANTINE_MUSICAL_SYMBOLS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Byzantine Musical Symbols"/>
              <initialValues xsi:type="references:StringReference" value="ByzantineMusicalSymbols"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Byzantine Musical Symbols&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="MUSICAL_SYMBOLS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="MUSICAL_SYMBOLS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Musical Symbols"/>
              <initialValues xsi:type="references:StringReference" value="MusicalSymbols"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Musical Symbols&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="TAI_XUAN_JING_SYMBOLS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="TAI_XUAN_JING_SYMBOLS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Tai Xuan Jing Symbols"/>
              <initialValues xsi:type="references:StringReference" value="TaiXuanJingSymbols"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Tai Xuan Jing Symbols&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="MATHEMATICAL_ALPHANUMERIC_SYMBOLS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="MATHEMATICAL_ALPHANUMERIC_SYMBOLS"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Mathematical Alphanumeric Symbols"/>
              <initialValues xsi:type="references:StringReference" value="MathematicalAlphanumericSymbols"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Mathematical Alphanumeric Symbols&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="CJK Unified Ideographs Extension B"/>
              <initialValues xsi:type="references:StringReference" value="CJKUnifiedIdeographsExtensionB"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;CJK Unified Ideographs Extension B&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="CJK Compatibility Ideographs Supplement"/>
              <initialValues xsi:type="references:StringReference" value="CJKCompatibilityIdeographsSupplement"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;CJK Compatibility Ideographs Supplement&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="TAGS">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="TAGS"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Tags&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="VARIATION_SELECTORS_SUPPLEMENT">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="VARIATION_SELECTORS_SUPPLEMENT"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Variation Selectors Supplement"/>
              <initialValues xsi:type="references:StringReference" value="VariationSelectorsSupplement"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Variation Selectors Supplement&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SUPPLEMENTARY_PRIVATE_USE_AREA_A">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="SUPPLEMENTARY_PRIVATE_USE_AREA_A"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Supplementary Private Use Area-A"/>
              <initialValues xsi:type="references:StringReference" value="SupplementaryPrivateUseArea-A"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Supplementary Private Use Area-A&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="SUPPLEMENTARY_PRIVATE_USE_AREA_B">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="SUPPLEMENTARY_PRIVATE_USE_AREA_B"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Supplementary Private Use Area-B"/>
              <initialValues xsi:type="references:StringReference" value="SupplementaryPrivateUseArea-B"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Supplementary Private Use Area-B&quot; Unicode character block.&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="HIGH_SURROGATES">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="HIGH_SURROGATES"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="High Surrogates"/>
              <initialValues xsi:type="references:StringReference" value="HighSurrogates"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;High Surrogates&quot; Unicode character block.&#xA;         * This block represents codepoint values in the high surrogate&#xA;         * range: 0xD800 through 0xDB7F&#xA;         *&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="HIGH_PRIVATE_USE_SURROGATES">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="HIGH_PRIVATE_USE_SURROGATES"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="High Private Use Surrogates"/>
              <initialValues xsi:type="references:StringReference" value="HighPrivateUseSurrogates"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;High Private Use Surrogates&quot; Unicode character block.&#xA;         * This block represents codepoint values in the high surrogate&#xA;         * range: 0xDB80 through 0xDBFF&#xA;         *&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="LOW_SURROGATES">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.66"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="LOW_SURROGATES"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="references:StringReference" value="Low Surrogates"/>
              <initialValues xsi:type="references:StringReference" value="LowSurrogates"/>
            </arrayInitializer>
          </arguments>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Constant for the &quot;Low Surrogates&quot; Unicode character block.&#xA;         * This block represents codepoint values in the high surrogate&#xA;         * range: 0xDC00 through 0xDFFF&#xA;         *&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="blockStarts">
        <initialValue xsi:type="arrays:ArrayInstantiationByValues">
          <arrayInitializer>
            <comments>// Supplementary Private Use Area-B</comments>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="0"/>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="128">
              <comments>// Basic Latin</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="256">
              <comments>// Latin-1 Supplement</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="384">
              <comments>// Latin Extended-A</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="592">
              <comments>// Latin Extended-B</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="688">
              <comments>// IPA Extensions</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="768">
              <comments>// Spacing Modifier Letters</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="880">
              <comments>// Combining Diacritical Marks</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="1024">
              <comments>// Greek and Coptic</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="1280">
              <comments>// Cyrillic</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="1328">
              <comments>// Cyrillic Supplementary</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="1424">
              <comments>// Armenian</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="1536">
              <comments>// Hebrew</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="1792">
              <comments>// Arabic</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="1872">
              <comments>// Syriac</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="1920">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="1984">
              <comments>// Thaana</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="2304">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="2432">
              <comments>// Devanagari</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="2560">
              <comments>// Bengali</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="2688">
              <comments>// Gurmukhi</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="2816">
              <comments>// Gujarati</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="2944">
              <comments>// Oriya</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="3072">
              <comments>// Tamil</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="3200">
              <comments>// Telugu</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="3328">
              <comments>// Kannada</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="3456">
              <comments>// Malayalam</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="3584">
              <comments>// Sinhala</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="3712">
              <comments>// Thai</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="3840">
              <comments>// Lao</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="4096">
              <comments>// Tibetan</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="4256">
              <comments>// Myanmar</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="4352">
              <comments>// Georgian</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="4608">
              <comments>// Hangul Jamo</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="4992">
              <comments>// Ethiopic</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="5024">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="5120">
              <comments>// Cherokee</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="5760">
              <comments>// Unified Canadian Aboriginal Syllabics</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="5792">
              <comments>// Ogham</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="5888">
              <comments>// Runic</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="5920">
              <comments>// Tagalog</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="5952">
              <comments>// Hanunoo</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="5984">
              <comments>// Buhid</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="6016">
              <comments>// Tagbanwa</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="6144">
              <comments>// Khmer</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="6320">
              <comments>// Mongolian</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="6400">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="6480">
              <comments>// Limbu</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="6528">
              <comments>// Tai Le</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="6624">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="6656">
              <comments>// Khmer Symbols</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="7424">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="7552">
              <comments>// Phonetic Extensions</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="7680">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="7936">
              <comments>// Latin Extended Additional</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="8192">
              <comments>// Greek Extended</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="8304">
              <comments>// General Punctuation</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="8352">
              <comments>// Superscripts and Subscripts</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="8400">
              <comments>// Currency Symbols</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="8448">
              <comments>// Combining Diacritical Marks for Symbols</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="8528">
              <comments>// Letterlike Symbols</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="8592">
              <comments>// Number Forms</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="8704">
              <comments>// Arrows</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="8960">
              <comments>// Mathematical Operators</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="9216">
              <comments>// Miscellaneous Technical</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="9280">
              <comments>// Control Pictures</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="9312">
              <comments>// Optical Character Recognition</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="9472">
              <comments>// Enclosed Alphanumerics</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="9600">
              <comments>// Box Drawing</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="9632">
              <comments>// Block Elements</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="9728">
              <comments>// Geometric Shapes</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="9984">
              <comments>// Miscellaneous Symbols</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="10176">
              <comments>// Dingbats</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="10224">
              <comments>// Miscellaneous Mathematical Symbols-A</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="10240">
              <comments>// Supplemental Arrows-A</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="10496">
              <comments>// Braille Patterns</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="10624">
              <comments>// Supplemental Arrows-B</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="10752">
              <comments>// Miscellaneous Mathematical Symbols-B</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="11008">
              <comments>// Supplemental Mathematical Operators</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="11264">
              <comments>// Miscellaneous Symbols and Arrows</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="11904">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="12032">
              <comments>// CJK Radicals Supplement</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="12256">
              <comments>// Kangxi Radicals</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="12272">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="12288">
              <comments>// Ideographic Description Characters</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="12352">
              <comments>// CJK Symbols and Punctuation</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="12448">
              <comments>// Hiragana</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="12544">
              <comments>// Katakana</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="12592">
              <comments>// Bopomofo</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="12688">
              <comments>// Hangul Compatibility Jamo</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="12704">
              <comments>// Kanbun</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="12736">
              <comments>// Bopomofo Extended</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="12784">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="12800">
              <comments>// Katakana Phonetic Extensions</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="13056">
              <comments>// Enclosed CJK Letters and Months</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="13312">
              <comments>// CJK Compatibility</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="19904">
              <comments>// CJK Unified Ideographs Extension A</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="19968">
              <comments>// Yijing Hexagram Symbols</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="40960">
              <comments>// CJK Unified Ideographs</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="42128">
              <comments>// Yi Syllables</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="42192">
              <comments>// Yi Radicals</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="44032">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="55216">
              <comments>// Hangul Syllables</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="55296">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="56192">
              <comments>// High Surrogates</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="56320">
              <comments>// High Private Use Surrogates</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="57344">
              <comments>// Low Surrogates</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="63744">
              <comments>// Private Use</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="64256">
              <comments>// CJK Compatibility Ideographs</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="64336">
              <comments>// Alphabetic Presentation Forms</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="65024">
              <comments>// Arabic Presentation Forms-A</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="65040">
              <comments>// Variation Selectors</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="65056">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="65072">
              <comments>// Combining Half Marks</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="65104">
              <comments>// CJK Compatibility Forms</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="65136">
              <comments>// Small Form Variants</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="65280">
              <comments>// Arabic Presentation Forms-B</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="65520">
              <comments>// Halfwidth and Fullwidth Forms</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="65536">
              <comments>// Specials</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="65664">
              <comments>// Linear B Syllabary</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="65792">
              <comments>// Linear B Ideograms</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="65856">
              <comments>// Aegean Numbers</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="66304">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="66352">
              <comments>// Old Italic</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="66384">
              <comments>// Gothic</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="66432">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="66464">
              <comments>// Ugaritic</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="66560">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="66640">
              <comments>// Deseret</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="66688">
              <comments>// Shavian</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="66736">
              <comments>// Osmanya</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="67584">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="67648">
              <comments>// Cypriot Syllabary</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="118784">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="119040">
              <comments>// Byzantine Musical Symbols</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="119296">
              <comments>// Musical Symbols</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="119552">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="119648">
              <comments>// Tai Xuan Jing Symbols</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="119808">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="120832">
              <comments>// Mathematical Alphanumeric Symbols</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="131072">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="173792">
              <comments>// CJK Unified Ideographs Extension B</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="194560">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="195104">
              <comments>// CJK Compatibility Ideographs Supplement</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="917504">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="917632">
              <comments>// Tags</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="917760">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="918000">
              <comments>// Variation Selectors Supplement</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="983040">
              <comments>// unassigned</comments>
            </initialValues>
            <initialValues xsi:type="literals:HexIntegerLiteral" hexValue="1048576">
              <comments>// Supplementary Private Use Area-A</comments>
            </initialValues>
          </arrayInitializer>
        </initialValue>
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="blocks">
        <initialValue xsi:type="arrays:ArrayInstantiationByValues">
          <arrayInitializer>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.4"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.5"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.6"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.7"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.8"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.9"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.10"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.11"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.12"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.89"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.13"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.14"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.15"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.70"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.71"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.16"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.17"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.18"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.19"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.20"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.21"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.22"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.23"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.24"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.72"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.25"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.26"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.27"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.73"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.28"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.29"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.74"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.75"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.76"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.77"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.78"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.90"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.91"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.92"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.93"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.79"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.80"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.94"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.95"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.96"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.97"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.30"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.31"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.32"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.33"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.34"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.35"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.36"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.37"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.38"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.39"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.40"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.41"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.42"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.43"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.44"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.45"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.46"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.47"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.48"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.98"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.99"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.81"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.100"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.101"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.102"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.103"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.82"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.83"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.84"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.49"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.50"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.51"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.52"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.53"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.54"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.85"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.104"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.55"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.56"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.86"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.105"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.57"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.87"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.88"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.58"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.127"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.128"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.129"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.59"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.60"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.61"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.62"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.106"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.63"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.64"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.65"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.66"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.67"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.68"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.107"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.108"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.109"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.110"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.111"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.112"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.113"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.114"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.115"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.116"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.117"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.118"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.119"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.120"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.121"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.122"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.123"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.124"/>
            <initialValues xsi:type="literals:NullLiteral"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.125"/>
            <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.126"/>
          </arrayInitializer>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <arrayDimensionsBefore/>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:ClassMethod" name="of">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="c">
          <typeReference xsi:type="types:Char"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Returns the object representing the Unicode block containing the&#xA;         * given character, or &lt;code>null&lt;/code> if the character is not a&#xA;         * member of a defined block.&#xA;         *&#xA;                 * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;                 * href=&quot;Character.html#supplementary&quot;> supplementary&#xA;                 * characters&lt;/a>. To support all Unicode characters,&#xA;                 * including supplementary characters, use the {@link&#xA;                 * #of(int)} method.&#xA;         *&#xA;         * @param   c  The character in question&#xA;         * @return  The &lt;code>UnicodeBlock&lt;/code> instance representing the&#xA;         *          Unicode block of which this character is a member, or&#xA;         *          &lt;code>null&lt;/code> if the character is not a member of any&#xA;         *          Unicode block&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.66/@members.133">
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.132/@parameters.0"/>
            </arguments>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="of">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Returns the object representing the Unicode block&#xA;         * containing the given character (Unicode code point), or&#xA;         * &lt;code>null&lt;/code> if the character is not a member of a&#xA;         * defined block.&#xA;         *&#xA;                 * @param   codePoint the character (Unicode code point) in question.&#xA;         * @return  The &lt;code>UnicodeBlock&lt;/code> instance representing the&#xA;         *          Unicode block of which this character is a member, or&#xA;         *          &lt;code>null&lt;/code> if the character is not a member of any&#xA;         *          Unicode block&#xA;                 * @exception IllegalArgumentException if the specified&#xA;                 * &lt;code>codePoint&lt;/code> is an invalid Unicode code point.&#xA;                 * @see Character#isValidCodePoint(int)&#xA;                 * @since   1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="IllegalArgumentException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </throwable>
            </statements>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@parameters.0"/>
            </child>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="top">
            <typeReference xsi:type="types:Int"/>
            <additionalLocalVariables name="bottom"/>
            <additionalLocalVariables name="current"/>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable/@additionalLocalVariables.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.130">
              <next xsi:type="references:IdentifierReference"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable/@additionalLocalVariables.1"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:MultiplicativeExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              <multiplicativeOperators xsi:type="operators:Division"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:WhileLoop">
          <comments>// invariant: top > current >= bottom &amp;&amp; codePoint >= unicodeBlockStarts[bottom]</comments>
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable/@additionalLocalVariables.0"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable/@additionalLocalVariables.1"/>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.130">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable/@additionalLocalVariables.1"/>
                  </arraySelectors>
                </children>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </condition>
              <elseStatement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable/@additionalLocalVariables.1"/>
                  </expression>
                </statements>
              </elseStatement>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable/@additionalLocalVariables.1"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:MultiplicativeExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable/@additionalLocalVariables.0"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </expression>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                  <multiplicativeOperators xsi:type="operators:Division"/>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable/@additionalLocalVariables.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.131">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.133/@statements.1/@variable/@additionalLocalVariables.1"/>
            </arraySelectors>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="forName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.66"/>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="blockName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Returns the UnicodeBlock with the given name. Block&#xA;         * names are determined by The Unicode Standard. The file&#xA;         * Blocks-&amp;lt;version&amp;gt;.txt defines blocks for a particular&#xA;         * version of the standard. The {@link Character} class specifies&#xA;         * the version of the standard that it supports.&#xA;         * &lt;p>&#xA;         * This method accepts block names in the following forms:&#xA;         * &lt;ol>&#xA;         * &lt;li> Canonical block names as defined by the Unicode Standard.&#xA;         * For example, the standard defines a &quot;Basic Latin&quot; block. Therefore, this&#xA;         * method accepts &quot;Basic Latin&quot; as a valid block name. The documentation of &#xA;         * each UnicodeBlock provides the canonical name.&#xA;         * &lt;li>Canonical block names with all spaces removed. For example, &quot;BasicLatin&quot;&#xA;         * is a valid block name for the &quot;Basic Latin&quot; block.&#xA;         * &lt;li>The text representation of each constant UnicodeBlock identifier.&#xA;         * For example, this method will return the {@link #BASIC_LATIN} block if&#xA;         * provided with the &quot;BASIC_LATIN&quot; name. This form replaces all spaces and&#xA;         *  hyphens in the canonical name with underscores.&#xA;         * &lt;/ol>&#xA;         * Finally, character case is ignored for all of the valid block name forms.&#xA;         * For example, &quot;BASIC_LATIN&quot; and &quot;basic_latin&quot; are both valid block names.&#xA;         * The en_US locale's case mapping rules are used to provide case-insensitive&#xA;         * string comparisons for block name validation.&#xA;         * &lt;p>&#xA;         * If the Unicode Standard changes block names, both the previous and&#xA;         * current names will be accepted.&#xA;         *&#xA;         * @param blockName A &lt;code>UnicodeBlock&lt;/code> name.&#xA;         * @return The &lt;code>UnicodeBlock&lt;/code> instance identified&#xA;         *         by &lt;code>blockName&lt;/code>&#xA;         * @throws IllegalArgumentException if &lt;code>blockName&lt;/code> is an&#xA;         *         invalid name&#xA;         * @throws NullPointerException if &lt;code>blockName&lt;/code> is null&#xA;         * @since 1.5&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="block">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.66"/>
            </typeReference>
            <initialValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.66"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../util/Map.class.xmi#//@classifiers.0/@members.4"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.134/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.69"/>
                      <arguments xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <target xsi:type="members:Field" href="../util/Locale.class.xmi#//@classifiers.0/@members.18"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
                      </arguments>
                    </next>
                  </arguments>
                </next>
              </child>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="IllegalArgumentException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </throwable>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.134/@statements.0/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@members.134/@statements.0/@variable"/>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A family of character subsets representing the character blocks in the&#xA;     * Unicode specification. Character blocks generally define characters&#xA;     * used for a specific script or purpose. A character is contained by&#xA;     * at most one Unicode block.&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.65"/>
      </extends>
    </members>
    <members xsi:type="members:Field" name="value">
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The value of the &lt;code>Character&lt;/code>.&#xA;     *&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="3786198910865385080"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** use serialVersionUID from JDK 1.0.2 for interoperability */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="Character">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a newly allocated &lt;code>Character&lt;/code> object that&#xA;     * represents the specified &lt;code>char&lt;/code> value.&#xA;     *&#xA;     * @param  value   the value to be represented by the &#xA;     *                  &lt;code>Character&lt;/code> object.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="classifiers:Class" name="CharacterCache">
      <members xsi:type="members:Constructor" name="CharacterCache">
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Field" name="cache">
        <initialValue xsi:type="arrays:ArrayInstantiationBySize">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <sizes xsi:type="expressions:AdditiveExpression">
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="127"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </sizes>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arrayDimensionsAfter/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="statements:Block">
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@members.1">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@members.2/@statements.0/@init"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <arguments xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Char"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@members.2/@statements.0/@init"/>
                </arguments>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@members.2/@statements.0/@init"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@members.1">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
          <init xsi:type="variables:LocalVariable" name="i">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </init>
          <updates xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@members.2/@statements.0/@init"/>
            <operator xsi:type="operators:PlusPlus"/>
          </updates>
        </statements>
        <modifiers xsi:type="modifiers:Static"/>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="valueOf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;tt>Character&lt;/tt> instance representing the specified&#xA;     * &lt;tt>char&lt;/tt> value.&#xA;     * If a new &lt;tt>Character&lt;/tt> instance is not required, this method&#xA;     * should generally be used in preference to the constructor&#xA;     * {@link #Character(char)}, as this method is likely to yield&#xA;     * significantly better space and time performance by caching&#xA;     * frequently requested values.&#xA;     *&#xA;     * @param  c a char value.&#xA;     * @return a &lt;tt>Character&lt;/tt> instance representing &lt;tt>c&lt;/tt>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <comments>// must cache</comments>
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@members.1">
                <arraySelectors>
                  <position xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:Int"/>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0"/>
                  </position>
                </arraySelectors>
              </next>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="127"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="charValue">
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of this &lt;code>Character&lt;/code> object.&#xA;     * @return  the primitive &lt;code>char&lt;/code> value represented by&#xA;     *          this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a hash code for this &lt;code>Character&lt;/code>.&#xA;     * @return  a hash code value for this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Int"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares this object against the specified object.&#xA;     * The result is &lt;code>true&lt;/code> if and only if the argument is not&#xA;     * &lt;code>null&lt;/code> and is a &lt;code>Character&lt;/code> object that&#xA;     * represents the same &lt;code>char&lt;/code> value as this object.&#xA;     *&#xA;     * @param   obj   the object to compare with.&#xA;     * @return  &lt;code>true&lt;/code> if the objects are the same;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
              <children xsi:type="expressions:NestedExpression">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.72"/>
                <expression xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0"/>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.0"/>
                </expression>
              </children>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>String&lt;/code> object representing this&#xA;     * &lt;code>Character&lt;/code>'s value.  The result is a string of&#xA;     * length 1 whose sole component is the primitive&#xA;     * &lt;code>char&lt;/code> value represented by this&#xA;     * &lt;code>Character&lt;/code> object.&#xA;     *&#xA;     * @return  a string representation of this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="buf">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="arrays:ArrayInstantiationByValues">
            <arrayInitializer>
              <initialValues xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
            </arrayInitializer>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.77"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.0/@variable"/>
          </next>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>String&lt;/code> object representing the&#xA;     * specified &lt;code>char&lt;/code>.  The result is a string of length&#xA;     * 1 consisting solely of the specified &lt;code>char&lt;/code>.&#xA;     *&#xA;     * @param c the &lt;code>char&lt;/code> to be converted&#xA;     * @return the string representation of the specified &lt;code>char&lt;/code>&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="String.class.xmi#//@classifiers.0/@members.82"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="String.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="FAST_PATH_MAX">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="255"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Maximum character handled by internal fast-path code which</comments>
        <comments>// avoids initializing large tables.</comments>
        <comments>// Note: performance of this &quot;fast-path&quot; code may be sub-optimal</comments>
        <comments>// in negative cases for some accessors due to complicated ranges.</comments>
        <comments>// Should revisit after optimization of table initialization.</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getPlane">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Provide the character plane to which this codepoint belongs.&#xA;     * &#xA;     * @param ch the codepoint&#xA;     * @return the plane of the codepoint argument&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ShiftExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
            <shiftOperators xsi:type="operators:UnsignedRightShift"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isValidCodePoint">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines whether the specified code point is a valid Unicode&#xA;     * code point value in the range of &lt;code>0x0000&lt;/code> to&#xA;     * &lt;code>0x10FFFF&lt;/code> inclusive. This method is equivalent to&#xA;     * the expression:&#xA;     *&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * codePoint >= 0x0000 &amp;&amp; codePoint &lt;= 0x10FFFF&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @param  codePoint the Unicode code point to be tested&#xA;     * @return &lt;code>true&lt;/code> if the specified code point value&#xA;     * is a valid code point value;&#xA;     * &lt;code>false&lt;/code> otherwise.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isSupplementaryCodePoint">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines whether the specified character (Unicode code point)&#xA;     * is in the supplementary character range. The method call is&#xA;     * equivalent to the expression:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * codePoint >= 0x10000 &amp;&amp; codePoint &lt;= 0x10ffff&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @param  codePoint the character (Unicode code point) to be tested&#xA;     * @return &lt;code>true&lt;/code> if the specified character is in the Unicode&#xA;     *         supplementary character range; &lt;code>false&lt;/code> otherwise.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isHighSurrogate">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the given &lt;code>char&lt;/code> value is a&#xA;     * high-surrogate code unit (also known as &lt;i>leading-surrogate&#xA;     * code unit&lt;/i>). Such values do not represent characters by&#xA;     * themselves, but are used in the representation of &lt;a&#xA;     * href=&quot;#supplementary&quot;>supplementary characters&lt;/a> in the&#xA;     * UTF-16 encoding.&#xA;     *&#xA;     * &lt;p>This method returns &lt;code>true&lt;/code> if and only if&#xA;     * &lt;blockquote>&lt;pre>ch >= '&amp;#92;uD800' &amp;&amp; ch &lt;= '&amp;#92;uDBFF'&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * is &lt;code>true&lt;/code>.&#xA;     *&#xA;     * @param   ch   the &lt;code>char&lt;/code> value to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the &lt;code>char&lt;/code> value&#xA;     *          is between '&amp;#92;uD800' and '&amp;#92;uDBFF' inclusive;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isLowSurrogate(char)&#xA;     * @see     Character.UnicodeBlock#of(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isLowSurrogate">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the given &lt;code>char&lt;/code> value is a&#xA;     * low-surrogate code unit (also known as &lt;i>trailing-surrogate code&#xA;     * unit&lt;/i>). Such values do not represent characters by themselves,&#xA;     * but are used in the representation of &lt;a&#xA;     * href=&quot;#supplementary&quot;>supplementary characters&lt;/a> in the UTF-16 encoding.&#xA;     *&#xA;     * &lt;p> This method returns &lt;code>true&lt;/code> if and only if&#xA;     * &lt;blockquote>&lt;pre>ch >= '&amp;#92;uDC00' &amp;&amp; ch &lt;= '&amp;#92;uDFFF'&#xA;     * &lt;/pre>&lt;/blockquote> is &lt;code>true&lt;/code>.&#xA;     *&#xA;     * @param   ch   the &lt;code>char&lt;/code> value to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the &lt;code>char&lt;/code> value&#xA;     *          is between '&amp;#92;uDC00' and '&amp;#92;uDFFF' inclusive;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see java.lang.Character#isHighSurrogate(char)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isSurrogatePair">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="high">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="low">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines whether the specified pair of &lt;code>char&lt;/code>&#xA;     * values is a valid surrogate pair. This method is equivalent to&#xA;     * the expression:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * isHighSurrogate(high) &amp;&amp; isLowSurrogate(low)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @param  high the high-surrogate code value to be tested&#xA;     * @param  low the low-surrogate code value to be tested&#xA;     * @return &lt;code>true&lt;/code> if the specified high and&#xA;     * low-surrogate code values represent a valid surrogate pair;&#xA;     * &lt;code>false&lt;/code> otherwise.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.83/@parameters.0"/>
          </children>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.83/@parameters.1"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="charCount">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines the number of &lt;code>char&lt;/code> values needed to&#xA;     * represent the specified character (Unicode code point). If the&#xA;     * specified character is equal to or greater than 0x10000, then&#xA;     * the method returns 2. Otherwise, the method returns 1.&#xA;     *&#xA;     * &lt;p>This method doesn't validate the specified character to be a&#xA;     * valid Unicode code point. The caller must validate the&#xA;     * character value using {@link #isValidCodePoint(int) isValidCodePoint}&#xA;     * if necessary.&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  2 if the character is a valid supplementary character; 1 otherwise.&#xA;     * @see     #isSupplementaryCodePoint(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </child>
          <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
          <expressionElse xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toCodePoint">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="high">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="low">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts the specified surrogate pair to its supplementary code&#xA;     * point value. This method does not validate the specified&#xA;     * surrogate pair. The caller must validate it using {@link&#xA;     * #isSurrogatePair(char, char) isSurrogatePair} if necessary.&#xA;     *&#xA;     * @param  high the high-surrogate code unit&#xA;     * @param  low the low-surrogate code unit&#xA;     * @return the supplementary code point composed from the&#xA;     *         specified surrogate pair.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ShiftExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85/@parameters.0"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </expression>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              <shiftOperators xsi:type="operators:LeftShift"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </expression>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62"/>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointAt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="seq">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the code point at the given index of the&#xA;     * &lt;code>CharSequence&lt;/code>. If the &lt;code>char&lt;/code> value at&#xA;     * the given index in the &lt;code>CharSequence&lt;/code> is in the&#xA;     * high-surrogate range, the following index is less than the&#xA;     * length of the &lt;code>CharSequence&lt;/code>, and the&#xA;     * &lt;code>char&lt;/code> value at the following index is in the&#xA;     * low-surrogate range, then the supplementary code point&#xA;     * corresponding to this surrogate pair is returned. Otherwise,&#xA;     * the &lt;code>char&lt;/code> value at the given index is returned.&#xA;     *&#xA;     * @param seq a sequence of &lt;code>char&lt;/code> values (Unicode code&#xA;     * units)&#xA;     * @param index the index to the &lt;code>char&lt;/code> values (Unicode&#xA;     * code units) in &lt;code>seq&lt;/code> to be converted&#xA;     * @return the Unicode code point at the given index&#xA;     * @exception NullPointerException if &lt;code>seq&lt;/code> is null.&#xA;     * @exception IndexOutOfBoundsException if the value&#xA;     * &lt;code>index&lt;/code> is negative or not less than&#xA;     * {@link CharSequence#length() seq.length()}.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c1">
          <typeReference xsi:type="types:Char"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.1"/>
              <arguments xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.1"/>
                <operator xsi:type="operators:PlusPlus"/>
              </arguments>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="c2">
                  <typeReference xsi:type="types:Char"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.1"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.1"/>
                    </next>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Return">
                    <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.85">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@statements.1/@statement/@statements.0/@statement/@statements.0/@variable"/>
                    </returnValue>
                  </statements>
                </statement>
                <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@statements.1/@statement/@statements.0/@statement/@statements.0/@variable"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@statements.0/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointAt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the code point at the given index of the&#xA;     * &lt;code>char&lt;/code> array. If the &lt;code>char&lt;/code> value at&#xA;     * the given index in the &lt;code>char&lt;/code> array is in the&#xA;     * high-surrogate range, the following index is less than the&#xA;     * length of the &lt;code>char&lt;/code> array, and the&#xA;     * &lt;code>char&lt;/code> value at the following index is in the&#xA;     * low-surrogate range, then the supplementary code point&#xA;     * corresponding to this surrogate pair is returned. Otherwise,&#xA;     * the &lt;code>char&lt;/code> value at the given index is returned.&#xA;     *&#xA;     * @param a the &lt;code>char&lt;/code> array&#xA;     * @param index the index to the &lt;code>char&lt;/code> values (Unicode&#xA;     * code units) in the &lt;code>char&lt;/code> array to be converted&#xA;     * @return the Unicode code point at the given index&#xA;     * @exception NullPointerException if &lt;code>a&lt;/code> is null.&#xA;     * @exception IndexOutOfBoundsException if the value&#xA;     * &lt;code>index&lt;/code> is negative or not less than&#xA;     * the length of the &lt;code>char&lt;/code> array.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.89">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.87/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.87/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.87/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointAt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="limit">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the code point at the given index of the&#xA;     * &lt;code>char&lt;/code> array, where only array elements with&#xA;     * &lt;code>index&lt;/code> less than &lt;code>limit&lt;/code> can be used. If&#xA;     * the &lt;code>char&lt;/code> value at the given index in the&#xA;     * &lt;code>char&lt;/code> array is in the high-surrogate range, the&#xA;     * following index is less than the &lt;code>limit&lt;/code>, and the&#xA;     * &lt;code>char&lt;/code> value at the following index is in the&#xA;     * low-surrogate range, then the supplementary code point&#xA;     * corresponding to this surrogate pair is returned. Otherwise,&#xA;     * the &lt;code>char&lt;/code> value at the given index is returned.&#xA;     *&#xA;     * @param a the &lt;code>char&lt;/code> array&#xA;     * @param index the index to the &lt;code>char&lt;/code> values (Unicode&#xA;     * code units) in the &lt;code>char&lt;/code> array to be converted&#xA;     * @param limit the index after the last array element that can be used in the&#xA;     * &lt;code>char&lt;/code> array&#xA;     * @return the Unicode code point at the given index&#xA;     * @exception NullPointerException if &lt;code>a&lt;/code> is null.&#xA;     * @exception IndexOutOfBoundsException if the &lt;code>index&lt;/code>&#xA;     * argument is negative or not less than the &lt;code>limit&lt;/code>&#xA;     * argument, or if the &lt;code>limit&lt;/code> argument is negative or&#xA;     * greater than the length of the &lt;code>char&lt;/code> array.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@parameters.2"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@parameters.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@parameters.0">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.89">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88/@parameters.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointAtImpl">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="limit">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c1">
          <typeReference xsi:type="types:Char"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.0">
            <arraySelectors>
              <position xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.1"/>
                <operator xsi:type="operators:PlusPlus"/>
              </position>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="c2">
                  <typeReference xsi:type="types:Char"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.0">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.1"/>
                    </arraySelectors>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Return">
                    <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.85">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.1/@statement/@statements.0/@statement/@statements.0/@variable"/>
                    </returnValue>
                  </statements>
                </statement>
                <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.1/@statement/@statements.0/@statement/@statements.0/@variable"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@parameters.2"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.0/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointBefore">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="seq">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the code point preceding the given index of the&#xA;     * &lt;code>CharSequence&lt;/code>. If the &lt;code>char&lt;/code> value at&#xA;     * &lt;code>(index - 1)&lt;/code> in the &lt;code>CharSequence&lt;/code> is in&#xA;     * the low-surrogate range, &lt;code>(index - 2)&lt;/code> is not&#xA;     * negative, and the &lt;code>char&lt;/code> value at &lt;code>(index -&#xA;     * 2)&lt;/code> in the &lt;code>CharSequence&lt;/code> is in the&#xA;     * high-surrogate range, then the supplementary code point&#xA;     * corresponding to this surrogate pair is returned. Otherwise,&#xA;     * the &lt;code>char&lt;/code> value at &lt;code>(index - 1)&lt;/code> is&#xA;     * returned.&#xA;     *&#xA;     * @param seq the &lt;code>CharSequence&lt;/code> instance&#xA;     * @param index the index following the code point that should be returned&#xA;     * @return the Unicode code point value before the given index.&#xA;     * @exception NullPointerException if &lt;code>seq&lt;/code> is null.&#xA;     * @exception IndexOutOfBoundsException if the &lt;code>index&lt;/code>&#xA;     * argument is less than 1 or greater than {@link&#xA;     * CharSequence#length() seq.length()}.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c2">
          <typeReference xsi:type="types:Char"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.1"/>
              <arguments xsi:type="expressions:PrefixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90/@parameters.1"/>
                <operator xsi:type="operators:MinusMinus"/>
              </arguments>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="c1">
                  <typeReference xsi:type="types:Char"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.1"/>
                      <arguments xsi:type="expressions:PrefixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90/@parameters.1"/>
                        <operator xsi:type="operators:MinusMinus"/>
                      </arguments>
                    </next>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Return">
                    <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.85">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90/@statements.1/@statement/@statements.0/@statement/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90/@statements.0/@variable"/>
                    </returnValue>
                  </statements>
                </statement>
                <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90/@statements.1/@statement/@statements.0/@statement/@statements.0/@variable"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90/@parameters.1"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90/@statements.0/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointBefore">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the code point preceding the given index of the&#xA;     * &lt;code>char&lt;/code> array. If the &lt;code>char&lt;/code> value at&#xA;     * &lt;code>(index - 1)&lt;/code> in the &lt;code>char&lt;/code> array is in&#xA;     * the low-surrogate range, &lt;code>(index - 2)&lt;/code> is not&#xA;     * negative, and the &lt;code>char&lt;/code> value at &lt;code>(index -&#xA;     * 2)&lt;/code> in the &lt;code>char&lt;/code> array is in the&#xA;     * high-surrogate range, then the supplementary code point&#xA;     * corresponding to this surrogate pair is returned. Otherwise,&#xA;     * the &lt;code>char&lt;/code> value at &lt;code>(index - 1)&lt;/code> is&#xA;     * returned.&#xA;     *&#xA;     * @param a the &lt;code>char&lt;/code> array&#xA;     * @param index the index following the code point that should be returned&#xA;     * @return the Unicode code point value before the given index.&#xA;     * @exception NullPointerException if &lt;code>a&lt;/code> is null.&#xA;     * @exception IndexOutOfBoundsException if the &lt;code>index&lt;/code>&#xA;     * argument is less than 1 or greater than the length of the&#xA;     * &lt;code>char&lt;/code> array&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.93">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91/@parameters.1"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointBefore">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the code point preceding the given index of the&#xA;     * &lt;code>char&lt;/code> array, where only array elements with&#xA;     * &lt;code>index&lt;/code> greater than or equal to &lt;code>start&lt;/code>&#xA;     * can be used. If the &lt;code>char&lt;/code> value at &lt;code>(index -&#xA;     * 1)&lt;/code> in the &lt;code>char&lt;/code> array is in the&#xA;     * low-surrogate range, &lt;code>(index - 2)&lt;/code> is not less than&#xA;     * &lt;code>start&lt;/code>, and the &lt;code>char&lt;/code> value at&#xA;     * &lt;code>(index - 2)&lt;/code> in the &lt;code>char&lt;/code> array is in&#xA;     * the high-surrogate range, then the supplementary code point&#xA;     * corresponding to this surrogate pair is returned. Otherwise,&#xA;     * the &lt;code>char&lt;/code> value at &lt;code>(index - 1)&lt;/code> is&#xA;     * returned.&#xA;     *&#xA;     * @param a the &lt;code>char&lt;/code> array&#xA;     * @param index the index following the code point that should be returned&#xA;     * @param start the index of the first array element in the&#xA;     * &lt;code>char&lt;/code> array&#xA;     * @return the Unicode code point value before the given index.&#xA;     * @exception NullPointerException if &lt;code>a&lt;/code> is null.&#xA;     * @exception IndexOutOfBoundsException if the &lt;code>index&lt;/code>&#xA;     * argument is not greater than the &lt;code>start&lt;/code> argument or&#xA;     * is greater than the length of the &lt;code>char&lt;/code> array, or&#xA;     * if the &lt;code>start&lt;/code> argument is negative or not less than&#xA;     * the length of the &lt;code>char&lt;/code> array.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@parameters.2"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@parameters.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@parameters.0">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.93">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92/@parameters.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointBeforeImpl">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c2">
          <typeReference xsi:type="types:Char"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@parameters.0">
            <arraySelectors>
              <position xsi:type="expressions:PrefixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@parameters.1"/>
                <operator xsi:type="operators:MinusMinus"/>
              </position>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="c1">
                  <typeReference xsi:type="types:Char"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@parameters.0">
                    <arraySelectors>
                      <position xsi:type="expressions:PrefixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@parameters.1"/>
                        <operator xsi:type="operators:MinusMinus"/>
                      </position>
                    </arraySelectors>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Return">
                    <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.85">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@statements.1/@statement/@statements.0/@statement/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@statements.0/@variable"/>
                    </returnValue>
                  </statements>
                </statement>
                <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@statements.1/@statement/@statements.0/@statement/@statements.0/@variable"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@parameters.2"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@statements.0/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toChars">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dstIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts the specified character (Unicode code point) to its&#xA;     * UTF-16 representation. If the specified code point is a BMP&#xA;     * (Basic Multilingual Plane or Plane 0) value, the same value is&#xA;     * stored in &lt;code>dst[dstIndex]&lt;/code>, and 1 is returned. If the&#xA;     * specified code point is a supplementary character, its&#xA;     * surrogate values are stored in &lt;code>dst[dstIndex]&lt;/code>&#xA;     * (high-surrogate) and &lt;code>dst[dstIndex+1]&lt;/code>&#xA;     * (low-surrogate), and 2 is returned.&#xA;     *&#xA;     * @param  codePoint the character (Unicode code point) to be converted.&#xA;     * @param  dst an array of &lt;code>char&lt;/code> in which the&#xA;     * &lt;code>codePoint&lt;/code>'s UTF-16 value is stored.&#xA;     * @param dstIndex the start index into the &lt;code>dst&lt;/code>&#xA;     * array where the converted value is stored.&#xA;     * @return 1 if the code point is a BMP code point, 2 if the&#xA;     * code point is a supplementary code point.&#xA;     * @exception IllegalArgumentException if the specified&#xA;     * &lt;code>codePoint&lt;/code> is not a valid Unicode code point.&#xA;     * @exception NullPointerException if the specified &lt;code>dst&lt;/code> is null.&#xA;     * @exception IndexOutOfBoundsException if &lt;code>dstIndex&lt;/code>&#xA;     * is negative or not less than &lt;code>dst.length&lt;/code>, or if&#xA;     * &lt;code>dst&lt;/code> at &lt;code>dstIndex&lt;/code> doesn't have enough&#xA;     * array element(s) to store the resulting &lt;code>char&lt;/code>&#xA;     * value(s). (If &lt;code>dstIndex&lt;/code> is equal to&#xA;     * &lt;code>dst.length-1&lt;/code> and the specified&#xA;     * &lt;code>codePoint&lt;/code> is a supplementary character, the&#xA;     * high-surrogate value is not stored in&#xA;     * &lt;code>dst[dstIndex]&lt;/code>.)&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@parameters.1">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@parameters.2"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Char"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@parameters.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.96">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@parameters.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toChars">
      <typeReference xsi:type="types:Char"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts the specified character (Unicode code point) to its&#xA;     * UTF-16 representation stored in a &lt;code>char&lt;/code> array. If&#xA;     * the specified code point is a BMP (Basic Multilingual Plane or&#xA;     * Plane 0) value, the resulting &lt;code>char&lt;/code> array has&#xA;     * the same value as &lt;code>codePoint&lt;/code>. If the specified code&#xA;     * point is a supplementary code point, the resulting&#xA;     * &lt;code>char&lt;/code> array has the corresponding surrogate pair.&#xA;     *&#xA;     * @param  codePoint a Unicode code point&#xA;     * @return a &lt;code>char&lt;/code> array having&#xA;     *         &lt;code>codePoint&lt;/code>'s UTF-16 representation.&#xA;     * @exception IllegalArgumentException if the specified&#xA;     * &lt;code>codePoint&lt;/code> is not a valid Unicode code point.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="arrays:ArrayInstantiationByValues">
              <typeReference xsi:type="types:Char"/>
              <arrayDimensionsBefore/>
              <arrayInitializer>
                <initialValues xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Char"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95/@parameters.0"/>
                </initialValues>
              </arrayInitializer>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.96">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95/@statements.2/@variable"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toSurrogates">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="offset">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@parameters.1">
            <arraySelectors>
              <position xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@parameters.2"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </position>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Char"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AdditiveExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AndExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@statements.0/@variable"/>
                    <children xsi:type="literals:HexIntegerLiteral" hexValue="1023"/>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </expression>
            </child>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@parameters.1">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@parameters.2"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Char"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AdditiveExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ShiftExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@statements.0/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
                    <shiftOperators xsi:type="operators:UnsignedRightShift"/>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </expression>
            </child>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointCount">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="seq">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="beginIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="endIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the number of Unicode code points in the text range of&#xA;     * the specified char sequence. The text range begins at the&#xA;     * specified &lt;code>beginIndex&lt;/code> and extends to the&#xA;     * &lt;code>char&lt;/code> at index &lt;code>endIndex - 1&lt;/code>. Thus the&#xA;     * length (in &lt;code>char&lt;/code>s) of the text range is&#xA;     * &lt;code>endIndex-beginIndex&lt;/code>. Unpaired surrogates within&#xA;     * the text range count as one code point each.&#xA;     *&#xA;     * @param seq the char sequence&#xA;     * @param beginIndex the index to the first &lt;code>char&lt;/code> of&#xA;     * the text range.&#xA;     * @param endIndex the index after the last &lt;code>char&lt;/code> of&#xA;     * the text range.&#xA;     * @return the number of Unicode code points in the specified text&#xA;     * range&#xA;     * @exception NullPointerException if &lt;code>seq&lt;/code> is null.&#xA;     * @exception IndexOutOfBoundsException if the&#xA;     * &lt;code>beginIndex&lt;/code> is negative, or &lt;code>endIndex&lt;/code>&#xA;     * is larger than the length of the given sequence, or&#xA;     * &lt;code>beginIndex&lt;/code> is larger than &lt;code>endIndex&lt;/code>.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="length">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@statements.0/@variable"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.2"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@statements.2/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@statements.3/@init"/>
                      <operator xsi:type="operators:PlusPlus"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@statements.3/@init"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.2"/>
                    <relationOperators xsi:type="operators:LessThan"/>
                  </children>
                  <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.0">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.1"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@statements.3/@init"/>
                      </next>
                    </arguments>
                  </children>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.1"/>
                  <arguments xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@statements.3/@init"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </arguments>
                </next>
              </arguments>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.1"/>
        </init>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointCount">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the number of Unicode code points in a subarray of the&#xA;     * &lt;code>char&lt;/code> array argument. The &lt;code>offset&lt;/code>&#xA;     * argument is the index of the first &lt;code>char&lt;/code> of the&#xA;     * subarray and the &lt;code>count&lt;/code> argument specifies the&#xA;     * length of the subarray in &lt;code>char&lt;/code>s. Unpaired&#xA;     * surrogates within the subarray count as one code point each.&#xA;     *&#xA;     * @param a the &lt;code>char&lt;/code> array&#xA;     * @param offset the index of the first &lt;code>char&lt;/code> in the&#xA;     * given &lt;code>char&lt;/code> array&#xA;     * @param count the length of the subarray in &lt;code>char&lt;/code>s&#xA;     * @return the number of Unicode code points in the specified subarray&#xA;     * @exception NullPointerException if &lt;code>a&lt;/code> is null.&#xA;     * @exception IndexOutOfBoundsException if &lt;code>offset&lt;/code> or&#xA;     * &lt;code>count&lt;/code> is negative, or if &lt;code>offset +&#xA;     * count&lt;/code> is larger than the length of the given array.&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@parameters.2"/>
            <children xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@parameters.0">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@parameters.1"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@parameters.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.99">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@parameters.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="codePointCountImpl">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="endIndex">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@parameters.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@statements.1/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@statements.2/@init"/>
                      <operator xsi:type="operators:PlusPlus"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@statements.2/@init"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@statements.0/@variable"/>
                    <relationOperators xsi:type="operators:LessThan"/>
                  </children>
                  <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@parameters.0">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@statements.2/@init"/>
                      </arraySelectors>
                    </arguments>
                  </children>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@parameters.0">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@statements.2/@init"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </arguments>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@parameters.1"/>
        </init>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="offsetByCodePoints">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="seq">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePointOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within the given char sequence that is offset&#xA;     * from the given &lt;code>index&lt;/code> by &lt;code>codePointOffset&lt;/code>&#xA;     * code points. Unpaired surrogates within the text range given by&#xA;     * &lt;code>index&lt;/code> and &lt;code>codePointOffset&lt;/code> count as&#xA;     * one code point each.&#xA;     *&#xA;     * @param seq the char sequence&#xA;     * @param index the index to be offset&#xA;     * @param codePointOffset the offset in code points&#xA;     * @return the index within the char sequence&#xA;     * @exception NullPointerException if &lt;code>seq&lt;/code> is null.&#xA;     * @exception IndexOutOfBoundsException if &lt;code>index&lt;/code>&#xA;     *   is negative or larger then the length of the char sequence,&#xA;     *   or if &lt;code>codePointOffset&lt;/code> is positive and the&#xA;     *   subsequence starting with &lt;code>index&lt;/code> has fewer than&#xA;     *   &lt;code>codePointOffset&lt;/code> code points, or if&#xA;     *   &lt;code>codePointOffset&lt;/code> is negative and the subsequence&#xA;     *   before &lt;code>index&lt;/code> has fewer than the absolute value&#xA;     *   of &lt;code>codePointOffset&lt;/code> code points.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="length">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.0/@variable"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="x">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="i">
              <typeReference xsi:type="types:Int"/>
            </variable>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.2/@variable"/>
                          <operator xsi:type="operators:PlusPlus"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:ConditionalAndExpression">
                      <children xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.2/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.0/@variable"/>
                        <relationOperators xsi:type="operators:LessThan"/>
                      </children>
                      <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.0">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.1"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.2/@variable"/>
                          </next>
                        </arguments>
                      </children>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.1"/>
                      <arguments xsi:type="expressions:SuffixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.2/@variable"/>
                        <operator xsi:type="operators:PlusPlus"/>
                      </arguments>
                    </next>
                  </arguments>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.3/@statement/@statements.0/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.2"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </children>
            </condition>
            <init xsi:type="expressions:ExpressionList">
              <expressions xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.3/@statement/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </expressions>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.3/@statement/@statements.0/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.3/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.2"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.2"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="i">
              <typeReference xsi:type="types:Int"/>
            </variable>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.2/@variable"/>
                          <operator xsi:type="operators:MinusMinus"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:ConditionalAndExpression">
                      <children xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.2/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        <relationOperators xsi:type="operators:GreaterThan"/>
                      </children>
                      <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.0">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.1"/>
                            <arguments xsi:type="expressions:AdditiveExpression">
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.2/@variable"/>
                              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                              <additiveOperators xsi:type="operators:Subtraction"/>
                            </arguments>
                          </next>
                        </arguments>
                      </children>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="CharSequence.class.xmi#//@classifiers.0/@members.1"/>
                      <arguments xsi:type="expressions:PrefixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.2/@variable"/>
                        <operator xsi:type="operators:MinusMinus"/>
                      </arguments>
                    </next>
                  </arguments>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.2/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.3/@elseStatement/@statements.0/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </children>
            </condition>
            <init xsi:type="expressions:ExpressionList">
              <expressions xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.3/@elseStatement/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.2"/>
              </expressions>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.3/@elseStatement/@statements.0/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.3/@elseStatement/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="offsetByCodePoints">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePointOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index within the given &lt;code>char&lt;/code> subarray&#xA;     * that is offset from the given &lt;code>index&lt;/code> by&#xA;     * &lt;code>codePointOffset&lt;/code> code points. The&#xA;     * &lt;code>start&lt;/code> and &lt;code>count&lt;/code> arguments specify a&#xA;     * subarray of the &lt;code>char&lt;/code> array. Unpaired surrogates&#xA;     * within the text range given by &lt;code>index&lt;/code> and&#xA;     * &lt;code>codePointOffset&lt;/code> count as one code point each.&#xA;     *&#xA;     * @param a the &lt;code>char&lt;/code> array&#xA;     * @param start the index of the first &lt;code>char&lt;/code> of the&#xA;     * subarray&#xA;     * @param count the length of the subarray in &lt;code>char&lt;/code>s&#xA;     * @param index the index to be offset&#xA;     * @param codePointOffset the offset in code points&#xA;     * @return the index within the subarray&#xA;     * @exception NullPointerException if &lt;code>a&lt;/code> is null.&#xA;     * @exception IndexOutOfBoundsException &#xA;     *   if &lt;code>start&lt;/code> or &lt;code>count&lt;/code> is negative,&#xA;     *   or if &lt;code>start + count&lt;/code> is larger than the length of&#xA;     *   the given array,&#xA;     *   or if &lt;code>index&lt;/code> is less than &lt;code>start&lt;/code> or&#xA;     *   larger then &lt;code>start + count&lt;/code>,&#xA;     *   or if &lt;code>codePointOffset&lt;/code> is positive and the text range&#xA;     *   starting with &lt;code>index&lt;/code> and ending with &lt;code>start&#xA;     *   + count - 1&lt;/code> has fewer than &lt;code>codePointOffset&lt;/code> code&#xA;     *   points,&#xA;     *   or if &lt;code>codePointOffset&lt;/code> is negative and the text range&#xA;     *   starting with &lt;code>start&lt;/code> and ending with &lt;code>index&#xA;     *   - 1&lt;/code> has fewer than the absolute value of&#xA;     *   &lt;code>codePointOffset&lt;/code> code points.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.2"/>
            <children xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.0">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.1"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.3"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.1"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.3"/>
            <children xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.2"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.102">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.3"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@parameters.4"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="offsetByCodePointsImpl">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePointOffset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="x">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.3"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="limit">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.2"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="i">
              <typeReference xsi:type="types:Int"/>
            </variable>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.0/@variable"/>
                          <operator xsi:type="operators:PlusPlus"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:ConditionalAndExpression">
                      <children xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.0/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.1/@statement/@statements.0/@variable"/>
                        <relationOperators xsi:type="operators:LessThan"/>
                      </children>
                      <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.0">
                          <arraySelectors>
                            <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.0/@variable"/>
                          </arraySelectors>
                        </arguments>
                      </children>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.0">
                    <arraySelectors>
                      <position xsi:type="expressions:SuffixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.0/@variable"/>
                        <operator xsi:type="operators:PlusPlus"/>
                      </position>
                    </arraySelectors>
                  </arguments>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.0/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.1/@statement/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.1/@statement/@statements.1/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.4"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </children>
            </condition>
            <init xsi:type="expressions:ExpressionList">
              <expressions xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.1/@statement/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </expressions>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.1/@statement/@statements.1/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.1/@statement/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.4"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.4"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="i">
              <typeReference xsi:type="types:Int"/>
            </variable>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.0/@variable"/>
                          <operator xsi:type="operators:MinusMinus"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:ConditionalAndExpression">
                      <children xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.0/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.1"/>
                        <relationOperators xsi:type="operators:GreaterThan"/>
                      </children>
                      <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.0">
                          <arraySelectors>
                            <position xsi:type="expressions:AdditiveExpression">
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.0/@variable"/>
                              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                              <additiveOperators xsi:type="operators:Subtraction"/>
                            </position>
                          </arraySelectors>
                        </arguments>
                      </children>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.0">
                    <arraySelectors>
                      <position xsi:type="expressions:PrefixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.0/@variable"/>
                        <operator xsi:type="operators:MinusMinus"/>
                      </position>
                    </arraySelectors>
                  </arguments>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.0/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.1"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.1/@elseStatement/@statements.0/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </children>
            </condition>
            <init xsi:type="expressions:ExpressionList">
              <expressions xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.1/@elseStatement/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.4"/>
              </expressions>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.1/@elseStatement/@statements.0/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.1/@elseStatement/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isLowerCase">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character is a lowercase character.&#xA;     * &lt;p>&#xA;     * A character is lowercase if its general category type, provided&#xA;     * by &lt;code>Character.getType(ch)&lt;/code>, is&#xA;     * &lt;code>LOWERCASE_LETTER&lt;/code>.&#xA;     * &lt;p>&#xA;     * The following are examples of lowercase characters:&#xA;     * &lt;p>&lt;blockquote>&lt;pre>&#xA;     * a b c d e f g h i j k l m n o p q r s t u v w x y z&#xA;     * '&amp;#92;u00DF' '&amp;#92;u00E0' '&amp;#92;u00E1' '&amp;#92;u00E2' '&amp;#92;u00E3' '&amp;#92;u00E4' '&amp;#92;u00E5' '&amp;#92;u00E6' &#xA;     * '&amp;#92;u00E7' '&amp;#92;u00E8' '&amp;#92;u00E9' '&amp;#92;u00EA' '&amp;#92;u00EB' '&amp;#92;u00EC' '&amp;#92;u00ED' '&amp;#92;u00EE'&#xA;     * '&amp;#92;u00EF' '&amp;#92;u00F0' '&amp;#92;u00F1' '&amp;#92;u00F2' '&amp;#92;u00F3' '&amp;#92;u00F4' '&amp;#92;u00F5' '&amp;#92;u00F6'&#xA;     * '&amp;#92;u00F8' '&amp;#92;u00F9' '&amp;#92;u00FA' '&amp;#92;u00FB' '&amp;#92;u00FC' '&amp;#92;u00FD' '&amp;#92;u00FE' '&amp;#92;u00FF'&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;p> Many other Unicode characters are lowercase too.&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isLowerCase(int)} method.&#xA;     *&#xA;     * @param   ch   the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is lowercase;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isLowerCase(char)&#xA;     * @see     java.lang.Character#isTitleCase(char)&#xA;     * @see     java.lang.Character#toLowerCase(char)&#xA;     * @see     java.lang.Character#getType(char)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.104">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isLowerCase">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character (Unicode code point) is a&#xA;     * lowercase character.&#xA;     * &lt;p>&#xA;     * A character is lowercase if its general category type, provided&#xA;     * by {@link Character#getType getType(codePoint)}, is&#xA;     * &lt;code>LOWERCASE_LETTER&lt;/code>.&#xA;     * &lt;p>&#xA;     * The following are examples of lowercase characters:&#xA;     * &lt;p>&lt;blockquote>&lt;pre>&#xA;     * a b c d e f g h i j k l m n o p q r s t u v w x y z&#xA;     * '&amp;#92;u00DF' '&amp;#92;u00E0' '&amp;#92;u00E1' '&amp;#92;u00E2' '&amp;#92;u00E3' '&amp;#92;u00E4' '&amp;#92;u00E5' '&amp;#92;u00E6' &#xA;     * '&amp;#92;u00E7' '&amp;#92;u00E8' '&amp;#92;u00E9' '&amp;#92;u00EA' '&amp;#92;u00EB' '&amp;#92;u00EC' '&amp;#92;u00ED' '&amp;#92;u00EE'&#xA;     * '&amp;#92;u00EF' '&amp;#92;u00F0' '&amp;#92;u00F1' '&amp;#92;u00F2' '&amp;#92;u00F3' '&amp;#92;u00F4' '&amp;#92;u00F5' '&amp;#92;u00F6'&#xA;     * '&amp;#92;u00F8' '&amp;#92;u00F9' '&amp;#92;u00FA' '&amp;#92;u00FB' '&amp;#92;u00FC' '&amp;#92;u00FD' '&amp;#92;u00FE' '&amp;#92;u00FF'&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;p> Many other Unicode characters are lowercase too.&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is lowercase;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isLowerCase(int)&#xA;     * @see     java.lang.Character#isTitleCase(int)&#xA;     * @see     java.lang.Character#toLowerCase(int)&#xA;     * @see     java.lang.Character#getType(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bLowerCase">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// codePoint must be in the valid range of codepoints</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.7"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.9"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.8"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.8"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.3"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.8"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.3"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bLowerCase remains false</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isUpperCase">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character is an uppercase character.&#xA;     * &lt;p>&#xA;     * A character is uppercase if its general category type, provided by&#xA;     * &lt;code>Character.getType(ch)&lt;/code>, is &lt;code>UPPERCASE_LETTER&lt;/code>.&#xA;     * &lt;p>&#xA;     * The following are examples of uppercase characters:&#xA;     * &lt;p>&lt;blockquote>&lt;pre>&#xA;     * A B C D E F G H I J K L M N O P Q R S T U V W X Y Z&#xA;     * '&amp;#92;u00C0' '&amp;#92;u00C1' '&amp;#92;u00C2' '&amp;#92;u00C3' '&amp;#92;u00C4' '&amp;#92;u00C5' '&amp;#92;u00C6' '&amp;#92;u00C7'&#xA;     * '&amp;#92;u00C8' '&amp;#92;u00C9' '&amp;#92;u00CA' '&amp;#92;u00CB' '&amp;#92;u00CC' '&amp;#92;u00CD' '&amp;#92;u00CE' '&amp;#92;u00CF'&#xA;     * '&amp;#92;u00D0' '&amp;#92;u00D1' '&amp;#92;u00D2' '&amp;#92;u00D3' '&amp;#92;u00D4' '&amp;#92;u00D5' '&amp;#92;u00D6' '&amp;#92;u00D8'&#xA;     * '&amp;#92;u00D9' '&amp;#92;u00DA' '&amp;#92;u00DB' '&amp;#92;u00DC' '&amp;#92;u00DD' '&amp;#92;u00DE'&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;p> Many other Unicode characters are uppercase too.&lt;p>&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isUpperCase(int)} method.&#xA;     *&#xA;     * @param   ch   the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is uppercase;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isLowerCase(char)&#xA;     * @see     java.lang.Character#isTitleCase(char)&#xA;     * @see     java.lang.Character#toUpperCase(char)&#xA;     * @see     java.lang.Character#getType(char)&#xA;     * @since   1.0&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.106">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.105/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isUpperCase">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character (Unicode code point) is an uppercase character.&#xA;     * &lt;p>&#xA;     * A character is uppercase if its general category type, provided by&#xA;     * {@link Character#getType(int) getType(codePoint)}, is &lt;code>UPPERCASE_LETTER&lt;/code>.&#xA;     * &lt;p>&#xA;     * The following are examples of uppercase characters:&#xA;     * &lt;p>&lt;blockquote>&lt;pre>&#xA;     * A B C D E F G H I J K L M N O P Q R S T U V W X Y Z&#xA;     * '&amp;#92;u00C0' '&amp;#92;u00C1' '&amp;#92;u00C2' '&amp;#92;u00C3' '&amp;#92;u00C4' '&amp;#92;u00C5' '&amp;#92;u00C6' '&amp;#92;u00C7'&#xA;     * '&amp;#92;u00C8' '&amp;#92;u00C9' '&amp;#92;u00CA' '&amp;#92;u00CB' '&amp;#92;u00CC' '&amp;#92;u00CD' '&amp;#92;u00CE' '&amp;#92;u00CF'&#xA;     * '&amp;#92;u00D0' '&amp;#92;u00D1' '&amp;#92;u00D2' '&amp;#92;u00D3' '&amp;#92;u00D4' '&amp;#92;u00D5' '&amp;#92;u00D6' '&amp;#92;u00D8'&#xA;     * '&amp;#92;u00D9' '&amp;#92;u00DA' '&amp;#92;u00DB' '&amp;#92;u00DC' '&amp;#92;u00DD' '&amp;#92;u00DE'&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;p> Many other Unicode characters are uppercase too.&lt;p>&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is uppercase;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isLowerCase(int)&#xA;     * @see     java.lang.Character#isTitleCase(int)&#xA;     * @see     java.lang.Character#toUpperCase(int)&#xA;     * @see     java.lang.Character#getType(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bUpperCase">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.8"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.10"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.9"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.9"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.4"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.9"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.4"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bUpperCase remains false;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isTitleCase">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character is a titlecase character.&#xA;     * &lt;p> &#xA;     * A character is a titlecase character if its general&#xA;     * category type, provided by &lt;code>Character.getType(ch)&lt;/code>,&#xA;     * is &lt;code>TITLECASE_LETTER&lt;/code>.&#xA;     * &lt;p>&#xA;     * Some characters look like pairs of Latin letters. For example, there&#xA;     * is an uppercase letter that looks like &quot;LJ&quot; and has a corresponding&#xA;     * lowercase letter that looks like &quot;lj&quot;. A third form, which looks like &quot;Lj&quot;,&#xA;     * is the appropriate form to use when rendering a word in lowercase&#xA;     * with initial capitals, as for a book title.&#xA;     * &lt;p>&#xA;     * These are some of the Unicode characters for which this method returns&#xA;     * &lt;code>true&lt;/code>:&#xA;     * &lt;ul>&#xA;     * &lt;li>&lt;code>LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON&lt;/code>&#xA;     * &lt;li>&lt;code>LATIN CAPITAL LETTER L WITH SMALL LETTER J&lt;/code>&#xA;     * &lt;li>&lt;code>LATIN CAPITAL LETTER N WITH SMALL LETTER J&lt;/code>&#xA;     * &lt;li>&lt;code>LATIN CAPITAL LETTER D WITH SMALL LETTER Z&lt;/code>&#xA;     * &lt;/ul>&#xA;     * &lt;p> Many other Unicode characters are titlecase too.&lt;p>&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isTitleCase(int)} method.&#xA;     *&#xA;     * @param   ch   the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is titlecase;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isLowerCase(char)&#xA;     * @see     java.lang.Character#isUpperCase(char)&#xA;     * @see     java.lang.Character#toTitleCase(char)&#xA;     * @see     java.lang.Character#getType(char)&#xA;     * @since   1.0.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.108">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isTitleCase">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character (Unicode code point) is a titlecase character.&#xA;     * &lt;p> &#xA;     * A character is a titlecase character if its general&#xA;     * category type, provided by {@link Character#getType(int) getType(codePoint)},&#xA;     * is &lt;code>TITLECASE_LETTER&lt;/code>.&#xA;     * &lt;p>&#xA;     * Some characters look like pairs of Latin letters. For example, there&#xA;     * is an uppercase letter that looks like &quot;LJ&quot; and has a corresponding&#xA;     * lowercase letter that looks like &quot;lj&quot;. A third form, which looks like &quot;Lj&quot;,&#xA;     * is the appropriate form to use when rendering a word in lowercase&#xA;     * with initial capitals, as for a book title.&#xA;     * &lt;p>&#xA;     * These are some of the Unicode characters for which this method returns&#xA;     * &lt;code>true&lt;/code>:&#xA;     * &lt;ul>&#xA;     * &lt;li>&lt;code>LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON&lt;/code>&#xA;     * &lt;li>&lt;code>LATIN CAPITAL LETTER L WITH SMALL LETTER J&lt;/code>&#xA;     * &lt;li>&lt;code>LATIN CAPITAL LETTER N WITH SMALL LETTER J&lt;/code>&#xA;     * &lt;li>&lt;code>LATIN CAPITAL LETTER D WITH SMALL LETTER Z&lt;/code>&#xA;     * &lt;/ul>&#xA;     * &lt;p> Many other Unicode characters are titlecase too.&lt;p>&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is titlecase;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isLowerCase(int)&#xA;     * @see     java.lang.Character#isUpperCase(int)&#xA;     * @see     java.lang.Character#toTitleCase(int)&#xA;     * @see     java.lang.Character#getType(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bTitleCase">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.9"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.11"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.10"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.10"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.5"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.10"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.5"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bTitleCase remains false;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isDigit">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character is a digit.&#xA;     * &lt;p>&#xA;     * A character is a digit if its general category type, provided&#xA;     * by &lt;code>Character.getType(ch)&lt;/code>, is&#xA;     * &lt;code>DECIMAL_DIGIT_NUMBER&lt;/code>.&#xA;     * &lt;p>&#xA;     * Some Unicode character ranges that contain digits:&#xA;     * &lt;ul>&#xA;     * &lt;li>&lt;code>'&amp;#92;u0030'&lt;/code> through &lt;code>'&amp;#92;u0039'&lt;/code>, &#xA;     *     ISO-LATIN-1 digits (&lt;code>'0'&lt;/code> through &lt;code>'9'&lt;/code>)&#xA;     * &lt;li>&lt;code>'&amp;#92;u0660'&lt;/code> through &lt;code>'&amp;#92;u0669'&lt;/code>,&#xA;     *     Arabic-Indic digits&#xA;     * &lt;li>&lt;code>'&amp;#92;u06F0'&lt;/code> through &lt;code>'&amp;#92;u06F9'&lt;/code>,&#xA;     *     Extended Arabic-Indic digits&#xA;     * &lt;li>&lt;code>'&amp;#92;u0966'&lt;/code> through &lt;code>'&amp;#92;u096F'&lt;/code>,&#xA;     *     Devanagari digits&#xA;     * &lt;li>&lt;code>'&amp;#92;uFF10'&lt;/code> through &lt;code>'&amp;#92;uFF19'&lt;/code>,&#xA;     *     Fullwidth digits&#xA;     * &lt;/ul>&#xA;     *&#xA;     * Many other character ranges contain digits as well.&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isDigit(int)} method.&#xA;     *&#xA;     * @param   ch   the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is a digit;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#digit(char, int)&#xA;     * @see     java.lang.Character#forDigit(int, int)&#xA;     * @see     java.lang.Character#getType(char)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.110">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.109/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isDigit">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character (Unicode code point) is a digit.&#xA;     * &lt;p>&#xA;     * A character is a digit if its general category type, provided&#xA;     * by {@link Character#getType(int) getType(codePoint)}, is&#xA;     * &lt;code>DECIMAL_DIGIT_NUMBER&lt;/code>.&#xA;     * &lt;p>&#xA;     * Some Unicode character ranges that contain digits:&#xA;     * &lt;ul>&#xA;     * &lt;li>&lt;code>'&amp;#92;u0030'&lt;/code> through &lt;code>'&amp;#92;u0039'&lt;/code>, &#xA;     *     ISO-LATIN-1 digits (&lt;code>'0'&lt;/code> through &lt;code>'9'&lt;/code>)&#xA;     * &lt;li>&lt;code>'&amp;#92;u0660'&lt;/code> through &lt;code>'&amp;#92;u0669'&lt;/code>,&#xA;     *     Arabic-Indic digits&#xA;     * &lt;li>&lt;code>'&amp;#92;u06F0'&lt;/code> through &lt;code>'&amp;#92;u06F9'&lt;/code>,&#xA;     *     Extended Arabic-Indic digits&#xA;     * &lt;li>&lt;code>'&amp;#92;u0966'&lt;/code> through &lt;code>'&amp;#92;u096F'&lt;/code>,&#xA;     *     Devanagari digits&#xA;     * &lt;li>&lt;code>'&amp;#92;uFF10'&lt;/code> through &lt;code>'&amp;#92;uFF19'&lt;/code>,&#xA;     *     Fullwidth digits&#xA;     * &lt;/ul>&#xA;     *&#xA;     * Many other character ranges contain digits as well.&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is a digit;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#forDigit(int, int)&#xA;     * @see     java.lang.Character#getType(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bDigit">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.10"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.12"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.11"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.11"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.6"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.11"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.6"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bDigit remains false;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isDefined">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if a character is defined in Unicode.&#xA;     * &lt;p>&#xA;     * A character is defined if at least one of the following is true:&#xA;     * &lt;ul>&#xA;     * &lt;li>It has an entry in the UnicodeData file.&#xA;     * &lt;li>It has a value in a range defined by the UnicodeData file.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isDefined(int)} method.&#xA;     *&#xA;     * @param   ch   the character to be tested&#xA;     * @return  &lt;code>true&lt;/code> if the character has a defined meaning&#xA;     *          in Unicode; &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isDigit(char)&#xA;     * @see     java.lang.Character#isLetter(char)&#xA;     * @see     java.lang.Character#isLetterOrDigit(char)&#xA;     * @see     java.lang.Character#isLowerCase(char)&#xA;     * @see     java.lang.Character#isTitleCase(char)&#xA;     * @see     java.lang.Character#isUpperCase(char)&#xA;     * @since   1.0.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.112">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.111/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isDefined">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if a character (Unicode code point) is defined in Unicode.&#xA;     * &lt;p>&#xA;     * A character is defined if at least one of the following is true:&#xA;     * &lt;ul>&#xA;     * &lt;li>It has an entry in the UnicodeData file.&#xA;     * &lt;li>It has a value in a range defined by the UnicodeData file.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character has a defined meaning&#xA;     *          in Unicode; &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isDigit(int)&#xA;     * @see     java.lang.Character#isLetter(int)&#xA;     * @see     java.lang.Character#isLetterOrDigit(int)&#xA;     * @see     java.lang.Character#isLowerCase(int)&#xA;     * @see     java.lang.Character#isTitleCase(int)&#xA;     * @see     java.lang.Character#isUpperCase(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bDefined">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.11"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.13"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.12"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.12"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.7"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.12"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.7"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bDefined remains false;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isLetter">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character is a letter.&#xA;     * &lt;p>&#xA;     * A character is considered to be a letter if its general&#xA;     * category type, provided by &lt;code>Character.getType(ch)&lt;/code>,&#xA;     * is any of the following:&#xA;     * &lt;ul>&#xA;     * &lt;li> &lt;code>UPPERCASE_LETTER&lt;/code>&#xA;     * &lt;li> &lt;code>LOWERCASE_LETTER&lt;/code>&#xA;     * &lt;li> &lt;code>TITLECASE_LETTER&lt;/code>&#xA;     * &lt;li> &lt;code>MODIFIER_LETTER&lt;/code>&#xA;     * &lt;li> &lt;code>OTHER_LETTER&lt;/code>&#xA;     * &lt;/ul>&#xA;     *&#xA;     * Not all letters have case. Many characters are&#xA;     * letters but are neither uppercase nor lowercase nor titlecase.&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isLetter(int)} method.&#xA;     *&#xA;     * @param   ch   the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is a letter;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isDigit(char)&#xA;     * @see     java.lang.Character#isJavaIdentifierStart(char)&#xA;     * @see     java.lang.Character#isJavaLetter(char)&#xA;     * @see     java.lang.Character#isJavaLetterOrDigit(char)&#xA;     * @see     java.lang.Character#isLetterOrDigit(char)&#xA;     * @see     java.lang.Character#isLowerCase(char)&#xA;     * @see     java.lang.Character#isTitleCase(char)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierStart(char)&#xA;     * @see     java.lang.Character#isUpperCase(char)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.114">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isLetter">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character (Unicode code point) is a letter.&#xA;     * &lt;p>&#xA;     * A character is considered to be a letter if its general&#xA;     * category type, provided by {@link Character#getType(int) getType(codePoint)},&#xA;     * is any of the following:&#xA;     * &lt;ul>&#xA;     * &lt;li> &lt;code>UPPERCASE_LETTER&lt;/code>&#xA;     * &lt;li> &lt;code>LOWERCASE_LETTER&lt;/code>&#xA;     * &lt;li> &lt;code>TITLECASE_LETTER&lt;/code>&#xA;     * &lt;li> &lt;code>MODIFIER_LETTER&lt;/code>&#xA;     * &lt;li> &lt;code>OTHER_LETTER&lt;/code>&#xA;     * &lt;/ul>&#xA;     *&#xA;     * Not all letters have case. Many characters are&#xA;     * letters but are neither uppercase nor lowercase nor titlecase.&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is a letter;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isDigit(int)&#xA;     * @see     java.lang.Character#isJavaIdentifierStart(int)&#xA;     * @see     java.lang.Character#isLetterOrDigit(int)&#xA;     * @see     java.lang.Character#isLowerCase(int)&#xA;     * @see     java.lang.Character#isTitleCase(int)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierStart(int)&#xA;     * @see     java.lang.Character#isUpperCase(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bLetter">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.12"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.14"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.13"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.13"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.8"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.13"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.8"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bLetter remains false;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isLetterOrDigit">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character is a letter or digit.&#xA;     * &lt;p>&#xA;     * A character is considered to be a letter or digit if either&#xA;     * &lt;code>Character.isLetter(char ch)&lt;/code> or&#xA;     * &lt;code>Character.isDigit(char ch)&lt;/code> returns&#xA;     * &lt;code>true&lt;/code> for the character.&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isLetterOrDigit(int)} method.&#xA;     *&#xA;     * @param   ch   the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is a letter or digit;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isDigit(char)&#xA;     * @see     java.lang.Character#isJavaIdentifierPart(char)&#xA;     * @see     java.lang.Character#isJavaLetter(char)&#xA;     * @see     java.lang.Character#isJavaLetterOrDigit(char)&#xA;     * @see     java.lang.Character#isLetter(char)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierPart(char)&#xA;     * @since   1.0.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.116">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isLetterOrDigit">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character (Unicode code point) is a letter or digit.&#xA;     * &lt;p>&#xA;     * A character is considered to be a letter or digit if either&#xA;     * {@link #isLetter(int) isLetter(codePoint)} or&#xA;     * {@link #isDigit(int) isDigit(codePoint)} returns&#xA;     * &lt;code>true&lt;/code> for the character.&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is a letter or digit;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isDigit(int)&#xA;     * @see     java.lang.Character#isJavaIdentifierPart(int)&#xA;     * @see     java.lang.Character#isLetter(int)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierPart(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bLetterOrDigit">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.13"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.15"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.14"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.14"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.9"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.14"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.9"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bLetterOrDigit remains false;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isJavaLetter">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Determines if the specified character is permissible as the first&#xA;     * character in a Java identifier.&#xA;     * &lt;p>&#xA;     * A character may start a Java identifier if and only if&#xA;     * one of the following is true:&#xA;     * &lt;ul>&#xA;     * &lt;li> {@link #isLetter(char) isLetter(ch)} returns &lt;code>true&lt;/code>&#xA;     * &lt;li> {@link #getType(char) getType(ch)} returns &lt;code>LETTER_NUMBER&lt;/code>&#xA;     * &lt;li> ch is a currency symbol (such as &quot;$&quot;)&#xA;     * &lt;li> ch is a connecting punctuation character (such as &quot;_&quot;).&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   ch the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character may start a Java&#xA;     *          identifier; &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isJavaLetterOrDigit(char)&#xA;     * @see     java.lang.Character#isJavaIdentifierStart(char)&#xA;     * @see     java.lang.Character#isJavaIdentifierPart(char)&#xA;     * @see     java.lang.Character#isLetter(char)&#xA;     * @see     java.lang.Character#isLetterOrDigit(char)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierStart(char)&#xA;     * @since   1.02&#xA;     * @deprecated Replaced by isJavaIdentifierStart(char).&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.119">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isJavaLetterOrDigit">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Determines if the specified character may be part of a Java&#xA;     * identifier as other than the first character.&#xA;     * &lt;p>&#xA;     * A character may be part of a Java identifier if and only if any&#xA;     * of the following are true:&#xA;     * &lt;ul>&#xA;     * &lt;li>  it is a letter&#xA;     * &lt;li>  it is a currency symbol (such as &lt;code>'$'&lt;/code>)&#xA;     * &lt;li>  it is a connecting punctuation character (such as &lt;code>'_'&lt;/code>)&#xA;     * &lt;li>  it is a digit&#xA;     * &lt;li>  it is a numeric letter (such as a Roman numeral character)&#xA;     * &lt;li>  it is a combining mark&#xA;     * &lt;li>  it is a non-spacing mark&#xA;     * &lt;li> &lt;code>isIdentifierIgnorable&lt;/code> returns&#xA;     * &lt;code>true&lt;/code> for the character.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   ch the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character may be part of a&#xA;     *          Java identifier; &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isJavaLetter(char)&#xA;     * @see     java.lang.Character#isJavaIdentifierStart(char)&#xA;     * @see     java.lang.Character#isJavaIdentifierPart(char)&#xA;     * @see     java.lang.Character#isLetter(char)&#xA;     * @see     java.lang.Character#isLetterOrDigit(char)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierPart(char)&#xA;     * @see     java.lang.Character#isIdentifierIgnorable(char)&#xA;     * @since   1.02&#xA;     * @deprecated Replaced by isJavaIdentifierPart(char).&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.121">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.118/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isJavaIdentifierStart">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character is&#xA;     * permissible as the first character in a Java identifier.&#xA;     * &lt;p>&#xA;     * A character may start a Java identifier if and only if&#xA;     * one of the following conditions is true:&#xA;     * &lt;ul>&#xA;     * &lt;li> {@link #isLetter(char) isLetter(ch)} returns &lt;code>true&lt;/code>&#xA;     * &lt;li> {@link #getType(char) getType(ch)} returns &lt;code>LETTER_NUMBER&lt;/code>&#xA;     * &lt;li> ch is a currency symbol (such as &quot;$&quot;)&#xA;     * &lt;li> ch is a connecting punctuation character (such as &quot;_&quot;).&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isJavaIdentifierStart(int)} method.&#xA;     *&#xA;     * @param   ch the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character may start a Java identifier;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isJavaIdentifierPart(char)&#xA;     * @see     java.lang.Character#isLetter(char)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierStart(char)&#xA;     * @since   1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.120">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isJavaIdentifierStart">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the character (Unicode code point) is&#xA;     * permissible as the first character in a Java identifier.&#xA;     * &lt;p>&#xA;     * A character may start a Java identifier if and only if&#xA;     * one of the following conditions is true:&#xA;     * &lt;ul>&#xA;     * &lt;li> {@link #isLetter(int) isLetter(codePoint)}&#xA;     *      returns &lt;code>true&lt;/code>&#xA;     * &lt;li> {@link #getType(int) getType(codePoint)}&#xA;     *      returns &lt;code>LETTER_NUMBER&lt;/code>&#xA;     * &lt;li> the referenced character is a currency symbol (such as &quot;$&quot;)&#xA;     * &lt;li> the referenced character is a connecting punctuation character&#xA;     *      (such as &quot;_&quot;).&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character may start a Java identifier;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isJavaIdentifierPart(int)&#xA;     * @see     java.lang.Character#isLetter(int)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierStart(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bJavaStart">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.15"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.17"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.16"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.16"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.11"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.16"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.11"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bJavaStart remains false;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isJavaIdentifierPart">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character may be part of a Java&#xA;     * identifier as other than the first character.&#xA;     * &lt;p>&#xA;     * A character may be part of a Java identifier if any of the following&#xA;     * are true:&#xA;     * &lt;ul>&#xA;     * &lt;li>  it is a letter&#xA;     * &lt;li>  it is a currency symbol (such as &lt;code>'$'&lt;/code>)&#xA;     * &lt;li>  it is a connecting punctuation character (such as &lt;code>'_'&lt;/code>)&#xA;     * &lt;li>  it is a digit&#xA;     * &lt;li>  it is a numeric letter (such as a Roman numeral character)&#xA;     * &lt;li>  it is a combining mark&#xA;     * &lt;li>  it is a non-spacing mark&#xA;     * &lt;li> &lt;code>isIdentifierIgnorable&lt;/code> returns&#xA;     * &lt;code>true&lt;/code> for the character&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isJavaIdentifierPart(int)} method.&#xA;     *&#xA;     * @param   ch      the character to be tested.&#xA;     * @return &lt;code>true&lt;/code> if the character may be part of a&#xA;     *          Java identifier; &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isIdentifierIgnorable(char)&#xA;     * @see     java.lang.Character#isJavaIdentifierStart(char)&#xA;     * @see     java.lang.Character#isLetterOrDigit(char)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierPart(char)&#xA;     * @since   1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.122">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isJavaIdentifierPart">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the character (Unicode code point) may be part of a Java&#xA;     * identifier as other than the first character.&#xA;     * &lt;p>&#xA;     * A character may be part of a Java identifier if any of the following&#xA;     * are true:&#xA;     * &lt;ul>&#xA;     * &lt;li>  it is a letter&#xA;     * &lt;li>  it is a currency symbol (such as &lt;code>'$'&lt;/code>)&#xA;     * &lt;li>  it is a connecting punctuation character (such as &lt;code>'_'&lt;/code>)&#xA;     * &lt;li>  it is a digit&#xA;     * &lt;li>  it is a numeric letter (such as a Roman numeral character)&#xA;     * &lt;li>  it is a combining mark&#xA;     * &lt;li>  it is a non-spacing mark&#xA;     * &lt;li> {@link #isIdentifierIgnorable(int)&#xA;     * isIdentifierIgnorable(codePoint)} returns &lt;code>true&lt;/code> for&#xA;     * the character&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return &lt;code>true&lt;/code> if the character may be part of a&#xA;     *          Java identifier; &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isIdentifierIgnorable(int)&#xA;     * @see     java.lang.Character#isJavaIdentifierStart(int)&#xA;     * @see     java.lang.Character#isLetterOrDigit(int)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierPart(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bJavaPart">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.16"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.18"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.17"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.17"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.12"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.17"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.12"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bJavaPart remains false;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isUnicodeIdentifierStart">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character is permissible as the&#xA;     * first character in a Unicode identifier.&#xA;     * &lt;p>&#xA;     * A character may start a Unicode identifier if and only if&#xA;     * one of the following conditions is true:&#xA;     * &lt;ul>&#xA;     * &lt;li> {@link #isLetter(char) isLetter(ch)} returns &lt;code>true&lt;/code>&#xA;     * &lt;li> {@link #getType(char) getType(ch)} returns &#xA;     *      &lt;code>LETTER_NUMBER&lt;/code>.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isUnicodeIdentifierStart(int)} method.&#xA;     *&#xA;     * @param   ch      the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character may start a Unicode &#xA;     *          identifier; &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isJavaIdentifierStart(char)&#xA;     * @see     java.lang.Character#isLetter(char)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierPart(char)&#xA;     * @since   1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.124">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isUnicodeIdentifierStart">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character (Unicode code point) is permissible as the&#xA;     * first character in a Unicode identifier.&#xA;     * &lt;p>&#xA;     * A character may start a Unicode identifier if and only if&#xA;     * one of the following conditions is true:&#xA;     * &lt;ul>&#xA;     * &lt;li> {@link #isLetter(int) isLetter(codePoint)}&#xA;     *      returns &lt;code>true&lt;/code>&#xA;     * &lt;li> {@link #getType(int) getType(codePoint)}&#xA;     *      returns &lt;code>LETTER_NUMBER&lt;/code>.&#xA;     * &lt;/ul>&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character may start a Unicode &#xA;     *          identifier; &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isJavaIdentifierStart(int)&#xA;     * @see     java.lang.Character#isLetter(int)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierPart(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bUnicodeStart">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.17"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.19"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.18"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.18"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.13"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.18"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.13"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bUnicodeStart remains false;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isUnicodeIdentifierPart">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character may be part of a Unicode&#xA;     * identifier as other than the first character.&#xA;     * &lt;p>&#xA;     * A character may be part of a Unicode identifier if and only if&#xA;     * one of the following statements is true:&#xA;     * &lt;ul>&#xA;     * &lt;li>  it is a letter&#xA;     * &lt;li>  it is a connecting punctuation character (such as &lt;code>'_'&lt;/code>)&#xA;     * &lt;li>  it is a digit&#xA;     * &lt;li>  it is a numeric letter (such as a Roman numeral character)&#xA;     * &lt;li>  it is a combining mark&#xA;     * &lt;li>  it is a non-spacing mark&#xA;     * &lt;li> &lt;code>isIdentifierIgnorable&lt;/code> returns&#xA;     * &lt;code>true&lt;/code> for this character.&#xA;     * &lt;/ul>&#xA;     * &#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isUnicodeIdentifierPart(int)} method.&#xA;     *&#xA;     * @param   ch      the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character may be part of a &#xA;     *          Unicode identifier; &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isIdentifierIgnorable(char)&#xA;     * @see     java.lang.Character#isJavaIdentifierPart(char)&#xA;     * @see     java.lang.Character#isLetterOrDigit(char)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierStart(char)&#xA;     * @since   1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.126">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.125/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isUnicodeIdentifierPart">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character (Unicode code point) may be part of a Unicode&#xA;     * identifier as other than the first character.&#xA;     * &lt;p>&#xA;     * A character may be part of a Unicode identifier if and only if&#xA;     * one of the following statements is true:&#xA;     * &lt;ul>&#xA;     * &lt;li>  it is a letter&#xA;     * &lt;li>  it is a connecting punctuation character (such as &lt;code>'_'&lt;/code>)&#xA;     * &lt;li>  it is a digit&#xA;     * &lt;li>  it is a numeric letter (such as a Roman numeral character)&#xA;     * &lt;li>  it is a combining mark&#xA;     * &lt;li>  it is a non-spacing mark&#xA;     * &lt;li> &lt;code>isIdentifierIgnorable&lt;/code> returns&#xA;     * &lt;code>true&lt;/code> for this character.&#xA;     * &lt;/ul>&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character may be part of a &#xA;     *          Unicode identifier; &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isIdentifierIgnorable(int)&#xA;     * @see     java.lang.Character#isJavaIdentifierPart(int)&#xA;     * @see     java.lang.Character#isLetterOrDigit(int)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierStart(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bUnicodePart">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.18"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.20"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.19"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.19"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.14"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.19"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.14"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>//bUnicodePart remains false;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isIdentifierIgnorable">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character should be regarded as&#xA;     * an ignorable character in a Java identifier or a Unicode identifier.&#xA;     * &lt;p>&#xA;     * The following Unicode characters are ignorable in a Java identifier&#xA;     * or a Unicode identifier:&#xA;     * &lt;ul>&#xA;     * &lt;li>ISO control characters that are not whitespace&#xA;     * &lt;ul>&#xA;     * &lt;li>&lt;code>'&amp;#92;u0000'&lt;/code> through &lt;code>'&amp;#92;u0008'&lt;/code>&#xA;     * &lt;li>&lt;code>'&amp;#92;u000E'&lt;/code> through &lt;code>'&amp;#92;u001B'&lt;/code>&#xA;     * &lt;li>&lt;code>'&amp;#92;u007F'&lt;/code> through &lt;code>'&amp;#92;u009F'&lt;/code>&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;li>all characters that have the &lt;code>FORMAT&lt;/code> general&#xA;     * category value&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isIdentifierIgnorable(int)} method.&#xA;     *&#xA;     * @param   ch      the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is an ignorable control &#xA;     *          character that may be part of a Java or Unicode identifier;&#xA;     *           &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isJavaIdentifierPart(char)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierPart(char)&#xA;     * @since   1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.128">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.127/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isIdentifierIgnorable">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character (Unicode code point) should be regarded as&#xA;     * an ignorable character in a Java identifier or a Unicode identifier.&#xA;     * &lt;p>&#xA;     * The following Unicode characters are ignorable in a Java identifier&#xA;     * or a Unicode identifier:&#xA;     * &lt;ul>&#xA;     * &lt;li>ISO control characters that are not whitespace&#xA;     * &lt;ul>&#xA;     * &lt;li>&lt;code>'&amp;#92;u0000'&lt;/code> through &lt;code>'&amp;#92;u0008'&lt;/code>&#xA;     * &lt;li>&lt;code>'&amp;#92;u000E'&lt;/code> through &lt;code>'&amp;#92;u001B'&lt;/code>&#xA;     * &lt;li>&lt;code>'&amp;#92;u007F'&lt;/code> through &lt;code>'&amp;#92;u009F'&lt;/code>&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;li>all characters that have the &lt;code>FORMAT&lt;/code> general&#xA;     * category value&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is an ignorable control &#xA;     *          character that may be part of a Java or Unicode identifier;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isJavaIdentifierPart(int)&#xA;     * @see     java.lang.Character#isUnicodeIdentifierPart(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bIdentifierIgnorable">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.21"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.20"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.20"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.15"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.20"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.15"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bIdentifierIgnorable remains false;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toLowerCase">
      <typeReference xsi:type="types:Char"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts the character argument to lowercase using case&#xA;     * mapping information from the UnicodeData file.&#xA;     * &lt;p>&#xA;     * Note that&#xA;     * &lt;code>Character.isLowerCase(Character.toLowerCase(ch))&lt;/code>&#xA;     * does not always return &lt;code>true&lt;/code> for some ranges of&#xA;     * characters, particularly those that are symbols or ideographs.&#xA;     *&#xA;     * &lt;p>In general, {@link java.lang.String#toLowerCase()} should be used to map&#xA;     * characters to lowercase. &lt;code>String&lt;/code> case mapping methods&#xA;     * have several benefits over &lt;code>Character&lt;/code> case mapping methods.&#xA;     * &lt;code>String&lt;/code> case mapping methods can perform locale-sensitive&#xA;     * mappings, context-sensitive mappings, and 1:M character mappings, whereas&#xA;     * the &lt;code>Character&lt;/code> case mapping methods cannot.&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #toLowerCase(int)} method.&#xA;     *&#xA;     * @param   ch   the character to be converted.&#xA;     * @return  the lowercase equivalent of the character, if any;&#xA;     *          otherwise, the character itself.&#xA;     * @see     java.lang.Character#isLowerCase(char)&#xA;     * @see     java.lang.String#toLowerCase()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Char"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.130">
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.129/@parameters.0"/>
            </arguments>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toLowerCase">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts the character (Unicode code point) argument to&#xA;     * lowercase using case mapping information from the UnicodeData&#xA;     * file.&#xA;     *&#xA;     * &lt;p> Note that&#xA;     * &lt;code>Character.isLowerCase(Character.toLowerCase(codePoint))&lt;/code>&#xA;     * does not always return &lt;code>true&lt;/code> for some ranges of&#xA;     * characters, particularly those that are symbols or ideographs.&#xA;     *&#xA;     * &lt;p>In general, {@link java.lang.String#toLowerCase()} should be used to map&#xA;     * characters to lowercase. &lt;code>String&lt;/code> case mapping methods&#xA;     * have several benefits over &lt;code>Character&lt;/code> case mapping methods.&#xA;     * &lt;code>String&lt;/code> case mapping methods can perform locale-sensitive&#xA;     * mappings, context-sensitive mappings, and 1:M character mappings, whereas&#xA;     * the &lt;code>Character&lt;/code> case mapping methods cannot.&#xA;     *&#xA;     * @param   codePoint   the character (Unicode code point) to be converted.&#xA;     * @return  the lowercase equivalent of the character (Unicode code&#xA;     *          point), if any; otherwise, the character itself.&#xA;     * @see     java.lang.Character#isLowerCase(int)&#xA;     * @see     java.lang.String#toLowerCase()&#xA;     *&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="lowerCase">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="plane">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.20"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.22"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.21"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.21"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.16"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.21"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.16"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// lowerCase remains codePoint;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.1/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toUpperCase">
      <typeReference xsi:type="types:Char"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts the character argument to uppercase using case mapping&#xA;     * information from the UnicodeData file.&#xA;     * &lt;p>&#xA;     * Note that&#xA;     * &lt;code>Character.isUpperCase(Character.toUpperCase(ch))&lt;/code>&#xA;     * does not always return &lt;code>true&lt;/code> for some ranges of&#xA;     * characters, particularly those that are symbols or ideographs.&#xA;     *&#xA;     * &lt;p>In general, {@link java.lang.String#toUpperCase()} should be used to map&#xA;     * characters to uppercase. &lt;code>String&lt;/code> case mapping methods&#xA;     * have several benefits over &lt;code>Character&lt;/code> case mapping methods.&#xA;     * &lt;code>String&lt;/code> case mapping methods can perform locale-sensitive&#xA;     * mappings, context-sensitive mappings, and 1:M character mappings, whereas&#xA;     * the &lt;code>Character&lt;/code> case mapping methods cannot.&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #toUpperCase(int)} method.&#xA;     *&#xA;     * @param   ch   the character to be converted.&#xA;     * @return  the uppercase equivalent of the character, if any;&#xA;     *          otherwise, the character itself.&#xA;     * @see     java.lang.Character#isUpperCase(char)&#xA;     * @see     java.lang.String#toUpperCase()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Char"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.132">
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@parameters.0"/>
            </arguments>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toUpperCase">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts the character (Unicode code point) argument to&#xA;     * uppercase using case mapping information from the UnicodeData&#xA;     * file.&#xA;     * &#xA;     * &lt;p>Note that&#xA;     * &lt;code>Character.isUpperCase(Character.toUpperCase(codePoint))&lt;/code>&#xA;     * does not always return &lt;code>true&lt;/code> for some ranges of&#xA;     * characters, particularly those that are symbols or ideographs.&#xA;     *&#xA;     * &lt;p>In general, {@link java.lang.String#toUpperCase()} should be used to map&#xA;     * characters to uppercase. &lt;code>String&lt;/code> case mapping methods&#xA;     * have several benefits over &lt;code>Character&lt;/code> case mapping methods.&#xA;     * &lt;code>String&lt;/code> case mapping methods can perform locale-sensitive&#xA;     * mappings, context-sensitive mappings, and 1:M character mappings, whereas&#xA;     * the &lt;code>Character&lt;/code> case mapping methods cannot.&#xA;     *&#xA;     * @param   codePoint   the character (Unicode code point) to be converted.&#xA;     * @return  the uppercase equivalent of the character, if any;&#xA;     *          otherwise, the character itself.&#xA;     * @see     java.lang.Character#isUpperCase(int)&#xA;     * @see     java.lang.String#toUpperCase()&#xA;     * &#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="upperCase">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="plane">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.21"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.23"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.22"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.22"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.17"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.22"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.17"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// upperCase remains codePoint;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.1/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toTitleCase">
      <typeReference xsi:type="types:Char"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts the character argument to titlecase using case mapping&#xA;     * information from the UnicodeData file. If a character has no&#xA;     * explicit titlecase mapping and is not itself a titlecase char&#xA;     * according to UnicodeData, then the uppercase mapping is&#xA;     * returned as an equivalent titlecase mapping. If the&#xA;     * &lt;code>char&lt;/code> argument is already a titlecase&#xA;     * &lt;code>char&lt;/code>, the same &lt;code>char&lt;/code> value will be&#xA;     * returned.&#xA;     * &lt;p>&#xA;     * Note that&#xA;     * &lt;code>Character.isTitleCase(Character.toTitleCase(ch))&lt;/code>&#xA;     * does not always return &lt;code>true&lt;/code> for some ranges of&#xA;     * characters.&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #toTitleCase(int)} method.&#xA;     *&#xA;     * @param   ch   the character to be converted.&#xA;     * @return  the titlecase equivalent of the character, if any;&#xA;     *          otherwise, the character itself.&#xA;     * @see     java.lang.Character#isTitleCase(char)&#xA;     * @see     java.lang.Character#toLowerCase(char)&#xA;     * @see     java.lang.Character#toUpperCase(char)&#xA;     * @since   1.0.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Char"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.134">
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.133/@parameters.0"/>
            </arguments>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toTitleCase">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts the character (Unicode code point) argument to titlecase using case mapping&#xA;     * information from the UnicodeData file. If a character has no&#xA;     * explicit titlecase mapping and is not itself a titlecase char&#xA;     * according to UnicodeData, then the uppercase mapping is&#xA;     * returned as an equivalent titlecase mapping. If the&#xA;     * character argument is already a titlecase&#xA;     * character, the same character value will be&#xA;     * returned.&#xA;     * &#xA;     * &lt;p>Note that&#xA;     * &lt;code>Character.isTitleCase(Character.toTitleCase(codePoint))&lt;/code>&#xA;     * does not always return &lt;code>true&lt;/code> for some ranges of&#xA;     * characters.&#xA;     *&#xA;     * @param   codePoint   the character (Unicode code point) to be converted.&#xA;     * @return  the titlecase equivalent of the character, if any;&#xA;     *          otherwise, the character itself.&#xA;     * @see     java.lang.Character#isTitleCase(int)&#xA;     * @see     java.lang.Character#toLowerCase(int)&#xA;     * @see     java.lang.Character#toUpperCase(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="titleCase">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@parameters.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="plane">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.22"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@parameters.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.24"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.23"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.23"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.18"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.23"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.18"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// titleCase remains codePoint;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@statements.1/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="digit">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="radix">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the numeric value of the character &lt;code>ch&lt;/code> in the&#xA;     * specified radix.&#xA;     * &lt;p>&#xA;     * If the radix is not in the range &lt;code>MIN_RADIX&lt;/code>&amp;nbsp;&amp;lt;=&#xA;     * &lt;code>radix&lt;/code>&amp;nbsp;&amp;lt;= &lt;code>MAX_RADIX&lt;/code> or if the&#xA;     * value of &lt;code>ch&lt;/code> is not a valid digit in the specified&#xA;     * radix, &lt;code>-1&lt;/code> is returned. A character is a valid digit&#xA;     * if at least one of the following is true:&#xA;     * &lt;ul>&#xA;     * &lt;li>The method &lt;code>isDigit&lt;/code> is &lt;code>true&lt;/code> of the character&#xA;     *     and the Unicode decimal digit value of the character (or its&#xA;     *     single-character decomposition) is less than the specified radix.&#xA;     *     In this case the decimal digit value is returned.&#xA;     * &lt;li>The character is one of the uppercase Latin letters&#xA;     *     &lt;code>'A'&lt;/code> through &lt;code>'Z'&lt;/code> and its code is less than&#xA;     *     &lt;code>radix&amp;nbsp;+ 'A'&amp;nbsp;-&amp;nbsp;10&lt;/code>.&#xA;     *     In this case, &lt;code>ch&amp;nbsp;- 'A'&amp;nbsp;+&amp;nbsp;10&lt;/code>&#xA;     *     is returned.&#xA;     * &lt;li>The character is one of the lowercase Latin letters&#xA;     *     &lt;code>'a'&lt;/code> through &lt;code>'z'&lt;/code> and its code is less than&#xA;     *     &lt;code>radix&amp;nbsp;+ 'a'&amp;nbsp;-&amp;nbsp;10&lt;/code>.&#xA;     *     In this case, &lt;code>ch&amp;nbsp;- 'a'&amp;nbsp;+&amp;nbsp;10&lt;/code>&#xA;     *     is returned.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #digit(int, int)} method.&#xA;     *&#xA;     * @param   ch      the character to be converted.&#xA;     * @param   radix   the radix.&#xA;     * @return  the numeric value represented by the character in the&#xA;     *          specified radix.&#xA;     * @see     java.lang.Character#forDigit(int, int)&#xA;     * @see     java.lang.Character#isDigit(char)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="digit">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="radix">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the numeric value of the specified character (Unicode&#xA;     * code point) in the specified radix.&#xA;     * &#xA;     * &lt;p>If the radix is not in the range &lt;code>MIN_RADIX&lt;/code>&amp;nbsp;&amp;lt;=&#xA;     * &lt;code>radix&lt;/code>&amp;nbsp;&amp;lt;= &lt;code>MAX_RADIX&lt;/code> or if the&#xA;     * character is not a valid digit in the specified&#xA;     * radix, &lt;code>-1&lt;/code> is returned. A character is a valid digit&#xA;     * if at least one of the following is true:&#xA;     * &lt;ul>&#xA;     * &lt;li>The method {@link #isDigit(int) isDigit(codePoint)} is &lt;code>true&lt;/code> of the character&#xA;     *     and the Unicode decimal digit value of the character (or its&#xA;     *     single-character decomposition) is less than the specified radix.&#xA;     *     In this case the decimal digit value is returned.&#xA;     * &lt;li>The character is one of the uppercase Latin letters&#xA;     *     &lt;code>'A'&lt;/code> through &lt;code>'Z'&lt;/code> and its code is less than&#xA;     *     &lt;code>radix&amp;nbsp;+ 'A'&amp;nbsp;-&amp;nbsp;10&lt;/code>.&#xA;     *     In this case, &lt;code>ch&amp;nbsp;- 'A'&amp;nbsp;+&amp;nbsp;10&lt;/code>&#xA;     *     is returned.&#xA;     * &lt;li>The character is one of the lowercase Latin letters&#xA;     *     &lt;code>'a'&lt;/code> through &lt;code>'z'&lt;/code> and its code is less than&#xA;     *     &lt;code>radix&amp;nbsp;+ 'a'&amp;nbsp;-&amp;nbsp;10&lt;/code>.&#xA;     *     In this case, &lt;code>ch&amp;nbsp;- 'a'&amp;nbsp;+&amp;nbsp;10&lt;/code>&#xA;     *     is returned.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be converted.&#xA;     * @param   radix   the radix.&#xA;     * @return  the numeric value represented by the character in the&#xA;     *          specified radix.&#xA;     * @see     java.lang.Character#forDigit(int, int)&#xA;     * @see     java.lang.Character#isDigit(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="digit">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.23"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.25"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.0"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.1"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.24"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.0"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.1"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.24"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.0"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.1"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.19"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.0"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.1"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.24"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.0"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.1"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.19"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.0"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@parameters.1"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// digit remains -1;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNumericValue">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>int&lt;/code> value that the specified Unicode&#xA;     * character represents. For example, the character&#xA;     * &lt;code>'&amp;#92;u216C'&lt;/code> (the roman numeral fifty) will return&#xA;     * an int with a value of 50.&#xA;     * &lt;p>&#xA;     * The letters A-Z in their uppercase (&lt;code>'&amp;#92;u0041'&lt;/code> through&#xA;     * &lt;code>'&amp;#92;u005A'&lt;/code>), lowercase&#xA;     * (&lt;code>'&amp;#92;u0061'&lt;/code> through &lt;code>'&amp;#92;u007A'&lt;/code>), and&#xA;     * full width variant (&lt;code>'&amp;#92;uFF21'&lt;/code> through&#xA;     * &lt;code>'&amp;#92;uFF3A'&lt;/code> and &lt;code>'&amp;#92;uFF41'&lt;/code> through&#xA;     * &lt;code>'&amp;#92;uFF5A'&lt;/code>) forms have numeric values from 10&#xA;     * through 35. This is independent of the Unicode specification,&#xA;     * which does not assign numeric values to these &lt;code>char&lt;/code>&#xA;     * values.&#xA;     * &lt;p>&#xA;     * If the character does not have a numeric value, then -1 is returned.&#xA;     * If the character has a numeric value that cannot be represented as a&#xA;     * nonnegative integer (for example, a fractional value), then -2&#xA;     * is returned.&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #getNumericValue(int)} method.&#xA;     *&#xA;     * @param   ch      the character to be converted.&#xA;     * @return  the numeric value of the character, as a nonnegative &lt;code>int&lt;/code>&#xA;     *           value; -2 if the character has a numeric value that is not a&#xA;     *          nonnegative integer; -1 if the character has no numeric value.&#xA;     * @see     java.lang.Character#forDigit(int, int)&#xA;     * @see     java.lang.Character#isDigit(char)&#xA;     * @since   1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.138">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNumericValue">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>int&lt;/code> value that the specified &#xA;     * character (Unicode code point) represents. For example, the character&#xA;     * &lt;code>'&amp;#92;u216C'&lt;/code> (the Roman numeral fifty) will return&#xA;     * an &lt;code>int&lt;/code> with a value of 50.&#xA;     * &lt;p>&#xA;     * The letters A-Z in their uppercase (&lt;code>'&amp;#92;u0041'&lt;/code> through&#xA;     * &lt;code>'&amp;#92;u005A'&lt;/code>), lowercase&#xA;     * (&lt;code>'&amp;#92;u0061'&lt;/code> through &lt;code>'&amp;#92;u007A'&lt;/code>), and&#xA;     * full width variant (&lt;code>'&amp;#92;uFF21'&lt;/code> through&#xA;     * &lt;code>'&amp;#92;uFF3A'&lt;/code> and &lt;code>'&amp;#92;uFF41'&lt;/code> through&#xA;     * &lt;code>'&amp;#92;uFF5A'&lt;/code>) forms have numeric values from 10&#xA;     * through 35. This is independent of the Unicode specification,&#xA;     * which does not assign numeric values to these &lt;code>char&lt;/code>&#xA;     * values.&#xA;     * &lt;p>&#xA;     * If the character does not have a numeric value, then -1 is returned.&#xA;     * If the character has a numeric value that cannot be represented as a&#xA;     * nonnegative integer (for example, a fractional value), then -2&#xA;     * is returned.&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be converted.&#xA;     * @return  the numeric value of the character, as a nonnegative &lt;code>int&lt;/code>&#xA;     *          value; -2 if the character has a numeric value that is not a&#xA;     *          nonnegative integer; -1 if the character has no numeric value.&#xA;     * @see     java.lang.Character#forDigit(int, int)&#xA;     * @see     java.lang.Character#isDigit(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="numericValue">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.24"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.26"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.25"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.25"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.20"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.25"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.20"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// numericValue remains -1</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isSpace">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Determines if the specified character is ISO-LATIN-1 white space.&#xA;     * This method returns &lt;code>true&lt;/code> for the following five&#xA;     * characters only:&#xA;     * &lt;table>&#xA;     * &lt;tr>&lt;td>&lt;code>'\t'&lt;/code>&lt;/td>            &lt;td>&lt;code>'&amp;#92;u0009'&lt;/code>&lt;/td>&#xA;     *     &lt;td>&lt;code>HORIZONTAL TABULATION&lt;/code>&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td>&lt;code>'\n'&lt;/code>&lt;/td>            &lt;td>&lt;code>'&amp;#92;u000A'&lt;/code>&lt;/td>&#xA;     *     &lt;td>&lt;code>NEW LINE&lt;/code>&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td>&lt;code>'\f'&lt;/code>&lt;/td>            &lt;td>&lt;code>'&amp;#92;u000C'&lt;/code>&lt;/td>&#xA;     *     &lt;td>&lt;code>FORM FEED&lt;/code>&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td>&lt;code>'\r'&lt;/code>&lt;/td>            &lt;td>&lt;code>'&amp;#92;u000D'&lt;/code>&lt;/td>&#xA;     *     &lt;td>&lt;code>CARRIAGE RETURN&lt;/code>&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td>&lt;code>'&amp;nbsp;'&lt;/code>&lt;/td>  &lt;td>&lt;code>'&amp;#92;u0020'&lt;/code>&lt;/td>&#xA;     *     &lt;td>&lt;code>SPACE&lt;/code>&lt;/td>&lt;/tr>&#xA;     * &lt;/table>&#xA;     *&#xA;     * @param      ch   the character to be tested.&#xA;     * @return     &lt;code>true&lt;/code> if the character is ISO-LATIN-1 white&#xA;     *             space; &lt;code>false&lt;/code> otherwise.&#xA;     * @see        java.lang.Character#isSpaceChar(char)&#xA;     * @see        java.lang.Character#isWhitespace(char)&#xA;     * @deprecated Replaced by isWhitespace(char).&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@parameters.0"/>
              <children xsi:type="literals:HexIntegerLiteral" hexValue="32"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AndExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:ShiftExpression">
                      <children xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:InclusiveOrExpression">
                          <children xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:ShiftExpression">
                              <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                              <children xsi:type="literals:HexIntegerLiteral" hexValue="9"/>
                              <shiftOperators xsi:type="operators:LeftShift"/>
                            </expression>
                          </children>
                          <children xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:ShiftExpression">
                              <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                              <children xsi:type="literals:HexIntegerLiteral" hexValue="10"/>
                              <shiftOperators xsi:type="operators:LeftShift"/>
                            </expression>
                          </children>
                          <children xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:ShiftExpression">
                              <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                              <children xsi:type="literals:HexIntegerLiteral" hexValue="12"/>
                              <shiftOperators xsi:type="operators:LeftShift"/>
                            </expression>
                          </children>
                          <children xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:ShiftExpression">
                              <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                              <children xsi:type="literals:HexIntegerLiteral" hexValue="13"/>
                              <shiftOperators xsi:type="operators:LeftShift"/>
                            </expression>
                          </children>
                          <children xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:ShiftExpression">
                              <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                              <children xsi:type="literals:HexIntegerLiteral" hexValue="32"/>
                              <shiftOperators xsi:type="operators:LeftShift"/>
                            </expression>
                          </children>
                        </expression>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@parameters.0"/>
                      <shiftOperators xsi:type="operators:RightShift"/>
                    </expression>
                  </children>
                  <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                </expression>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </expression>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isSpaceChar">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character is a Unicode space character.&#xA;     * A character is considered to be a space character if and only if&#xA;     * it is specified to be a space character by the Unicode standard. This&#xA;     * method returns true if the character's general category type is any of&#xA;     * the following:&#xA;     * &lt;ul>&#xA;     * &lt;li> &lt;code>SPACE_SEPARATOR&lt;/code>&#xA;     * &lt;li> &lt;code>LINE_SEPARATOR&lt;/code>&#xA;     * &lt;li> &lt;code>PARAGRAPH_SEPARATOR&lt;/code>&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isSpaceChar(int)} method.&#xA;     *&#xA;     * @param   ch      the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is a space character; &#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isWhitespace(char)&#xA;     * @since   1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.141">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.140/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isSpaceChar">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character (Unicode code point) is a&#xA;     * Unicode space character.  A character is considered to be a&#xA;     * space character if and only if it is specified to be a space&#xA;     * character by the Unicode standard. This method returns true if&#xA;     * the character's general category type is any of the following:&#xA;     *&#xA;     * &lt;ul>&#xA;     * &lt;li> {@link #SPACE_SEPARATOR}&#xA;     * &lt;li> {@link #LINE_SEPARATOR}&#xA;     * &lt;li> {@link #PARAGRAPH_SEPARATOR}&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is a space character; &#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isWhitespace(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bSpaceChar">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.14"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.16"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.15"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.15"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.10"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.15"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.10"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bSpaceChar remains false</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isWhitespace">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character is white space according to Java.&#xA;     * A character is a Java whitespace character if and only if it satisfies&#xA;     * one of the following criteria:&#xA;     * &lt;ul>&#xA;     * &lt;li> It is a Unicode space character (&lt;code>SPACE_SEPARATOR&lt;/code>,&#xA;     *      &lt;code>LINE_SEPARATOR&lt;/code>, or &lt;code>PARAGRAPH_SEPARATOR&lt;/code>) &#xA;     *      but is not also a non-breaking space (&lt;code>'&amp;#92;u00A0'&lt;/code>,&#xA;     *      &lt;code>'&amp;#92;u2007'&lt;/code>, &lt;code>'&amp;#92;u202F'&lt;/code>).&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u0009'&lt;/code>, HORIZONTAL TABULATION.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u000A'&lt;/code>, LINE FEED.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u000B'&lt;/code>, VERTICAL TABULATION.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u000C'&lt;/code>, FORM FEED.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u000D'&lt;/code>, CARRIAGE RETURN.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u001C'&lt;/code>, FILE SEPARATOR.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u001D'&lt;/code>, GROUP SEPARATOR.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u001E'&lt;/code>, RECORD SEPARATOR.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u001F'&lt;/code>, UNIT SEPARATOR.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isWhitespace(int)} method.&#xA;     *&#xA;     * @param   ch the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is a Java whitespace&#xA;     *          character; &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isSpaceChar(char)&#xA;     * @since   1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.143">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isWhitespace">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character (Unicode code point) is&#xA;     * white space according to Java.  A character is a Java&#xA;     * whitespace character if and only if it satisfies one of the&#xA;     * following criteria:&#xA;     * &lt;ul>&#xA;     * &lt;li> It is a Unicode space character ({@link #SPACE_SEPARATOR},&#xA;     *      {@link #LINE_SEPARATOR}, or {@link #PARAGRAPH_SEPARATOR}) &#xA;     *      but is not also a non-breaking space (&lt;code>'&amp;#92;u00A0'&lt;/code>,&#xA;     *      &lt;code>'&amp;#92;u2007'&lt;/code>, &lt;code>'&amp;#92;u202F'&lt;/code>).&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u0009'&lt;/code>, HORIZONTAL TABULATION.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u000A'&lt;/code>, LINE FEED.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u000B'&lt;/code>, VERTICAL TABULATION.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u000C'&lt;/code>, FORM FEED.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u000D'&lt;/code>, CARRIAGE RETURN.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u001C'&lt;/code>, FILE SEPARATOR.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u001D'&lt;/code>, GROUP SEPARATOR.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u001E'&lt;/code>, RECORD SEPARATOR.&#xA;     * &lt;li> It is &lt;code>'&amp;#92;u001F'&lt;/code>, UNIT SEPARATOR.&#xA;     * &lt;/ul>&#xA;     * &lt;p>&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is a Java whitespace&#xA;     *          character; &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isSpaceChar(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bWhiteSpace">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.25"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.27"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.26"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.26"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.21"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.26"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.21"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bWhiteSpace remains false</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isISOControl">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the specified character is an ISO control&#xA;     * character.  A character is considered to be an ISO control&#xA;     * character if its code is in the range &lt;code>'&amp;#92;u0000'&lt;/code>&#xA;     * through &lt;code>'&amp;#92;u001F'&lt;/code> or in the range&#xA;     * &lt;code>'&amp;#92;u007F'&lt;/code> through &lt;code>'&amp;#92;u009F'&lt;/code>.&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isISOControl(int)} method.&#xA;     *&#xA;     * @param   ch      the character to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is an ISO control character;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     *&#xA;     * @see     java.lang.Character#isSpaceChar(char)&#xA;     * @see     java.lang.Character#isWhitespace(char)&#xA;     * @since   1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.145">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isISOControl">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the referenced character (Unicode code point) is an ISO control&#xA;     * character.  A character is considered to be an ISO control&#xA;     * character if its code is in the range &lt;code>'&amp;#92;u0000'&lt;/code>&#xA;     * through &lt;code>'&amp;#92;u001F'&lt;/code> or in the range&#xA;     * &lt;code>'&amp;#92;u007F'&lt;/code> through &lt;code>'&amp;#92;u009F'&lt;/code>.&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is an ISO control character;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     * @see     java.lang.Character#isSpaceChar(int)&#xA;     * @see     java.lang.Character#isWhitespace(int)&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.145/@parameters.0"/>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="0"/>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.145/@parameters.0"/>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="31"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </children>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.145/@parameters.0"/>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="127"/>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.145/@parameters.0"/>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="159"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </children>
            </expression>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getType">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a value indicating a character's general category.&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #getType(int)} method.&#xA;     *&#xA;     * @param   ch      the character to be tested.&#xA;     * @return  a value of type &lt;code>int&lt;/code> representing the &#xA;     *          character's general category.&#xA;     * @see     java.lang.Character#COMBINING_SPACING_MARK&#xA;     * @see     java.lang.Character#CONNECTOR_PUNCTUATION&#xA;     * @see     java.lang.Character#CONTROL&#xA;     * @see     java.lang.Character#CURRENCY_SYMBOL&#xA;     * @see     java.lang.Character#DASH_PUNCTUATION&#xA;     * @see     java.lang.Character#DECIMAL_DIGIT_NUMBER&#xA;     * @see     java.lang.Character#ENCLOSING_MARK&#xA;     * @see     java.lang.Character#END_PUNCTUATION&#xA;     * @see     java.lang.Character#FINAL_QUOTE_PUNCTUATION&#xA;     * @see     java.lang.Character#FORMAT&#xA;     * @see     java.lang.Character#INITIAL_QUOTE_PUNCTUATION&#xA;     * @see     java.lang.Character#LETTER_NUMBER&#xA;     * @see     java.lang.Character#LINE_SEPARATOR&#xA;     * @see     java.lang.Character#LOWERCASE_LETTER&#xA;     * @see     java.lang.Character#MATH_SYMBOL&#xA;     * @see     java.lang.Character#MODIFIER_LETTER&#xA;     * @see     java.lang.Character#MODIFIER_SYMBOL&#xA;     * @see     java.lang.Character#NON_SPACING_MARK&#xA;     * @see     java.lang.Character#OTHER_LETTER&#xA;     * @see     java.lang.Character#OTHER_NUMBER&#xA;     * @see     java.lang.Character#OTHER_PUNCTUATION&#xA;     * @see     java.lang.Character#OTHER_SYMBOL&#xA;     * @see     java.lang.Character#PARAGRAPH_SEPARATOR&#xA;     * @see     java.lang.Character#PRIVATE_USE&#xA;     * @see     java.lang.Character#SPACE_SEPARATOR&#xA;     * @see     java.lang.Character#START_PUNCTUATION&#xA;     * @see     java.lang.Character#SURROGATE&#xA;     * @see     java.lang.Character#TITLECASE_LETTER&#xA;     * @see     java.lang.Character#UNASSIGNED&#xA;     * @see     java.lang.Character#UPPERCASE_LETTER&#xA;     * @since   1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.147">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.146/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getType">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a value indicating a character's general category.&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  a value of type &lt;code>int&lt;/code> representing the &#xA;     *          character's general category.&#xA;     * @see     Character#COMBINING_SPACING_MARK COMBINING_SPACING_MARK&#xA;     * @see     Character#CONNECTOR_PUNCTUATION CONNECTOR_PUNCTUATION&#xA;     * @see     Character#CONTROL CONTROL&#xA;     * @see     Character#CURRENCY_SYMBOL CURRENCY_SYMBOL&#xA;     * @see     Character#DASH_PUNCTUATION DASH_PUNCTUATION&#xA;     * @see     Character#DECIMAL_DIGIT_NUMBER DECIMAL_DIGIT_NUMBER&#xA;     * @see     Character#ENCLOSING_MARK ENCLOSING_MARK&#xA;     * @see     Character#END_PUNCTUATION END_PUNCTUATION&#xA;     * @see     Character#FINAL_QUOTE_PUNCTUATION FINAL_QUOTE_PUNCTUATION&#xA;     * @see     Character#FORMAT FORMAT&#xA;     * @see     Character#INITIAL_QUOTE_PUNCTUATION INITIAL_QUOTE_PUNCTUATION&#xA;     * @see     Character#LETTER_NUMBER LETTER_NUMBER&#xA;     * @see     Character#LINE_SEPARATOR LINE_SEPARATOR&#xA;     * @see     Character#LOWERCASE_LETTER LOWERCASE_LETTER&#xA;     * @see     Character#MATH_SYMBOL MATH_SYMBOL&#xA;     * @see     Character#MODIFIER_LETTER MODIFIER_LETTER&#xA;     * @see     Character#MODIFIER_SYMBOL MODIFIER_SYMBOL&#xA;     * @see     Character#NON_SPACING_MARK NON_SPACING_MARK&#xA;     * @see     Character#OTHER_LETTER OTHER_LETTER&#xA;     * @see     Character#OTHER_NUMBER OTHER_NUMBER&#xA;     * @see     Character#OTHER_PUNCTUATION OTHER_PUNCTUATION&#xA;     * @see     Character#OTHER_SYMBOL OTHER_SYMBOL&#xA;     * @see     Character#PARAGRAPH_SEPARATOR PARAGRAPH_SEPARATOR&#xA;     * @see     Character#PRIVATE_USE PRIVATE_USE&#xA;     * @see     Character#SPACE_SEPARATOR SPACE_SEPARATOR&#xA;     * @see     Character#START_PUNCTUATION START_PUNCTUATION&#xA;     * @see     Character#SURROGATE SURROGATE&#xA;     * @see     Character#TITLECASE_LETTER TITLECASE_LETTER&#xA;     * @see     Character#UNASSIGNED UNASSIGNED&#xA;     * @see     Character#UPPERCASE_LETTER UPPERCASE_LETTER&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="type">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.6"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.8"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.7"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.7"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@statements.0/@variable">
                    <comments>// Undefined      </comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.2"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.7"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.2"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// type remains UNASSIGNED</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="forDigit">
      <typeReference xsi:type="types:Char"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="digit">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="radix">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines the character representation for a specific digit in&#xA;     * the specified radix. If the value of &lt;code>radix&lt;/code> is not a&#xA;     * valid radix, or the value of &lt;code>digit&lt;/code> is not a valid&#xA;     * digit in the specified radix, the null character&#xA;     * (&lt;code>'&amp;#92;u0000'&lt;/code>) is returned.&#xA;     * &lt;p>&#xA;     * The &lt;code>radix&lt;/code> argument is valid if it is greater than or&#xA;     * equal to &lt;code>MIN_RADIX&lt;/code> and less than or equal to&#xA;     * &lt;code>MAX_RADIX&lt;/code>. The &lt;code>digit&lt;/code> argument is valid if&#xA;     * &lt;code>0&amp;nbsp;&amp;lt;=digit&amp;nbsp;&amp;lt;&amp;nbsp;radix&lt;/code>.&#xA;     * &lt;p>&#xA;     * If the digit is less than 10, then&#xA;     * &lt;code>'0'&amp;nbsp;+ digit&lt;/code> is returned. Otherwise, the value&#xA;     * &lt;code>'a'&amp;nbsp;+ digit&amp;nbsp;-&amp;nbsp;10&lt;/code> is returned.&#xA;     *&#xA;     * @param   digit   the number to convert to a character.&#xA;     * @param   radix   the radix.&#xA;     * @return  the &lt;code>char&lt;/code> representation of the specified digit&#xA;     *          in the specified radix.&#xA;     * @see     java.lang.Character#MIN_RADIX&#xA;     * @see     java.lang.Character#MAX_RADIX&#xA;     * @see     java.lang.Character#digit(char, int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:CharacterLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@parameters.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:CharacterLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Char"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="literals:CharacterLiteral" value="48"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@parameters.0"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </expression>
              </child>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Char"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AdditiveExpression">
              <children xsi:type="literals:CharacterLiteral" value="97"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </expression>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDirectionality">
      <typeReference xsi:type="types:Byte"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the Unicode directionality property for the given&#xA;     * character.  Character directionality is used to calculate the&#xA;     * visual ordering of text. The directionality value of undefined&#xA;     * &lt;code>char&lt;/code> values is &lt;code>DIRECTIONALITY_UNDEFINED&lt;/code>.&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #getDirectionality(int)} method.&#xA;     *&#xA;     * @param  ch &lt;code>char&lt;/code> for which the directionality property &#xA;     *            is requested.&#xA;     * @return the directionality property of the &lt;code>char&lt;/code> value.&#xA;     *&#xA;     * @see Character#DIRECTIONALITY_UNDEFINED&#xA;     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT&#xA;     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT&#xA;     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC&#xA;     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER&#xA;     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR&#xA;     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR&#xA;     * @see Character#DIRECTIONALITY_ARABIC_NUMBER&#xA;     * @see Character#DIRECTIONALITY_COMMON_NUMBER_SEPARATOR&#xA;     * @see Character#DIRECTIONALITY_NONSPACING_MARK&#xA;     * @see Character#DIRECTIONALITY_BOUNDARY_NEUTRAL&#xA;     * @see Character#DIRECTIONALITY_PARAGRAPH_SEPARATOR&#xA;     * @see Character#DIRECTIONALITY_SEGMENT_SEPARATOR&#xA;     * @see Character#DIRECTIONALITY_WHITESPACE&#xA;     * @see Character#DIRECTIONALITY_OTHER_NEUTRALS&#xA;     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING&#xA;     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE&#xA;     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING&#xA;     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE&#xA;     * @see Character#DIRECTIONALITY_POP_DIRECTIONAL_FORMAT&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.150">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.149/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDirectionality">
      <typeReference xsi:type="types:Byte"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the Unicode directionality property for the given&#xA;     * character (Unicode code point).  Character directionality is&#xA;     * used to calculate the visual ordering of text. The&#xA;     * directionality value of undefined character is {@link&#xA;     * #DIRECTIONALITY_UNDEFINED}.&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) for which&#xA;     *          the directionality property * is requested.&#xA;     * @return the directionality property of the character.&#xA;     *&#xA;     * @see Character#DIRECTIONALITY_UNDEFINED DIRECTIONALITY_UNDEFINED&#xA;     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT DIRECTIONALITY_LEFT_TO_RIGHT&#xA;     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT DIRECTIONALITY_RIGHT_TO_LEFT&#xA;     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC&#xA;     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER DIRECTIONALITY_EUROPEAN_NUMBER&#xA;     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR&#xA;     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR&#xA;     * @see Character#DIRECTIONALITY_ARABIC_NUMBER DIRECTIONALITY_ARABIC_NUMBER&#xA;     * @see Character#DIRECTIONALITY_COMMON_NUMBER_SEPARATOR DIRECTIONALITY_COMMON_NUMBER_SEPARATOR&#xA;     * @see Character#DIRECTIONALITY_NONSPACING_MARK DIRECTIONALITY_NONSPACING_MARK&#xA;     * @see Character#DIRECTIONALITY_BOUNDARY_NEUTRAL DIRECTIONALITY_BOUNDARY_NEUTRAL&#xA;     * @see Character#DIRECTIONALITY_PARAGRAPH_SEPARATOR DIRECTIONALITY_PARAGRAPH_SEPARATOR&#xA;     * @see Character#DIRECTIONALITY_SEGMENT_SEPARATOR DIRECTIONALITY_SEGMENT_SEPARATOR&#xA;     * @see Character#DIRECTIONALITY_WHITESPACE DIRECTIONALITY_WHITESPACE&#xA;     * @see Character#DIRECTIONALITY_OTHER_NEUTRALS DIRECTIONALITY_OTHER_NEUTRALS&#xA;     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING&#xA;     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE&#xA;     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING&#xA;     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE&#xA;     * @see Character#DIRECTIONALITY_POP_DIRECTIONAL_FORMAT DIRECTIONALITY_POP_DIRECTIONAL_FORMAT&#xA;     * @since    1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="directionality">
          <typeReference xsi:type="types:Byte"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.26"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.28"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.27"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.27"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.22"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.27"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.22"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// directionality remains DIRECTIONALITY_UNDEFINED</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isMirrored">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines whether the character is mirrored according to the&#xA;     * Unicode specification.  Mirrored characters should have their&#xA;     * glyphs horizontally mirrored when displayed in text that is&#xA;     * right-to-left.  For example, &lt;code>'&amp;#92;u0028'&lt;/code> LEFT&#xA;     * PARENTHESIS is semantically defined to be an &lt;i>opening&#xA;     * parenthesis&lt;/i>.  This will appear as a &quot;(&quot; in text that is&#xA;     * left-to-right but as a &quot;)&quot; in text that is right-to-left.&#xA;     *&#xA;     * &lt;p>&lt;b>Note:&lt;/b> This method cannot handle &lt;a&#xA;     * href=&quot;#supplementary&quot;> supplementary characters&lt;/a>. To support&#xA;     * all Unicode characters, including supplementary characters, use&#xA;     * the {@link #isMirrored(int)} method.&#xA;     *&#xA;     * @param  ch &lt;code>char&lt;/code> for which the mirrored property is requested&#xA;     * @return &lt;code>true&lt;/code> if the char is mirrored, &lt;code>false&lt;/code>&#xA;     *         if the &lt;code>char&lt;/code> is not mirrored or is not defined.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.152">
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isMirrored">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines whether the specified character (Unicode code point)&#xA;     * is mirrored according to the Unicode specification.  Mirrored&#xA;     * characters should have their glyphs horizontally mirrored when&#xA;     * displayed in text that is right-to-left.  For example,&#xA;     * &lt;code>'&amp;#92;u0028'&lt;/code> LEFT PARENTHESIS is semantically&#xA;     * defined to be an &lt;i>opening parenthesis&lt;/i>.  This will appear&#xA;     * as a &quot;(&quot; in text that is left-to-right but as a &quot;)&quot; in text&#xA;     * that is right-to-left.&#xA;     *&#xA;     * @param   codePoint the character (Unicode code point) to be tested.&#xA;     * @return  &lt;code>true&lt;/code> if the character is mirrored, &lt;code>false&lt;/code>&#xA;     *          if the character is not mirrored or is not defined.&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bMirrored">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.27"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="plane">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@parameters.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.29"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.28"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.28"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.23"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.28"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.23"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// bMirrored remains false</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@statements.1/@elseStatement/@statements.0/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.152/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="anotherCharacter">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares two &lt;code>Character&lt;/code> objects numerically.&#xA;     *&#xA;     * @param   anotherCharacter   the &lt;code>Character&lt;/code> to be compared.&#xA;&#xA;     * @return  the value &lt;code>0&lt;/code> if the argument &lt;code>Character&lt;/code> &#xA;     *          is equal to this &lt;code>Character&lt;/code>; a value less than &#xA;     *          &lt;code>0&lt;/code> if this &lt;code>Character&lt;/code> is numerically less &#xA;     *          than the &lt;code>Character&lt;/code> argument; and a value greater than &#xA;     *          &lt;code>0&lt;/code> if this &lt;code>Character&lt;/code> is numerically greater &#xA;     *          than the &lt;code>Character&lt;/code> argument (unsigned comparison).  &#xA;     *          Note that this is strictly a numerical comparison; it is not &#xA;     *          locale-dependent.&#xA;     * @since   1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.153/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
          </children>
          <additiveOperators xsi:type="operators:Subtraction"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toUpperCaseEx">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Converts the character (Unicode code point) argument to uppercase using&#xA;     * information from the UnicodeData file.&#xA;     * &lt;p>&#xA;     *&#xA;     * @param   codePoint   the character (Unicode code point) to be converted.&#xA;     * @return  either the uppercase equivalent of the character, if &#xA;     *          any, or an error flag (&lt;code>Character.ERROR&lt;/code>) &#xA;     *          that indicates that a 1:M &lt;code>char&lt;/code> mapping exists.&#xA;     * @see     java.lang.Character#isLowerCase(char)&#xA;     * @see     java.lang.Character#isUpperCase(char)&#xA;     * @see     java.lang.Character#toLowerCase(char)&#xA;     * @see     java.lang.Character#toTitleCase(char)&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="upperCase">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@parameters.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="plane">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Assert">
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.28"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@parameters.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.30"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData01.class.xmi#//@classifiers.0/@members.22"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData01.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData02.class.xmi#//@classifiers.0/@members.22"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData02.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Undefined</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@statements.0/@variable">
                    <comments>// Undefined</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataUndefined.class.xmi#//@classifiers.0/@members.17"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataUndefined.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterData0E.class.xmi#//@classifiers.0/@members.22"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterData0E.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <comments>// Private Use</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@statements.0/@variable">
                    <comments>// Private Use</comments>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0/@members.17"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@parameters.0"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CharacterDataPrivateUse.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="expressions:NestedExpression">
                <expression xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Break">
                <comments>// the argument's plane is invalid, and thus is an invalid codepoint</comments>
                <comments>// upperCase remains codePoint;</comments>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@statements.1/@variable"/>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.154/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toUpperCaseCharArray">
      <typeReference xsi:type="types:Char"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="codePoint">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Converts the character (Unicode code point) argument to uppercase using case&#xA;     * mapping information from the SpecialCasing file in the Unicode&#xA;     * specification. If a character has no explicit uppercase&#xA;     * mapping, then the &lt;code>char&lt;/code> itself is returned in the&#xA;     * &lt;code>char[]&lt;/code>.&#xA;     *&#xA;     * @param   codePoint   the character (Unicode code point) to be converted.&#xA;     * @return a &lt;code>char[]&lt;/code> with the uppercased character.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="upperCase">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Assert">
        <comments>// As of Unicode 4.0, 1:M uppercasings only happen in the BMP.</comments>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.155/@parameters.0"/>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.155/@parameters.0"/>
            </child>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.155/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterDataLatin1.class.xmi#//@classifiers.0/@members.29"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.155/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterDataLatin1.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.155/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.155/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CharacterData00.class.xmi#//@classifiers.0/@members.31"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.155/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="CharacterData00.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.155/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:Field" name="SIZE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The number of bits used to represent a &lt;tt>char&lt;/tt> value in unsigned&#xA;     * binary form.&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="reverseBytes">
      <typeReference xsi:type="types:Char"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ch">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value obtained by reversing the order of the bytes in the&#xA;     * specified &lt;tt>char&lt;/tt> value.&#xA;     *&#xA;     * @return the value obtained by reversing (or, equivalently, swapping)&#xA;     *     the bytes in the specified &lt;tt>char&lt;/tt> value.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Char"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InclusiveOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AndExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.157/@parameters.0"/>
                      <children xsi:type="literals:HexIntegerLiteral" hexValue="65280"/>
                    </expression>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                  <shiftOperators xsi:type="operators:RightShift"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.157/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                  <shiftOperators xsi:type="operators:LeftShift"/>
                </expression>
              </children>
            </expression>
          </child>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>Character&lt;/code> class wraps a value of the primitive&#xA; * type &lt;code>char&lt;/code> in an object. An object of type&#xA; * &lt;code>Character&lt;/code> contains a single field whose type is&#xA; * &lt;code>char&lt;/code>.&#xA; * &lt;p>&#xA; * In addition, this class provides several methods for determining&#xA; * a character's category (lowercase letter, digit, etc.) and for converting&#xA; * characters from uppercase to lowercase and vice versa.&#xA; * &lt;p>&#xA; * Character information is based on the Unicode Standard, version 4.0.&#xA; * &lt;p>&#xA; * The methods and data of class &lt;code>Character&lt;/code> are defined by&#xA; * the information in the &lt;i>UnicodeData&lt;/i> file that is part of the&#xA; * Unicode Character Database maintained by the Unicode&#xA; * Consortium. This file specifies various properties including name&#xA; * and general category for every defined Unicode code point or&#xA; * character range.&#xA; * &lt;p>&#xA; * The file and its description are available from the Unicode Consortium at:&#xA; * &lt;ul>&#xA; * &lt;li>&lt;a href=&quot;http://www.unicode.org&quot;>http://www.unicode.org&lt;/a>&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;h4>&lt;a name=&quot;unicode&quot;>Unicode Character Representations&lt;/a>&lt;/h4>&#xA; *&#xA; * &lt;p>The &lt;code>char&lt;/code> data type (and therefore the value that a&#xA; * &lt;code>Character&lt;/code> object encapsulates) are based on the&#xA; * original Unicode specification, which defined characters as&#xA; * fixed-width 16-bit entities. The Unicode standard has since been&#xA; * changed to allow for characters whose representation requires more&#xA; * than 16 bits.  The range of legal &lt;em>code point&lt;/em>s is now&#xA; * U+0000 to U+10FFFF, known as &lt;em>Unicode scalar value&lt;/em>.&#xA; * (Refer to the &lt;a&#xA; * href=&quot;http://www.unicode.org/reports/tr27/#notation&quot;>&lt;i>&#xA; * definition&lt;/i>&lt;/a> of the U+&lt;i>n&lt;/i> notation in the Unicode&#xA; * standard.)&#xA; *&#xA; * &lt;p>The set of characters from U+0000 to U+FFFF is sometimes&#xA; * referred to as the &lt;em>Basic Multilingual Plane (BMP)&lt;/em>. &lt;a&#xA; * name=&quot;supplementary&quot;>Characters&lt;/a> whose code points are greater&#xA; * than U+FFFF are called &lt;em>supplementary character&lt;/em>s.  The Java&#xA; * 2 platform uses the UTF-16 representation in &lt;code>char&lt;/code>&#xA; * arrays and in the &lt;code>String&lt;/code> and &lt;code>StringBuffer&lt;/code>&#xA; * classes. In this representation, supplementary characters are&#xA; * represented as a pair of &lt;code>char&lt;/code> values, the first from&#xA; * the &lt;em>high-surrogates&lt;/em> range, (&amp;#92;uD800-&amp;#92;uDBFF), the&#xA; * second from the &lt;em>low-surrogates&lt;/em> range&#xA; * (&amp;#92;uDC00-&amp;#92;uDFFF).&#xA; *&#xA; * &lt;p>A &lt;code>char&lt;/code> value, therefore, represents Basic&#xA; * Multilingual Plane (BMP) code points, including the surrogate&#xA; * code points, or code units of the UTF-16 encoding. An&#xA; * &lt;code>int&lt;/code> value represents all Unicode code points,&#xA; * including supplementary code points. The lower (least significant)&#xA; * 21 bits of &lt;code>int&lt;/code> are used to represent Unicode code&#xA; * points and the upper (most significant) 11 bits must be zero.&#xA; * Unless otherwise specified, the behavior with respect to&#xA; * supplementary characters and surrogate &lt;code>char&lt;/code> values is&#xA; * as follows:&#xA; *&#xA; * &lt;ul>&#xA; * &lt;li>The methods that only accept a &lt;code>char&lt;/code> value cannot support&#xA; * supplementary characters. They treat &lt;code>char&lt;/code> values from the&#xA; * surrogate ranges as undefined characters. For example,&#xA; * &lt;code>Character.isLetter('&amp;#92;uD840')&lt;/code> returns &lt;code>false&lt;/code>, even though&#xA; * this specific value if followed by any low-surrogate value in a string&#xA; * would represent a letter.&#xA; *&#xA; * &lt;li>The methods that accept an &lt;code>int&lt;/code> value support all&#xA; * Unicode characters, including supplementary characters. For&#xA; * example, &lt;code>Character.isLetter(0x2F81A)&lt;/code> returns&#xA; * &lt;code>true&lt;/code> because the code point value represents a letter&#xA; * (a CJK ideograph).&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p>In the J2SE API documentation, &lt;em>Unicode code point&lt;/em> is&#xA; * used for character values in the range between U+0000 and U+10FFFF,&#xA; * and &lt;em>Unicode code unit&lt;/em> is used for 16-bit&#xA; * &lt;code>char&lt;/code> values that are code units of the &lt;em>UTF-16&lt;/em>&#xA; * encoding. For more information on Unicode terminology, refer to the&#xA; * &lt;a href=&quot;http://www.unicode.org/glossary/&quot;>Unicode Glossary&lt;/a>.&#xA; *&#xA; * @author  Lee Boynton&#xA; * @author  Guy Steele&#xA; * @author  Akira Tanaka&#xA; * @since   1.0&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Final"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <namespaces>java</namespaces>
      <namespaces>io</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../io/Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="Comparable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="Object.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
