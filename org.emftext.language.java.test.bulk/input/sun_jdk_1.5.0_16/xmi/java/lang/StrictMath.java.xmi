<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="StrictMath.java">
  <comments>/*&#xA; * @(#)StrictMath.java&#x9;1.26 04/06/14&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>lang</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Random.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>misc</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="StrictMath">
    <members xsi:type="members:Constructor" name="StrictMath">
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Don't let anyone instantiate this class.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="E">
      <initialValue xsi:type="literals:DecimalDoubleLiteral" decimalValue="2.718281828459045"/>
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The &lt;code>double&lt;/code> value that is closer than any other to&#xA;     * &lt;i>e&lt;/i>, the base of the natural logarithms.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="PI">
      <initialValue xsi:type="literals:DecimalDoubleLiteral" decimalValue="3.141592653589793"/>
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The &lt;code>double&lt;/code> value that is closer than any other to&#xA;     * &lt;i>pi&lt;/i>, the ratio of the circumference of a circle to its&#xA;     * diameter.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="sin">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the trigonometric sine of an angle. Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN or an infinity, then the &#xA;     * result is NaN.&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&lt;/ul>&#xA;     *&#xA;     * @param   a   an angle, in radians.&#xA;     * @return  the sine of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="cos">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the trigonometric cosine of an angle. Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN or an infinity, then the &#xA;     * result is NaN.&lt;/ul>&#xA;     *&#xA;     * @param   a   an angle, in radians.&#xA;     * @return  the cosine of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="tan">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the trigonometric tangent of an angle. Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN or an infinity, then the result &#xA;     * is NaN.&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&lt;/ul>&#xA;     *&#xA;     * @param   a   an angle, in radians.&#xA;     * @return  the tangent of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asin">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the arc sine of an angle, in the range of -&lt;i>pi&lt;/i>/2 through&#xA;     * &lt;i>pi&lt;/i>/2. Special cases: &#xA;     * &lt;ul>&lt;li>If the argument is NaN or its absolute value is greater &#xA;     * than 1, then the result is NaN.&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&lt;/ul>&#xA;     *&#xA;     * @param   a   the value whose arc sine is to be returned.&#xA;     * @return  the arc sine of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="acos">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the arc cosine of an angle, in the range of 0.0 through&#xA;     * &lt;i>pi&lt;/i>. Special case:&#xA;     * &lt;ul>&lt;li>If the argument is NaN or its absolute value is greater &#xA;     * than 1, then the result is NaN.&lt;/ul>&#xA;     *&#xA;     * @param   a   the value whose arc cosine is to be returned.&#xA;     * @return  the arc cosine of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="atan">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the arc tangent of an angle, in the range of -&lt;i>pi&lt;/i>/2&#xA;     * through &lt;i>pi&lt;/i>/2. Special cases: &#xA;     * &lt;ul>&lt;li>If the argument is NaN, then the result is NaN.&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&lt;/ul>&#xA;     *&#xA;     * @param   a   the value whose arc tangent is to be returned.&#xA;     * @return  the arc tangent of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:ClassMethod" name="toRadians">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="angdeg">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts an angle measured in degrees to an approximately&#xA;     * equivalent angle measured in radians.  The conversion from&#xA;     * degrees to radians is generally inexact.&#xA;     *&#xA;     * @param   angdeg   an angle, in degrees&#xA;     * @return  the measurement of the angle &lt;code>angdeg&lt;/code>&#xA;     *          in radians.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Strictfp"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:MultiplicativeExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="180.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <multiplicativeOperators xsi:type="operators:Division"/>
          <multiplicativeOperators xsi:type="operators:Multiplication"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toDegrees">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="angrad">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts an angle measured in radians to an approximately&#xA;     * equivalent angle measured in degrees.  The conversion from&#xA;     * radians to degrees is generally inexact; users should&#xA;     * &lt;i>not&lt;/i> expect &lt;code>cos(toRadians(90.0))&lt;/code> to exactly&#xA;     * equal &lt;code>0.0&lt;/code>.&#xA;     *&#xA;     * @param   angrad   an angle, in radians&#xA;     * @return  the measurement of the angle &lt;code>angrad&lt;/code>&#xA;     *          in degrees.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Strictfp"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:MultiplicativeExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="180.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <multiplicativeOperators xsi:type="operators:Multiplication"/>
          <multiplicativeOperators xsi:type="operators:Division"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="exp">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns Euler's number &lt;i>e&lt;/i> raised to the power of a&#xA;     * &lt;code>double&lt;/code> value. Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN, the result is NaN.&#xA;     * &lt;li>If the argument is positive infinity, then the result is &#xA;     * positive infinity.&#xA;     * &lt;li>If the argument is negative infinity, then the result is &#xA;     * positive zero.&lt;/ul>&#xA;     *&#xA;     * @param   a   the exponent to raise &lt;i>e&lt;/i> to.&#xA;     * @return  the value &lt;i>e&lt;/i>&lt;sup>&lt;code>a&lt;/code>&lt;/sup>, &#xA;     *&#x9;&#x9;where &lt;i>e&lt;/i> is the base of the natural logarithms.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="log">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the natural logarithm (base &lt;i>e&lt;/i>) of a &lt;code>double&lt;/code>&#xA;     * value. Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN or less than zero, then the result &#xA;     * is NaN.&#xA;     * &lt;li>If the argument is positive infinity, then the result is &#xA;     * positive infinity.&#xA;     * &lt;li>If the argument is positive zero or negative zero, then the &#xA;     * result is negative infinity.&lt;/ul>&#xA;     *&#xA;     * @param   a   a value&#xA;     * @return  the value ln&amp;nbsp;&lt;code>a&lt;/code>, the natural logarithm of&#xA;     *          &lt;code>a&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="log10">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the base 10 logarithm of a &lt;code>double&lt;/code> value.&#xA;     * Special cases:&#xA;     *&#xA;     * &lt;ul>&lt;li>If the argument is NaN or less than zero, then the result &#xA;     * is NaN.&#xA;     * &lt;li>If the argument is positive infinity, then the result is &#xA;     * positive infinity.&#xA;     * &lt;li>If the argument is positive zero or negative zero, then the &#xA;     * result is negative infinity.&#xA;     * &lt;li> If the argument is equal to 10&lt;sup>&lt;i>n&lt;/i>&lt;/sup> for&#xA;     * integer &lt;i>n&lt;/i>, then the result is &lt;i>n&lt;/i>.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   a   a value&#xA;     * @return  the base 10 logarithm of  &lt;code>a&lt;/code>.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="sqrt">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the correctly rounded positive square root of a&#xA;     * &lt;code>double&lt;/code> value.&#xA;     * Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN or less than zero, then the result &#xA;     * is NaN. &#xA;     * &lt;li>If the argument is positive infinity, then the result is positive &#xA;     * infinity. &#xA;     * &lt;li>If the argument is positive zero or negative zero, then the &#xA;     * result is the same as the argument.&lt;/ul>&#xA;     * Otherwise, the result is the &lt;code>double&lt;/code> value closest to &#xA;     * the true mathematical square root of the argument value.&#xA;     *&#xA;     * @param   a   a value.&#xA;     * @return  the positive square root of &lt;code>a&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="cbrt">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the cube root of a &lt;code>double&lt;/code> value.  For&#xA;     * positive finite &lt;code>x&lt;/code>, &lt;code>cbrt(-x) ==&#xA;     * -cbrt(x)&lt;/code>; that is, the cube root of a negative value is&#xA;     * the negative of the cube root of that value's magnitude.&#xA;     * Special cases: &#xA;     *&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>If the argument is NaN, then the result is NaN.&#xA;     *&#xA;     * &lt;li>If the argument is infinite, then the result is an infinity&#xA;     * with the same sign as the argument.&#xA;     *&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&#xA;     * &#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   a   a value.&#xA;     * @return  the cube root of &lt;code>a&lt;/code>.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="IEEEremainder">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f1">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f2">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Computes the remainder operation on two arguments as prescribed &#xA;     * by the IEEE 754 standard.&#xA;     * The remainder value is mathematically equal to &#xA;     * &lt;code>f1&amp;nbsp;-&amp;nbsp;f2&lt;/code>&amp;nbsp;&amp;times;&amp;nbsp;&lt;i>n&lt;/i>,&#xA;     * where &lt;i>n&lt;/i> is the mathematical integer closest to the exact &#xA;     * mathematical value of the quotient &lt;code>f1/f2&lt;/code>, and if two &#xA;     * mathematical integers are equally close to &lt;code>f1/f2&lt;/code>, &#xA;     * then &lt;i>n&lt;/i> is the integer that is even. If the remainder is &#xA;     * zero, its sign is the same as the sign of the first argument. &#xA;     * Special cases:&#xA;     * &lt;ul>&lt;li>If either argument is NaN, or the first argument is infinite, &#xA;     * or the second argument is positive zero or negative zero, then the &#xA;     * result is NaN.&#xA;     * &lt;li>If the first argument is finite and the second argument is &#xA;     * infinite, then the result is the same as the first argument.&lt;/ul>&#xA;     *&#xA;     * @param   f1   the dividend.&#xA;     * @param   f2   the divisor.&#xA;     * @return  the remainder when &lt;code>f1&lt;/code> is divided by&#xA;     *          &lt;code>f2&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="ceil">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the smallest (closest to negative infinity)&#xA;     * &lt;code>double&lt;/code> value that is greater than or equal to the&#xA;     * argument and is equal to a mathematical integer. Special cases:&#xA;     * &lt;ul>&lt;li>If the argument value is already equal to a&#xA;     * mathematical integer, then the result is the same as the&#xA;     * argument.  &lt;li>If the argument is NaN or an infinity or&#xA;     * positive zero or negative zero, then the result is the same as&#xA;     * the argument.  &lt;li>If the argument value is less than zero but&#xA;     * greater than -1.0, then the result is negative zero.&lt;/ul> Note&#xA;     * that the value of &lt;code>StrictMath.ceil(x)&lt;/code> is exactly the&#xA;     * value of &lt;code>-StrictMath.floor(-x)&lt;/code>.&#xA;     *&#xA;     * @param   a   a value.&#xA;     * @return  the smallest (closest to negative infinity) &#xA;     *          floating-point value that is greater than or equal to&#xA;     *          the argument and is equal to a mathematical integer. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="floor">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the largest (closest to positive infinity)&#xA;     * &lt;code>double&lt;/code> value that is less than or equal to the&#xA;     * argument and is equal to a mathematical integer. Special cases:&#xA;     * &lt;ul>&lt;li>If the argument value is already equal to a&#xA;     * mathematical integer, then the result is the same as the&#xA;     * argument.  &lt;li>If the argument is NaN or an infinity or&#xA;     * positive zero or negative zero, then the result is the same as&#xA;     * the argument.&lt;/ul>&#xA;     *&#xA;     * @param   a   a value.&#xA;     * @return  the largest (closest to positive infinity) &#xA;     *          floating-point value that less than or equal to the argument&#xA;     *          and is equal to a mathematical integer. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:ClassMethod" name="rint">
      <comments>// restore original sign</comments>
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>double&lt;/code> value that is closest in value&#xA;     * to the argument and is equal to a mathematical integer. If two&#xA;     * &lt;code>double&lt;/code> values that are mathematical integers are&#xA;     * equally close to the value of the argument, the result is the&#xA;     * integer value that is even. Special cases:&#xA;     * &lt;ul>&lt;li>If the argument value is already equal to a mathematical &#xA;     * integer, then the result is the same as the argument. &#xA;     * &lt;li>If the argument is NaN or an infinity or positive zero or negative &#xA;     * zero, then the result is the same as the argument.&lt;/ul>&#xA;     *&#xA;     * @param   a   a value.&#xA;     * @return  the closest floating-point value to &lt;code>a&lt;/code> that is&#xA;     *          equal to a mathematical integer.&#xA;     * @author Joseph D. Darcy&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="twoToThe52">
          <typeReference xsi:type="types:Double">
            <comments>/*&#xA;&#x9; * If the absolute value of a is not less than 2^52, it&#xA;&#x9; * is either a finite integer (the double format does not have&#xA;&#x9; * enough significand bits for a number that large to have any&#xA;&#x9; * fractional portion), an infinity, or a NaN.  In any of&#xA;&#x9; * these cases, rint of the argument is the argument.&#xA;&#x9; *&#xA;&#x9; * Otherwise, the sum (twoToThe52 + a ) will properly round&#xA;&#x9; * away any fractional portion of a since ulp(twoToThe52) ==&#xA;&#x9; * 1.0; subtracting out twoToThe52 from this sum will then be&#xA;&#x9; * exact and leave the rounded integer portion of a.&#xA;&#x9; *&#xA;&#x9; * This method does *not* need to be declared strictfp to get&#xA;&#x9; * fully reproducible results.  Whether or not a method is&#xA;&#x9; * declared strictfp can only make a difference in the&#xA;&#x9; * returned result if some operation would overflow or&#xA;&#x9; * underflow with strictfp semantics.  The operation&#xA;&#x9; * (twoToThe52 + a ) cannot overflow since large values of a&#xA;&#x9; * are screened out; the add cannot underflow since twoToThe52&#xA;&#x9; * is too large.  The subtraction ((twoToThe52 + a ) -&#xA;&#x9; * twoToThe52) will be exact as discussed above and thus&#xA;&#x9; * cannot overflow or meaningfully underflow.  Finally, the&#xA;&#x9; * last multiply in the return statement is by plus or minus&#xA;&#x9; * 1.0, which is exact too.&#xA;&#x9; */</comments>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Double"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="52"/>
                <shiftOperators xsi:type="operators:LeftShift"/>
              </expression>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sign">
          <typeReference xsi:type="types:Double">
            <comments>// 2^52</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0/@members.8"/>
              <arguments xsi:type="literals:DecimalDoubleLiteral" decimalValue="1.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
            <comments>// preserve sign info</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Math.class.xmi#//@classifiers.0/@members.32"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="Math.class.xmi#//@classifiers.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
                <comments>// E_min &lt;= ilogb(a) &lt;= 51</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </expression>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </expression>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:MultiplicativeExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          <multiplicativeOperators xsi:type="operators:Multiplication"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="atan2">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts rectangular coordinates (&lt;code>x&lt;/code>,&amp;nbsp;&lt;code>y&lt;/code>)&#xA;     * to polar (r,&amp;nbsp;&lt;i>theta&lt;/i>).&#xA;     * This method computes the phase &lt;i>theta&lt;/i> by computing an arc tangent&#xA;     * of &lt;code>y/x&lt;/code> in the range of -&lt;i>pi&lt;/i> to &lt;i>pi&lt;/i>. Special &#xA;     * cases:&#xA;     * &lt;ul>&lt;li>If either argument is NaN, then the result is NaN. &#xA;     * &lt;li>If the first argument is positive zero and the second argument &#xA;     * is positive, or the first argument is positive and finite and the &#xA;     * second argument is positive infinity, then the result is positive &#xA;     * zero. &#xA;     * &lt;li>If the first argument is negative zero and the second argument &#xA;     * is positive, or the first argument is negative and finite and the &#xA;     * second argument is positive infinity, then the result is negative zero. &#xA;     * &lt;li>If the first argument is positive zero and the second argument &#xA;     * is negative, or the first argument is positive and finite and the &#xA;     * second argument is negative infinity, then the result is the &#xA;     * &lt;code>double&lt;/code> value closest to &lt;i>pi&lt;/i>. &#xA;     * &lt;li>If the first argument is negative zero and the second argument &#xA;     * is negative, or the first argument is negative and finite and the &#xA;     * second argument is negative infinity, then the result is the &#xA;     * &lt;code>double&lt;/code> value closest to -&lt;i>pi&lt;/i>. &#xA;     * &lt;li>If the first argument is positive and the second argument is &#xA;     * positive zero or negative zero, or the first argument is positive &#xA;     * infinity and the second argument is finite, then the result is the &#xA;     * &lt;code>double&lt;/code> value closest to &lt;i>pi&lt;/i>/2. &#xA;     * &lt;li>If the first argument is negative and the second argument is &#xA;     * positive zero or negative zero, or the first argument is negative &#xA;     * infinity and the second argument is finite, then the result is the &#xA;     * &lt;code>double&lt;/code> value closest to -&lt;i>pi&lt;/i>/2. &#xA;     * &lt;li>If both arguments are positive infinity, then the result is the &#xA;     * &lt;code>double&lt;/code> value closest to &lt;i>pi&lt;/i>/4. &#xA;     * &lt;li>If the first argument is positive infinity and the second argument &#xA;     * is negative infinity, then the result is the &lt;code>double&lt;/code> &#xA;     * value closest to 3*&lt;i>pi&lt;/i>/4. &#xA;     * &lt;li>If the first argument is negative infinity and the second argument &#xA;     * is positive infinity, then the result is the &lt;code>double&lt;/code> value &#xA;     * closest to -&lt;i>pi&lt;/i>/4. &#xA;     * &lt;li>If both arguments are negative infinity, then the result is the &#xA;     * &lt;code>double&lt;/code> value closest to -3*&lt;i>pi&lt;/i>/4.&lt;/ul>&#xA;     *&#xA;     * @param   y   the ordinate coordinate&#xA;     * @param   x   the abscissa coordinate&#xA;     * @return  the &lt;i>theta&lt;/i> component of the point&#xA;     *          (&lt;i>r&lt;/i>,&amp;nbsp;&lt;i>theta&lt;/i>)&#xA;     *          in polar coordinates that corresponds to the point&#xA;     *          (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in Cartesian coordinates.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="pow">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of the first argument raised to the power of the&#xA;     * second argument. Special cases:&#xA;     *&#xA;     * &lt;ul>&lt;li>If the second argument is positive or negative zero, then the &#xA;     * result is 1.0. &#xA;     * &lt;li>If the second argument is 1.0, then the result is the same as the &#xA;     * first argument.&#xA;     * &lt;li>If the second argument is NaN, then the result is NaN. &#xA;     * &lt;li>If the first argument is NaN and the second argument is nonzero, &#xA;     * then the result is NaN. &#xA;     *&#xA;     * &lt;li>If&#xA;     * &lt;ul>&#xA;     * &lt;li>the absolute value of the first argument is greater than 1&#xA;     * and the second argument is positive infinity, or&#xA;     * &lt;li>the absolute value of the first argument is less than 1 and&#xA;     * the second argument is negative infinity,&#xA;     * &lt;/ul>&#xA;     * then the result is positive infinity. &#xA;     *&#xA;     * &lt;li>If &#xA;     * &lt;ul>&#xA;     * &lt;li>the absolute value of the first argument is greater than 1 and &#xA;     * the second argument is negative infinity, or &#xA;     * &lt;li>the absolute value of the &#xA;     * first argument is less than 1 and the second argument is positive &#xA;     * infinity,&#xA;     * &lt;/ul>&#xA;     * then the result is positive zero. &#xA;     *&#xA;     * &lt;li>If the absolute value of the first argument equals 1 and the &#xA;     * second argument is infinite, then the result is NaN. &#xA;     *&#xA;     * &lt;li>If &#xA;     * &lt;ul>&#xA;     * &lt;li>the first argument is positive zero and the second argument&#xA;     * is greater than zero, or&#xA;     * &lt;li>the first argument is positive infinity and the second&#xA;     * argument is less than zero,&#xA;     * &lt;/ul>&#xA;     * then the result is positive zero. &#xA;     *&#xA;     * &lt;li>If &#xA;     * &lt;ul>&#xA;     * &lt;li>the first argument is positive zero and the second argument&#xA;     * is less than zero, or&#xA;     * &lt;li>the first argument is positive infinity and the second&#xA;     * argument is greater than zero,&#xA;     * &lt;/ul>&#xA;     * then the result is positive infinity.&#xA;     *&#xA;     * &lt;li>If &#xA;     * &lt;ul>&#xA;     * &lt;li>the first argument is negative zero and the second argument&#xA;     * is greater than zero but not a finite odd integer, or&#xA;     * &lt;li>the first argument is negative infinity and the second&#xA;     * argument is less than zero but not a finite odd integer,&#xA;     * &lt;/ul>&#xA;     * then the result is positive zero. &#xA;     *&#xA;     * &lt;li>If &#xA;     * &lt;ul>&#xA;     * &lt;li>the first argument is negative zero and the second argument&#xA;     * is a positive finite odd integer, or&#xA;     * &lt;li>the first argument is negative infinity and the second&#xA;     * argument is a negative finite odd integer,&#xA;     * &lt;/ul>&#xA;     * then the result is negative zero. &#xA;     *&#xA;     * &lt;li>If&#xA;     * &lt;ul>&#xA;     * &lt;li>the first argument is negative zero and the second argument&#xA;     * is less than zero but not a finite odd integer, or&#xA;     * &lt;li>the first argument is negative infinity and the second&#xA;     * argument is greater than zero but not a finite odd integer,&#xA;     * &lt;/ul>&#xA;     * then the result is positive infinity. &#xA;     *&#xA;     * &lt;li>If &#xA;     * &lt;ul>&#xA;     * &lt;li>the first argument is negative zero and the second argument&#xA;     * is a negative finite odd integer, or&#xA;     * &lt;li>the first argument is negative infinity and the second&#xA;     * argument is a positive finite odd integer,&#xA;     * &lt;/ul>&#xA;     * then the result is negative infinity. &#xA;     *&#xA;     * &lt;li>If the first argument is finite and less than zero&#xA;     * &lt;ul>&#xA;     * &lt;li> if the second argument is a finite even integer, the&#xA;     * result is equal to the result of raising the absolute value of&#xA;     * the first argument to the power of the second argument&#xA;     *&#xA;     * &lt;li>if the second argument is a finite odd integer, the result&#xA;     * is equal to the negative of the result of raising the absolute&#xA;     * value of the first argument to the power of the second&#xA;     * argument&#xA;     *&#xA;     * &lt;li>if the second argument is finite and not an integer, then&#xA;     * the result is NaN.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;li>If both arguments are integers, then the result is exactly equal &#xA;     * to the mathematical result of raising the first argument to the power &#xA;     * of the second argument if that result can in fact be represented &#xA;     * exactly as a &lt;code>double&lt;/code> value.&lt;/ul>&#xA;     * &#xA;     * &lt;p>(In the foregoing descriptions, a floating-point value is&#xA;     * considered to be an integer if and only if it is finite and a&#xA;     * fixed point of the method {@link #ceil &lt;tt>ceil&lt;/tt>} or,&#xA;     * equivalently, a fixed point of the method {@link #floor&#xA;     * &lt;tt>floor&lt;/tt>}. A value is a fixed point of a one-argument&#xA;     * method if and only if the result of applying the method to the&#xA;     * value is equal to the value.)&#xA;     *&#xA;     * @param   a   base.&#xA;     * @param   b   the exponent.&#xA;     * @return  the value &lt;code>a&lt;sup>b&lt;/sup>&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:ClassMethod" name="round">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the closest &lt;code>int&lt;/code> to the argument. The &#xA;     * result is rounded to an integer by adding 1/2, taking the &#xA;     * floor of the result, and casting the result to type &lt;code>int&lt;/code>. &#xA;     * In other words, the result is equal to the value of the expression:&#xA;     * &lt;p>&lt;pre>(int)Math.floor(a + 0.5f)&lt;/pre>&#xA;     * &lt;p>&#xA;     * Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN, the result is 0.&#xA;     * &lt;li>If the argument is negative infinity or any value less than or &#xA;     * equal to the value of &lt;code>Integer.MIN_VALUE&lt;/code>, the result is &#xA;     * equal to the value of &lt;code>Integer.MIN_VALUE&lt;/code>. &#xA;     * &lt;li>If the argument is positive infinity or any value greater than or &#xA;     * equal to the value of &lt;code>Integer.MAX_VALUE&lt;/code>, the result is &#xA;     * equal to the value of &lt;code>Integer.MAX_VALUE&lt;/code>.&lt;/ul> &#xA;     *&#xA;     * @param   a   a floating-point value to be rounded to an integer.&#xA;     * @return  the value of the argument rounded to the nearest&#xA;     *          &lt;code>int&lt;/code> value.&#xA;     * @see     java.lang.Integer#MAX_VALUE&#xA;     * @see     java.lang.Integer#MIN_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Int"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
              <children xsi:type="literals:DecimalFloatLiteral" decimalValue="0.5"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="round">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the closest &lt;code>long&lt;/code> to the argument. The result &#xA;     * is rounded to an integer by adding 1/2, taking the floor of the &#xA;     * result, and casting the result to type &lt;code>long&lt;/code>. In other &#xA;     * words, the result is equal to the value of the expression:&#xA;     * &lt;p>&lt;pre>(long)Math.floor(a + 0.5d)&lt;/pre>&#xA;     * &lt;p>&#xA;     * Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is NaN, the result is 0.&#xA;     * &lt;li>If the argument is negative infinity or any value less than or &#xA;     * equal to the value of &lt;code>Long.MIN_VALUE&lt;/code>, the result is &#xA;     * equal to the value of &lt;code>Long.MIN_VALUE&lt;/code>. &#xA;     * &lt;li>If the argument is positive infinity or any value greater than or &#xA;     * equal to the value of &lt;code>Long.MAX_VALUE&lt;/code>, the result is &#xA;     * equal to the value of &lt;code>Long.MAX_VALUE&lt;/code>.&lt;/ul> &#xA;     *&#xA;     * @param   a  a floating-point value to be rounded to a&#xA;     *&#x9;&#x9;&lt;code>long&lt;/code>. &#xA;     * @return  the value of the argument rounded to the nearest&#xA;     *          &lt;code>long&lt;/code> value.&#xA;     * @see     java.lang.Long#MAX_VALUE&#xA;     * @see     java.lang.Long#MIN_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Long"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
              <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="0.5"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="randomNumberGenerator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Random.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="initRNG">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../util/Random.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="random">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>double&lt;/code> value with a positive sign, greater &#xA;     * than or equal to &lt;code>0.0&lt;/code> and less than &lt;code>1.0&lt;/code>. &#xA;     * Returned values are chosen pseudorandomly with (approximately) &#xA;     * uniform distribution from that range. &#xA;     * &#xA;     * &lt;p>When this method is first called, it creates a single new&#xA;     * pseudorandom-number generator, exactly as if by the expression&#xA;     * &lt;blockquote>&lt;pre>new java.util.Random&lt;/pre>&lt;/blockquote> This&#xA;     * new pseudorandom-number generator is used thereafter for all&#xA;     * calls to this method and is used nowhere else.&#xA;     * &#xA;     * &lt;p>This method is properly synchronized to allow correct use by&#xA;     * more than one thread. However, if many threads need to generate&#xA;     * pseudorandom numbers at a great rate, it may reduce contention&#xA;     * for each thread to have its own pseudorandom number generator.&#xA;     *  &#xA;     * @return  a pseudorandom &lt;code>double&lt;/code> greater than or equal &#xA;     * to &lt;code>0.0&lt;/code> and less than &lt;code>1.0&lt;/code>.&#xA;     * @see     java.util.Random#nextDouble()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.25"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../util/Random.class.xmi#//@classifiers.0/@members.21"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="abs">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the absolute value of an &lt;code>int&lt;/code> value..&#xA;     * If the argument is not negative, the argument is returned.&#xA;     * If the argument is negative, the negation of the argument is returned. &#xA;     * &#xA;     * &lt;p>Note that if the argument is equal to the value of&#xA;     * &lt;code>Integer.MIN_VALUE&lt;/code>, the most negative representable&#xA;     * &lt;code>int&lt;/code> value, the result is that same value, which is&#xA;     * negative.&#xA;     *&#xA;     * @param   a   the  argument whose absolute value is to be determined.&#xA;     * @return  the absolute value of the argument.&#xA;     * @see     java.lang.Integer#MIN_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </child>
          <expressionIf xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
          </expressionIf>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="abs">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the absolute value of a &lt;code>long&lt;/code> value.&#xA;     * If the argument is not negative, the argument is returned.&#xA;     * If the argument is negative, the negation of the argument is returned. &#xA;     * &#xA;     * &lt;p>Note that if the argument is equal to the value of&#xA;     * &lt;code>Long.MIN_VALUE&lt;/code>, the most negative representable&#xA;     * &lt;code>long&lt;/code> value, the result is that same value, which&#xA;     * is negative.&#xA;     *&#xA;     * @param   a   the  argument whose absolute value is to be determined.&#xA;     * @return  the absolute value of the argument.&#xA;     * @see     java.lang.Long#MIN_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </child>
          <expressionIf xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
          </expressionIf>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="abs">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the absolute value of a &lt;code>float&lt;/code> value. &#xA;     * If the argument is not negative, the argument is returned.&#xA;     * If the argument is negative, the negation of the argument is returned. &#xA;     * Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is positive zero or negative zero, the &#xA;     * result is positive zero. &#xA;     * &lt;li>If the argument is infinite, the result is positive infinity. &#xA;     * &lt;li>If the argument is NaN, the result is NaN.&lt;/ul>&#xA;     * In other words, the result is the same as the value of the expression: &#xA;     * &lt;p>&lt;pre>Float.intBitsToFloat(0x7fffffff &amp; Float.floatToIntBits(a))&lt;/pre>&#xA;     *&#xA;     * @param   a   the argument whose absolute value is to be determined&#xA;     * @return  the absolute value of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
              <children xsi:type="literals:DecimalFloatLiteral"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="expressions:AdditiveExpression">
            <children xsi:type="literals:DecimalFloatLiteral"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </expressionIf>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="abs">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the absolute value of a &lt;code>double&lt;/code> value.&#xA;     * If the argument is not negative, the argument is returned.&#xA;     * If the argument is negative, the negation of the argument is returned. &#xA;     * Special cases:&#xA;     * &lt;ul>&lt;li>If the argument is positive zero or negative zero, the result &#xA;     * is positive zero. &#xA;     * &lt;li>If the argument is infinite, the result is positive infinity. &#xA;     * &lt;li>If the argument is NaN, the result is NaN.&lt;/ul>&#xA;     * In other words, the result is the same as the value of the expression: &#xA;     * &lt;p>&lt;code>Double.longBitsToDouble((Double.doubleToLongBits(a)&amp;lt;&amp;lt;1)&amp;gt;&amp;gt;&amp;gt;1)&lt;/code>&#xA;     *&#xA;     * @param   a   the argument whose absolute value is to be determined&#xA;     * @return  the absolute value of the argument.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
              <children xsi:type="literals:DecimalDoubleLiteral"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="expressions:AdditiveExpression">
            <children xsi:type="literals:DecimalDoubleLiteral"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </expressionIf>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="max">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the greater of two &lt;code>int&lt;/code> values. That is, the &#xA;     * result is the argument closer to the value of &#xA;     * &lt;code>Integer.MAX_VALUE&lt;/code>. If the arguments have the same value, &#xA;     * the result is that same value.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the larger of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     * @see     java.lang.Long#MAX_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="max">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the greater of two &lt;code>long&lt;/code> values. That is, the &#xA;     * result is the argument closer to the value of &#xA;     * &lt;code>Long.MAX_VALUE&lt;/code>. If the arguments have the same value, &#xA;     * the result is that same value. &#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the larger of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     * @see     java.lang.Long#MAX_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="negativeZeroFloatBits">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Float.class.xmi#//@classifiers.0/@members.30"/>
          <arguments xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalFloatLiteral"/>
          </arguments>
        </next>
        <target xsi:type="classifiers:Class" href="Float.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="negativeZeroDoubleBits">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Double.class.xmi#//@classifiers.0/@members.29"/>
          <arguments xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalDoubleLiteral"/>
          </arguments>
        </next>
        <target xsi:type="classifiers:Class" href="Double.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="max">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the greater of two &lt;code>float&lt;/code> values.  That is,&#xA;     * the result is the argument closer to positive infinity. If the&#xA;     * arguments have the same value, the result is that same&#xA;     * value. If either value is NaN, then the result is NaN.  Unlike&#xA;     * the numerical comparison operators, this method considers&#xA;     * negative zero to be strictly smaller than positive zero. If one&#xA;     * argument is positive zero and the other negative zero, the&#xA;     * result is positive zero.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the larger of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// a is NaN</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
              <children xsi:type="literals:DecimalFloatLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
              <children xsi:type="literals:DecimalFloatLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Float.class.xmi#//@classifiers.0/@members.30"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="Float.class.xmi#//@classifiers.0"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="max">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the greater of two &lt;code>double&lt;/code> values.  That&#xA;     * is, the result is the argument closer to positive infinity. If&#xA;     * the arguments have the same value, the result is that same&#xA;     * value. If either value is NaN, then the result is NaN.  Unlike&#xA;     * the numerical comparison operators, this method considers&#xA;     * negative zero to be strictly smaller than positive zero. If one&#xA;     * argument is positive zero and the other negative zero, the&#xA;     * result is positive zero.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the larger of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// a is NaN</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
              <children xsi:type="literals:DecimalDoubleLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
              <children xsi:type="literals:DecimalDoubleLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Double.class.xmi#//@classifiers.0/@members.29"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="Double.class.xmi#//@classifiers.0"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="min">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the smaller of two &lt;code>int&lt;/code> values. That is,&#xA;     * the result the argument closer to the value of&#xA;     * &lt;code>Integer.MIN_VALUE&lt;/code>.  If the arguments have the same&#xA;     * value, the result is that same value.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the smaller of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     * @see     java.lang.Long#MIN_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.1"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="min">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the smaller of two &lt;code>long&lt;/code> values. That is,&#xA;     * the result is the argument closer to the value of&#xA;     * &lt;code>Long.MIN_VALUE&lt;/code>. If the arguments have the same&#xA;     * value, the result is that same value.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the smaller of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     * @see     java.lang.Long#MIN_VALUE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.1"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="min">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the smaller of two &lt;code>float&lt;/code> values.  That is,&#xA;     * the result is the value closer to negative infinity. If the&#xA;     * arguments have the same value, the result is that same&#xA;     * value. If either value is NaN, then the result is NaN.  Unlike&#xA;     * the numerical comparison operators, this method considers&#xA;     * negative zero to be strictly smaller than positive zero.  If&#xA;     * one argument is positive zero and the other is negative zero,&#xA;     * the result is negative zero.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the smaller of &lt;code>a&lt;/code> and &lt;code>b.&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// a is NaN</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
              <children xsi:type="literals:DecimalFloatLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
              <children xsi:type="literals:DecimalFloatLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Float.class.xmi#//@classifiers.0/@members.30"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="Float.class.xmi#//@classifiers.0"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="min">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the smaller of two &lt;code>double&lt;/code> values.  That&#xA;     * is, the result is the value closer to negative infinity. If the&#xA;     * arguments have the same value, the result is that same&#xA;     * value. If either value is NaN, then the result is NaN.  Unlike&#xA;     * the numerical comparison operators, this method considers&#xA;     * negative zero to be strictly smaller than positive zero. If one&#xA;     * argument is positive zero and the other is negative zero, the&#xA;     * result is negative zero.&#xA;     *&#xA;     * @param   a   an argument.&#xA;     * @param   b   another argument.&#xA;     * @return  the smaller of &lt;code>a&lt;/code> and &lt;code>b&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// a is NaN</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
              <children xsi:type="literals:DecimalDoubleLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
              <children xsi:type="literals:DecimalDoubleLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Double.class.xmi#//@classifiers.0/@members.29"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="Double.class.xmi#//@classifiers.0"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="ulp">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the size of an ulp of the argument.  An ulp of a&#xA;     * &lt;code>double&lt;/code> value is the positive distance between this&#xA;     * floating-point value and the &lt;code>double&lt;/code> value next&#xA;     * larger in magnitude.  Note that for non-NaN &lt;i>x&lt;/i>,&#xA;     * &lt;code>ulp(-&lt;i>x&lt;/i>) == ulp(&lt;i>x&lt;/i>)&lt;/code>.&#xA;     * &#xA;     * &lt;p>Special Cases:&#xA;     * &lt;ul>&#xA;     * &lt;li> If the argument is NaN, then the result is NaN.&#xA;     * &lt;li> If the argument is positive or negative infinity, then the&#xA;     * result is positive infinity.&#xA;     * &lt;li> If the argument is positive or negative zero, then the result is&#xA;     * &lt;code>Double.MIN_VALUE&lt;/code>.&#xA;     * &lt;li> If the argument is &amp;plusmn;&lt;code>Double.MAX_VALUE&lt;/code>, then&#xA;     * the result is equal to 2&lt;sup>971&lt;/sup>.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param d the floating-point value whose ulp is to be returned&#xA;     * @return the size of an ulp of the argument&#xA;     * @author Joseph D. Darcy&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0/@members.30"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
            </next>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="ulp">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the size of an ulp of the argument.  An ulp of a&#xA;     * &lt;code>float&lt;/code> value is the positive distance between this&#xA;     * floating-point value and the &lt;code>float&lt;/code> value next&#xA;     * larger in magnitude.  Note that for non-NaN &lt;i>x&lt;/i>,&#xA;     * &lt;code>ulp(-&lt;i>x&lt;/i>) == ulp(&lt;i>x&lt;/i>)&lt;/code>.&#xA;     * &#xA;     * &lt;p>Special Cases:&#xA;     * &lt;ul>&#xA;     * &lt;li> If the argument is NaN, then the result is NaN.&#xA;     * &lt;li> If the argument is positive or negative infinity, then the&#xA;     * result is positive infinity.&#xA;     * &lt;li> If the argument is positive or negative zero, then the result is&#xA;     * &lt;code>Float.MIN_VALUE&lt;/code>.&#xA;     * &lt;li> If the argument is &amp;plusmn;&lt;code>Float.MAX_VALUE&lt;/code>, then&#xA;     * the result is equal to 2&lt;sup>104&lt;/sup>.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param f the floating-point value whose ulp is to be returned&#xA;     * @return the size of an ulp of the argument&#xA;     * @author Joseph D. Darcy&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0/@members.31"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
            </next>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="signum">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the signum function of the argument; zero if the argument&#xA;     * is zero, 1.0 if the argument is greater than zero, -1.0 if the&#xA;     * argument is less than zero.&#xA;     *&#xA;     * &lt;p>Special Cases:&#xA;     * &lt;ul>&#xA;     * &lt;li> If the argument is NaN, then the result is NaN.&#xA;     * &lt;li> If the argument is positive zero or negative zero, then the&#xA;     *      result is the same as the argument.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param d the floating-point value whose signum is to be returned&#xA;     * @return the signum function of the argument&#xA;     * @author Joseph D. Darcy&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
            </next>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="signum">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the signum function of the argument; zero if the argument&#xA;     * is zero, 1.0f if the argument is greater than zero, -1.0f if the&#xA;     * argument is less than zero.&#xA;     *&#xA;     * &lt;p>Special Cases:&#xA;     * &lt;ul>&#xA;     * &lt;li> If the argument is NaN, then the result is NaN.&#xA;     * &lt;li> If the argument is positive zero or negative zero, then the&#xA;     *      result is the same as the argument.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param f the floating-point value whose signum is to be returned&#xA;     * @return the signum function of the argument&#xA;     * @author Joseph D. Darcy&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../sun/misc/FpUtils.class.xmi#//@classifiers.0"/>
            </next>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="sinh">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the hyperbolic sine of a &lt;code>double&lt;/code> value.&#xA;     * The hyperbolic sine of &lt;i>x&lt;/i> is defined to be&#xA;     * (&lt;i>e&lt;sup>x&lt;/sup>&amp;nbsp;-&amp;nbsp;e&lt;sup>-x&lt;/sup>&lt;/i>)/2&#xA;     * where &lt;i>e&lt;/i> is {@linkplain Math#E Euler's number}.&#xA;     *&#xA;     * &lt;p>Special cases:&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>If the argument is NaN, then the result is NaN.&#xA;     *&#xA;     * &lt;li>If the argument is infinite, then the result is an infinity&#xA;     * with the same sign as the argument.&#xA;     *&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   x The number whose hyperbolic sine is to be returned.&#xA;     * @return  The hyperbolic sine of &lt;code>x&lt;/code>.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="cosh">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the hyperbolic cosine of a &lt;code>double&lt;/code> value.&#xA;     * The hyperbolic cosine of &lt;i>x&lt;/i> is defined to be&#xA;     * (&lt;i>e&lt;sup>x&lt;/sup>&amp;nbsp;+&amp;nbsp;e&lt;sup>-x&lt;/sup>&lt;/i>)/2&#xA;     * where &lt;i>e&lt;/i> is {@linkplain Math#E Euler's number}.&#xA;     *&#xA;     * &lt;p>Special cases:&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>If the argument is NaN, then the result is NaN.&#xA;     *&#xA;     * &lt;li>If the argument is infinite, then the result is positive&#xA;     * infinity.&#xA;     *&#xA;     * &lt;li>If the argument is zero, then the result is &lt;code>1.0&lt;/code>.&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   x The number whose hyperbolic cosine is to be returned.&#xA;     * @return  The hyperbolic cosine of &lt;code>x&lt;/code>.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="tanh">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the hyperbolic tangent of a &lt;code>double&lt;/code> value.&#xA;     * The hyperbolic tangent of &lt;i>x&lt;/i> is defined to be&#xA;     * (&lt;i>e&lt;sup>x&lt;/sup>&amp;nbsp;-&amp;nbsp;e&lt;sup>-x&lt;/sup>&lt;/i>)/(&lt;i>e&lt;sup>x&lt;/sup>&amp;nbsp;+&amp;nbsp;e&lt;sup>-x&lt;/sup>&lt;/i>),&#xA;     * in other words, {@linkplain Math#sinh&#xA;     * sinh(&lt;i>x&lt;/i>)}/{@linkplain Math#cosh cosh(&lt;i>x&lt;/i>)}.  Note&#xA;     * that the absolute value of the exact tanh is always less than&#xA;     * 1.&#xA;     *&#xA;     * &lt;p>Special cases:&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>If the argument is NaN, then the result is NaN.&#xA;     *&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&#xA;     *&#xA;     * &lt;li>If the argument is positive infinity, then the result is&#xA;     * &lt;code>+1.0&lt;/code>.&#xA;     *&#xA;     * &lt;li>If the argument is negative infinity, then the result is&#xA;     * &lt;code>-1.0&lt;/code>.&#xA;     *  &#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   x The number whose hyperbolic tangent is to be returned.&#xA;     * @return  The hyperbolic tangent of &lt;code>x&lt;/code>.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="hypot">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns sqrt(&lt;i>x&lt;/i>&lt;sup>2&lt;/sup>&amp;nbsp;+&lt;i>y&lt;/i>&lt;sup>2&lt;/sup>)&#xA;     * without intermediate overflow or underflow.&#xA;     *&#xA;     * &lt;p>Special cases:&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li> If either argument is infinite, then the result&#xA;     * is positive infinity.&#xA;     *&#xA;     * &lt;li> If either argument is NaN and neither argument is infinite,&#xA;     * then the result is NaN.&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param x a value&#xA;     * @param y a value&#xA;     * @return sqrt(&lt;i>x&lt;/i>&lt;sup>2&lt;/sup>&amp;nbsp;+&lt;i>y&lt;/i>&lt;sup>2&lt;/sup>)&#xA;     * without intermediate overflow or underflow&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="expm1">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;i>e&lt;/i>&lt;sup>x&lt;/sup>&amp;nbsp;-1.  Note that for values of&#xA;     * &lt;i>x&lt;/i> near 0, the exact sum of&#xA;     * &lt;code>expm1(x)&lt;/code>&amp;nbsp;+&amp;nbsp;1 is much closer to the true&#xA;     * result of &lt;i>e&lt;/i>&lt;sup>x&lt;/sup> than &lt;code>exp(x)&lt;/code>.&#xA;     *&#xA;     * &lt;p>Special cases:&#xA;     * &lt;ul>&#xA;     * &lt;li>If the argument is NaN, the result is NaN.&#xA;     *&#xA;     * &lt;li>If the argument is positive infinity, then the result is&#xA;     * positive infinity.&#xA;     *&#xA;     * &lt;li>If the argument is negative infinity, then the result is&#xA;     * -1.0.&#xA;     *&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   x   the exponent to raise &lt;i>e&lt;/i> to in the computation of&#xA;     *              &lt;i>e&lt;/i>&lt;sup>&lt;code>x&lt;/code>&lt;/sup>&amp;nbsp;-1.&#xA;     * @return  the value &lt;i>e&lt;/i>&lt;sup>&lt;code>x&lt;/code>&lt;/sup>&amp;nbsp;-&amp;nbsp;1.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="log1p">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the natural logarithm of the sum of the argument and 1.&#xA;     * Note that for small values &lt;code>x&lt;/code>, the result of&#xA;     * &lt;code>log1p(x)&lt;/code> is much closer to the true result of ln(1&#xA;     * + &lt;code>x&lt;/code>) than the floating-point evaluation of&#xA;     * &lt;code>log(1.0+x)&lt;/code>.&#xA;     *&#xA;     * &lt;p>Special cases:&#xA;     *&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>If the argument is NaN or less than -1, then the result is&#xA;     * NaN.&#xA;     *&#xA;     * &lt;li>If the argument is positive infinity, then the result is&#xA;     * positive infinity.&#xA;     *&#xA;     * &lt;li>If the argument is negative one, then the result is&#xA;     * negative infinity.&#xA;     *&#xA;     * &lt;li>If the argument is zero, then the result is a zero with the&#xA;     * same sign as the argument.&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param   x   a value&#xA;     * @return the value ln(&lt;code>x&lt;/code>&amp;nbsp;+&amp;nbsp;1), the natural&#xA;     * log of &lt;code>x&lt;/code>&amp;nbsp;+&amp;nbsp;1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The class &lt;code>StrictMath&lt;/code> contains methods for performing basic &#xA; * numeric operations such as the elementary exponential, logarithm, &#xA; * square root, and trigonometric functions. &#xA; * &#xA; * &lt;p>To help ensure portability of Java programs, the definitions of&#xA; * some of the numeric functions in this package require that they&#xA; * produce the same results as certain published algorithms. These&#xA; * algorithms are available from the well-known network library&#xA; * &lt;code>netlib&lt;/code> as the package &quot;Freely Distributable Math&#xA; * Library,&quot; &lt;a&#xA; * href=&quot;ftp://ftp.netlib.org/fdlibm.tar&quot;>&lt;code>fdlibm&lt;/code>&lt;/a>. These&#xA; * algorithms, which are written in the C programming language, are&#xA; * then to be understood as executed with all floating-point&#xA; * operations following the rules of Java floating-point arithmetic.&#xA; * &#xA; * &lt;p>The Java math library is defined with respect to&#xA; * &lt;code>fdlibm&lt;/code> version 5.3. Where &lt;code>fdlibm&lt;/code> provides&#xA; * more than one definition for a function (such as&#xA; * &lt;code>acos&lt;/code>), use the &quot;IEEE 754 core function&quot; version&#xA; * (residing in a file whose name begins with the letter&#xA; * &lt;code>e&lt;/code>).  The methods which require &lt;code>fdlibm&lt;/code>&#xA; * semantics are &lt;code>sin&lt;/code>, &lt;code>cos&lt;/code>, &lt;code>tan&lt;/code>,&#xA; * &lt;code>asin&lt;/code>, &lt;code>acos&lt;/code>, &lt;code>atan&lt;/code>,&#xA; * &lt;code>exp&lt;/code>, &lt;code>log&lt;/code>, &lt;code>log10&lt;/code>,&#xA; * &lt;code>cbrt&lt;/code>, &lt;code>atan2&lt;/code>, &lt;code>pow&lt;/code>,&#xA; * &lt;code>sinh&lt;/code>, &lt;code>cosh&lt;/code>, &lt;code>tanh&lt;/code>,&#xA; * &lt;code>hypot&lt;/code>, &lt;code>expm1&lt;/code>, and &lt;code>log1p&lt;/code>.&#xA; *&#xA; * @author  unascribed&#xA; * @author  Joseph D. Darcy&#xA; * @version 1.26, 06/14/04&#xA; * @since   1.3&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Final"/>
  </classifiers>
</containers:CompilationUnit>
