<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="MemoryPoolMXBean.java">
  <comments>/*&#xA; * @(#)MemoryPoolMXBean.java&#x9;1.21 06/03/08&#xA; *&#xA; * Copyright 2006 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>lang</namespaces>
  <namespaces>management</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="MemoryPoolMXBean">
    <members xsi:type="members:InterfaceMethod" name="getName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the name representing this memory pool.&#xA;     *&#xA;     * @return the name of this memory pool.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getType">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Enumeration" href="MemoryType.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the type of this memory pool.&#xA;     *&#xA;     * &lt;p>&#xA;     * &lt;b>MBeanServer access&lt;/b>:&lt;br>&#xA;     * The mapped type of &lt;tt>MemoryType&lt;/tt> is &lt;tt>String&lt;/tt>&#xA;     * and the value is the name of the &lt;tt>MemoryType&lt;/tt>.&#xA;     *&#xA;     * @return the type of this memory pool.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getUsage">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="MemoryUsage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an estimate of the memory usage of this memory pool.&#xA;     * This method returns &lt;tt>null&lt;/tt>&#xA;     * if this memory pool is not valid (i.e. no longer exists).&#xA;     *&#xA;     * &lt;p>&#xA;     * This method requests the Java virtual machine to make&#xA;     * a best-effort estimate of the current memory usage of this&#xA;     * memory pool. For some memory pools, this method may be an&#xA;     * expensive operation that requires some computation to determine&#xA;     * the estimate.  An implementation should document when&#xA;     * this is the case.&#xA;     *&#xA;     * &lt;p>This method is designed for use in monitoring system&#xA;     * memory usage and detecting low memory condition.&#xA;     *&#xA;     * &lt;p>&#xA;     * &lt;b>MBeanServer access&lt;/b>:&lt;br>&#xA;     * The mapped type of &lt;tt>MemoryUsage&lt;/tt> is&#xA;     * &lt;tt>CompositeData&lt;/tt> with attributes as specified in&#xA;     * {@link MemoryUsage#from MemoryUsage}.&#xA;     *&#xA;     * @return a {@link MemoryUsage} object; or &lt;tt>null&lt;/tt> if &#xA;     * this pool not valid.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPeakUsage">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="MemoryUsage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the peak memory usage of this memory pool since the&#xA;     * Java virtual machine was started or since the peak was reset.&#xA;     * This method returns &lt;tt>null&lt;/tt>&#xA;     * if this memory pool is not valid (i.e. no longer exists).&#xA;     *&#xA;     * &lt;p>&#xA;     * &lt;b>MBeanServer access&lt;/b>:&lt;br>&#xA;     * The mapped type of &lt;tt>MemoryUsage&lt;/tt> is&#xA;     * &lt;tt>CompositeData&lt;/tt> with attributes as specified in&#xA;     * {@link MemoryUsage#from MemoryUsage}.&#xA;     *&#xA;     * @return a {@link MemoryUsage} object representing the peak&#xA;     * memory usage; or &lt;tt>null&lt;/tt> if this pool is not valid.&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="resetPeakUsage">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Resets the peak memory usage statistic of this memory pool&#xA;     * to the current memory usage.&#xA;     *&#xA;     * @throws java.lang.SecurityException if a security manager&#xA;     *         exists and the caller does not have&#xA;     *         ManagementPermission(&quot;control&quot;).&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isValid">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if this memory pool is valid in the Java virtual&#xA;     * machine.  A memory pool becomes invalid once the Java virtual&#xA;     * machine removes it from the memory system.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if the memory pool is valid in the running &#xA;     *              Java virtual machine;&#xA;     *         &lt;tt>false&lt;/tt> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMemoryManagerNames">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the name of memory managers that manages this memory pool.&#xA;     * Each memory pool will be managed by at least one memory manager.&#xA;     *&#xA;     * @return an array of &lt;tt>String&lt;/tt> objects, each is the name of&#xA;     * a memory manager managing this memory pool.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getUsageThreshold">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the usage threshold value of this memory pool in bytes.&#xA;     * Each memory pool has a platform-dependent default threshold value.&#xA;     * The current usage threshold can be changed via the&#xA;     * {@link #setUsageThreshold setUsageThreshold} method.&#xA;     *&#xA;     * @return the usage threshold value of this memory pool in bytes.&#xA;     *&#xA;     * @throws UnsupportedOperationException if this memory pool&#xA;     *         does not support a usage threshold.&#xA;     *&#xA;     * @see #isUsageThresholdSupported&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setUsageThreshold">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="threshold">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the threshold of this memory pool to the given &lt;tt>threshold&lt;/tt>&#xA;     * value if this memory pool supports the usage threshold. &#xA;     * The usage threshold crossing checking is enabled in this memory pool &#xA;     * if the threshold is set to a positive value.&#xA;     * The usage threshold crossing checking is disabled&#xA;     * if it is set to zero. &#xA;     *&#xA;     * @param threshold the new threshold value in bytes. Must be non-negative.&#xA;     *&#xA;     * @throws IllegalArgumentException if &lt;tt>threshold&lt;/tt> is negative&#xA;     *         or greater than the maximum amount of memory for&#xA;     *         this memory pool if defined.&#xA;     *&#xA;     * @throws UnsupportedOperationException if this memory pool&#xA;     *         does not support a usage threshold.&#xA;     *&#xA;     * @throws java.lang.SecurityException if a security manager&#xA;     *         exists and the caller does not have&#xA;     *         ManagementPermission(&quot;control&quot;).&#xA;     *&#xA;     * @see #isUsageThresholdSupported&#xA;     * @see &lt;a href=&quot;#UsageThreshold&quot;>Usage threshold&lt;/a>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isUsageThresholdExceeded">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if the memory usage of this memory pool&#xA;     * reaches or exceeds its usage threshold value.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if the memory usage of&#xA;     * this memory pool reaches or exceeds the threshold value;&#xA;     * &lt;tt>false&lt;/tt> otherwise.&#xA;     *&#xA;     * @throws UnsupportedOperationException if this memory pool&#xA;     *         does not support a usage threshold.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getUsageThresholdCount">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the number of times that the memory usage has crossed&#xA;     * the usage threshold.&#xA;     *&#xA;     * @return the number of times that the memory usage &#xA;     * has crossed its usage threshold value.&#xA;     *&#xA;     * @throws UnsupportedOperationException if this memory pool&#xA;     * does not support a usage threshold.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isUsageThresholdSupported">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if this memory pool supports usage threshold.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if this memory pool supports usage threshold; &#xA;     * &lt;tt>false&lt;/tt> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCollectionUsageThreshold">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the collection usage threshold value of this memory pool &#xA;     * in bytes.  The default value is zero. The collection usage &#xA;     * threshold can be changed via the &#xA;     * {@link #setCollectionUsageThreshold setCollectionUsageThreshold} method.&#xA;     * &#xA;     * @return the collection usage threshold of this memory pool in bytes.&#xA;     *&#xA;     * @throws UnsupportedOperationException if this memory pool&#xA;     *         does not support a collection usage threshold.&#xA;     *&#xA;     * @see #isCollectionUsageThresholdSupported&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setCollectionUsageThreshold">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="threhsold">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the collection usage threshold of this memory pool to &#xA;     * the given &lt;tt>threshold&lt;/tt> value. &#xA;     * When this threshold is set to positive, the Java virtual machine&#xA;     * will check the memory usage at its best appropriate time after it has &#xA;     * expended effort in recycling unused objects in this memory pool.&#xA;     * &lt;p>&#xA;     * The collection usage threshold crossing checking is enabled &#xA;     * in this memory pool if the threshold is set to a positive value.&#xA;     * The collection usage threshold crossing checking is disabled&#xA;     * if it is set to zero. &#xA;     * &#xA;     * @param threhsold the new collection usage threshold value in bytes.&#xA;     *              Must be non-negative.&#xA;     *&#xA;     * @throws IllegalArgumentException if &lt;tt>threshold&lt;/tt> is negative&#xA;     *         or greater than the maximum amount of memory for &#xA;     *         this memory pool if defined.&#xA;     *&#xA;     * @throws UnsupportedOperationException if this memory pool&#xA;     *         does not support a collection usage threshold.&#xA;     *&#xA;     * @throws java.lang.SecurityException if a security manager&#xA;     *         exists and the caller does not have&#xA;     *         ManagementPermission(&quot;control&quot;).&#xA;     *&#xA;     * @see #isCollectionUsageThresholdSupported&#xA;     * @see &lt;a href=&quot;#CollectionThreshold&quot;>Collection usage threshold&lt;/a>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isCollectionUsageThresholdExceeded">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if the memory usage of this memory pool after&#xA;     * the most recent collection on which the Java virtual&#xA;     * machine has expended effort has reached or&#xA;     * exceeded its collection usage threshold. &#xA;     * This method does not request the Java virtual&#xA;     * machine to perform any garbage collection other than its normal&#xA;     * automatic memory management.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if the memory usage of this memory pool &#xA;     * reaches or exceeds the collection usage threshold value&#xA;     * in the most recent collection;&#xA;     * &lt;tt>false&lt;/tt> otherwise.&#xA;     *&#xA;     * @throws UnsupportedOperationException if this memory pool&#xA;     *         does not support a usage threshold.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCollectionUsageThresholdCount">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the number of times that the Java virtual machine&#xA;     * has detected that the memory usage has reached or &#xA;     * exceeded the collection usage threshold.&#xA;     *&#xA;     * @return the number of times that the memory &#xA;     * usage has reached or exceeded the collection usage threshold.&#xA;     *&#xA;     * @throws UnsupportedOperationException if this memory pool&#xA;     *         does not support a collection usage threshold.&#xA;     *&#xA;     * @see #isCollectionUsageThresholdSupported&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCollectionUsage">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="MemoryUsage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the memory usage after the Java virtual machine  &#xA;     * most recently expended effort in recycling unused objects&#xA;     * in this memory pool.&#xA;     * This method does not request the Java virtual&#xA;     * machine to perform any garbage collection other than its normal&#xA;     * automatic memory management.&#xA;     * This method returns &lt;tt>null&lt;/tt> if the Java virtual&#xA;     * machine does not support this method.&#xA;     * &#xA;     * &lt;p>&#xA;     * &lt;b>MBeanServer access&lt;/b>:&lt;br>&#xA;     * The mapped type of &lt;tt>MemoryUsage&lt;/tt> is&#xA;     * &lt;tt>CompositeData&lt;/tt> with attributes as specified in&#xA;     * {@link MemoryUsage#from MemoryUsage}.&#xA;     *&#xA;     * @return a {@link MemoryUsage} representing the memory usage of&#xA;     * this memory pool after the Java virtual machine most recently &#xA;     * expended effort in recycling unused objects;&#xA;     * &lt;tt>null&lt;/tt> if this method is not supported.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isCollectionUsageThresholdSupported">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if this memory pool supports a collection usage threshold.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if this memory pool supports the&#xA;     * collection usage threshold; &lt;tt>false&lt;/tt> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The management interface for a memory pool.  A memory pool&#xA; * represents the memory resource managed by the Java virtual machine&#xA; * and is managed by one or more {@link MemoryManagerMXBean memory managers}.&#xA; *&#xA; * &lt;p> A Java virtual machine has one or more instances of the &#xA; * implementation class of this interface.  An instance &#xA; * implementing this interface is &#xA; * an &lt;a href=&quot;ManagementFactory.html#MXBean&quot;>MXBean&lt;/a>&#xA; * that can be obtained by calling&#xA; * the {@link ManagementFactory#getMemoryPoolMXBeans} method or&#xA; * from the {@link ManagementFactory#getPlatformMBeanServer&#xA; * platform &lt;tt>MBeanServer&lt;/tt>} method.&#xA; *&#xA; * &lt;p>The &lt;tt>ObjectName&lt;/tt> for uniquely identifying the MXBean for&#xA; * a memory pool within an &lt;tt>MBeanServer&lt;/tt> is:&#xA; * &lt;blockquote>&#xA; *    {@link ManagementFactory#MEMORY_POOL_MXBEAN_DOMAIN_TYPE&#xA; *    &lt;tt>java.lang:type=MemoryPool&lt;/tt>}&lt;tt>,name=&lt;/tt>&lt;i>pool's name&lt;/i>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;h4>Memory Type&lt;/h4>&#xA; * &lt;p>The Java virtual machine has a heap for object allocation and also&#xA; * maintains non-heap memory for the method area and the Java virtual &#xA; * machine execution.  The Java virtual machine can have one or more&#xA; * memory pools.  Each memory pool represents a memory area&#xA; * of one of the following types:&#xA; * &lt;ul>&#xA; *   &lt;li>{@link MemoryType#HEAP heap}&lt;/li> &#xA; *   &lt;li>{@link MemoryType#NON_HEAP non-heap}&lt;/li> &#xA; * &lt;/ul>&#xA; *&#xA; * &lt;h4>Memory Usage Monitoring&lt;/h4>&#xA; *&#xA; * A memory pool has the following attributes:&#xA; * &lt;ul>&#xA; *   &lt;li>&lt;a href=&quot;#Usage&quot;>Memory usage&lt;/a>&lt;/li>&#xA; *   &lt;li>&lt;a href=&quot;#PeakUsage&quot;>Peak memory usage&lt;/a>&lt;/li>&#xA; *   &lt;li>&lt;a href=&quot;#UsageThreshold&quot;>Usage Threshold&lt;/a>&lt;/li>&#xA; *   &lt;li>&lt;a href=&quot;#CollectionThreshold&quot;>Collection Usage Threshold&lt;/a>&#xA; *       (only supported by some &lt;em>garbage-collected&lt;/em> memory pools)&lt;/li>&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;h4>&lt;a name=&quot;Usage&quot;>1. Memory Usage&lt;/a>&lt;/h4>&#xA; *&#xA; * The {@link #getUsage} method provides an estimate&#xA; * of the current usage of a memory pool.&#xA; * For a garbage-collected memory pool, the amount of used memory &#xA; * includes the memory occupied by all objects in the pool &#xA; * including both &lt;em>reachable&lt;/em> and &lt;em>unreachable&lt;/em> objects. &#xA; *&#xA; * &lt;p>In general, this method is a lightweight operation for getting&#xA; * an approximate memory usage.  For some memory pools, for example, &#xA; * when objects are not packed contiguously, this method may be&#xA; * an expensive operation that requires some computation to determine &#xA; * the current memory usage.  An implementation should document when&#xA; * this is the case.&#xA; *&#xA; * &lt;h4>&lt;a name=&quot;PeakUsage&quot;>2. Peak Memory Usage&lt;/a>&lt;/h4>&#xA; *&#xA; * The Java virtual machine maintains the peak memory usage of a memory&#xA; * pool since the virtual machine was started or the peak was reset.&#xA; * The peak memory usage is returned by the {@link #getPeakUsage} method&#xA; * and reset by calling the {@link #resetPeakUsage} method.&#xA; *&#xA; * &lt;h4>&lt;a name=&quot;UsageThreshold&quot;>3. Usage Threshold&lt;/a>&lt;/h4>&#xA; * &#xA; * Each memory pool has a manageable attribute &#xA; * called the &lt;i>usage threshold&lt;/i> which has a default value supplied&#xA; * by the Java virtual machine.  The default value is platform-dependent.&#xA; * The usage threshold can be set via the&#xA; * {@link #setUsageThreshold setUsageThreshold} method.&#xA; * If the threshold is set to a positive value, the usage threshold crossing&#xA; * checking is enabled in this memory pool. &#xA; * If the usage threshold is set to zero, usage &#xA; * threshold crossing checking on this memory pool is disabled.&#xA; * The {@link MemoryPoolMXBean#isUsageThresholdSupported} method can &#xA; * be used to determine if this functionality is supported.&#xA; * &lt;p>&#xA; * A Java virtual machine performs usage threshold crossing checking on a&#xA; * memory pool basis at its best appropriate time, typically, &#xA; * at garbage collection time.&#xA; * Each memory pool maintains a {@link #getUsageThresholdCount &#xA; * usage threshold count} that will get incremented &#xA; * every time when the Java virtual machine &#xA; * detects that the memory pool usage is crossing the threshold.&#xA; * &lt;p>&#xA; * This manageable usage threshold attribute is designed for monitoring the&#xA; * increasing trend of memory usage with low overhead.&#xA; * Usage threshold may not be appropriate for some memory pools. &#xA; * For example, a generational garbage collector, a common garbage collection&#xA; * algorithm used in many Java virtual machine implementations,&#xA; * manages two or more generations segregating objects by age.&#xA; * Most of the objects are allocated in &#xA; * the &lt;em>youngest generation&lt;/em> (say a nursery memory pool).  &#xA; * The nursery memory pool is designed to be filled up and &#xA; * collecting the nursery memory pool will free most of its memory space&#xA; * since it is expected to contain mostly short-lived objects&#xA; * and mostly are unreachable at garbage collection time.&#xA; * In this case, it is more appropriate for the nursery memory pool&#xA; * not to support a usage threshold.  In addition,&#xA; * if the cost of an object allocation &#xA; * in one memory pool is very low (for example, just atomic pointer exchange),&#xA; * the Java virtual machine would probably not support the usage threshold&#xA; * for that memory pool since the overhead in comparing the usage with &#xA; * the threshold is higher than the cost of object allocation.&#xA; *&#xA; * &lt;p>&#xA; * The memory usage of the system can be monitored using &#xA; * &lt;a href=&quot;#Polling&quot;>polling&lt;/a> or &#xA; * &lt;a href=&quot;#ThresholdNotification&quot;>threshold notification&lt;/a> mechanisms.&#xA; *&#xA; * &lt;ol type=&quot;a&quot;>&#xA; *   &lt;li>&lt;a name=&quot;Polling&quot;>&lt;b>Polling&lt;/b>&lt;/a>&#xA; *       &lt;p>&#xA; *       An application can continuously monitor its memory usage&#xA; *       by calling either the {@link #getUsage} method for all&#xA; *       memory pools or the {@link #isUsageThresholdExceeded} method&#xA; *       for those memory pools that support a usage threshold.&#xA; *       Below is example code that has a thread delicated for&#xA; *       task distribution and processing.  At every interval, &#xA; *       it will determine if it should receive and process new tasks based &#xA; *       on its memory usage.  If the memory usage exceeds its usage threshold,&#xA; *       it will redistribute all outstanding tasks to other VMs and&#xA; *       stop receiving new tasks until the memory usage returns&#xA; *       below its usage threshold.&#xA; *&#xA; *       &lt;pre>  &#xA; *       // Assume the usage threshold is supported for this pool.&#xA; *       // Set the threshold to myThreshold above which no new tasks&#xA; *       // should be taken.&#xA; *       pool.setUsageThreshold(myThreshold);&#xA; *       ....&#xA; *&#xA; *       boolean lowMemory = false;&#xA; *       while (true) {&#xA; *          if (pool.isUsageThresholdExceeded()) {&#xA; *              // potential low memory, so redistribute tasks to other VMs&#xA; *              lowMemory = true;&#xA; *              redistributeTasks();&#xA; *              // stop receiving new tasks&#xA; *              stopReceivingTasks();&#xA; *          } else {&#xA; *              if (lowMemory) {&#xA; *                  // resume receiving tasks&#xA; *                  lowMemory = false;&#xA; *                  resumeReceivingTasks();&#xA; *              } &#xA; *              // processing outstanding task&#xA; *              ...&#xA; *          }&#xA; *          // sleep for sometime&#xA; *          try {&#xA; *              Thread.sleep(sometime);&#xA; *          } catch (InterruptedException e) {&#xA; *              ...&#xA; *          }&#xA; *       }&#xA; *       &lt;/pre>  &#xA; *&#xA; * &lt;hr>&#xA; *       The above example does not differentiate the case where &#xA; *       the memory usage has temporarily dropped below the usage threshold&#xA; *       from the case where the memory usage remains above the threshould&#xA; *       between two iterations.  The usage threshold count returned by&#xA; *       the {@link #getUsageThresholdCount} method&#xA; *       can be used to determine&#xA; *       if the memory usage has returned below the threshold&#xA; *       between two polls.&#xA; *       &lt;p>&#xA; *       Below shows another example that takes some action if a &#xA; *       memory pool is under low memory and ignores the memory usage&#xA; *       changes during the action processing time. &#xA; *&#xA; *       &lt;pre>&#xA; *       // Assume the usage threshold is supported for this pool.&#xA; *       // Set the threshold to myThreshold which determines if &#xA; *       // the application will take some action under low memory condition.&#xA; *       pool.setUsageThreshold(myThreshold);&#xA; *&#xA; *       int prevCrossingCount = 0;&#xA; *       while (true) {&#xA; *           // A busy loop to detect when the memory usage  &#xA; *           // has exceeded the threshold.&#xA; *           while (!pool.isUsageThresholdExceeded() || &#xA; *                  pool.getUsageThresholdCount() == prevCrossingCount) {&#xA; *               try {&#xA; *                   Thread.sleep(sometime)&#xA; *               } catch (InterruptException e) {&#xA; *                   ....&#xA; *               }&#xA; *           }&#xA; *&#xA; *           // Do some processing such as check for memory usage&#xA; *           // and issue a warning&#xA; *           ....&#xA; *&#xA; *           // Gets the current threshold count. The busy loop will then&#xA; *           // ignore any crossing of threshold happens during the processing.&#xA; *           prevCrossingCount = pool.getUsageThresholdCount();&#xA; *       }&#xA; *       &lt;/pre>&lt;hr>&#xA; *   &lt;/li>&#xA; *   &lt;li>&lt;a name=&quot;ThresholdNotification&quot;>&lt;b>Usage Threshold Notifications&lt;/b>&lt;/a>&#xA; *       &lt;p>&#xA; *       Usage threshold notification will be emitted by {@link MemoryMXBean}.&#xA; *       When the Java virtual machine detects that the memory usage of&#xA; *       a memory pool has reached or exceeded the usage threshold&#xA; *       the virtual machine will trigger the &lt;tt>MemoryMXBean&lt;/tt> to emit an&#xA; *       {@link MemoryNotificationInfo#MEMORY_THRESHOLD_EXCEEDED&#xA; *       usage threshold exceeded notification}.&#xA; *       Another usage threshold exceeded notification will not be &#xA; *       generated until the usage has fallen below the threshold and &#xA; *       then exceeded it again.&#xA; *       &lt;p>&#xA; *       Below is an example code implementing the same logic as the&#xA; *       first example above but using the usage threshold notification &#xA; *       mechanism to detect low memory conditions instead of polling.&#xA; *       In this example code, upon receiving notification, the notification&#xA; *       listener notifies another thread to perform the actual action&#xA; *       such as to redistribute outstanding tasks, stop receiving tasks,&#xA; *       or resume receiving tasks.&#xA; *       The &lt;tt>handleNotification&lt;/tt> method should be designed to&#xA; *       do a very minimal amount of work and return without delay to avoid &#xA; *       causing delay in delivering subsequent notifications.  Time-consuming&#xA; *       actions should be performed by a separate thread.&#xA; *       The notification listener may be invoked by multiple threads &#xA; *       concurrently; so the tasks performed by the listener&#xA; *       should be properly synchronized. &#xA; *&#xA; *       &lt;pre>  &#xA; *       class MyListener implements javax.management.NotificationListener {&#xA; *            public void handleNotification(Notification notification, Object handback)  {&#xA; *                String notifType = notification.getType();&#xA; *                if (notifType.equals(MemoryNotificationInfo.MEMORY_THRESHOLD_EXCEEDED)) {&#xA; *                    // potential low memory, notify another thread&#xA; *                    // to redistribute outstanding tasks to other VMs&#xA; *                    // and stop receiving new tasks.&#xA; *                    lowMemory = true;&#xA; *                    notifyAnotherThread(lowMemory);&#xA; *                }&#xA; *            }&#xA; *       }&#xA; *&#xA; *       // Register MyListener with MemoryMXBean  &#xA; *       MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();&#xA; *       NotificationEmitter emitter = (NotificationEmitter) mbean;&#xA; *       MyListener listener = new MyListener();&#xA; *       emitter.addNotificationListener(listener, null, null);&#xA; *&#xA; *       // Assume this pool supports a usage threshold.&#xA; *       // Set the threshold to myThreshold above which no new tasks&#xA; *       // should be taken.&#xA; *       pool.setUsageThreshold(myThreshold);&#xA; *       &#xA; *       // Usage threshold detection is enabled and notification will be &#xA; *       // handled by MyListener.  Continue for other processing.&#xA; *       ....&#xA; *&#xA; *       &lt;/pre>  &#xA; * &lt;hr>&#xA; *       &lt;p>&#xA; *       There is no guarantee about when the &lt;tt>MemoryMXBean&lt;/tt> will emit&#xA; *       a threshold notification and when the notification will be delivered.&#xA; *       When a notification listener is invoked, the memory usage of &#xA; *       the memory pool may have crossed the usage threshold more&#xA; *       than once.&#xA; *       The {@link MemoryNotificationInfo#getCount} method returns the number&#xA; *       of times that the memory usage has crossed the usage threshold&#xA; *       at the point in time when the notification was constructed.&#xA; *       It can be compared with the current usage threshold count returned&#xA; *       by the {@link #getUsageThresholdCount} method to determine if &#xA; *       such situation has occurred.&#xA; *   &lt;/li>&#xA; * &lt;/ol>&#xA; *&#xA; * &lt;h4>&lt;a name=&quot;CollectionThreshold&quot;>4. Collection Usage Threshold&lt;/a>&lt;/h4>&#xA; * &#xA; * Collection usage threshold is a manageable attribute only applicable&#xA; * to some garbage-collected memory pools.&#xA; * After a Java virtual machine has expended effort in reclaiming memory&#xA; * space by recycling unused objects in a memory pool at garbage collection&#xA; * time, some number of bytes in the memory pools that are garbaged &#xA; * collected will still be in use.  The collection usage threshold &#xA; * allows a value to be set for this number of bytes such&#xA; * that if the threshold is exceeded, &#xA; * a {@link MemoryNotificationInfo#MEMORY_THRESHOLD_EXCEEDED&#xA; * collection usage threshold exceeded notification}&#xA; * will be emitted by the {@link MemoryMXBean}. &#xA; * In addition, the {@link #getCollectionUsageThresholdCount&#xA; * collection usage threshold count} will then be incremented.&#xA; *&#xA; * &lt;p>&#xA; * The {@link MemoryPoolMXBean#isCollectionUsageThresholdSupported} method can &#xA; * be used to determine if this functionality is supported.&#xA; *&#xA; * &lt;p>&#xA; * A Java virtual machine performs collection usage threshold checking&#xA; * on a memory pool basis.  This checking is enabled if the collection&#xA; * usage threshold is set to a positive value.&#xA; * If the collection usage threshold is set to zero, this checking &#xA; * is disabled on this memory pool.  Default value is zero.&#xA; * The Java virtual machine performs the collection usage threshold &#xA; * checking at garbage collection time.&#xA; *&#xA; * &lt;p>&#xA; * Some garbage-collected memory pools may&#xA; * choose not to support the collection usage threshold.  For example,&#xA; * a memory pool is only managed by a continuous concurrent garbage&#xA; * collector.  Objects can be allocated in this memory pool by some thread&#xA; * while the unused objects are reclaimed by the concurrent garbage&#xA; * collector simultaneously.  Unless there is a well-defined &#xA; * garbage collection time which is the best appropriate time&#xA; * to check the memory usage, the collection usage threshold should not&#xA; * be supported.&#xA; *&#xA; * &lt;p>&#xA; * The collection usage threshold is designed for monitoring the memory usage &#xA; * after the Java virtual machine has expended effort in reclaiming &#xA; * memory space.  The collection usage could also be monitored &#xA; * by the polling and threshold notification mechanism &#xA; * described above for the &lt;a href=&quot;#UsageThreshold&quot;>usage threshold&lt;/a>&#xA; * in a similar fashion.&#xA; *&#xA; * @see &lt;a href=&quot;../../../javax/management/package-summary.html&quot;>&#xA; *      JMX Specification.&lt;/a>&#xA; * @see &lt;a href=&quot;package-summary.html#examples&quot;>&#xA; *      Ways to Access MXBeans&lt;/a>&#xA; *&#xA; * @author  Mandy Chung&#xA; * @version 1.21, 03/08/06 &#xA; * @since   1.5&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
