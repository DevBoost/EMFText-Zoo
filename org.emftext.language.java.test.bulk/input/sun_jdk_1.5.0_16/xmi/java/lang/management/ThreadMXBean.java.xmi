<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="ThreadMXBean.java">
  <comments>/*&#xA; * @(#)ThreadMXBean.java&#x9;1.14 04/04/29 &#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>lang</namespaces>
  <namespaces>management</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="ThreadMXBean">
    <members xsi:type="members:InterfaceMethod" name="getThreadCount">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current number of live threads including both &#xA;     * daemon and non-daemon threads.&#xA;     *&#xA;     * @return the current number of live threads.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPeakThreadCount">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the peak live thread count since the Java virtual machine &#xA;     * started or peak was reset.&#xA;     *&#xA;     * @return the peak live thread count.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTotalStartedThreadCount">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the total number of threads created and also started &#xA;     * since the Java virtual machine started.&#xA;     *&#xA;     * @return the total number of threads started.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDaemonThreadCount">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current number of live daemon threads.&#xA;     *&#xA;     * @return the current number of live daemon threads.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAllThreadIds">
      <typeReference xsi:type="types:Long"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns all live thread IDs. &#xA;     * Some threads included in the returned array&#xA;     * may have been terminated when this method returns.&#xA;     *&#xA;     * @return an array of &lt;tt>long&lt;/tt>, each is a thread ID.&#xA;     *&#xA;     * @throws java.lang.SecurityException if a security manager&#xA;     *         exists and the caller does not have&#xA;     *         ManagementPermission(&quot;monitor&quot;).&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getThreadInfo">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ThreadInfo.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="id">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the thread info for a thread of the specified&#xA;     * &lt;tt>id&lt;/tt> with no stack trace. This method is equivalent to calling:&#xA;     * &lt;blockquote>&#xA;     *   {@link #getThreadInfo(long, int) getThreadInfo(id, 0);}&#xA;     * &lt;/blockquote>&#xA;     *&#xA;     * &lt;p>&#xA;     * This method returns a &lt;tt>ThreadInfo&lt;/tt> object representing&#xA;     * the thread information for the thread of the specified ID.&#xA;     * The stack trace in the returned &lt;tt>ThreadInfo&lt;/tt> object will&#xA;     * be an empty array of &lt;tt>StackTraceElement&lt;/tt>.&#xA;     *&#xA;     * If a thread of the given ID is not alive or does not exist,&#xA;     * this method will return &lt;tt>null&lt;/tt>.  A thread is alive if &#xA;     * it has been started and has not yet died.&#xA;     *&#xA;     * &lt;p>&#xA;     * &lt;b>MBeanServer access&lt;/b>:&lt;br>&#xA;     * The mapped type of &lt;tt>ThreadInfo&lt;/tt> is&#xA;     * &lt;tt>CompositeData&lt;/tt> with attributes as specified in&#xA;     * {@link ThreadInfo#from ThreadInfo}.&#xA;     *&#xA;     * @param id the thread ID of the thread. Must be positive. &#xA;     *&#xA;     * @return a {@link ThreadInfo} object for the thread of the given ID &#xA;     * with no stack trace;&#xA;     * &lt;tt>null&lt;/tt> if the thread of the given ID is not alive or&#xA;     * it does not exist.&#xA;     *&#xA;     * @throws IllegalArgumentException if &lt;tt>id &amp;lt= 0&lt;/tt>.&#xA;     * @throws java.lang.SecurityException if a security manager&#xA;     *         exists and the caller does not have&#xA;     *         ManagementPermission(&quot;monitor&quot;).&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getThreadInfo">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ThreadInfo.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ids">
        <typeReference xsi:type="types:Long"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the thread info for each thread &#xA;     * whose ID is in the input array &lt;tt>ids&lt;/tt> with no&#xA;     * stack trace. This method is equivalent to calling:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *   {@link #getThreadInfo(long[], int) getThreadInfo}(ids, 0);&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * &lt;p>&#xA;     * This method returns an array of the &lt;tt>ThreadInfo&lt;/tt> objects.&#xA;     * The stack trace in each &lt;tt>ThreadInfo&lt;/tt> object will&#xA;     * be an empty array of &lt;tt>StackTraceElement&lt;/tt>.&#xA;     *&#xA;     * If a thread of a given ID is not alive or does not exist,&#xA;     * the corresponding element in the returned array will&#xA;     * contain &lt;tt>null&lt;/tt>.  A thread is alive if &#xA;     * it has been started and has not yet died.&#xA;     *&#xA;     * &lt;p>&#xA;     * &lt;b>MBeanServer access&lt;/b>:&lt;br>&#xA;     * The mapped type of &lt;tt>ThreadInfo&lt;/tt> is&#xA;     * &lt;tt>CompositeData&lt;/tt> with attributes as specified in&#xA;     * {@link ThreadInfo#from ThreadInfo}.&#xA;     *&#xA;     * @param ids an array of thread IDs &#xA;     * @return an array of the {@link ThreadInfo} objects, each containing&#xA;     * information about a thread whose ID is in the corresponding&#xA;     * element of the input array of IDs. &#xA;     *&#xA;     * @throws IllegalArgumentException if any element in the input array &#xA;     *      &lt;tt>ids&lt;/tt> is &lt;tt>&amp;lt= 0&lt;/tt>.&#xA;     * @throws java.lang.SecurityException if a security manager&#xA;     *         exists and the caller does not have&#xA;     *         ManagementPermission(&quot;monitor&quot;).&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getThreadInfo">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ThreadInfo.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="id">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="maxDepth">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a thread info for a thread of &#xA;     * the specified &lt;tt>id&lt;/tt>.&#xA;     * The &lt;tt>maxDepth&lt;/tt> parameter indicates the maximum number of &#xA;     * &lt;tt>StackTraceElement&lt;/tt> to be retrieved from the stack trace.&#xA;     * If &lt;tt>maxDepth == Integer.MAX_VALUE&lt;/tt>, the entire stack trace of &#xA;     * the thread will be dumped. &#xA;     * If &lt;tt>maxDepth == 0&lt;/tt>, no stack trace of the thread &#xA;     * will be dumped. &#xA;     * &lt;p>&#xA;     * When the Java virtual machine has no stack trace information &#xA;     * about a thread or &lt;tt>maxDepth == 0&lt;/tt>, &#xA;     * the stack trace in the &#xA;     * &lt;tt>ThreadInfo&lt;/tt> object will be an empty array of &#xA;     * &lt;tt>StackTraceElement&lt;/tt>.&#xA;     *&#xA;     * &lt;p>&#xA;     * If a thread of the given ID is not alive or does not exist, &#xA;     * this method will return &lt;tt>null&lt;/tt>.  A thread is alive if &#xA;     * it has been started and has not yet died.&#xA;     *&#xA;     * &lt;p>&#xA;     * &lt;b>MBeanServer access&lt;/b>:&lt;br>&#xA;     * The mapped type of &lt;tt>ThreadInfo&lt;/tt> is&#xA;     * &lt;tt>CompositeData&lt;/tt> with attributes as specified in&#xA;     * {@link ThreadInfo#from ThreadInfo}.&#xA;     *&#xA;     * @param id the thread ID of the thread. Must be positive. &#xA;     * @param maxDepth the maximum number of entries in the stack trace &#xA;     * to be dumped. &lt;tt>Integer.MAX_VALUE&lt;/tt> could be used to request&#xA;     * the entire stack to be dumped.&#xA;     * &#xA;     * @return a {@link ThreadInfo} of the thread of the given ID.&#xA;     * &lt;tt>null&lt;/tt> if the thread of the given ID is not alive or&#xA;     * it does not exist.&#xA;     *&#xA;     * @throws IllegalArgumentException if &lt;tt>id &amp;lt= 0&lt;/tt>.&#xA;     * @throws IllegalArgumentException if &lt;tt>maxDepth is negative&lt;/tt>.&#xA;     * @throws java.lang.SecurityException if a security manager&#xA;     *         exists and the caller does not have&#xA;     *         ManagementPermission(&quot;monitor&quot;).&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getThreadInfo">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ThreadInfo.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ids">
        <typeReference xsi:type="types:Long"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="maxDepth">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the thread info for each thread &#xA;     * whose ID is in the input array &lt;tt>ids&lt;/tt>.&#xA;     * The &lt;tt>maxDepth&lt;/tt> parameter indicates the maximum number of &#xA;     * &lt;tt>StackTraceElement&lt;/tt> to be retrieved from the stack trace.&#xA;     * If &lt;tt>maxDepth == Integer.MAX_VALUE&lt;/tt>, the entire stack trace of &#xA;     * the thread will be dumped. &#xA;     * If &lt;tt>maxDepth == 0&lt;/tt>, no stack trace of the thread &#xA;     * will be dumped.&#xA;     * &lt;p>&#xA;     * When the Java virtual machine has no stack trace information &#xA;     * about a thread or &lt;tt>maxDepth == 0&lt;/tt>, &#xA;     * the stack trace in the&#xA;     * &lt;tt>ThreadInfo&lt;/tt> object will be an empty array of &#xA;     * &lt;tt>StackTraceElement&lt;/tt>.&#xA;     * &lt;p>&#xA;     * This method returns an array of the &lt;tt>ThreadInfo&lt;/tt> objects,&#xA;     * each is the thread information about the thread with the same index&#xA;     * as in the &lt;tt>ids&lt;/tt> array.&#xA;     * If a thread of the given ID is not alive or does not exist,&#xA;     * &lt;tt>null&lt;/tt> will be set in the corresponding element &#xA;     * in the returned array.  A thread is alive if &#xA;     * it has been started and has not yet died.&#xA;     *&#xA;     * &lt;p>&#xA;     * &lt;b>MBeanServer access&lt;/b>:&lt;br>&#xA;     * The mapped type of &lt;tt>ThreadInfo&lt;/tt> is&#xA;     * &lt;tt>CompositeData&lt;/tt> with attributes as specified in&#xA;     * {@link ThreadInfo#from ThreadInfo}.&#xA;     *&#xA;     * @param ids an array of thread IDs &#xA;     * @param maxDepth the maximum number of entries in the stack trace &#xA;     * to be dumped. &lt;tt>Integer.MAX_VALUE&lt;/tt> could be used to request&#xA;     * the entire stack to be dumped.&#xA;     *&#xA;     * @return an array of the {@link ThreadInfo} objects, each containing&#xA;     * information about a thread whose ID is in the corresponding&#xA;     * element of the input array of IDs. &#xA;     *&#xA;     * @throws IllegalArgumentException if &lt;tt>maxDepth is negative&lt;/tt>.&#xA;     * @throws IllegalArgumentException if any element in the input array &#xA;     *      &lt;tt>ids&lt;/tt> is &lt;tt>&amp;lt= 0&lt;/tt>.&#xA;     * @throws java.lang.SecurityException if a security manager&#xA;     *         exists and the caller does not have&#xA;     *         ManagementPermission(&quot;monitor&quot;).&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isThreadContentionMonitoringSupported">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if the Java virtual machine supports thread contention monitoring.&#xA;     *&#xA;     * @return&#xA;     *   &lt;tt>true&lt;/tt>&#xA;     *     if the Java virtual machine supports thread contention monitoring;&#xA;     *   &lt;tt>false&lt;/tt> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isThreadContentionMonitoringEnabled">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if thread contention monitoring is enabled.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if thread contention monitoring is enabled;&#xA;     *         &lt;tt>false&lt;/tt> otherwise.&#xA;     *&#xA;     * @throws java.lang.UnsupportedOperationException if the Java virtual &#xA;     * machine does not support thread contention monitoring.&#xA;&#xA;     * @see #isThreadContentionMonitoringSupported&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setThreadContentionMonitoringEnabled">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="enable">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enables or disables thread contention monitoring.&#xA;     * Thread contention monitoring is disabled by default.&#xA;     *&#xA;     * @param enable &lt;tt>true&lt;/tt> to enable;&#xA;     *               &lt;tt>false&lt;/tt> to disable.&#xA;     *&#xA;     * @throws java.lang.UnsupportedOperationException if the Java &#xA;     * virtual machine does not support thread contention monitoring.&#xA;     *&#xA;     * @throws java.lang.SecurityException if a security manager&#xA;     *         exists and the caller does not have&#xA;     *         ManagementPermission(&quot;control&quot;).&#xA;     *&#xA;     * @see #isThreadContentionMonitoringSupported&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCurrentThreadCpuTime">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the total CPU time for the current thread in nanoseconds.&#xA;     * The returned value is of nanoseconds precison but&#xA;     * not necessarily nanoseconds accuracy.&#xA;     * If the implementation distinguishes between user mode time and system &#xA;     * mode time, the returned CPU time is the amount of time that &#xA;     * the current thread has executed in user mode or system mode.&#xA;     *&#xA;     * &lt;p>&#xA;     * This is a convenient method for local management use and is &#xA;     * equivalent to calling:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *   {@link #getThreadCpuTime getThreadCpuTime}(Thread.currentThread().getId());&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @return the total CPU time for the current thread if CPU time&#xA;     * measurement is enabled; &lt;tt>-1&lt;/tt> otherwise.&#xA;     *&#xA;     * @throws java.lang.UnsupportedOperationException if the Java &#xA;     * virtual machine does not support CPU time measurement for&#xA;     * the current thread.&#xA;     *&#xA;     * @see #getCurrentThreadUserTime&#xA;     * @see #isCurrentThreadCpuTimeSupported&#xA;     * @see #isThreadCpuTimeEnabled&#xA;     * @see #setThreadCpuTimeEnabled&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCurrentThreadUserTime">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the CPU time that the current thread has executed &#xA;     * in user mode in nanoseconds.&#xA;     * The returned value is of nanoseconds precison but&#xA;     * not necessarily nanoseconds accuracy.&#xA;     *&#xA;     * &lt;p>&#xA;     * This is a convenient method for local management use and is &#xA;     * equivalent to calling:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *   {@link #getThreadUserTime getThreadUserTime}(Thread.currentThread().getId());&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @return the user-level CPU time for the current thread if CPU time&#xA;     * measurement is enabled; &lt;tt>-1&lt;/tt> otherwise.&#xA;     *&#xA;     * @throws java.lang.UnsupportedOperationException if the Java &#xA;     * virtual machine does not support CPU time measurement for&#xA;     * the current thread.&#xA;     *&#xA;     * @see #getCurrentThreadCpuTime&#xA;     * @see #isCurrentThreadCpuTimeSupported&#xA;     * @see #isThreadCpuTimeEnabled&#xA;     * @see #setThreadCpuTimeEnabled&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getThreadCpuTime">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="id">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the total CPU time for a thread of the specified ID in nanoseconds.&#xA;     * The returned value is of nanoseconds precision but&#xA;     * not necessarily nanoseconds accuracy.&#xA;     * If the implementation distinguishes between user mode time and system &#xA;     * mode time, the returned CPU time is the amount of time that &#xA;     * the thread has executed in user mode or system mode.&#xA;     *&#xA;     * &lt;p>&#xA;     * If the thread of the specified ID is not alive or does not exist,&#xA;     * this method returns &lt;tt>-1&lt;/tt>. If CPU time measurement&#xA;     * is disabled, this method returns &lt;tt>-1&lt;/tt>.&#xA;     * A thread is alive if it has been started and has not yet died.&#xA;     * &lt;p>&#xA;     * If CPU time measurement is enabled after the thread has started,&#xA;     * the Java virtual machine implementation may choose any time up to&#xA;     * and including the time that the capability is enabled as the point&#xA;     * where CPU time measurement starts.&#xA;     *&#xA;     * @param id the thread ID of a thread&#xA;     * @return the total CPU time for a thread of the specified ID&#xA;     * if the thread of the specified ID exists, the thread is alive,&#xA;     * and CPU time measurement is enabled;&#xA;     * &lt;tt>-1&lt;/tt> otherwise.&#xA;     *&#xA;     * @throws IllegalArgumentException if &lt;tt>id &amp;lt= 0 &lt;/tt>.&#xA;     * @throws java.lang.UnsupportedOperationException if the Java &#xA;     * virtual machine does not support CPU time measurement for &#xA;     * other threads.&#xA;     *&#xA;     * @see #getThreadUserTime&#xA;     * @see #isThreadCpuTimeSupported&#xA;     * @see #isThreadCpuTimeEnabled&#xA;     * @see #setThreadCpuTimeEnabled&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getThreadUserTime">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="id">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the CPU time that a thread of the specified ID &#xA;     * has executed in user mode in nanoseconds.&#xA;     * The returned value is of nanoseconds precision but&#xA;     * not necessarily nanoseconds accuracy.&#xA;     *&#xA;     * &lt;p>&#xA;     * If the thread of the specified ID is not alive or does not exist,&#xA;     * this method returns &lt;tt>-1&lt;/tt>. If CPU time measurement&#xA;     * is disabled, this method returns &lt;tt>-1&lt;/tt>.&#xA;     * A thread is alive if it has been started and has not yet died.&#xA;     * &lt;p>&#xA;     * If CPU time measurement is enabled after the thread has started,&#xA;     * the Java virtual machine implementation may choose any time up to&#xA;     * and including the time that the capability is enabled as the point&#xA;     * where CPU time measurement starts.&#xA;     *&#xA;     * @param id the thread ID of a thread&#xA;     * @return the user-level CPU time for a thread of the specified ID&#xA;     * if the thread of the specified ID exists, the thread is alive,&#xA;     * and CPU time measurement is enabled;&#xA;     * &lt;tt>-1&lt;/tt> otherwise.&#xA;     *&#xA;     * @throws IllegalArgumentException if &lt;tt>id &amp;lt= 0 &lt;/tt>.&#xA;     * @throws java.lang.UnsupportedOperationException if the Java &#xA;     * virtual machine does not support CPU time measurement for &#xA;     * other threads.&#xA;     *&#xA;     * @see #getThreadCpuTime&#xA;     * @see #isThreadCpuTimeSupported&#xA;     * @see #isThreadCpuTimeEnabled&#xA;     * @see #setThreadCpuTimeEnabled&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isThreadCpuTimeSupported">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if the Java virtual machine implementation supports CPU time&#xA;     * measurement for any thread.&#xA;     * A Java virtual machine implementation that supports CPU time&#xA;     * measurement for any thread will also support CPU time&#xA;     * measurement for the current thread.  &#xA;     *&#xA;     * @return&#xA;     *   &lt;tt>true&lt;/tt>&#xA;     *     if the Java virtual machine supports CPU time &#xA;     *     measurement for any thread;&#xA;     *   &lt;tt>false&lt;/tt> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isCurrentThreadCpuTimeSupported">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if the Java virtual machine supports CPU time&#xA;     * measurement for the current thread.&#xA;     * This method returns &lt;tt>true&lt;/tt> if {@link #isThreadCpuTimeSupported}&#xA;     * returns &lt;tt>true&lt;/tt>.&#xA;     *&#xA;     * @return&#xA;     *   &lt;tt>true&lt;/tt>&#xA;     *     if the Java virtual machine supports CPU time &#xA;     *     measurement for current thread;&#xA;     *   &lt;tt>false&lt;/tt> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isThreadCpuTimeEnabled">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if thread CPU time measurement is enabled.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if thread CPU time measurement is enabled;&#xA;     *         &lt;tt>false&lt;/tt> otherwise.&#xA;     *&#xA;     * @throws java.lang.UnsupportedOperationException if the Java virtual &#xA;     * machine does not support CPU time measurement for other threads&#xA;     * nor for the current thread.&#xA;     *&#xA;     * @see #isThreadCpuTimeSupported&#xA;     * @see #isCurrentThreadCpuTimeSupported&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setThreadCpuTimeEnabled">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="enable">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enables or disables thread CPU time measurement.  The default&#xA;     * is platform dependent.&#xA;     *&#xA;     * @param enable &lt;tt>true&lt;/tt> to enable;&#xA;     *               &lt;tt>false&lt;/tt> to disable.&#xA;     *&#xA;     * @throws java.lang.UnsupportedOperationException if the Java &#xA;     * virtual machine does not support CPU time measurement for&#xA;     * any threads nor for the current thread.&#xA;     *&#xA;     * @throws java.lang.SecurityException if a security manager&#xA;     *         exists and the caller does not have&#xA;     *         ManagementPermission(&quot;control&quot;).&#xA;     *&#xA;     * @see #isThreadCpuTimeSupported&#xA;     * @see #isCurrentThreadCpuTimeSupported&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="findMonitorDeadlockedThreads">
      <typeReference xsi:type="types:Long"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Finds cycles of threads that are in deadlock waiting to acquire&#xA;     * object monitors. That is, threads that are blocked waiting to enter a&#xA;     * synchronization block or waiting to reenter a synchronization block&#xA;     * after an {@link Object#wait Object.wait} call, &#xA;     * where each thread owns one monitor while&#xA;     * trying to obtain another monitor already held by another thread&#xA;     * in a cycle.&#xA;     * &lt;p>&#xA;     * More formally, a thread is &lt;em>monitor deadlocked&lt;/em> if it is&#xA;     * part of a cycle in the relation &quot;is waiting for an object monitor&#xA;     * owned by&quot;.  In the simplest case, thread A is blocked waiting&#xA;     * for a monitor owned by thread B, and thread B is blocked waiting&#xA;     * for a monitor owned by thread A.&#xA;     * &lt;p>&#xA;     * This method is designed for troubleshooting use, but not for&#xA;     * synchronization control.  It might be an expensive operation.&#xA;     *&#xA;     * @return an array of IDs of the threads that are monitor&#xA;     * deadlocked, if any; &lt;tt>null&lt;/tt> otherwise.&#xA;     *&#xA;     * @throws java.lang.SecurityException if a security manager&#xA;     *         exists and the caller does not have&#xA;     *         ManagementPermission(&quot;monitor&quot;).&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="resetPeakThreadCount">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Resets the peak thread count to the current number of&#xA;     * live threads.&#xA;     *&#xA;     * @throws java.lang.SecurityException if a security manager&#xA;     *         exists and the caller does not have&#xA;     *         ManagementPermission(&quot;control&quot;).&#xA;     *&#xA;     * @see #getPeakThreadCount&#xA;     * @see #getThreadCount&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The management interface for the thread system of&#xA; * the Java virtual machine.&#xA; *&#xA; * &lt;p> A Java virtual machine has a single instance of the implementation&#xA; * class of this interface.  This instance implementing this interface is&#xA; * an &lt;a href=&quot;ManagementFactory.html#MXBean&quot;>MXBean&lt;/a>&#xA; * that can be obtained by calling&#xA; * the {@link ManagementFactory#getThreadMXBean} method or&#xA; * from the {@link ManagementFactory#getPlatformMBeanServer&#xA; * platform &lt;tt>MBeanServer&lt;/tt>} method.&#xA; *&#xA; * &lt;p>The &lt;tt>ObjectName&lt;/tt> for uniquely identifying the MXBean for&#xA; * the thread system within an MBeanServer is:&#xA; * &lt;blockquote>&#xA; *    {@link ManagementFactory#THREAD_MXBEAN_NAME &#xA; *           &lt;tt>java.lang:type=Threading&lt;/tt>}&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;h4>Thread ID&lt;/h4>&#xA; * Thread ID is a positive long value returned by calling the&#xA; * {@link java.lang.Thread#getId} method for a thread.&#xA; * The thread ID is unique during its lifetime.  When a thread &#xA; * is terminated, this thread ID may be reused.&#xA; *&#xA; * &lt;p> Some methods in this interface take a thread ID or an array&#xA; * of thread IDs as the input parameter and return per-thread information.&#xA; *&#xA; * &lt;h4>Thread CPU time&lt;/h4>&#xA; * A Java virtual machine implementation may support measuring&#xA; * the CPU time for the current thread, for any thread, or for no threads.&#xA; *&#xA; * &lt;p>&#xA; * The {@link #isThreadCpuTimeSupported} method can be used to determine&#xA; * if a Java virtual machine supports measuring of the CPU time for any &#xA; * thread.  The {@link #isCurrentThreadCpuTimeSupported} method can &#xA; * be used to determine if a Java virtual machine supports measuring of &#xA; * the CPU time for the current  thread.&#xA; * A Java virtual machine implementation that supports CPU time measurement &#xA; * for any thread will also support that for the current thread.&#xA; *&#xA; * &lt;p> The CPU time provided by this interface has nanosecond precision&#xA; * but not necessarily nanosecond accuracy.&#xA; *&#xA; * &lt;p>&#xA; * A Java virtual machine may disable CPU time measurement&#xA; * by default.&#xA; * The {@link #isThreadCpuTimeEnabled} and {@link #setThreadCpuTimeEnabled}&#xA; * methods can be used to test if CPU time measurement is enabled&#xA; * and to enable/disable this support respectively.&#xA; * Enabling thread CPU measurement could be expensive in some&#xA; * Java virtual machine implementations.&#xA; *&#xA; * &lt;h4>Thread Contention Monitoring&lt;/h4>&#xA; * Some Java virtual machines may support thread contention monitoring.&#xA; * The {@link #isThreadContentionMonitoringSupported} method can be used to &#xA; * determine if a Java virtual machine supports thread contention monitoring.&#xA; *&#xA; * The thread contention monitoring is disabled by default.  The &#xA; * {@link #setThreadContentionMonitoringEnabled} method can be used to enable&#xA; * thread contention monitoring.&#xA; *&#xA; * @see &lt;a href=&quot;../../../javax/management/package-summary.html&quot;>&#xA; *      JMX Specification.&lt;/a>&#xA; * @see &lt;a href=&quot;package-summary.html#examples&quot;>&#xA; *      Ways to Access MXBeans&lt;/a>&#xA; *&#xA; * @author  Mandy Chung&#xA; * @version 1.14, 04/29/04&#xA; * @since   1.5&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
