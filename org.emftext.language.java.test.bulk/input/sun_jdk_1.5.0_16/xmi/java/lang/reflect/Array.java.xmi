<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="Array.java">
  <comments>/*&#xA; * @(#)Array.java&#x9;1.21 04/04/20&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>lang</namespaces>
  <namespaces>reflect</namespaces>
  <classifiers xsi:type="classifiers:Class" name="Array">
    <members xsi:type="members:Constructor" name="Array">
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Constructor.  Class Array is not instantiable.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="newInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="componentType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Class" href="../Class.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NegativeArraySizeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new array with the specified component type and&#xA;     * length.&#xA;     * Invoking this method is equivalent to creating an array&#xA;     * as follows:&#xA;     * &lt;blockquote>&#xA;     * &lt;pre>&#xA;     * int[] x = {length};&#xA;     * Array.newInstance(componentType, x);&#xA;     * &lt;/pre>&#xA;     * &lt;/blockquote>&#xA;     *&#xA;     * @param componentType the &lt;code>Class&lt;/code> object representing the&#xA;     * component type of the new array&#xA;     * @param length the length of the new array&#xA;     * @return the new array&#xA;     * @exception NullPointerException if the specified&#xA;     * &lt;code>componentType&lt;/code> parameter is null&#xA;     * @exception IllegalArgumentException if componentType is Void.TYPE&#xA;     * @exception NegativeArraySizeException if the specified &lt;code>length&lt;/code> &#xA;     * is negative&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="componentType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Class" href="../Class.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dimensions">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NegativeArraySizeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new array&#xA;     * with the specified component type and dimensions. &#xA;     * If &lt;code>componentType&lt;/code>&#xA;     * represents a non-array class or interface, the new array&#xA;     * has &lt;code>dimensions.length&lt;/code> dimensions and&amp;nbsp;&#xA;     * &lt;code>componentType&amp;nbsp;&lt;/code> as its component type. If&#xA;     * &lt;code>componentType&lt;/code> represents an array class, the&#xA;     * number of dimensions of the new array is equal to the sum&#xA;     * of &lt;code>dimensions.length&lt;/code> and the number of&#xA;     * dimensions of &lt;code>componentType&lt;/code>. In this case, the&#xA;     * component type of the new array is the component type of&#xA;     * &lt;code>componentType&lt;/code>.&#xA;     * &#xA;     * &lt;p>The number of dimensions of the new array must not&#xA;     * exceed the number of array dimensions supported by the&#xA;     * implementation (typically 255).&#xA;     *&#xA;     * @param componentType the &lt;code>Class&lt;/code> object representing the component&#xA;     * type of the new array&#xA;     * @param dimensions an array of &lt;code>int&lt;/code> types representing the dimensions of&#xA;     * the new array&#xA;     * @return the new array&#xA;     * @exception NullPointerException if the specified &#xA;     * &lt;code>componentType&lt;/code> argument is null&#xA;     * @exception IllegalArgumentException if the specified &lt;code>dimensions&lt;/code> &#xA;     * argument is a zero-dimensional array, or if the number of&#xA;     * requested dimensions exceeds the limit on the number of array dimensions &#xA;     * supported by the implementation (typically 255), or if componentType &#xA;     * is Void.TYPE.&#xA;     * @exception NegativeArraySizeException if any of the components in&#xA;     * the specified &lt;code>dimensions&lt;/code> argument is negative.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLength">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the length of the specified array object, as an &lt;code>int&lt;/code>.&#xA;     *&#xA;     * @param array the array&#xA;     * @return the length of the array&#xA;     * @exception IllegalArgumentException if the object argument is not&#xA;     * an array&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of the indexed component in the specified&#xA;     * array object.  The value is automatically wrapped in an object&#xA;     * if it has a primitive type.&#xA;     *&#xA;     * @param array the array&#xA;     * @param index the index&#xA;     * @return the (possibly wrapped) value of the indexed component in&#xA;     * the specified array&#xA;     * @exception NullPointerException If the specified object is null&#xA;     * @exception IllegalArgumentException If the specified object is not&#xA;     * an array&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to the&#xA;     * length of the specified array&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBoolean">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of the indexed component in the specified&#xA;     * array object, as a &lt;code>boolean&lt;/code>.&#xA;     *&#xA;     * @param array the array&#xA;     * @param index the index&#xA;     * @return the value of the indexed component in the specified array&#xA;     * @exception NullPointerException If the specified object is null&#xA;     * @exception IllegalArgumentException If the specified object is not&#xA;     * an array, or if the indexed element cannot be converted to the&#xA;     * return type by an identity or widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to the&#xA;     * length of the specified array&#xA;     * @see Array#get&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getByte">
      <typeReference xsi:type="types:Byte"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of the indexed component in the specified&#xA;     * array object, as a &lt;code>byte&lt;/code>.&#xA;     *&#xA;     * @param array the array&#xA;     * @param index the index&#xA;     * @return the value of the indexed component in the specified array&#xA;     * @exception NullPointerException If the specified object is null&#xA;     * @exception IllegalArgumentException If the specified object is not&#xA;     * an array, or if the indexed element cannot be converted to the&#xA;     * return type by an identity or widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to the&#xA;     * length of the specified array&#xA;     * @see Array#get&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getChar">
      <typeReference xsi:type="types:Char"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of the indexed component in the specified&#xA;     * array object, as a &lt;code>char&lt;/code>.&#xA;     *&#xA;     * @param array the array&#xA;     * @param index the index&#xA;     * @return the value of the indexed component in the specified array&#xA;     * @exception NullPointerException If the specified object is null&#xA;     * @exception IllegalArgumentException If the specified object is not&#xA;     * an array, or if the indexed element cannot be converted to the&#xA;     * return type by an identity or widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to the&#xA;     * length of the specified array&#xA;     * @see Array#get&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getShort">
      <typeReference xsi:type="types:Short"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of the indexed component in the specified&#xA;     * array object, as a &lt;code>short&lt;/code>.&#xA;     *&#xA;     * @param array the array&#xA;     * @param index the index&#xA;     * @return the value of the indexed component in the specified array&#xA;     * @exception NullPointerException If the specified object is null&#xA;     * @exception IllegalArgumentException If the specified object is not&#xA;     * an array, or if the indexed element cannot be converted to the&#xA;     * return type by an identity or widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to the&#xA;     * length of the specified array&#xA;     * @see Array#get&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getInt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of the indexed component in the specified&#xA;     * array object, as an &lt;code>int&lt;/code>.&#xA;     *&#xA;     * @param array the array&#xA;     * @param index the index&#xA;     * @return the value of the indexed component in the specified array&#xA;     * @exception NullPointerException If the specified object is null&#xA;     * @exception IllegalArgumentException If the specified object is not&#xA;     * an array, or if the indexed element cannot be converted to the&#xA;     * return type by an identity or widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to the&#xA;     * length of the specified array&#xA;     * @see Array#get&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLong">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of the indexed component in the specified&#xA;     * array object, as a &lt;code>long&lt;/code>.&#xA;     *&#xA;     * @param array the array&#xA;     * @param index the index&#xA;     * @return the value of the indexed component in the specified array&#xA;     * @exception NullPointerException If the specified object is null&#xA;     * @exception IllegalArgumentException If the specified object is not&#xA;     * an array, or if the indexed element cannot be converted to the&#xA;     * return type by an identity or widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to the&#xA;     * length of the specified array&#xA;     * @see Array#get&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFloat">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of the indexed component in the specified&#xA;     * array object, as a &lt;code>float&lt;/code>.&#xA;     *&#xA;     * @param array the array&#xA;     * @param index the index&#xA;     * @return the value of the indexed component in the specified array&#xA;     * @exception NullPointerException If the specified object is null&#xA;     * @exception IllegalArgumentException If the specified object is not&#xA;     * an array, or if the indexed element cannot be converted to the&#xA;     * return type by an identity or widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to the&#xA;     * length of the specified array&#xA;     * @see Array#get&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDouble">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of the indexed component in the specified&#xA;     * array object, as a &lt;code>double&lt;/code>.&#xA;     *&#xA;     * @param array the array&#xA;     * @param index the index&#xA;     * @return the value of the indexed component in the specified array&#xA;     * @exception NullPointerException If the specified object is null&#xA;     * @exception IllegalArgumentException If the specified object is not&#xA;     * an array, or if the indexed element cannot be converted to the&#xA;     * return type by an identity or widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to the&#xA;     * length of the specified array&#xA;     * @see Array#get&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="set">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the value of the indexed component of the specified array&#xA;     * object to the specified new value.  The new value is first&#xA;     * automatically unwrapped if the array has a primitive component&#xA;     * type.&#xA;     * @param array the array&#xA;     * @param index the index into the array&#xA;     * @param value the new value of the indexed component&#xA;     * @exception NullPointerException If the specified object argument&#xA;     * is null&#xA;     * @exception IllegalArgumentException If the specified object argument&#xA;     * is not an array, or if the array component type is primitive and&#xA;     * an unwrapping conversion fails&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to&#xA;     * the length of the specified array&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setBoolean">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="z">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the value of the indexed component of the specified array&#xA;     * object to the specified &lt;code>boolean&lt;/code> value.&#xA;     * @param array the array&#xA;     * @param index the index into the array&#xA;     * @param z the new value of the indexed component&#xA;     * @exception NullPointerException If the specified object argument&#xA;     * is null&#xA;     * @exception IllegalArgumentException If the specified object argument&#xA;     * is not an array, or if the specified value cannot be converted&#xA;     * to the underlying array's component type by an identity or a&#xA;     * primitive widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to&#xA;     * the length of the specified array&#xA;     * @see Array#set&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setByte">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the value of the indexed component of the specified array&#xA;     * object to the specified &lt;code>byte&lt;/code> value.&#xA;     * @param array the array&#xA;     * @param index the index into the array&#xA;     * @param b the new value of the indexed component&#xA;     * @exception NullPointerException If the specified object argument&#xA;     * is null&#xA;     * @exception IllegalArgumentException If the specified object argument&#xA;     * is not an array, or if the specified value cannot be converted&#xA;     * to the underlying array's component type by an identity or a&#xA;     * primitive widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to&#xA;     * the length of the specified array&#xA;     * @see Array#set&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setChar">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the value of the indexed component of the specified array&#xA;     * object to the specified &lt;code>char&lt;/code> value.&#xA;     * @param array the array&#xA;     * @param index the index into the array&#xA;     * @param c the new value of the indexed component&#xA;     * @exception NullPointerException If the specified object argument&#xA;     * is null&#xA;     * @exception IllegalArgumentException If the specified object argument&#xA;     * is not an array, or if the specified value cannot be converted&#xA;     * to the underlying array's component type by an identity or a&#xA;     * primitive widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to&#xA;     * the length of the specified array&#xA;     * @see Array#set&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setShort">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:Short"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the value of the indexed component of the specified array&#xA;     * object to the specified &lt;code>short&lt;/code> value.&#xA;     * @param array the array&#xA;     * @param index the index into the array&#xA;     * @param s the new value of the indexed component&#xA;     * @exception NullPointerException If the specified object argument&#xA;     * is null&#xA;     * @exception IllegalArgumentException If the specified object argument&#xA;     * is not an array, or if the specified value cannot be converted&#xA;     * to the underlying array's component type by an identity or a&#xA;     * primitive widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to&#xA;     * the length of the specified array&#xA;     * @see Array#set&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setInt">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the value of the indexed component of the specified array&#xA;     * object to the specified &lt;code>int&lt;/code> value.&#xA;     * @param array the array&#xA;     * @param index the index into the array&#xA;     * @param i the new value of the indexed component&#xA;     * @exception NullPointerException If the specified object argument&#xA;     * is null&#xA;     * @exception IllegalArgumentException If the specified object argument&#xA;     * is not an array, or if the specified value cannot be converted&#xA;     * to the underlying array's component type by an identity or a&#xA;     * primitive widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to&#xA;     * the length of the specified array&#xA;     * @see Array#set&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setLong">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the value of the indexed component of the specified array&#xA;     * object to the specified &lt;code>long&lt;/code> value.&#xA;     * @param array the array&#xA;     * @param index the index into the array&#xA;     * @param l the new value of the indexed component&#xA;     * @exception NullPointerException If the specified object argument&#xA;     * is null&#xA;     * @exception IllegalArgumentException If the specified object argument&#xA;     * is not an array, or if the specified value cannot be converted&#xA;     * to the underlying array's component type by an identity or a&#xA;     * primitive widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to&#xA;     * the length of the specified array&#xA;     * @see Array#set&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setFloat">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the value of the indexed component of the specified array&#xA;     * object to the specified &lt;code>float&lt;/code> value.&#xA;     * @param array the array&#xA;     * @param index the index into the array&#xA;     * @param f the new value of the indexed component&#xA;     * @exception NullPointerException If the specified object argument&#xA;     * is null&#xA;     * @exception IllegalArgumentException If the specified object argument&#xA;     * is not an array, or if the specified value cannot be converted&#xA;     * to the underlying array's component type by an identity or a&#xA;     * primitive widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to&#xA;     * the length of the specified array&#xA;     * @see Array#set&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setDouble">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the value of the indexed component of the specified array&#xA;     * object to the specified &lt;code>double&lt;/code> value.&#xA;     * @param array the array&#xA;     * @param index the index into the array&#xA;     * @param d the new value of the indexed component&#xA;     * @exception NullPointerException If the specified object argument&#xA;     * is null&#xA;     * @exception IllegalArgumentException If the specified object argument&#xA;     * is not an array, or if the specified value cannot be converted&#xA;     * to the underlying array's component type by an identity or a&#xA;     * primitive widening conversion&#xA;     * @exception ArrayIndexOutOfBoundsException If the specified &lt;code>index&lt;/code> &#xA;     * argument is negative, or if it is greater than or equal to&#xA;     * the length of the specified array&#xA;     * @see Array#set&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="newArray">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="componentType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Class.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NegativeArraySizeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/*&#xA;     * Private&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="multiNewArray">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="componentType">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Class.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dimensions">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NegativeArraySizeException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>Array&lt;/code> class provides static methods to dynamically create and&#xA; * access Java arrays.&#xA; *&#xA; * &lt;p>&lt;code>Array&lt;/code> permits widening conversions to occur during a get or set&#xA; * operation, but throws an &lt;code>IllegalArgumentException&lt;/code> if a narrowing&#xA; * conversion would occur.&#xA; *&#xA; * @author Nakul Saraiya&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Final"/>
  </classifiers>
</containers:CompilationUnit>
