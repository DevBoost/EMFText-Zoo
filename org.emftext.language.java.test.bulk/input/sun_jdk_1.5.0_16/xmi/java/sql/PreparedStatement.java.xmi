<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:annotations="http://www.emftext.org/java/annotations" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/annotations ../../java.ecore#/0 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="PreparedStatement.java">
  <comments>/*&#xA; * @(#)PreparedStatement.java&#x9;1.44 04/05/18&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>sql</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>math</namespaces>
    <classifier xsi:type="classifiers:Class" href="../math/BigDecimal.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="PreparedStatement">
    <members xsi:type="members:InterfaceMethod" name="executeQuery">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Executes the SQL query in this &lt;code>PreparedStatement&lt;/code> object&#xA;     * and returns the &lt;code>ResultSet&lt;/code> object generated by the query.&#xA;     *&#xA;     * @return a &lt;code>ResultSet&lt;/code> object that contains the data produced by the&#xA;     *         query; never &lt;code>null&lt;/code>&#xA;     * @exception SQLException if a database access error occurs or the SQL&#xA;     *            statement does not return a &lt;code>ResultSet&lt;/code> object&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="executeUpdate">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Executes the SQL statement in this &lt;code>PreparedStatement&lt;/code> object,&#xA;     * which must be an SQL &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code> or&#xA;     * &lt;code>DELETE&lt;/code> statement; or an SQL statement that returns nothing, &#xA;     * such as a DDL statement.&#xA;     *&#xA;     * @return either (1) the row count for &lt;code>INSERT&lt;/code>, &lt;code>UPDATE&lt;/code>,&#xA;     *         or &lt;code>DELETE&lt;/code> statements&#xA;     *         or (2) 0 for SQL statements that return nothing&#xA;     * @exception SQLException if a database access error occurs or the SQL&#xA;     *            statement returns a &lt;code>ResultSet&lt;/code> object&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setNull">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to SQL &lt;code>NULL&lt;/code>.&#xA;     *&#xA;     * &lt;P>&lt;B>Note:&lt;/B> You must specify the parameter's SQL type.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param sqlType the SQL type code defined in &lt;code>java.sql.Types&lt;/code>&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setBoolean">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>boolean&lt;/code> value.&#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>BIT&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setByte">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>byte&lt;/code> value.  &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>TINYINT&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Byte"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setShort">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>short&lt;/code> value. &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>SMALLINT&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Short"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setInt">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>int&lt;/code> value.  &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>INTEGER&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setLong">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>long&lt;/code> value. &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>BIGINT&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setFloat">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>float&lt;/code> value. &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>FLOAT&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setDouble">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>double&lt;/code> value.  &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>DOUBLE&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setBigDecimal">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.math.BigDecimal&lt;/code> value.  &#xA;     * The driver converts this to an SQL &lt;code>NUMERIC&lt;/code> value when&#xA;     * it sends it to the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../math/BigDecimal.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setString">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>String&lt;/code> value. &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>VARCHAR&lt;/code> or &lt;code>LONGVARCHAR&lt;/code> value&#xA;     * (depending on the argument's&#xA;     * size relative to the driver's limits on &lt;code>VARCHAR&lt;/code> values)&#xA;     * when it sends it to the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setBytes">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java array of bytes.  The driver converts&#xA;     * this to an SQL &lt;code>VARBINARY&lt;/code> or &lt;code>LONGVARBINARY&lt;/code>&#xA;     * (depending on the argument's size relative to the driver's limits on&#xA;     * &lt;code>VARBINARY&lt;/code> values) when it sends it to the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setDate">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.sql.Date&lt;/code> value.  &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>DATE&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>sql</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setTime">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.sql.Time&lt;/code> value.  &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>TIME&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>sql</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Time.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setTimestamp">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.sql.Timestamp&lt;/code> value.  &#xA;     * The driver&#xA;     * converts this to an SQL &lt;code>TIMESTAMP&lt;/code> value when it sends it to the&#xA;     * database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>sql</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Timestamp.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setAsciiStream">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given input stream, which will have &#xA;     * the specified number of bytes.&#xA;     * When a very large ASCII value is input to a &lt;code>LONGVARCHAR&lt;/code>&#xA;     * parameter, it may be more practical to send it via a&#xA;     * &lt;code>java.io.InputStream&lt;/code>. Data will be read from the stream&#xA;     * as needed until end-of-file is reached.  The JDBC driver will&#xA;     * do any necessary conversion from ASCII to the database char format.&#xA;     * &#xA;     * &lt;P>&lt;B>Note:&lt;/B> This stream object can either be a standard&#xA;     * Java stream object or your own subclass that implements the&#xA;     * standard interface.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the Java input stream that contains the ASCII parameter value&#xA;     * @param length the number of bytes in the stream &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setUnicodeStream">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Sets the designated parameter to the given input stream, which &#xA;     * will have the specified number of bytes. A Unicode character has&#xA;     * two bytes, with the first byte being the high byte, and the second&#xA;     * being the low byte.&#xA;     *&#xA;     * When a very large Unicode value is input to a &lt;code>LONGVARCHAR&lt;/code>&#xA;     * parameter, it may be more practical to send it via a&#xA;     * &lt;code>java.io.InputStream&lt;/code> object. The data will be read from the &#xA;     * stream as needed until end-of-file is reached.  The JDBC driver will&#xA;     * do any necessary conversion from Unicode to the database char format.&#xA;     * &#xA;     * &lt;P>&lt;B>Note:&lt;/B> This stream object can either be a standard&#xA;     * Java stream object or your own subclass that implements the&#xA;     * standard interface.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...  &#xA;     * @param x a &lt;code>java.io.InputStream&lt;/code> object that contains the&#xA;     *        Unicode parameter value as two-byte Unicode characters&#xA;     * @param length the number of bytes in the stream &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @deprecated&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="../lang/Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setBinaryStream">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given input stream, which will have &#xA;     * the specified number of bytes.&#xA;     * When a very large binary value is input to a &lt;code>LONGVARBINARY&lt;/code>&#xA;     * parameter, it may be more practical to send it via a&#xA;     * &lt;code>java.io.InputStream&lt;/code> object. The data will be read from the &#xA;     * stream as needed until end-of-file is reached.&#xA;     * &#xA;     * &lt;P>&lt;B>Note:&lt;/B> This stream object can either be a standard&#xA;     * Java stream object or your own subclass that implements the&#xA;     * standard interface.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the java input stream which contains the binary parameter value&#xA;     * @param length the number of bytes in the stream &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="clearParameters">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Clears the current parameter values immediately.&#xA;     * &lt;P>In general, parameter values remain in force for repeated use of a&#xA;     * statement. Setting a parameter value automatically clears its&#xA;     * previous value.  However, in some cases it is useful to immediately&#xA;     * release the resources used by the current parameter values; this can&#xA;     * be done by calling the method &lt;code>clearParameters&lt;/code>.&#xA;     *&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setObject">
      <typeReference xsi:type="types:Void">
        <comments>//----------------------------------------------------------------------</comments>
        <comments>// Advanced features:</comments>
        <comments>/**&#xA;     * &lt;p>Sets the value of the designated parameter with the given object. The second&#xA;     * argument must be an object type; for integral values, the&#xA;     * &lt;code>java.lang&lt;/code> equivalent objects should be used.&#xA;     *&#xA;     * &lt;p>The given Java object will be converted to the given targetSqlType&#xA;     * before being sent to the database.&#xA;     *&#xA;     * If the object has a custom mapping (is of a class implementing the &#xA;     * interface &lt;code>SQLData&lt;/code>),&#xA;     * the JDBC driver should call the method &lt;code>SQLData.writeSQL&lt;/code> to &#xA;     * write it to the SQL data stream.&#xA;     * If, on the other hand, the object is of a class implementing&#xA;     * &lt;code>Ref&lt;/code>, &lt;code>Blob&lt;/code>, &lt;code>Clob&lt;/code>, &lt;code>Struct&lt;/code>, &#xA;     * or &lt;code>Array&lt;/code>, the driver should pass it to the database as a &#xA;     * value of the corresponding SQL type.&#xA;     *&#xA;     * &lt;p>Note that this method may be used to pass database-specific&#xA;     * abstract data types. &#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the object containing the input parameter value&#xA;     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be &#xA;     * sent to the database. The scale argument may further qualify this type.&#xA;     * @param scale for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types,&#xA;     *          this is the number of digits after the decimal point.  For all other&#xA;     *          types, this value will be ignored.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Types &#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="targetSqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setObject">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;    * Sets the value of the designated parameter with the given object.&#xA;    * This method is like the method &lt;code>setObject&lt;/code>&#xA;    * above, except that it assumes a scale of zero.&#xA;    *&#xA;    * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;    * @param x the object containing the input parameter value&#xA;    * @param targetSqlType the SQL type (as defined in java.sql.Types) to be &#xA;    *                      sent to the database&#xA;    * @exception SQLException if a database access error occurs&#xA;    */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="targetSqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setObject">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * &lt;p>Sets the value of the designated parameter using the given object. &#xA;     * The second parameter must be of type &lt;code>Object&lt;/code>; therefore, the&#xA;     * &lt;code>java.lang&lt;/code> equivalent objects should be used for built-in types.&#xA;     *&#xA;     * &lt;p>The JDBC specification specifies a standard mapping from&#xA;     * Java &lt;code>Object&lt;/code> types to SQL types.  The given argument &#xA;     * will be converted to the corresponding SQL type before being&#xA;     * sent to the database.&#xA;     *&#xA;     * &lt;p>Note that this method may be used to pass datatabase-&#xA;     * specific abstract data types, by using a driver-specific Java&#xA;     * type.&#xA;     *&#xA;     * If the object is of a class implementing the interface &lt;code>SQLData&lt;/code>,&#xA;     * the JDBC driver should call the method &lt;code>SQLData.writeSQL&lt;/code>&#xA;     * to write it to the SQL data stream.&#xA;     * If, on the other hand, the object is of a class implementing&#xA;     * &lt;code>Ref&lt;/code>, &lt;code>Blob&lt;/code>, &lt;code>Clob&lt;/code>, &lt;code>Struct&lt;/code>, &#xA;     * or &lt;code>Array&lt;/code>, the driver should pass it to the database as a &#xA;     * value of the corresponding SQL type.&#xA;     * &lt;P>&#xA;     * This method throws an exception if there is an ambiguity, for example, if the&#xA;     * object is of a class implementing more than one of the interfaces named above.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the object containing the input parameter value &#xA;     * @exception SQLException if a database access error occurs or the type &#xA;     *            of the given object is ambiguous&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="execute">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Executes the SQL statement in this &lt;code>PreparedStatement&lt;/code> object,&#xA;     * which may be any kind of SQL statement.&#xA;     * Some prepared statements return multiple results; the &lt;code>execute&lt;/code>&#xA;     * method handles these complex statements as well as the simpler&#xA;     * form of statements handled by the methods &lt;code>executeQuery&lt;/code>&#xA;     * and &lt;code>executeUpdate&lt;/code>.&#xA;     * &lt;P>&#xA;     * The &lt;code>execute&lt;/code> method returns a &lt;code>boolean&lt;/code> to&#xA;     * indicate the form of the first result.  You must call either the method&#xA;     * &lt;code>getResultSet&lt;/code> or &lt;code>getUpdateCount&lt;/code>&#xA;     * to retrieve the result; you must call &lt;code>getMoreResults&lt;/code> to&#xA;     * move to any subsequent result(s).&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if the first result is a &lt;code>ResultSet&lt;/code>&#xA;     *         object; &lt;code>false&lt;/code> if the first result is an update&#xA;     *         count or there is no result&#xA;     * @exception SQLException if a database access error occurs or an argument&#xA;     *            is supplied to this method&#xA;     * @see Statement#execute&#xA;     * @see Statement#getResultSet&#xA;     * @see Statement#getUpdateCount&#xA;     * @see Statement#getMoreResults&#xA;&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addBatch">
      <typeReference xsi:type="types:Void">
        <comments>//--------------------------JDBC 2.0-----------------------------</comments>
        <comments>/**&#xA;     * Adds a set of parameters to this &lt;code>PreparedStatement&lt;/code>&#xA;     * object's batch of commands.&#xA;     * &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Statement#addBatch&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setCharacterStream">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>Reader&lt;/code>&#xA;     * object, which is the given number of characters long.&#xA;     * When a very large UNICODE value is input to a &lt;code>LONGVARCHAR&lt;/code>&#xA;     * parameter, it may be more practical to send it via a&#xA;     * &lt;code>java.io.Reader&lt;/code> object. The data will be read from the stream&#xA;     * as needed until end-of-file is reached.  The JDBC driver will&#xA;     * do any necessary conversion from UNICODE to the database char format.&#xA;     * &#xA;     * &lt;P>&lt;B>Note:&lt;/B> This stream object can either be a standard&#xA;     * Java stream object or your own subclass that implements the&#xA;     * standard interface.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param reader the &lt;code>java.io.Reader&lt;/code> object that contains the &#xA;     *        Unicode data&#xA;     * @param length the number of characters in the stream &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="reader">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/Reader.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setRef">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given&#xA;     *  &lt;code>REF(&amp;lt;structured-type&amp;gt;)&lt;/code> value.&#xA;     * The driver converts this to an SQL &lt;code>REF&lt;/code> value when it&#xA;     * sends it to the database.&#xA;     *&#xA;     * @param i the first parameter is 1, the second is 2, ...&#xA;     * @param x an SQL &lt;code>REF&lt;/code> value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Ref.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setBlob">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>Blob&lt;/code> object.&#xA;     * The driver converts this to an SQL &lt;code>BLOB&lt;/code> value when it&#xA;     * sends it to the database.&#xA;     *&#xA;     * @param i the first parameter is 1, the second is 2, ...&#xA;     * @param x a &lt;code>Blob&lt;/code> object that maps an SQL &lt;code>BLOB&lt;/code> value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Blob.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setClob">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>Clob&lt;/code> object.&#xA;     * The driver converts this to an SQL &lt;code>CLOB&lt;/code> value when it&#xA;     * sends it to the database.&#xA;     *&#xA;     * @param i the first parameter is 1, the second is 2, ...&#xA;     * @param x a &lt;code>Clob&lt;/code> object that maps an SQL &lt;code>CLOB&lt;/code> value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Clob.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setArray">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>Array&lt;/code> object.&#xA;     * The driver converts this to an SQL &lt;code>ARRAY&lt;/code> value when it&#xA;     * sends it to the database.&#xA;     *&#xA;     * @param i the first parameter is 1, the second is 2, ...&#xA;     * @param x an &lt;code>Array&lt;/code> object that maps an SQL &lt;code>ARRAY&lt;/code> value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Array.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMetaData">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a &lt;code>ResultSetMetaData&lt;/code> object that contains&#xA;     * information about the columns of the &lt;code>ResultSet&lt;/code> object&#xA;     * that will be returned when this &lt;code>PreparedStatement&lt;/code> object &#xA;     * is executed.&#xA;     * &lt;P>&#xA;     * Because a &lt;code>PreparedStatement&lt;/code> object is precompiled, it is&#xA;     * possible to know about the &lt;code>ResultSet&lt;/code> object that it will&#xA;     * return without having to execute it.  Consequently, it is possible&#xA;     * to invoke the method &lt;code>getMetaData&lt;/code> on a&#xA;     * &lt;code>PreparedStatement&lt;/code> object rather than waiting to execute&#xA;     * it and then invoking the &lt;code>ResultSet.getMetaData&lt;/code> method&#xA;     * on the &lt;code>ResultSet&lt;/code> object that is returned.&#xA;     * &lt;P>&#xA;     * &lt;B>NOTE:&lt;/B> Using this method may be expensive for some drivers due&#xA;     * to the lack of underlying DBMS support.&#xA;     *&#xA;     * @return the description of a &lt;code>ResultSet&lt;/code> object's columns or&#xA;     *         &lt;code>null&lt;/code> if the driver cannot return a&#xA;     *         &lt;code>ResultSetMetaData&lt;/code> object&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSetMetaData.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setDate">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.sql.Date&lt;/code> value,&#xA;     * using the given &lt;code>Calendar&lt;/code> object.  The driver uses&#xA;     * the &lt;code>Calendar&lt;/code> object to construct an SQL &lt;code>DATE&lt;/code> value,&#xA;     * which the driver then sends to the database.  With &#xA;     * a &lt;code>Calendar&lt;/code> object, the driver can calculate the date&#xA;     * taking into account a custom timezone.  If no&#xA;     * &lt;code>Calendar&lt;/code> object is specified, the driver uses the default&#xA;     * timezone, which is that of the virtual machine running the application.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value&#xA;     * @param cal the &lt;code>Calendar&lt;/code> object the driver will use&#xA;     *            to construct the date&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>sql</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setTime">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.sql.Time&lt;/code> value,&#xA;     * using the given &lt;code>Calendar&lt;/code> object.  The driver uses&#xA;     * the &lt;code>Calendar&lt;/code> object to construct an SQL &lt;code>TIME&lt;/code> value,&#xA;     * which the driver then sends to the database.  With &#xA;     * a &lt;code>Calendar&lt;/code> object, the driver can calculate the time&#xA;     * taking into account a custom timezone.  If no&#xA;     * &lt;code>Calendar&lt;/code> object is specified, the driver uses the default&#xA;     * timezone, which is that of the virtual machine running the application.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value&#xA;     * @param cal the &lt;code>Calendar&lt;/code> object the driver will use&#xA;     *            to construct the time&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>sql</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Time.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setTimestamp">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.sql.Timestamp&lt;/code> value,&#xA;     * using the given &lt;code>Calendar&lt;/code> object.  The driver uses&#xA;     * the &lt;code>Calendar&lt;/code> object to construct an SQL &lt;code>TIMESTAMP&lt;/code> value,&#xA;     * which the driver then sends to the database.  With a&#xA;     *  &lt;code>Calendar&lt;/code> object, the driver can calculate the timestamp&#xA;     * taking into account a custom timezone.  If no&#xA;     * &lt;code>Calendar&lt;/code> object is specified, the driver uses the default&#xA;     * timezone, which is that of the virtual machine running the application.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the parameter value &#xA;     * @param cal the &lt;code>Calendar&lt;/code> object the driver will use&#xA;     *            to construct the timestamp&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>sql</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Timestamp.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setNull">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to SQL &lt;code>NULL&lt;/code>.&#xA;     * This version of the method &lt;code>setNull&lt;/code> should&#xA;     * be used for user-defined types and REF type parameters.  Examples&#xA;     * of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and &#xA;     * named array types.&#xA;     *&#xA;     * &lt;P>&lt;B>Note:&lt;/B> To be portable, applications must give the&#xA;     * SQL type code and the fully-qualified SQL type name when specifying&#xA;     * a NULL user-defined or REF parameter.  In the case of a user-defined type &#xA;     * the name is the type name of the parameter itself.  For a REF &#xA;     * parameter, the name is the type name of the referenced type.  If &#xA;     * a JDBC driver does not need the type code or type name information, &#xA;     * it may ignore it.     &#xA;     *&#xA;     * Although it is intended for user-defined and Ref parameters,&#xA;     * this method may be used to set a null parameter of any JDBC type.&#xA;     * If the parameter does not have a user-defined or REF type, the given&#xA;     * typeName is ignored.&#xA;     *&#xA;     *&#xA;     * @param paramIndex the first parameter is 1, the second is 2, ...&#xA;     * @param sqlType a value from &lt;code>java.sql.Types&lt;/code>&#xA;     * @param typeName the fully-qualified name of an SQL user-defined type;&#xA;     *  ignored if the parameter is not a user-defined type or REF &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="paramIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="typeName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setURL">
      <typeReference xsi:type="types:Void">
        <comments>//------------------------- JDBC 3.0 -----------------------------------</comments>
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.net.URL&lt;/code> value. &#xA;     * The driver converts this to an SQL &lt;code>DATALINK&lt;/code> value&#xA;     * when it sends it to the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, ...&#xA;     * @param x the &lt;code>java.net.URL&lt;/code> object to be set&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>net</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../net/URL.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getParameterMetaData">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the number, types and properties of this &#xA;     * &lt;code>PreparedStatement&lt;/code> object's parameters.&#xA;     *&#xA;     * @return a &lt;code>ParameterMetaData&lt;/code> object that contains information&#xA;     *         about the number, types and properties of this &#xA;     *         &lt;code>PreparedStatement&lt;/code> object's parameters&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see ParameterMetaData&#xA;     * @since 1.4&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ParameterMetaData.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * An object that represents a precompiled SQL statement.&#xA; * &lt;P>A SQL statement is precompiled and stored in a&#xA; * &lt;code>PreparedStatement&lt;/code> object. This object can then be used to&#xA; * efficiently execute this statement multiple times. &#xA; *&#xA; * &lt;P>&lt;B>Note:&lt;/B> The setter methods (&lt;code>setShort&lt;/code>, &lt;code>setString&lt;/code>,&#xA; * and so on) for setting IN parameter values&#xA; * must specify types that are compatible with the defined SQL type of&#xA; * the input parameter. For instance, if the IN parameter has SQL type&#xA; * &lt;code>INTEGER&lt;/code>, then the method &lt;code>setInt&lt;/code> should be used.&#xA; *&#xA; * &lt;p>If arbitrary parameter type conversions are required, the method&#xA; * &lt;code>setObject&lt;/code> should be used with a target SQL type.&#xA; * &lt;P>&#xA; * In the following example of setting a parameter, &lt;code>con&lt;/code> represents&#xA; * an active connection:  &#xA; * &lt;PRE>&#xA; *   PreparedStatement pstmt = con.prepareStatement(&quot;UPDATE EMPLOYEES&#xA; *                                     SET SALARY = ? WHERE ID = ?&quot;);&#xA; *   pstmt.setBigDecimal(1, 153833.00)&#xA; *   pstmt.setInt(2, 110592)&#xA; * &lt;/PRE>&#xA; *&#xA; * @see Connection#prepareStatement&#xA; * @see ResultSet &#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Statement.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
