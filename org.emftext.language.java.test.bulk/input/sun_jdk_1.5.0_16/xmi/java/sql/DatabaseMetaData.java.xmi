<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="DatabaseMetaData.java">
  <comments>/*&#xA; * @(#)DatabaseMetaData.java&#x9;1.53 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>sql</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="DatabaseMetaData">
    <members xsi:type="members:InterfaceMethod" name="allProceduresAreCallable">
      <typeReference xsi:type="types:Boolean">
        <comments>//----------------------------------------------------------------------</comments>
        <comments>// First, a variety of minor information about the target database.</comments>
        <comments>/**&#xA;     * Retrieves whether the current user can call all the procedures &#xA;     * returned by the method &lt;code>getProcedures&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="allTablesAreSelectable">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether the current user can use all the tables returned &#xA;     * by the method &lt;code>getTables&lt;/code> in a &lt;code>SELECT&lt;/code> &#xA;     * statement.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getURL">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the URL for this DBMS.&#xA;     *&#xA;     * @return the URL for this DBMS or &lt;code>null&lt;/code> if it cannot be &#xA;     *          generated&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getUserName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the user name as known to this database.&#xA;     *&#xA;     * @return the database user name&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isReadOnly">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database is in read-only mode.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="nullsAreSortedHigh">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether &lt;code>NULL&lt;/code> values are sorted high.&#xA;     * Sorted high means that &lt;code>NULL&lt;/code> values&#xA;     * sort higher than any other value in a domain.  In an ascending order,&#xA;     * if this method returns &lt;code>true&lt;/code>,  &lt;code>NULL&lt;/code> values&#xA;     * will appear at the end. By contrast, the method &#xA;     * &lt;code>nullsAreSortedAtEnd&lt;/code> indicates whether &lt;code>NULL&lt;/code> values&#xA;     * are sorted at the end regardless of sort order.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="nullsAreSortedLow">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether &lt;code>NULL&lt;/code> values are sorted low.&#xA;     * Sorted low means that &lt;code>NULL&lt;/code> values&#xA;     * sort lower than any other value in a domain.  In an ascending order,&#xA;     * if this method returns &lt;code>true&lt;/code>,  &lt;code>NULL&lt;/code> values&#xA;     * will appear at the beginning. By contrast, the method &#xA;     * &lt;code>nullsAreSortedAtStart&lt;/code> indicates whether &lt;code>NULL&lt;/code> values&#xA;     * are sorted at the beginning regardless of sort order.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="nullsAreSortedAtStart">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether &lt;code>NULL&lt;/code> values are sorted at the start regardless &#xA;     * of sort order.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="nullsAreSortedAtEnd">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether &lt;code>NULL&lt;/code> values are sorted at the end regardless of &#xA;     * sort order.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDatabaseProductName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the name of this database product.&#xA;     *&#xA;     * @return database product name&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDatabaseProductVersion">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the version number of this database product.&#xA;     *&#xA;     * @return database version number&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDriverName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the name of this JDBC driver.&#xA;     *&#xA;     * @return JDBC driver name&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDriverVersion">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the version number of this JDBC driver as a &lt;code>String&lt;/code>.&#xA;     *&#xA;     * @return JDBC driver version&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDriverMajorVersion">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves this JDBC driver's major version number.&#xA;     *&#xA;     * @return JDBC driver major version&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDriverMinorVersion">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves this JDBC driver's minor version number.&#xA;     *&#xA;     * @return JDBC driver minor version number&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="usesLocalFiles">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database stores tables in a local file.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="usesLocalFilePerTable">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database uses a file for each table.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if this database uses a local file for each table;&#xA;     *         &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsMixedCaseIdentifiers">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database treats mixed case unquoted SQL identifiers as&#xA;     * case sensitive and as a result stores them in mixed case.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="storesUpperCaseIdentifiers">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database treats mixed case unquoted SQL identifiers as&#xA;     * case insensitive and stores them in upper case.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="storesLowerCaseIdentifiers">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database treats mixed case unquoted SQL identifiers as&#xA;     * case insensitive and stores them in lower case.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="storesMixedCaseIdentifiers">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database treats mixed case unquoted SQL identifiers as&#xA;     * case insensitive and stores them in mixed case.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsMixedCaseQuotedIdentifiers">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database treats mixed case quoted SQL identifiers as&#xA;     * case sensitive and as a result stores them in mixed case.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="storesUpperCaseQuotedIdentifiers">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database treats mixed case quoted SQL identifiers as&#xA;     * case insensitive and stores them in upper case.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="storesLowerCaseQuotedIdentifiers">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database treats mixed case quoted SQL identifiers as&#xA;     * case insensitive and stores them in lower case.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="storesMixedCaseQuotedIdentifiers">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database treats mixed case quoted SQL identifiers as&#xA;     * case insensitive and stores them in mixed case.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getIdentifierQuoteString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the string used to quote SQL identifiers.&#xA;     * This method returns a space &quot; &quot; if identifier quoting is not supported.&#xA;     *&#xA;     * @return the quoting string or a space if quoting is not supported&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSQLKeywords">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a comma-separated list of all of this database's SQL keywords&#xA;     * that are NOT also SQL92 keywords.&#xA;     *&#xA;     * @return the list of this database's keywords that are not also&#xA;     *         SQL92 keywords&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNumericFunctions">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a comma-separated list of math functions available with&#xA;     * this database.  These are the Open /Open CLI math function names used in &#xA;     * the JDBC function escape clause.&#xA;     *&#xA;     * @return the list of math functions supported by this database&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getStringFunctions">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a comma-separated list of string functions available with&#xA;     * this database.  These are the  Open Group CLI string function names used &#xA;     * in the JDBC function escape clause.&#xA;     *&#xA;     * @return the list of string functions supported by this database &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSystemFunctions">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a comma-separated list of system functions available with&#xA;     * this database.  These are the  Open Group CLI system function names used &#xA;     * in the JDBC function escape clause.&#xA;     *&#xA;     * @return a list of system functions supported by this database&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTimeDateFunctions">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a comma-separated list of the time and date functions available &#xA;     * with this database.&#xA;     *&#xA;     * @return the list of time and date functions supported by this database&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSearchStringEscape">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the string that can be used to escape wildcard characters.&#xA;     * This is the string that can be used to escape '_' or '%' in&#xA;     * the catalog search parameters that are a pattern (and therefore use one&#xA;     * of the wildcard characters).&#xA;     *&#xA;     * &lt;P>The '_' character represents any single character;&#xA;     * the '%' character represents any sequence of zero or &#xA;     * more characters.&#xA;     *&#xA;     * @return the string used to escape wildcard characters&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getExtraNameCharacters">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves all the &quot;extra&quot; characters that can be used in unquoted&#xA;     * identifier names (those beyond a-z, A-Z, 0-9 and _).&#xA;     *&#xA;     * @return the string containing the extra characters &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsAlterTableWithAddColumn">
      <typeReference xsi:type="types:Boolean">
        <comments>//--------------------------------------------------------------------</comments>
        <comments>// Functions describing which features are supported.</comments>
        <comments>/**&#xA;     * Retrieves whether this database supports &lt;code>ALTER TABLE&lt;/code>&#xA;     * with add column.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsAlterTableWithDropColumn">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports &lt;code>ALTER TABLE&lt;/code>&#xA;     * with drop column.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsColumnAliasing">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports column aliasing.&#xA;     *&#xA;     * &lt;P>If so, the SQL AS clause can be used to provide names for&#xA;     * computed columns or to provide alias names for columns as&#xA;     * required.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="nullPlusNonNullIsNull">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports concatenations between &#xA;     * &lt;code>NULL&lt;/code> and non-&lt;code>NULL&lt;/code> values being &#xA;     * &lt;code>NULL&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsConvert">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports the &lt;code>CONVERT&lt;/code>&#xA;     * function between SQL types.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsConvert">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports the &lt;code>CONVERT&lt;/code>&#xA;     * for two given SQL types.&#xA;     *&#xA;     * @param fromType the type to convert from; one of the type codes from&#xA;     *        the class &lt;code>java.sql.Types&lt;/code>&#xA;     * @param toType the type to convert to; one of the type codes from &#xA;     *        the class &lt;code>java.sql.Types&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Types&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsTableCorrelationNames">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports table correlation names.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsDifferentTableCorrelationNames">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether, when table correlation names are supported, they &#xA;     * are restricted to being different from the names of the tables.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsExpressionsInOrderBy">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports expressions in &#xA;     * &lt;code>ORDER BY&lt;/code> lists.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsOrderByUnrelated">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports using a column that is&#xA;     * not in the &lt;code>SELECT&lt;/code> statement in an&#xA;     * &lt;code>ORDER BY&lt;/code> clause.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsGroupBy">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports some form of &#xA;     * &lt;code>GROUP BY&lt;/code> clause.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsGroupByUnrelated">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports using a column that is&#xA;     * not in the &lt;code>SELECT&lt;/code> statement in a&#xA;     * &lt;code>GROUP BY&lt;/code> clause.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsGroupByBeyondSelect">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports using columns not included in&#xA;     * the &lt;code>SELECT&lt;/code> statement in a &lt;code>GROUP BY&lt;/code> clause &#xA;     * provided that all of the columns in the &lt;code>SELECT&lt;/code> statement&#xA;     * are included in the &lt;code>GROUP BY&lt;/code> clause.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsLikeEscapeClause">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports specifying a&#xA;     * &lt;code>LIKE&lt;/code> escape clause.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsMultipleResultSets">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports getting multiple &#xA;     * &lt;code>ResultSet&lt;/code> objects from a single call to the&#xA;     * method &lt;code>execute&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsMultipleTransactions">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database allows having multiple &#xA;     * transactions open at once (on different connections).&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsNonNullableColumns">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether columns in this database may be defined as non-nullable.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsMinimumSQLGrammar">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports the ODBC Minimum SQL grammar.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsCoreSQLGrammar">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports the ODBC Core SQL grammar.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsExtendedSQLGrammar">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports the ODBC Extended SQL grammar.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsANSI92EntryLevelSQL">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports the ANSI92 entry level SQL &#xA;     * grammar.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsANSI92IntermediateSQL">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports the ANSI92 intermediate SQL grammar supported.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsANSI92FullSQL">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports the ANSI92 full SQL grammar supported.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsIntegrityEnhancementFacility">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports the SQL Integrity &#xA;     * Enhancement Facility.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsOuterJoins">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports some form of outer join.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsFullOuterJoins">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports full nested outer joins.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsLimitedOuterJoins">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database provides limited support for outer &#xA;     * joins.  (This will be &lt;code>true&lt;/code> if the method &#xA;     * &lt;code>supportsFullOuterJoins&lt;/code> returns &lt;code>true&lt;/code>).&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSchemaTerm">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the database vendor's preferred term for &quot;schema&quot;.&#xA;     *&#xA;     * @return the vendor term for &quot;schema&quot;&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getProcedureTerm">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the database vendor's preferred term for &quot;procedure&quot;.&#xA;     *&#xA;     * @return the vendor term for &quot;procedure&quot;&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCatalogTerm">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the database vendor's preferred term for &quot;catalog&quot;.&#xA;     *&#xA;     * @return the vendor term for &quot;catalog&quot;&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isCatalogAtStart">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a catalog appears at the start of a fully qualified &#xA;     * table name.  If not, the catalog appears at the end.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if the catalog name appears at the beginning&#xA;     *         of a fully qualified table name; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCatalogSeparator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the &lt;code>String&lt;/code> that this database uses as the &#xA;     * separator between a catalog and table name.&#xA;     *&#xA;     * @return the separator string&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsSchemasInDataManipulation">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a schema name can be used in a data manipulation statement.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsSchemasInProcedureCalls">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a schema name can be used in a procedure call statement.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsSchemasInTableDefinitions">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a schema name can be used in a table definition statement.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsSchemasInIndexDefinitions">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a schema name can be used in an index definition statement.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsSchemasInPrivilegeDefinitions">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a schema name can be used in a privilege definition statement.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsCatalogsInDataManipulation">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a catalog name can be used in a data manipulation statement.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsCatalogsInProcedureCalls">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a catalog name can be used in a procedure call statement.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsCatalogsInTableDefinitions">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a catalog name can be used in a table definition statement.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsCatalogsInIndexDefinitions">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a catalog name can be used in an index definition statement.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsCatalogsInPrivilegeDefinitions">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a catalog name can be used in a privilege definition statement.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsPositionedDelete">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports positioned &lt;code>DELETE&lt;/code>&#xA;     * statements.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsPositionedUpdate">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports positioned &lt;code>UPDATE&lt;/code>&#xA;     * statements.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsSelectForUpdate">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports &lt;code>SELECT FOR UPDATE&lt;/code>&#xA;     * statements.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsStoredProcedures">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports stored procedure calls &#xA;     * that use the stored procedure escape syntax.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsSubqueriesInComparisons">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports subqueries in comparison &#xA;     * expressions.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsSubqueriesInExists">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports subqueries in &#xA;     * &lt;code>EXISTS&lt;/code> expressions.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsSubqueriesInIns">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports subqueries in &#xA;     * &lt;code>IN&lt;/code> statements.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsSubqueriesInQuantifieds">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports subqueries in quantified &#xA;     * expressions.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsCorrelatedSubqueries">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports correlated subqueries.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsUnion">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports SQL &lt;code>UNION&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsUnionAll">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports SQL &lt;code>UNION ALL&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsOpenCursorsAcrossCommit">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports keeping cursors open &#xA;     * across commits. &#xA;     * &#xA;     * @return &lt;code>true&lt;/code> if cursors always remain open;&#xA;     *       &lt;code>false&lt;/code> if they might not remain open&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsOpenCursorsAcrossRollback">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports keeping cursors open &#xA;     * across rollbacks.&#xA;     * &#xA;     * @return &lt;code>true&lt;/code> if cursors always remain open;&#xA;     *       &lt;code>false&lt;/code> if they might not remain open&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsOpenStatementsAcrossCommit">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports keeping statements open &#xA;     * across commits.&#xA;     * &#xA;     * @return &lt;code>true&lt;/code> if statements always remain open;&#xA;     *       &lt;code>false&lt;/code> if they might not remain open&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsOpenStatementsAcrossRollback">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports keeping statements open &#xA;     * across rollbacks.&#xA;     * &#xA;     * @return &lt;code>true&lt;/code> if statements always remain open;&#xA;     *       &lt;code>false&lt;/code> if they might not remain open&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxBinaryLiteralLength">
      <typeReference xsi:type="types:Int">
        <comments>//----------------------------------------------------------------------</comments>
        <comments>// The following group of methods exposes various limitations </comments>
        <comments>// based on the target database with the current driver.</comments>
        <comments>// Unless otherwise specified, a result of zero means there is no</comments>
        <comments>// limit, or the limit is not known.</comments>
        <comments>/**&#xA;     * Retrieves the maximum number of hex characters this database allows in an &#xA;     * inline binary literal.&#xA;     *&#xA;     * @return max the maximum length (in hex characters) for a binary literal;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxCharLiteralLength">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of characters this database allows &#xA;     * for a character literal.&#xA;     *&#xA;     * @return the maximum number of characters allowed for a character literal;&#xA;     *      a result of zero means that there is no limit or the limit is &#xA;     *      not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxColumnNameLength">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of characters this database allows&#xA;     * for a column name.&#xA;     *&#xA;     * @return the maximum number of characters allowed for a column name;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxColumnsInGroupBy">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of columns this database allows in a &#xA;     * &lt;code>GROUP BY&lt;/code> clause.&#xA;     *&#xA;     * @return the maximum number of columns allowed;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxColumnsInIndex">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of columns this database allows in an index.&#xA;     *&#xA;     * @return the maximum number of columns allowed;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxColumnsInOrderBy">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of columns this database allows in an &#xA;     * &lt;code>ORDER BY&lt;/code> clause.&#xA;     *&#xA;     * @return the maximum number of columns allowed;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxColumnsInSelect">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of columns this database allows in a &#xA;     * &lt;code>SELECT&lt;/code> list.&#xA;     *&#xA;     * @return the maximum number of columns allowed;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxColumnsInTable">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of columns this database allows in a table.&#xA;     *&#xA;     * @return the maximum number of columns allowed;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxConnections">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of concurrent connections to this&#xA;     * database that are possible.&#xA;     *&#xA;     * @return the maximum number of active connections possible at one time;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxCursorNameLength">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of characters that this database allows in a&#xA;     * cursor name.&#xA;     *&#xA;     * @return the maximum number of characters allowed in a cursor name;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxIndexLength">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of bytes this database allows for an &#xA;     * index, including all of the parts of the index.&#xA;     *&#xA;     * @return the maximum number of bytes allowed; this limit includes the &#xA;     *      composite of all the constituent parts of the index;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxSchemaNameLength">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of characters that this database allows in a&#xA;     * schema name.&#xA;     *&#xA;     * @return the maximum number of characters allowed in a schema name;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxProcedureNameLength">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of characters that this database allows in a&#xA;     * procedure name.&#xA;     *&#xA;     * @return the maximum number of characters allowed in a procedure name;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxCatalogNameLength">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of characters that this database allows in a&#xA;     * catalog name.&#xA;     *&#xA;     * @return the maximum number of characters allowed in a catalog name;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxRowSize">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of bytes this database allows in&#xA;     * a single row.&#xA;     *&#xA;     * @return the maximum number of bytes allowed for a row; a result of &#xA;     *         zero means that there is no limit or the limit is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="doesMaxRowSizeIncludeBlobs">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether the return value for the method &#xA;     * &lt;code>getMaxRowSize&lt;/code> includes the SQL data types &#xA;     * &lt;code>LONGVARCHAR&lt;/code> and &lt;code>LONGVARBINARY&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxStatementLength">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of characters this database allows in&#xA;     * an SQL statement.&#xA;     *&#xA;     * @return the maximum number of characters allowed for an SQL statement;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxStatements">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of active statements to this database&#xA;     * that can be open at the same time.&#xA;     *&#xA;     * @return the maximum number of statements that can be open at one time;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxTableNameLength">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of characters this database allows in&#xA;     * a table name.&#xA;     *&#xA;     * @return the maximum number of characters allowed for a table name;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxTablesInSelect">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of tables this database allows in a&#xA;     * &lt;code>SELECT&lt;/code> statement.&#xA;     *&#xA;     * @return the maximum number of tables allowed in a &lt;code>SELECT&lt;/code> &#xA;     *         statement; a result of zero means that there is no limit or &#xA;     *         the limit is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaxUserNameLength">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the maximum number of characters this database allows in&#xA;     * a user name.&#xA;     *&#xA;     * @return the maximum number of characters allowed for a user name;&#xA;     *      a result of zero means that there is no limit or the limit &#xA;     *      is not known&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDefaultTransactionIsolation">
      <typeReference xsi:type="types:Int">
        <comments>//----------------------------------------------------------------------</comments>
        <comments>/**&#xA;     * Retrieves this database's default transaction isolation level.  The&#xA;     * possible values are defined in &lt;code>java.sql.Connection&lt;/code>.&#xA;     *&#xA;     * @return the default isolation level &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Connection&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsTransactions">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports transactions. If not, invoking the&#xA;     * method &lt;code>commit&lt;/code> is a noop, and the isolation level is &#xA;     * &lt;code>TRANSACTION_NONE&lt;/code>.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if transactions are supported; &#xA;     *         &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsTransactionIsolationLevel">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports the given transaction isolation level.&#xA;     *&#xA;     * @param level one of the transaction isolation levels defined in &#xA;     *         &lt;code>java.sql.Connection&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Connection&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="level">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsDataDefinitionAndDataManipulationTransactions">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports both data definition and &#xA;     * data manipulation statements within a transaction.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsDataManipulationTransactionsOnly">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports only data manipulation &#xA;     * statements within a transaction.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="dataDefinitionCausesTransactionCommit">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a data definition statement within a transaction forces&#xA;     * the transaction to commit.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="dataDefinitionIgnoredInTransactions">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database ignores a data definition statement &#xA;     * within a transaction.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getProcedures">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the stored procedures available in the given&#xA;     * catalog.&#xA;     * &lt;P>&#xA;     * Only procedure descriptions matching the schema and&#xA;     * procedure name criteria are returned.  They are ordered by&#xA;     * &lt;code>PROCEDURE_SCHEM&lt;/code> and &lt;code>PROCEDURE_NAME&lt;/code>.&#xA;     *&#xA;     * &lt;P>Each procedure description has the the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>PROCEDURE_CAT&lt;/B> String => procedure catalog (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>PROCEDURE_SCHEM&lt;/B> String => procedure schema (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>PROCEDURE_NAME&lt;/B> String => procedure name&#xA;     *  &lt;LI> reserved for future use&#xA;     *  &lt;LI> reserved for future use&#xA;     *  &lt;LI> reserved for future use&#xA;     *&#x9;&lt;LI>&lt;B>REMARKS&lt;/B> String => explanatory comment on the procedure&#xA;     *&#x9;&lt;LI>&lt;B>PROCEDURE_TYPE&lt;/B> short => kind of procedure:&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> procedureResultUnknown - May return a result&#xA;     *      &lt;LI> procedureNoResult - Does not return a result&#xA;     *      &lt;LI> procedureReturnsResult - Returns a result&#xA;     *      &lt;/UL>&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in the database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schemaPattern a schema name pattern; must match the schema name&#xA;     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param procedureNamePattern a procedure name pattern; must match the&#xA;     *        procedure name as it is stored in the database &#xA;     * @return &lt;code>ResultSet&lt;/code> - each row is a procedure description &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getSearchStringEscape &#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schemaPattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="procedureNamePattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:Field" name="procedureResultUnknown">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that it is not known whether the procedure returns&#xA;     * a result.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>PROCEDURE_TYPE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getProcedures&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="procedureNoResult">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the procedure does not return a result.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>PROCEDURE_TYPE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getProcedures&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="procedureReturnsResult">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the procedure returns a result.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>PROCEDURE_TYPE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getProcedures&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getProcedureColumns">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the given catalog's stored procedure parameter&#xA;     * and result columns.&#xA;     *&#xA;     * &lt;P>Only descriptions matching the schema, procedure and&#xA;     * parameter name criteria are returned.  They are ordered by&#xA;     * PROCEDURE_SCHEM and PROCEDURE_NAME. Within this, the return value,&#xA;     * if any, is first. Next are the parameter descriptions in call&#xA;     * order. The column descriptions follow in column number order.&#xA;     *&#xA;     * &lt;P>Each row in the &lt;code>ResultSet&lt;/code> is a parameter description or&#xA;     * column description with the following fields:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>PROCEDURE_CAT&lt;/B> String => procedure catalog (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>PROCEDURE_SCHEM&lt;/B> String => procedure schema (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>PROCEDURE_NAME&lt;/B> String => procedure name&#xA;     *&#x9;&lt;LI>&lt;B>COLUMN_NAME&lt;/B> String => column/parameter name &#xA;     *&#x9;&lt;LI>&lt;B>COLUMN_TYPE&lt;/B> Short => kind of column/parameter:&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> procedureColumnUnknown - nobody knows&#xA;     *      &lt;LI> procedureColumnIn - IN parameter&#xA;     *      &lt;LI> procedureColumnInOut - INOUT parameter&#xA;     *      &lt;LI> procedureColumnOut - OUT parameter&#xA;     *      &lt;LI> procedureColumnReturn - procedure return value&#xA;     *      &lt;LI> procedureColumnResult - result column in &lt;code>ResultSet&lt;/code>&#xA;     *      &lt;/UL>&#xA;     *  &lt;LI>&lt;B>DATA_TYPE&lt;/B> int => SQL type from java.sql.Types&#xA;     *&#x9;&lt;LI>&lt;B>TYPE_NAME&lt;/B> String => SQL type name, for a UDT type the&#xA;     *  type name is fully qualified&#xA;     *&#x9;&lt;LI>&lt;B>PRECISION&lt;/B> int => precision&#xA;     *&#x9;&lt;LI>&lt;B>LENGTH&lt;/B> int => length in bytes of data&#xA;     *&#x9;&lt;LI>&lt;B>SCALE&lt;/B> short => scale&#xA;     *&#x9;&lt;LI>&lt;B>RADIX&lt;/B> short => radix&#xA;     *&#x9;&lt;LI>&lt;B>NULLABLE&lt;/B> short => can it contain NULL.&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> procedureNoNulls - does not allow NULL values&#xA;     *      &lt;LI> procedureNullable - allows NULL values&#xA;     *      &lt;LI> procedureNullableUnknown - nullability unknown&#xA;     *      &lt;/UL>&#xA;     *&#x9;&lt;LI>&lt;B>REMARKS&lt;/B> String => comment describing parameter/column&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * &lt;P>&lt;B>Note:&lt;/B> Some databases may not return the column&#xA;     * descriptions for a procedure. Additional columns beyond&#xA;     * REMARKS can be defined by the database.&#xA;     *&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in the database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schemaPattern a schema name pattern; must match the schema name&#xA;     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param procedureNamePattern a procedure name pattern; must match the&#xA;     *        procedure name as it is stored in the database &#xA;     * @param columnNamePattern a column name pattern; must match the column name&#xA;     *        as it is stored in the database &#xA;     * @return &lt;code>ResultSet&lt;/code> - each row describes a stored procedure parameter or &#xA;     *      column&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getSearchStringEscape &#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schemaPattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="procedureNamePattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="columnNamePattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:Field" name="procedureColumnUnknown">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that type of the column is unknown.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>COLUMN_TYPE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> &#xA;     * returned by the method &lt;code>getProcedureColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="procedureColumnIn">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the column stores IN parameters.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>COLUMN_TYPE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> &#xA;     * returned by the method &lt;code>getProcedureColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="procedureColumnInOut">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the column stores INOUT parameters.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>COLUMN_TYPE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> &#xA;     * returned by the method &lt;code>getProcedureColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="procedureColumnOut">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the column stores OUT parameters.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>COLUMN_TYPE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> &#xA;     * returned by the method &lt;code>getProcedureColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="procedureColumnReturn">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the column stores return values.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>COLUMN_TYPE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> &#xA;     * returned by the method &lt;code>getProcedureColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="procedureColumnResult">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the column stores results.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>COLUMN_TYPE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> &#xA;     * returned by the method &lt;code>getProcedureColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="procedureNoNulls">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that &lt;code>NULL&lt;/code> values are not allowed.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>NULLABLE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getProcedureColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="procedureNullable">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that &lt;code>NULL&lt;/code> values are allowed.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>NULLABLE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getProcedureColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="procedureNullableUnknown">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that whether &lt;code>NULL&lt;/code> values are allowed&#xA;     * is unknown.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>NULLABLE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getProcedureColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTables">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the tables available in the given catalog.&#xA;     * Only table descriptions matching the catalog, schema, table&#xA;     * name and type criteria are returned.  They are ordered by&#xA;     * TABLE_TYPE, TABLE_SCHEM and TABLE_NAME.&#xA;     * &lt;P>&#xA;     * Each table description has the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_CAT&lt;/B> String => table catalog (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_SCHEM&lt;/B> String => table schema (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_NAME&lt;/B> String => table name&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_TYPE&lt;/B> String => table type.  Typical types are &quot;TABLE&quot;,&#xA;     *&#x9;&#x9;&#x9;&quot;VIEW&quot;,&#x9;&quot;SYSTEM TABLE&quot;, &quot;GLOBAL TEMPORARY&quot;, &#xA;     *&#x9;&#x9;&#x9;&quot;LOCAL TEMPORARY&quot;, &quot;ALIAS&quot;, &quot;SYNONYM&quot;.&#xA;     *&#x9;&lt;LI>&lt;B>REMARKS&lt;/B> String => explanatory comment on the table&#xA;     *  &lt;LI>&lt;B>TYPE_CAT&lt;/B> String => the types catalog (may be &lt;code>null&lt;/code>)&#xA;     *  &lt;LI>&lt;B>TYPE_SCHEM&lt;/B> String => the types schema (may be &lt;code>null&lt;/code>)&#xA;     *  &lt;LI>&lt;B>TYPE_NAME&lt;/B> String => type name (may be &lt;code>null&lt;/code>)&#xA;     *  &lt;LI>&lt;B>SELF_REFERENCING_COL_NAME&lt;/B> String => name of the designated &#xA;     *                  &quot;identifier&quot; column of a typed table (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>REF_GENERATION&lt;/B> String => specifies how values in &#xA;     *                  SELF_REFERENCING_COL_NAME are created. Values are&#xA;     *                  &quot;SYSTEM&quot;, &quot;USER&quot;, &quot;DERIVED&quot;. (may be &lt;code>null&lt;/code>)&#x9;&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * &lt;P>&lt;B>Note:&lt;/B> Some databases may not return information for&#xA;     * all tables.&#xA;     *&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in the database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schemaPattern a schema name pattern; must match the schema name&#xA;     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param tableNamePattern a table name pattern; must match the&#xA;     *        table name as it is stored in the database &#xA;     * @param types a list of table types to include; &lt;code>null&lt;/code> returns all types &#xA;     * @return &lt;code>ResultSet&lt;/code> - each row is a table description&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getSearchStringEscape &#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schemaPattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tableNamePattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="types">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsAfter/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSchemas">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the schema names available in this database.  The results&#xA;     * are ordered by schema name.&#xA;     *&#xA;     * &lt;P>The schema column is:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_SCHEM&lt;/B> String => schema name&#xA;     *  &lt;LI>&lt;B>TABLE_CATALOG&lt;/B> String => catalog name (may be &lt;code>null&lt;/code>)&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @return a &lt;code>ResultSet&lt;/code> object in which each row is a &#xA;     *         schema decription &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCatalogs">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the catalog names available in this database.  The results&#xA;     * are ordered by catalog name.&#xA;     *&#xA;     * &lt;P>The catalog column is:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_CAT&lt;/B> String => catalog name&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @return a &lt;code>ResultSet&lt;/code> object in which each row has a &#xA;     *         single &lt;code>String&lt;/code> column that is a catalog name &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTableTypes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the table types available in this database.  The results&#xA;     * are ordered by table type.&#xA;     *&#xA;     * &lt;P>The table type is:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_TYPE&lt;/B> String => table type.  Typical types are &quot;TABLE&quot;,&#xA;     *&#x9;&#x9;&#x9;&quot;VIEW&quot;,&#x9;&quot;SYSTEM TABLE&quot;, &quot;GLOBAL TEMPORARY&quot;, &#xA;     *&#x9;&#x9;&#x9;&quot;LOCAL TEMPORARY&quot;, &quot;ALIAS&quot;, &quot;SYNONYM&quot;.&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @return a &lt;code>ResultSet&lt;/code> object in which each row has a &#xA;     *         single &lt;code>String&lt;/code> column that is a table type &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getColumns">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of table columns available in &#xA;     * the specified catalog.&#xA;     *&#xA;     * &lt;P>Only column descriptions matching the catalog, schema, table&#xA;     * and column name criteria are returned.  They are ordered by&#xA;     * &lt;code>TABLE_SCHEM&lt;/code>, &lt;code>TABLE_NAME&lt;/code>, and &#xA;     * &lt;code>ORDINAL_POSITION&lt;/code>.&#xA;     *&#xA;     * &lt;P>Each column description has the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_CAT&lt;/B> String => table catalog (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_SCHEM&lt;/B> String => table schema (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_NAME&lt;/B> String => table name&#xA;     *&#x9;&lt;LI>&lt;B>COLUMN_NAME&lt;/B> String => column name&#xA;     *&#x9;&lt;LI>&lt;B>DATA_TYPE&lt;/B> int => SQL type from java.sql.Types&#xA;     *&#x9;&lt;LI>&lt;B>TYPE_NAME&lt;/B> String => Data source dependent type name,&#xA;     *  for a UDT the type name is fully qualified&#xA;     *&#x9;&lt;LI>&lt;B>COLUMN_SIZE&lt;/B> int => column size.  For char or date&#xA;     *&#x9;    types this is the maximum number of characters, for numeric or&#xA;     *&#x9;    decimal types this is precision.&#xA;     *&#x9;&lt;LI>&lt;B>BUFFER_LENGTH&lt;/B> is not used.&#xA;     *&#x9;&lt;LI>&lt;B>DECIMAL_DIGITS&lt;/B> int => the number of fractional digits&#xA;     *&#x9;&lt;LI>&lt;B>NUM_PREC_RADIX&lt;/B> int => Radix (typically either 10 or 2)&#xA;     *&#x9;&lt;LI>&lt;B>NULLABLE&lt;/B> int => is NULL allowed.&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> columnNoNulls - might not allow &lt;code>NULL&lt;/code> values&#xA;     *      &lt;LI> columnNullable - definitely allows &lt;code>NULL&lt;/code> values&#xA;     *      &lt;LI> columnNullableUnknown - nullability unknown&#xA;     *      &lt;/UL>&#xA;     *&#x9;&lt;LI>&lt;B>REMARKS&lt;/B> String => comment describing column (may be &lt;code>null&lt;/code>)&#xA;     * &#x9;&lt;LI>&lt;B>COLUMN_DEF&lt;/B> String => default value (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>SQL_DATA_TYPE&lt;/B> int => unused&#xA;     *&#x9;&lt;LI>&lt;B>SQL_DATETIME_SUB&lt;/B> int => unused&#xA;     *&#x9;&lt;LI>&lt;B>CHAR_OCTET_LENGTH&lt;/B> int => for char types the &#xA;     *       maximum number of bytes in the column&#xA;     *&#x9;&lt;LI>&lt;B>ORDINAL_POSITION&lt;/B> int&#x9;=> index of column in table &#xA;     *      (starting at 1)&#xA;     *&#x9;&lt;LI>&lt;B>IS_NULLABLE&lt;/B> String => &quot;NO&quot; means column definitely &#xA;     *      does not allow NULL values; &quot;YES&quot; means the column might &#xA;     *      allow NULL values.  An empty string means nobody knows.&#xA;     *  &lt;LI>&lt;B>SCOPE_CATLOG&lt;/B> String => catalog of table that is the scope&#xA;     *      of a reference attribute (&lt;code>null&lt;/code> if DATA_TYPE isn't REF)&#xA;     *  &lt;LI>&lt;B>SCOPE_SCHEMA&lt;/B> String => schema of table that is the scope&#xA;     *      of a reference attribute (&lt;code>null&lt;/code> if the DATA_TYPE isn't REF)&#xA;     *  &lt;LI>&lt;B>SCOPE_TABLE&lt;/B> String => table name that this the scope&#xA;     *      of a reference attribure (&lt;code>null&lt;/code> if the DATA_TYPE isn't REF)&#xA;     *  &lt;LI>&lt;B>SOURCE_DATA_TYPE&lt;/B> short => source type of a distinct type or user-generated&#xA;     *      Ref type, SQL type from java.sql.Types (&lt;code>null&lt;/code> if DATA_TYPE &#xA;     *      isn't DISTINCT or user-generated REF)&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in the database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schemaPattern a schema name pattern; must match the schema name&#xA;     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param tableNamePattern a table name pattern; must match the&#xA;     *        table name as it is stored in the database &#xA;     * @param columnNamePattern a column name pattern; must match the column&#xA;     *        name as it is stored in the database&#xA;     * @return &lt;code>ResultSet&lt;/code> - each row is a column description&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getSearchStringEscape &#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schemaPattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tableNamePattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="columnNamePattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:Field" name="columnNoNulls">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the column might not allow &lt;code>NULL&lt;/code> values.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>NULLABLE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> returned by the method&#xA;     * &lt;code>getColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="columnNullable">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the column definitely allows &lt;code>NULL&lt;/code> values.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>NULLABLE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> returned by the method&#xA;     * &lt;code>getColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="columnNullableUnknown">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the nullability of columns is unknown.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>NULLABLE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> returned by the method&#xA;     * &lt;code>getColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getColumnPrivileges">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the access rights for a table's columns.&#xA;     *&#xA;     * &lt;P>Only privileges matching the column name criteria are&#xA;     * returned.  They are ordered by COLUMN_NAME and PRIVILEGE.&#xA;     *&#xA;     * &lt;P>Each privilige description has the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_CAT&lt;/B> String => table catalog (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_SCHEM&lt;/B> String => table schema (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_NAME&lt;/B> String => table name&#xA;     *&#x9;&lt;LI>&lt;B>COLUMN_NAME&lt;/B> String => column name&#xA;     *&#x9;&lt;LI>&lt;B>GRANTOR&lt;/B> => grantor of access (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>GRANTEE&lt;/B> String => grantee of access&#xA;     *&#x9;&lt;LI>&lt;B>PRIVILEGE&lt;/B> String => name of access (SELECT, &#xA;     *      INSERT, UPDATE, REFRENCES, ...)&#xA;     *&#x9;&lt;LI>&lt;B>IS_GRANTABLE&lt;/B> String => &quot;YES&quot; if grantee is permitted &#xA;     *      to grant to others; &quot;NO&quot; if not; &lt;code>null&lt;/code> if unknown &#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in the database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schema a schema name; must match the schema name as it is&#xA;     *        stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param table a table name; must match the table name as it is&#xA;     *        stored in the database &#xA;     * @param columnNamePattern a column name pattern; must match the column&#xA;     *        name as it is stored in the database&#xA;     * @return &lt;code>ResultSet&lt;/code> - each row is a column privilege description&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getSearchStringEscape &#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schema">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="table">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="columnNamePattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTablePrivileges">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the access rights for each table available&#xA;     * in a catalog. Note that a table privilege applies to one or&#xA;     * more columns in the table. It would be wrong to assume that&#xA;     * this privilege applies to all columns (this may be true for&#xA;     * some systems but is not true for all.)&#xA;     *&#xA;     * &lt;P>Only privileges matching the schema and table name&#xA;     * criteria are returned.  They are ordered by TABLE_SCHEM,&#xA;     * TABLE_NAME, and PRIVILEGE.&#xA;     *&#xA;     * &lt;P>Each privilige description has the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_CAT&lt;/B> String => table catalog (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_SCHEM&lt;/B> String => table schema (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_NAME&lt;/B> String => table name&#xA;     *&#x9;&lt;LI>&lt;B>GRANTOR&lt;/B> => grantor of access (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>GRANTEE&lt;/B> String => grantee of access&#xA;     *&#x9;&lt;LI>&lt;B>PRIVILEGE&lt;/B> String => name of access (SELECT, &#xA;     *      INSERT, UPDATE, REFRENCES, ...)&#xA;     *&#x9;&lt;LI>&lt;B>IS_GRANTABLE&lt;/B> String => &quot;YES&quot; if grantee is permitted &#xA;     *      to grant to others; &quot;NO&quot; if not; &lt;code>null&lt;/code> if unknown &#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in the database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schemaPattern a schema name pattern; must match the schema name&#xA;     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param tableNamePattern a table name pattern; must match the&#xA;     *        table name as it is stored in the database &#xA;     * @return &lt;code>ResultSet&lt;/code> - each row is a table privilege description&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getSearchStringEscape &#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schemaPattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tableNamePattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBestRowIdentifier">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of a table's optimal set of columns that&#xA;     * uniquely identifies a row. They are ordered by SCOPE.&#xA;     *&#xA;     * &lt;P>Each column description has the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>SCOPE&lt;/B> short => actual scope of result&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> bestRowTemporary - very temporary, while using row&#xA;     *      &lt;LI> bestRowTransaction - valid for remainder of current transaction&#xA;     *      &lt;LI> bestRowSession - valid for remainder of current session&#xA;     *      &lt;/UL>&#xA;     *&#x9;&lt;LI>&lt;B>COLUMN_NAME&lt;/B> String => column name&#xA;     *&#x9;&lt;LI>&lt;B>DATA_TYPE&lt;/B> int => SQL data type from java.sql.Types&#xA;     *&#x9;&lt;LI>&lt;B>TYPE_NAME&lt;/B> String => Data source dependent type name,&#xA;     *  for a UDT the type name is fully qualified&#xA;     *&#x9;&lt;LI>&lt;B>COLUMN_SIZE&lt;/B> int => precision&#xA;     *&#x9;&lt;LI>&lt;B>BUFFER_LENGTH&lt;/B> int => not used&#xA;     *&#x9;&lt;LI>&lt;B>DECIMAL_DIGITS&lt;/B> short&#x9; => scale&#xA;     *&#x9;&lt;LI>&lt;B>PSEUDO_COLUMN&lt;/B> short => is this a pseudo column &#xA;     *      like an Oracle ROWID&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> bestRowUnknown - may or may not be pseudo column&#xA;     *      &lt;LI> bestRowNotPseudo - is NOT a pseudo column&#xA;     *      &lt;LI> bestRowPseudo - is a pseudo column&#xA;     *      &lt;/UL>&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in the database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schema a schema name; must match the schema name&#xA;     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param table a table name; must match the table name as it is stored &#xA;     *        in the database &#xA;     * @param scope the scope of interest; use same values as SCOPE&#xA;     * @param nullable include columns that are nullable.&#xA;     * @return &lt;code>ResultSet&lt;/code> - each row is a column description &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schema">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="table">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scope">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nullable">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:Field" name="bestRowTemporary">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the scope of the best row identifier is&#xA;     * very temporary, lasting only while the&#xA;     * row is being used.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>SCOPE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getBestRowIdentifier&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="bestRowTransaction">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the scope of the best row identifier is&#xA;     * the remainder of the current transaction.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>SCOPE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getBestRowIdentifier&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="bestRowSession">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the scope of the best row identifier is&#xA;     * the remainder of the current session.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>SCOPE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getBestRowIdentifier&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="bestRowUnknown">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the best row identifier may or may not be a pseudo column.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>PSEUDO_COLUMN&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getBestRowIdentifier&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="bestRowNotPseudo">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the best row identifier is NOT a pseudo column.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>PSEUDO_COLUMN&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getBestRowIdentifier&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="bestRowPseudo">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the best row identifier is a pseudo column.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>PSEUDO_COLUMN&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getBestRowIdentifier&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getVersionColumns">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of a table's columns that are automatically&#xA;     * updated when any value in a row is updated.  They are&#xA;     * unordered.&#xA;     *&#xA;     * &lt;P>Each column description has the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>SCOPE&lt;/B> short => is not used&#xA;     *&#x9;&lt;LI>&lt;B>COLUMN_NAME&lt;/B> String => column name&#xA;     *&#x9;&lt;LI>&lt;B>DATA_TYPE&lt;/B> int => SQL data type from &lt;code>java.sql.Types&lt;/code>&#xA;     *&#x9;&lt;LI>&lt;B>TYPE_NAME&lt;/B> String => Data source-dependent type name&#xA;     *&#x9;&lt;LI>&lt;B>COLUMN_SIZE&lt;/B> int => precision&#xA;     *&#x9;&lt;LI>&lt;B>BUFFER_LENGTH&lt;/B> int => length of column value in bytes&#xA;     *&#x9;&lt;LI>&lt;B>DECIMAL_DIGITS&lt;/B> short&#x9; => scale&#xA;     *&#x9;&lt;LI>&lt;B>PSEUDO_COLUMN&lt;/B> short => whether this is pseudo column &#xA;     *      like an Oracle ROWID&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> versionColumnUnknown - may or may not be pseudo column&#xA;     *      &lt;LI> versionColumnNotPseudo - is NOT a pseudo column&#xA;     *      &lt;LI> versionColumnPseudo - is a pseudo column&#xA;     *      &lt;/UL>&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in the database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schema a schema name; must match the schema name&#xA;     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param table a table name; must match the table name as it is stored &#xA;     *        in the database &#xA;     * @return a &lt;code>ResultSet&lt;/code> object in which each row is a &#xA;     *         column description &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schema">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="table">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:Field" name="versionColumnUnknown">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that this version column may or may not be a pseudo column.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>PSEUDO_COLUMN&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getVersionColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="versionColumnNotPseudo">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that this version column is NOT a pseudo column.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>PSEUDO_COLUMN&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getVersionColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="versionColumnPseudo">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that this version column is a pseudo column.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>PSEUDO_COLUMN&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getVersionColumns&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPrimaryKeys">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the given table's primary key columns.  They&#xA;     * are ordered by COLUMN_NAME.&#xA;     *&#xA;     * &lt;P>Each primary key column description has the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_CAT&lt;/B> String => table catalog (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_SCHEM&lt;/B> String => table schema (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_NAME&lt;/B> String => table name&#xA;     *&#x9;&lt;LI>&lt;B>COLUMN_NAME&lt;/B> String => column name&#xA;     *&#x9;&lt;LI>&lt;B>KEY_SEQ&lt;/B> short => sequence number within primary key&#xA;     *&#x9;&lt;LI>&lt;B>PK_NAME&lt;/B> String => primary key name (may be &lt;code>null&lt;/code>)&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in the database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schema a schema name; must match the schema name&#xA;     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param table a table name; must match the table name as it is stored &#xA;     *        in the database &#xA;     * @return &lt;code>ResultSet&lt;/code> - each row is a primary key column description &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schema">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="table">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getImportedKeys">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the primary key columns that are&#xA;     * referenced by a table's foreign key columns (the primary keys&#xA;     * imported by a table).  They are ordered by PKTABLE_CAT,&#xA;     * PKTABLE_SCHEM, PKTABLE_NAME, and KEY_SEQ.&#xA;     *&#xA;     * &lt;P>Each primary key column description has the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>PKTABLE_CAT&lt;/B> String => primary key table catalog &#xA;     *      being imported (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>PKTABLE_SCHEM&lt;/B> String => primary key table schema&#xA;     *      being imported (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>PKTABLE_NAME&lt;/B> String => primary key table name&#xA;     *      being imported&#xA;     *&#x9;&lt;LI>&lt;B>PKCOLUMN_NAME&lt;/B> String => primary key column name&#xA;     *      being imported&#xA;     *&#x9;&lt;LI>&lt;B>FKTABLE_CAT&lt;/B> String => foreign key table catalog (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>FKTABLE_SCHEM&lt;/B> String => foreign key table schema (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>FKTABLE_NAME&lt;/B> String => foreign key table name&#xA;     *&#x9;&lt;LI>&lt;B>FKCOLUMN_NAME&lt;/B> String => foreign key column name&#xA;     *&#x9;&lt;LI>&lt;B>KEY_SEQ&lt;/B> short => sequence number within a foreign key&#xA;     *&#x9;&lt;LI>&lt;B>UPDATE_RULE&lt;/B> short => What happens to a&#xA;     *       foreign key when the primary key is updated:&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> importedNoAction - do not allow update of primary &#xA;     *               key if it has been imported&#xA;     *      &lt;LI> importedKeyCascade - change imported key to agree &#xA;     *               with primary key update&#xA;     *      &lt;LI> importedKeySetNull - change imported key to &lt;code>NULL&lt;/code>&#xA;     *               if its primary key has been updated&#xA;     *      &lt;LI> importedKeySetDefault - change imported key to default values &#xA;     *               if its primary key has been updated&#xA;     *      &lt;LI> importedKeyRestrict - same as importedKeyNoAction &#xA;     *                                 (for ODBC 2.x compatibility)&#xA;     *      &lt;/UL>&#xA;     *&#x9;&lt;LI>&lt;B>DELETE_RULE&lt;/B> short => What happens to &#xA;     *      the foreign key when primary is deleted.&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> importedKeyNoAction - do not allow delete of primary &#xA;     *               key if it has been imported&#xA;     *      &lt;LI> importedKeyCascade - delete rows that import a deleted key&#xA;     *      &lt;LI> importedKeySetNull - change imported key to NULL if &#xA;     *               its primary key has been deleted&#xA;     *      &lt;LI> importedKeyRestrict - same as importedKeyNoAction &#xA;     *                                 (for ODBC 2.x compatibility)&#xA;     *      &lt;LI> importedKeySetDefault - change imported key to default if &#xA;     *               its primary key has been deleted&#xA;     *      &lt;/UL>&#xA;     *&#x9;&lt;LI>&lt;B>FK_NAME&lt;/B> String => foreign key name (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>PK_NAME&lt;/B> String => primary key name (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>DEFERRABILITY&lt;/B> short => can the evaluation of foreign key &#xA;     *      constraints be deferred until commit&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> importedKeyInitiallyDeferred - see SQL92 for definition&#xA;     *      &lt;LI> importedKeyInitiallyImmediate - see SQL92 for definition &#xA;     *      &lt;LI> importedKeyNotDeferrable - see SQL92 for definition &#xA;     *      &lt;/UL>&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in the database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schema a schema name; must match the schema name&#xA;     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param table a table name; must match the table name as it is stored &#xA;     *        in the database &#xA;     * @return &lt;code>ResultSet&lt;/code> - each row is a primary key column description &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getExportedKeys &#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schema">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="table">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:Field" name="importedKeyCascade">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * For the column &lt;code>UPDATE_RULE&lt;/code>,&#xA;     * indicates that&#xA;     * when the primary key is updated, the foreign key (imported key)&#xA;     * is changed to agree with it.&#xA;     * For the column &lt;code>DELETE_RULE&lt;/code>,&#xA;     * it indicates that&#xA;     * when the primary key is deleted, rows that imported that key&#xA;     * are deleted.&#xA;     * &lt;P>&#xA;     * A possible value for the columns &lt;code>UPDATE_RULE&lt;/code>&#xA;     * and &lt;code>DELETE_RULE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> objects returned by the methods&#xA;     * &lt;code>getImportedKeys&lt;/code>,  &lt;code>getExportedKeys&lt;/code>,&#xA;     * and &lt;code>getCrossReference&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="importedKeyRestrict">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * For the column &lt;code>UPDATE_RULE&lt;/code>, indicates that&#xA;     * a primary key may not be updated if it has been imported by&#xA;     * another table as a foreign key.&#xA;     * For the column &lt;code>DELETE_RULE&lt;/code>, indicates that&#xA;     * a primary key may not be deleted if it has been imported by&#xA;     * another table as a foreign key.&#xA;     * &lt;P>&#xA;     * A possible value for the columns &lt;code>UPDATE_RULE&lt;/code>&#xA;     * and &lt;code>DELETE_RULE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> objects returned by the methods&#xA;     * &lt;code>getImportedKeys&lt;/code>,  &lt;code>getExportedKeys&lt;/code>,&#xA;     * and &lt;code>getCrossReference&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="importedKeySetNull">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * For the columns &lt;code>UPDATE_RULE&lt;/code>&#xA;     * and &lt;code>DELETE_RULE&lt;/code>, indicates that&#xA;     * when the primary key is updated or deleted, the foreign key (imported key)&#xA;     * is changed to &lt;code>NULL&lt;/code>.&#xA;     * &lt;P>&#xA;     * A possible value for the columns &lt;code>UPDATE_RULE&lt;/code>&#xA;     * and &lt;code>DELETE_RULE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> objects returned by the methods&#xA;     * &lt;code>getImportedKeys&lt;/code>,  &lt;code>getExportedKeys&lt;/code>,&#xA;     * and &lt;code>getCrossReference&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="importedKeyNoAction">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * For the columns &lt;code>UPDATE_RULE&lt;/code>&#xA;     * and &lt;code>DELETE_RULE&lt;/code>, indicates that&#xA;     * if the primary key has been imported, it cannot be updated or deleted.&#xA;     * &lt;P>&#xA;     * A possible value for the columns &lt;code>UPDATE_RULE&lt;/code>&#xA;     * and &lt;code>DELETE_RULE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> objects returned by the methods&#xA;     * &lt;code>getImportedKeys&lt;/code>,  &lt;code>getExportedKeys&lt;/code>,&#xA;     * and &lt;code>getCrossReference&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="importedKeySetDefault">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * For the columns &lt;code>UPDATE_RULE&lt;/code>&#xA;     * and &lt;code>DELETE_RULE&lt;/code>, indicates that&#xA;     * if the primary key is updated or deleted, the foreign key (imported key)&#xA;     * is set to the default value.&#xA;     * &lt;P>&#xA;     * A possible value for the columns &lt;code>UPDATE_RULE&lt;/code>&#xA;     * and &lt;code>DELETE_RULE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> objects returned by the methods&#xA;     * &lt;code>getImportedKeys&lt;/code>,  &lt;code>getExportedKeys&lt;/code>,&#xA;     * and &lt;code>getCrossReference&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="importedKeyInitiallyDeferred">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates deferrability.  See SQL-92 for a definition.&#xA;     * &lt;P>&#xA;     * A possible value for the column &lt;code>DEFERRABILITY&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> objects returned by the methods&#xA;     * &lt;code>getImportedKeys&lt;/code>,  &lt;code>getExportedKeys&lt;/code>,&#xA;     * and &lt;code>getCrossReference&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="importedKeyInitiallyImmediate">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates deferrability.  See SQL-92 for a definition.&#xA;     * &lt;P>&#xA;     * A possible value for the column &lt;code>DEFERRABILITY&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> objects returned by the methods&#xA;     * &lt;code>getImportedKeys&lt;/code>,  &lt;code>getExportedKeys&lt;/code>,&#xA;     * and &lt;code>getCrossReference&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="importedKeyNotDeferrable">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates deferrability.  See SQL-92 for a definition.&#xA;     * &lt;P>&#xA;     * A possible value for the column &lt;code>DEFERRABILITY&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> objects returned by the methods&#xA;     * &lt;code>getImportedKeys&lt;/code>,  &lt;code>getExportedKeys&lt;/code>,&#xA;     * and &lt;code>getCrossReference&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getExportedKeys">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the foreign key columns that reference the&#xA;     * given table's primary key columns (the foreign keys exported by a&#xA;     * table).  They are ordered by FKTABLE_CAT, FKTABLE_SCHEM,&#xA;     * FKTABLE_NAME, and KEY_SEQ.&#xA;     *&#xA;     * &lt;P>Each foreign key column description has the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>PKTABLE_CAT&lt;/B> String => primary key table catalog (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>PKTABLE_SCHEM&lt;/B> String => primary key table schema (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>PKTABLE_NAME&lt;/B> String => primary key table name&#xA;     *&#x9;&lt;LI>&lt;B>PKCOLUMN_NAME&lt;/B> String => primary key column name&#xA;     *&#x9;&lt;LI>&lt;B>FKTABLE_CAT&lt;/B> String => foreign key table catalog (may be &lt;code>null&lt;/code>)&#xA;     *      being exported (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>FKTABLE_SCHEM&lt;/B> String => foreign key table schema (may be &lt;code>null&lt;/code>)&#xA;     *      being exported (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>FKTABLE_NAME&lt;/B> String => foreign key table name&#xA;     *      being exported&#xA;     *&#x9;&lt;LI>&lt;B>FKCOLUMN_NAME&lt;/B> String => foreign key column name&#xA;     *      being exported&#xA;     *&#x9;&lt;LI>&lt;B>KEY_SEQ&lt;/B> short => sequence number within foreign key&#xA;     *&#x9;&lt;LI>&lt;B>UPDATE_RULE&lt;/B> short => What happens to &#xA;     *       foreign key when primary is updated:&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> importedNoAction - do not allow update of primary &#xA;     *               key if it has been imported&#xA;     *      &lt;LI> importedKeyCascade - change imported key to agree &#xA;     *               with primary key update&#xA;     *      &lt;LI> importedKeySetNull - change imported key to &lt;code>NULL&lt;/code> if &#xA;     *               its primary key has been updated&#xA;     *      &lt;LI> importedKeySetDefault - change imported key to default values &#xA;     *               if its primary key has been updated&#xA;     *      &lt;LI> importedKeyRestrict - same as importedKeyNoAction &#xA;     *                                 (for ODBC 2.x compatibility)&#xA;     *      &lt;/UL>&#xA;     *&#x9;&lt;LI>&lt;B>DELETE_RULE&lt;/B> short => What happens to &#xA;     *      the foreign key when primary is deleted.&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> importedKeyNoAction - do not allow delete of primary &#xA;     *               key if it has been imported&#xA;     *      &lt;LI> importedKeyCascade - delete rows that import a deleted key&#xA;     *      &lt;LI> importedKeySetNull - change imported key to &lt;code>NULL&lt;/code> if &#xA;     *               its primary key has been deleted&#xA;     *      &lt;LI> importedKeyRestrict - same as importedKeyNoAction &#xA;     *                                 (for ODBC 2.x compatibility)&#xA;     *      &lt;LI> importedKeySetDefault - change imported key to default if &#xA;     *               its primary key has been deleted&#xA;     *      &lt;/UL>&#xA;     *&#x9;&lt;LI>&lt;B>FK_NAME&lt;/B> String => foreign key name (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>PK_NAME&lt;/B> String => primary key name (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>DEFERRABILITY&lt;/B> short => can the evaluation of foreign key &#xA;     *      constraints be deferred until commit&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> importedKeyInitiallyDeferred - see SQL92 for definition&#xA;     *      &lt;LI> importedKeyInitiallyImmediate - see SQL92 for definition &#xA;     *      &lt;LI> importedKeyNotDeferrable - see SQL92 for definition &#xA;     *      &lt;/UL>&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in this database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schema a schema name; must match the schema name&#xA;     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param table a table name; must match the table name as it is stored &#xA;     *        in this database &#xA;     * @return a &lt;code>ResultSet&lt;/code> object in which each row is a &#xA;     *         foreign key column description &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getImportedKeys &#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schema">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="table">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCrossReference">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the foreign key columns in the given foreign key&#xA;     * table that reference the primary key columns of the given primary key&#xA;     * table (describe how one table imports another's key). This&#xA;     * should normally return a single foreign key/primary key pair because&#xA;     * most tables import a foreign key from a table only once.  They&#xA;     * are ordered by FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, and&#xA;     * KEY_SEQ.&#xA;     *&#xA;     * &lt;P>Each foreign key column description has the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>PKTABLE_CAT&lt;/B> String => primary key table catalog (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>PKTABLE_SCHEM&lt;/B> String => primary key table schema (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>PKTABLE_NAME&lt;/B> String => primary key table name&#xA;     *&#x9;&lt;LI>&lt;B>PKCOLUMN_NAME&lt;/B> String => primary key column name&#xA;     *&#x9;&lt;LI>&lt;B>FKTABLE_CAT&lt;/B> String => foreign key table catalog (may be &lt;code>null&lt;/code>)&#xA;     *      being exported (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>FKTABLE_SCHEM&lt;/B> String => foreign key table schema (may be &lt;code>null&lt;/code>)&#xA;     *      being exported (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>FKTABLE_NAME&lt;/B> String => foreign key table name&#xA;     *      being exported&#xA;     *&#x9;&lt;LI>&lt;B>FKCOLUMN_NAME&lt;/B> String => foreign key column name&#xA;     *      being exported&#xA;     *&#x9;&lt;LI>&lt;B>KEY_SEQ&lt;/B> short => sequence number within foreign key&#xA;     *&#x9;&lt;LI>&lt;B>UPDATE_RULE&lt;/B> short => What happens to &#xA;     *       foreign key when primary is updated:&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> importedNoAction - do not allow update of primary &#xA;     *               key if it has been imported&#xA;     *      &lt;LI> importedKeyCascade - change imported key to agree &#xA;     *               with primary key update&#xA;     *      &lt;LI> importedKeySetNull - change imported key to &lt;code>NULL&lt;/code> if &#xA;     *               its primary key has been updated&#xA;     *      &lt;LI> importedKeySetDefault - change imported key to default values &#xA;     *               if its primary key has been updated&#xA;     *      &lt;LI> importedKeyRestrict - same as importedKeyNoAction &#xA;     *                                 (for ODBC 2.x compatibility)&#xA;     *      &lt;/UL>&#xA;     *&#x9;&lt;LI>&lt;B>DELETE_RULE&lt;/B> short => What happens to &#xA;     *      the foreign key when primary is deleted.&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> importedKeyNoAction - do not allow delete of primary &#xA;     *               key if it has been imported&#xA;     *      &lt;LI> importedKeyCascade - delete rows that import a deleted key&#xA;     *      &lt;LI> importedKeySetNull - change imported key to &lt;code>NULL&lt;/code> if &#xA;     *               its primary key has been deleted&#xA;     *      &lt;LI> importedKeyRestrict - same as importedKeyNoAction &#xA;     *                                 (for ODBC 2.x compatibility)&#xA;     *      &lt;LI> importedKeySetDefault - change imported key to default if &#xA;     *               its primary key has been deleted&#xA;     *      &lt;/UL>&#xA;     *&#x9;&lt;LI>&lt;B>FK_NAME&lt;/B> String => foreign key name (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>PK_NAME&lt;/B> String => primary key name (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>DEFERRABILITY&lt;/B> short => can the evaluation of foreign key &#xA;     *      constraints be deferred until commit&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> importedKeyInitiallyDeferred - see SQL92 for definition&#xA;     *      &lt;LI> importedKeyInitiallyImmediate - see SQL92 for definition &#xA;     *      &lt;LI> importedKeyNotDeferrable - see SQL92 for definition &#xA;     *      &lt;/UL>&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @param primaryCatalog a catalog name; must match the catalog name&#xA;     * as it is stored in the database; &quot;&quot; retrieves those without a&#xA;     * catalog; &lt;code>null&lt;/code> means drop catalog name from the selection criteria &#xA;     * @param primarySchema a schema name; must match the schema name as&#xA;     * it is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     * &lt;code>null&lt;/code> means drop schema name from the selection criteria &#xA;     * @param primaryTable the name of the table that exports the key; must match&#xA;     * the table name as it is stored in the database&#xA;     * @param foreignCatalog a catalog name; must match the catalog name as&#xA;     * it is stored in the database; &quot;&quot; retrieves those without a&#xA;     * catalog; &lt;code>null&lt;/code> means drop catalog name from the selection criteria&#xA;     * @param foreignSchema a schema name; must match the schema name as it&#xA;     * is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     * &lt;code>null&lt;/code> means drop schema name from the selection criteria &#xA;     * @param foreignTable the name of the table that imports the key; must match&#xA;     * the table name as it is stored in the database&#xA;     * @return &lt;code>ResultSet&lt;/code> - each row is a foreign key column description &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getImportedKeys &#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="primaryCatalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="primarySchema">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="primaryTable">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="foreignCatalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="foreignSchema">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="foreignTable">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTypeInfo">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of all the standard SQL types supported by&#xA;     * this database. They are ordered by DATA_TYPE and then by how&#xA;     * closely the data type maps to the corresponding JDBC SQL type.&#xA;     *&#xA;     * &lt;P>Each type description has the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>TYPE_NAME&lt;/B> String => Type name&#xA;     *&#x9;&lt;LI>&lt;B>DATA_TYPE&lt;/B> int => SQL data type from java.sql.Types&#xA;     *&#x9;&lt;LI>&lt;B>PRECISION&lt;/B> int => maximum precision&#xA;     *&#x9;&lt;LI>&lt;B>LITERAL_PREFIX&lt;/B> String => prefix used to quote a literal &#xA;     *      (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>LITERAL_SUFFIX&lt;/B> String => suffix used to quote a literal &#xA;     (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>CREATE_PARAMS&lt;/B> String => parameters used in creating &#xA;     *      the type (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>NULLABLE&lt;/B> short => can you use NULL for this type.&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> typeNoNulls - does not allow NULL values&#xA;     *      &lt;LI> typeNullable - allows NULL values&#xA;     *      &lt;LI> typeNullableUnknown - nullability unknown&#xA;     *      &lt;/UL>&#xA;     *&#x9;&lt;LI>&lt;B>CASE_SENSITIVE&lt;/B> boolean=> is it case sensitive.&#xA;     *&#x9;&lt;LI>&lt;B>SEARCHABLE&lt;/B> short => can you use &quot;WHERE&quot; based on this type:&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> typePredNone - No support&#xA;     *      &lt;LI> typePredChar - Only supported with WHERE .. LIKE&#xA;     *      &lt;LI> typePredBasic - Supported except for WHERE .. LIKE&#xA;     *      &lt;LI> typeSearchable - Supported for all WHERE ..&#xA;     *      &lt;/UL>&#xA;     *&#x9;&lt;LI>&lt;B>UNSIGNED_ATTRIBUTE&lt;/B> boolean => is it unsigned.&#xA;     *&#x9;&lt;LI>&lt;B>FIXED_PREC_SCALE&lt;/B> boolean => can it be a money value.&#xA;     *&#x9;&lt;LI>&lt;B>AUTO_INCREMENT&lt;/B> boolean => can it be used for an &#xA;     *      auto-increment value.&#xA;     *&#x9;&lt;LI>&lt;B>LOCAL_TYPE_NAME&lt;/B> String => localized version of type name &#xA;     *      (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>MINIMUM_SCALE&lt;/B> short => minimum scale supported&#xA;     *&#x9;&lt;LI>&lt;B>MAXIMUM_SCALE&lt;/B> short => maximum scale supported&#xA;     *&#x9;&lt;LI>&lt;B>SQL_DATA_TYPE&lt;/B> int => unused&#xA;     *&#x9;&lt;LI>&lt;B>SQL_DATETIME_SUB&lt;/B> int => unused&#xA;     *&#x9;&lt;LI>&lt;B>NUM_PREC_RADIX&lt;/B> int => usually 2 or 10&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @return a &lt;code>ResultSet&lt;/code> object in which each row is an SQL &#xA;     *         type description &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:Field" name="typeNoNulls">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that a &lt;code>NULL&lt;/code> value is NOT allowed for this&#xA;     * data type.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>NULLABLE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getTypeInfo&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="typeNullable">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that a &lt;code>NULL&lt;/code> value is allowed for this&#xA;     * data type.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>NULLABLE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getTypeInfo&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="typeNullableUnknown">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that it is not known whether a &lt;code>NULL&lt;/code> value &#xA;     * is allowed for this data type.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>NULLABLE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getTypeInfo&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="typePredNone">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that &lt;code>WHERE&lt;/code> search clauses are not supported&#xA;     * for this type.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>SEARCHABLE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getTypeInfo&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="typePredChar">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the only &lt;code>WHERE&lt;/code> search clause that can&#xA;     * be based on this type is &lt;code>WHERE . . . LIKE&lt;/code>.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>SEARCHABLE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getTypeInfo&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="typePredBasic">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that one can base all &lt;code>WHERE&lt;/code> search clauses &#xA;     * except &lt;code>WHERE . . . LIKE&lt;/code> on this data type.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>SEARCHABLE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getTypeInfo&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="typeSearchable">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that all &lt;code>WHERE&lt;/code> search clauses can be &#xA;     * based on this type.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>SEARCHABLE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getTypeInfo&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getIndexInfo">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the given table's indices and statistics. They are&#xA;     * ordered by NON_UNIQUE, TYPE, INDEX_NAME, and ORDINAL_POSITION.&#xA;     *&#xA;     * &lt;P>Each index column description has the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_CAT&lt;/B> String => table catalog (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_SCHEM&lt;/B> String => table schema (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TABLE_NAME&lt;/B> String => table name&#xA;     *&#x9;&lt;LI>&lt;B>NON_UNIQUE&lt;/B> boolean => Can index values be non-unique. &#xA;     *      false when TYPE is tableIndexStatistic&#xA;     *&#x9;&lt;LI>&lt;B>INDEX_QUALIFIER&lt;/B> String => index catalog (may be &lt;code>null&lt;/code>); &#xA;     *      &lt;code>null&lt;/code> when TYPE is tableIndexStatistic&#xA;     *&#x9;&lt;LI>&lt;B>INDEX_NAME&lt;/B> String => index name; &lt;code>null&lt;/code> when TYPE is &#xA;     *      tableIndexStatistic&#xA;     *&#x9;&lt;LI>&lt;B>TYPE&lt;/B> short => index type:&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> tableIndexStatistic - this identifies table statistics that are&#xA;     *           returned in conjuction with a table's index descriptions&#xA;     *      &lt;LI> tableIndexClustered - this is a clustered index&#xA;     *      &lt;LI> tableIndexHashed - this is a hashed index&#xA;     *      &lt;LI> tableIndexOther - this is some other style of index&#xA;     *      &lt;/UL>&#xA;     *&#x9;&lt;LI>&lt;B>ORDINAL_POSITION&lt;/B> short => column sequence number &#xA;     *      within index; zero when TYPE is tableIndexStatistic&#xA;     *&#x9;&lt;LI>&lt;B>COLUMN_NAME&lt;/B> String => column name; &lt;code>null&lt;/code> when TYPE is &#xA;     *      tableIndexStatistic&#xA;     *&#x9;&lt;LI>&lt;B>ASC_OR_DESC&lt;/B> String => column sort sequence, &quot;A&quot; => ascending, &#xA;     *      &quot;D&quot; => descending, may be &lt;code>null&lt;/code> if sort sequence is not supported; &#xA;     *      &lt;code>null&lt;/code> when TYPE is tableIndexStatistic&#x9;&#xA;     *&#x9;&lt;LI>&lt;B>CARDINALITY&lt;/B> int => When TYPE is tableIndexStatistic, then &#xA;     *      this is the number of rows in the table; otherwise, it is the &#xA;     *      number of unique values in the index.&#xA;     *&#x9;&lt;LI>&lt;B>PAGES&lt;/B> int => When TYPE is  tableIndexStatisic then &#xA;     *      this is the number of pages used for the table, otherwise it &#xA;     *      is the number of pages used for the current index.&#xA;     *&#x9;&lt;LI>&lt;B>FILTER_CONDITION&lt;/B> String => Filter condition, if any.  &#xA;     *      (may be &lt;code>null&lt;/code>)&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in this database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schema a schema name; must match the schema name&#xA;     *        as it is stored in this database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param table a table name; must match the table name as it is stored &#xA;     *        in this database &#xA;     * @param unique when true, return only indices for unique values; &#xA;     *     when false, return indices regardless of whether unique or not &#xA;     * @param approximate when true, result is allowed to reflect approximate &#xA;     *     or out of data values; when false, results are requested to be &#xA;     *     accurate&#xA;     * @return &lt;code>ResultSet&lt;/code> - each row is an index column description &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schema">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="table">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="unique">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="approximate">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:Field" name="tableIndexStatistic">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Short">
        <comments>/**&#xA;     * Indicates that this column contains table statistics that&#xA;     * are returned in conjunction with a table's index descriptions.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>TYPE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getIndexInfo&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="tableIndexClustered">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Short">
        <comments>/**&#xA;     * Indicates that this table index is a clustered index.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>TYPE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getIndexInfo&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="tableIndexHashed">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Short">
        <comments>/**&#xA;     * Indicates that this table index is a hashed index.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>TYPE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getIndexInfo&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="tableIndexOther">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Short">
        <comments>/**&#xA;     * Indicates that this table index is not a clustered&#xA;     * index, a hashed index, or table statistics;&#xA;     * it is something other than these.&#xA;     * &lt;P>&#xA;     * A possible value for column &lt;code>TYPE&lt;/code> in the&#xA;     * &lt;code>ResultSet&lt;/code> object returned by the method&#xA;     * &lt;code>getIndexInfo&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsResultSetType">
      <typeReference xsi:type="types:Boolean">
        <comments>//--------------------------JDBC 2.0-----------------------------</comments>
        <comments>/**&#xA;     * Retrieves whether this database supports the given result set type.&#xA;     *&#xA;     * @param type defined in &lt;code>java.sql.ResultSet&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Connection&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsResultSetConcurrency">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports the given concurrency type &#xA;     * in combination with the given result set type.&#xA;     *&#xA;     * @param type defined in &lt;code>java.sql.ResultSet&lt;/code>&#xA;     * @param concurrency type defined in &lt;code>java.sql.ResultSet&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Connection&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="concurrency">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="ownUpdatesAreVisible">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     *&#xA;     * Retrieves whether for the given type of &lt;code>ResultSet&lt;/code> object,&#xA;     * the result set's own updates are visible.&#xA;     *&#xA;     * @param type the &lt;code>ResultSet&lt;/code> type; one of&#xA;     *        &lt;code>ResultSet.TYPE_FORWARD_ONLY&lt;/code>,&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code>, or&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if updates are visible for the given result set type;&#xA;     *        &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="ownDeletesAreVisible">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a result set's own deletes are visible.&#xA;     *&#xA;     * @param type the &lt;code>ResultSet&lt;/code> type; one of&#xA;     *        &lt;code>ResultSet.TYPE_FORWARD_ONLY&lt;/code>,&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code>, or&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if deletes are visible for the given result set type;&#xA;     *        &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="ownInsertsAreVisible">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether a result set's own inserts are visible.&#xA;     *&#xA;     * @param type the &lt;code>ResultSet&lt;/code> type; one of&#xA;     *        &lt;code>ResultSet.TYPE_FORWARD_ONLY&lt;/code>,&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code>, or&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if inserts are visible for the given result set type;&#xA;     *        &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="othersUpdatesAreVisible">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether updates made by others are visible.&#xA;     *&#xA;     * @param type the &lt;code>ResultSet&lt;/code> type; one of&#xA;     *        &lt;code>ResultSet.TYPE_FORWARD_ONLY&lt;/code>,&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code>, or&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if updates made by others&#xA;     *        are visible for the given result set type;&#xA;     *        &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="othersDeletesAreVisible">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether deletes made by others are visible.&#xA;     *&#xA;     * @param type the &lt;code>ResultSet&lt;/code> type; one of&#xA;     *        &lt;code>ResultSet.TYPE_FORWARD_ONLY&lt;/code>,&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code>, or&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if deletes made by others&#xA;     *        are visible for the given result set type;&#xA;     *        &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="othersInsertsAreVisible">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether inserts made by others are visible.&#xA;     *&#xA;     * @param type the &lt;code>ResultSet&lt;/code> type; one of&#xA;     *        &lt;code>ResultSet.TYPE_FORWARD_ONLY&lt;/code>,&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code>, or&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if inserts made by others&#xA;     *         are visible for the given result set type;&#xA;     *         &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="updatesAreDetected">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether or not a visible row update can be detected by &#xA;     * calling the method &lt;code>ResultSet.rowUpdated&lt;/code>.&#xA;     *&#xA;     * @param type the &lt;code>ResultSet&lt;/code> type; one of&#xA;     *        &lt;code>ResultSet.TYPE_FORWARD_ONLY&lt;/code>,&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code>, or&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if changes are detected by the result set type;&#xA;     *         &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="deletesAreDetected">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether or not a visible row delete can be detected by &#xA;     * calling the method &lt;code>ResultSet.rowDeleted&lt;/code>.  If the method&#xA;     * &lt;code>deletesAreDetected&lt;/code> returns &lt;code>false&lt;/code>, it means that&#xA;     * deleted rows are removed from the result set.&#xA;     *&#xA;     * @param type the &lt;code>ResultSet&lt;/code> type; one of&#xA;     *        &lt;code>ResultSet.TYPE_FORWARD_ONLY&lt;/code>,&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code>, or&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if deletes are detected by the given result set type;&#xA;     *         &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="insertsAreDetected">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether or not a visible row insert can be detected&#xA;     * by calling the method &lt;code>ResultSet.rowInserted&lt;/code>.&#xA;     *&#xA;     * @param type the &lt;code>ResultSet&lt;/code> type; one of&#xA;     *        &lt;code>ResultSet.TYPE_FORWARD_ONLY&lt;/code>,&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code>, or&#xA;     *        &lt;code>ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if changes are detected by the specified result&#xA;     *         set type; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsBatchUpdates">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports batch updates.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if this database supports batch upcates;&#xA;     *         &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getUDTs">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the user-defined types (UDTs) defined &#xA;     * in a particular schema.  Schema-specific UDTs may have type &#xA;     * &lt;code>JAVA_OBJECT&lt;/code>, &lt;code>STRUCT&lt;/code>, &#xA;     * or &lt;code>DISTINCT&lt;/code>.&#xA;     *&#xA;     * &lt;P>Only types matching the catalog, schema, type name and type  &#xA;     * criteria are returned.  They are ordered by DATA_TYPE, TYPE_SCHEM &#xA;     * and TYPE_NAME.  The type name parameter may be a fully-qualified &#xA;     * name.  In this case, the catalog and schemaPattern parameters are&#xA;     * ignored.&#xA;     *&#xA;     * &lt;P>Each type description has the following columns:&#xA;     *  &lt;OL>&#xA;     *&#x9;&lt;LI>&lt;B>TYPE_CAT&lt;/B> String => the type's catalog (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TYPE_SCHEM&lt;/B> String => type's schema (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TYPE_NAME&lt;/B> String => type name&#xA;     *  &lt;LI>&lt;B>CLASS_NAME&lt;/B> String => Java class name&#xA;     *&#x9;&lt;LI>&lt;B>DATA_TYPE&lt;/B> int => type value defined in java.sql.Types.  &#xA;     *     One of JAVA_OBJECT, STRUCT, or DISTINCT&#xA;     *&#x9;&lt;LI>&lt;B>REMARKS&lt;/B> String => explanatory comment on the type&#xA;     *  &lt;LI>&lt;B>BASE_TYPE&lt;/B> short => type code of the source type of a &#xA;     *     DISTINCT type or the type that implements the user-generated&#xA;     *     reference type of the SELF_REFERENCING_COLUMN of a structured&#xA;     *     type as defined in java.sql.Types (&lt;code>null&lt;/code> if DATA_TYPE is not&#xA;     *     DISTINCT or not STRUCT with REFERENCE_GENERATION = USER_DEFINED) &#xA;     *  &lt;/OL>&#xA;     *&#xA;     * &lt;P>&lt;B>Note:&lt;/B> If the driver does not support UDTs, an empty&#xA;     * result set is returned.&#xA;     *&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in the database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schemaPattern a schema pattern name; must match the schema name&#xA;     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param typeNamePattern a type name pattern; must match the type name&#xA;     *        as it is stored in the database; may be a fully qualified name &#xA;     * @param types a list of user-defined types (JAVA_OBJECT, &#xA;     *        STRUCT, or DISTINCT) to include; &lt;code>null&lt;/code> returns all types &#xA;     * @return &lt;code>ResultSet&lt;/code> object in which each row describes a UDT&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schemaPattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="typeNamePattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="types">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getConnection">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the connection that produced this metadata object.&#xA;     * &lt;P>&#xA;     * @return the connection that produced this metadata object&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="Connection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsSavepoints">
      <typeReference xsi:type="types:Boolean">
        <comments>// ------------------- JDBC 3.0 -------------------------</comments>
        <comments>/**&#xA;     * Retrieves whether this database supports savepoints.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if savepoints are supported; &#xA;     *         &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsNamedParameters">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports named parameters to callable &#xA;     * statements.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if named parameters are supported; &#xA;     *         &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsMultipleOpenResults">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether it is possible to have multiple &lt;code>ResultSet&lt;/code> objects&#xA;     * returned from a &lt;code>CallableStatement&lt;/code> object&#xA;     * simultaneously.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if a &lt;code>CallableStatement&lt;/code> object&#xA;     *         can return multiple &lt;code>ResultSet&lt;/code> objects&#xA;     *         simultaneously; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a datanase access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsGetGeneratedKeys">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether auto-generated keys can be retrieved after &#xA;     * a statement has been executed.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if auto-generated keys can be retrieved&#xA;     *         after a statement has executed; &lt;code>false&lt;/code> otherwise&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSuperTypes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the user-defined type (UDT) hierarchies defined in a &#xA;     * particular schema in this database. Only the immediate super type/ &#xA;     * sub type relationship is modeled.&#xA;     * &lt;P>&#xA;     * Only supertype information for UDTs matching the catalog, &#xA;     * schema, and type name is returned. The type name parameter&#xA;     * may be a fully-qualified name. When the UDT name supplied is a &#xA;     * fully-qualified name, the catalog and schemaPattern parameters are &#xA;     * ignored. &#xA;     * &lt;P>&#xA;     * If a UDT does not have a direct super type, it is not listed here.&#xA;     * A row of the &lt;code>ResultSet&lt;/code> object returned by this method&#xA;     * describes the designated UDT and a direct supertype. A row has the following &#xA;     * columns:&#xA;     *  &lt;OL>&#xA;     *  &lt;LI>&lt;B>TYPE_CAT&lt;/B> String => the UDT's catalog (may be &lt;code>null&lt;/code>)&#xA;     *  &lt;LI>&lt;B>TYPE_SCHEM&lt;/B> String => UDT's schema (may be &lt;code>null&lt;/code>)&#xA;     *  &lt;LI>&lt;B>TYPE_NAME&lt;/B> String => type name of the UDT&#xA;     *  &lt;LI>&lt;B>SUPERTYPE_CAT&lt;/B> String => the direct super type's catalog &#xA;     *                           (may be &lt;code>null&lt;/code>)&#xA;     *  &lt;LI>&lt;B>SUPERTYPE_SCHEM&lt;/B> String => the direct super type's schema &#xA;     *                             (may be &lt;code>null&lt;/code>)&#xA;     *  &lt;LI>&lt;B>SUPERTYPE_NAME&lt;/B> String => the direct super type's name&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * &lt;P>&lt;B>Note:&lt;/B> If the driver does not support type hierarchies, an &#xA;     * empty result set is returned.&#xA;     *&#xA;     * @param catalog a catalog name; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means drop catalog name from the selection criteria&#xA;     * @param schemaPattern a schema name pattern; &quot;&quot; retrieves those &#xA;     *        without a schema&#xA;     * @param typeNamePattern a UDT name pattern; may be a fully-qualified&#xA;     *        name&#xA;     * @return a &lt;code>ResultSet&lt;/code> object in which a row gives information&#xA;     *         about the designated UDT&#xA;     * @throws SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schemaPattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="typeNamePattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSuperTables">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the table hierarchies defined in a particular &#xA;     * schema in this database.&#xA;     *&#xA;     * &lt;P>Only supertable information for tables matching the catalog, schema&#xA;     * and table name are returned. The table name parameter may be a fully-&#xA;     * qualified name, in which case, the catalog and schemaPattern parameters&#xA;     * are ignored. If a table does not have a super table, it is not listed here.&#xA;     * Supertables have to be defined in the same catalog and schema as the &#xA;     * sub tables. Therefore, the type description does not need to include&#xA;     * this information for the supertable.&#xA;     *&#xA;     * &lt;P>Each type description has the following columns:&#xA;     *  &lt;OL>&#xA;     *  &lt;LI>&lt;B>TABLE_CAT&lt;/B> String => the type's catalog (may be &lt;code>null&lt;/code>)&#xA;     *  &lt;LI>&lt;B>TABLE_SCHEM&lt;/B> String => type's schema (may be &lt;code>null&lt;/code>)&#xA;     *  &lt;LI>&lt;B>TABLE_NAME&lt;/B> String => type name&#xA;     *  &lt;LI>&lt;B>SUPERTABLE_NAME&lt;/B> String => the direct super type's name&#xA;     *  &lt;/OL>&#xA;     *&#xA;     * &lt;P>&lt;B>Note:&lt;/B> If the driver does not support type hierarchies, an &#xA;     * empty result set is returned.&#xA;     *&#xA;     * @param catalog a catalog name; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means drop catalog name from the selection criteria&#xA;     * @param schemaPattern a schema name pattern; &quot;&quot; retrieves those &#xA;     *        without a schema&#xA;     * @param tableNamePattern a table name pattern; may be a fully-qualified&#xA;     *        name&#xA;     * @return a &lt;code>ResultSet&lt;/code> object in which each row is a type description&#xA;     * @throws SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schemaPattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tableNamePattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:Field" name="attributeNoNulls">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Short">
        <comments>/**&#xA;     * Indicates that &lt;code>NULL&lt;/code> values might not be allowed.&#xA;     * &lt;P>&#xA;     * A possible value for the column&#xA;     * &lt;code>NULLABLE&lt;/code> in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getAttributes&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="attributeNullable">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Short">
        <comments>/**&#xA;     * Indicates that &lt;code>NULL&lt;/code> values are definitely allowed.&#xA;     * &lt;P>&#xA;     * A possible value for the column &lt;code>NULLABLE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getAttributes&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="attributeNullableUnknown">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Short">
        <comments>/**&#xA;     * Indicates that whether &lt;code>NULL&lt;/code> values are allowed is not&#xA;     * known. &#xA;     * &lt;P>&#xA;     * A possible value for the column &lt;code>NULLABLE&lt;/code>&#xA;     * in the &lt;code>ResultSet&lt;/code> object&#xA;     * returned by the method &lt;code>getAttributes&lt;/code>.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAttributes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves a description of the given attribute of the given type &#xA;     * for a user-defined type (UDT) that is available in the given schema &#xA;     * and catalog.&#xA;     * &lt;P>&#xA;     * Descriptions are returned only for attributes of UDTs matching the &#xA;     * catalog, schema, type, and attribute name criteria. They are ordered by&#xA;     * TYPE_SCHEM, TYPE_NAME and ORDINAL_POSITION. This description&#xA;     * does not contain inherited attributes.&#xA;     * &lt;P>&#xA;     * The &lt;code>ResultSet&lt;/code> object that is returned has the following &#xA;     * columns:&#xA;     * &lt;OL>&#xA;     *  &lt;LI>&lt;B>TYPE_CAT&lt;/B> String => type catalog (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TYPE_SCHEM&lt;/B> String => type schema (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>TYPE_NAME&lt;/B> String => type name&#xA;     *&#x9;&lt;LI>&lt;B>ATTR_NAME&lt;/B> String => attribute name&#xA;     *&#x9;&lt;LI>&lt;B>DATA_TYPE&lt;/B> int => attribute type SQL type from java.sql.Types&#xA;     *&#x9;&lt;LI>&lt;B>ATTR_TYPE_NAME&lt;/B> String => Data source dependent type name.&#xA;     *  For a UDT, the type name is fully qualified. For a REF, the type name is &#xA;     *  fully qualified and represents the target type of the reference type.&#xA;     *&#x9;&lt;LI>&lt;B>ATTR_SIZE&lt;/B> int => column size.  For char or date&#xA;     *&#x9;    types this is the maximum number of characters; for numeric or&#xA;     *&#x9;    decimal types this is precision.&#xA;     *&#x9;&lt;LI>&lt;B>DECIMAL_DIGITS&lt;/B> int => the number of fractional digits&#xA;     *&#x9;&lt;LI>&lt;B>NUM_PREC_RADIX&lt;/B> int => Radix (typically either 10 or 2)&#xA;     *&#x9;&lt;LI>&lt;B>NULLABLE&lt;/B> int => whether NULL is allowed&#xA;     *      &lt;UL>&#xA;     *      &lt;LI> attributeNoNulls - might not allow NULL values&#xA;     *      &lt;LI> attributeNullable - definitely allows NULL values&#xA;     *      &lt;LI> attributeNullableUnknown - nullability unknown&#xA;     *      &lt;/UL>&#xA;     *&#x9;&lt;LI>&lt;B>REMARKS&lt;/B> String => comment describing column (may be &lt;code>null&lt;/code>)&#xA;     * &#x9;&lt;LI>&lt;B>ATTR_DEF&lt;/B> String => default value (may be &lt;code>null&lt;/code>)&#xA;     *&#x9;&lt;LI>&lt;B>SQL_DATA_TYPE&lt;/B> int => unused&#xA;     *&#x9;&lt;LI>&lt;B>SQL_DATETIME_SUB&lt;/B> int => unused&#xA;     *&#x9;&lt;LI>&lt;B>CHAR_OCTET_LENGTH&lt;/B> int => for char types the &#xA;     *       maximum number of bytes in the column&#xA;     *&#x9;&lt;LI>&lt;B>ORDINAL_POSITION&lt;/B> int&#x9;=> index of column in table &#xA;     *      (starting at 1)&#xA;     *&#x9;&lt;LI>&lt;B>IS_NULLABLE&lt;/B> String => &quot;NO&quot; means column definitely &#xA;     *      does not allow NULL values; &quot;YES&quot; means the column might &#xA;     *      allow NULL values.  An empty string means unknown.&#xA;     *  &lt;LI>&lt;B>SCOPE_CATALOG&lt;/B> String => catalog of table that is the&#xA;     *      scope of a reference attribute (&lt;code>null&lt;/code> if DATA_TYPE isn't REF)&#xA;     *  &lt;LI>&lt;B>SCOPE_SCHEMA&lt;/B> String => schema of table that is the &#xA;     *      scope of a reference attribute (&lt;code>null&lt;/code> if DATA_TYPE isn't REF)&#xA;     *  &lt;LI>&lt;B>SCOPE_TABLE&lt;/B> String => table name that is the scope of a &#xA;     *      reference attribute (&lt;code>null&lt;/code> if the DATA_TYPE isn't REF)&#xA;     * &lt;LI>&lt;B>SOURCE_DATA_TYPE&lt;/B> short => source type of a distinct type or user-generated&#xA;     *      Ref type,SQL type from java.sql.Types (&lt;code>null&lt;/code> if DATA_TYPE &#xA;     *      isn't DISTINCT or user-generated REF)&#xA;     *  &lt;/OL>&#xA;     * @param catalog a catalog name; must match the catalog name as it&#xA;     *        is stored in the database; &quot;&quot; retrieves those without a catalog;&#xA;     *        &lt;code>null&lt;/code> means that the catalog name should not be used to narrow&#xA;     *        the search&#xA;     * @param schemaPattern a schema name pattern; must match the schema name&#xA;     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;&#xA;     *        &lt;code>null&lt;/code> means that the schema name should not be used to narrow&#xA;     *        the search&#xA;     * @param typeNamePattern a type name pattern; must match the&#xA;     *        type name as it is stored in the database &#xA;     * @param attributeNamePattern an attribute name pattern; must match the attribute&#xA;     *        name as it is declared in the database&#xA;     * @return a &lt;code>ResultSet&lt;/code> object in which each row is an &#xA;     *         attribute description&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="catalog">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="schemaPattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="typeNamePattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="attributeNamePattern">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsResultSetHoldability">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports the given result set holdability.&#xA;     *&#xA;     * @param holdability one of the following constants:&#xA;     *          &lt;code>ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code> or&#xA;     *          &lt;code>ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;code>&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Connection&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="holdability">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getResultSetHoldability">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the default holdability of this &lt;code>ResultSet&lt;/code>&#xA;     * object.&#xA;     *&#xA;     * @return the default holdability; either &#xA;     *         &lt;code>ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code> or&#xA;     *         &lt;code>ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code>&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDatabaseMajorVersion">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the major version number of the underlying database.&#xA;     *&#xA;     * @return the underlying database's major version&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDatabaseMinorVersion">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the minor version number of the underlying database.&#xA;     *&#xA;     * @return underlying database's minor version&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getJDBCMajorVersion">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the major JDBC version number for this&#xA;     * driver.&#xA;     * &#xA;     * @return JDBC version major number&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getJDBCMinorVersion">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the minor JDBC version number for this&#xA;     * driver.&#xA;     * &#xA;     * @return JDBC version minor number&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:Field" name="sqlStateXOpen">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the value is an&#xA;     * X/Open (now know as Open Group) SQL CLI SQLSTATE value.&#xA;     * &lt;P>&#xA;     * A possible return value for the method&#xA;     * &lt;code>SQLException.getSQLState&lt;/code>.&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="sqlStateSQL99">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates that the value is an SQL99 SQLSTATE value.&#xA;     * &lt;P>&#xA;     * A possible return value for the method&#xA;     * &lt;code>SQLException.getSQLState&lt;/code>.&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSQLStateType">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Indicates whether the SQLSTATE returned by &lt;code>SQLException.getSQLState&lt;/code>&#xA;     * is X/Open (now known as Open Group) SQL CLI or SQL99.&#xA;     * @return the type of SQLSTATE; one of:&#xA;     *        sqlStateXOpen or&#xA;     *        sqlStateSQL99&#xA;     * @throws SQLException if a database access error occurs &#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="locatorsUpdateCopy">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Indicates whether updates made to a LOB are made on a copy or directly &#xA;     * to the LOB.&#xA;     * @return &lt;code>true&lt;/code> if updates are made to a copy of the LOB;&#xA;     *         &lt;code>false&lt;/code> if updates are made directly to the LOB&#xA;     * @throws SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsStatementPooling">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether this database supports statement pooling.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if so; &lt;code>false&lt;/code> otherwise&#xA;     * @throws SQLExcpetion if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Comprehensive information about the database as a whole.&#xA; * &lt;P>&#xA; * This interface is implemented by driver vendors to let users know the capabilities&#xA; * of a Database Management System (DBMS) in combination with &#xA; * the driver based on JDBC&lt;sup>&lt;font size=-2>TM&lt;/font>&lt;/sup> technology &#xA; * (&quot;JDBC driver&quot;) that is used with it.  Different relational DBMSs often support&#xA; * different features, implement features in different ways, and use different&#xA; * data types.  In addition, a driver may implement a feature on top of what the &#xA; * DBMS offers.  Information returned by methods in this interface applies&#xA; * to the capabilities of a particular driver and a particular DBMS working&#xA; * together. Note that as used in this documentation, the term &quot;database&quot; is&#xA; * used generically to refer to both the driver and DBMS.&#xA; * &lt;P>&#xA; * A user for this interface is commonly a tool that needs to discover how to&#xA; * deal with the underlying DBMS.  This is especially true for applications&#xA; * that are intended to be used with more than one DBMS. For example, a tool might use the method &#xA; * &lt;code>getTypeInfo&lt;/code> to find out what data types can be used in a&#xA; * &lt;code>CREATE TABLE&lt;/code> statement.  Or a user might call the method&#xA; * &lt;code>supportsCorrelatedSubqueries&lt;/code> to see if it is possible to use&#xA; * a correlated subquery or &lt;code>supportsBatchUpdates&lt;/code> to see if it is &#xA; * possible to use batch updates. &#xA; * &lt;P>&#xA; * Some &lt;code>DatabaseMetaData&lt;/code> methods return lists of information&#xA; * in the form of &lt;code>ResultSet&lt;/code> objects.&#xA; * Regular &lt;code>ResultSet&lt;/code> methods, such as&#xA; * &lt;code>getString&lt;/code> and &lt;code>getInt&lt;/code>, can be used &#xA; * to retrieve the data from these &lt;code>ResultSet&lt;/code> objects.  If &#xA; * a given form of metadata is not available, the &lt;code>ResultSet&lt;/code>&#xA; * getter methods throw an &lt;code>SQLException&lt;/code>.&#xA; * &lt;P>&#xA; * Some &lt;code>DatabaseMetaData&lt;/code> methods take arguments that are &#xA; * String patterns.  These arguments all have names such as fooPattern.  &#xA; * Within a pattern String, &quot;%&quot; means match any substring of 0 or more &#xA; * characters, and &quot;_&quot; means match any one character. Only metadata &#xA; * entries matching the search pattern are returned. If a search pattern &#xA; * argument is set to &lt;code>null&lt;/code>, that argument's criterion will &#xA; * be dropped from the search.&#xA; * &lt;P>&#xA; * A method that gets information about a feature that the driver does not&#xA; * support will throw an &lt;code>SQLException&lt;/code>.&#xA; * In the case of methods that return a &lt;code>ResultSet&lt;/code>&#xA; * object, either a &lt;code>ResultSet&lt;/code> object (which may be empty) is &#xA; * returned or an &lt;code>SQLException&lt;/code> is thrown.&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
