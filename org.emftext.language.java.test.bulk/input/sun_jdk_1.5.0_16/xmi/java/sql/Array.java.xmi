<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="Array.java">
  <comments>/*&#xA; * @(#)Array.java&#x9;1.23 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>sql</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Array">
    <members xsi:type="members:InterfaceMethod" name="getBaseTypeName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;   * Retrieves the SQL type name of the elements in &#xA;   * the array designated by this &lt;code>Array&lt;/code> object.&#xA;   * If the elements are a built-in type, it returns&#xA;   * the database-specific type name of the elements. &#xA;   * If the elements are a user-defined type (UDT),&#xA;   * this method returns the fully-qualified SQL type name.&#xA;   *&#xA;   * @return a &lt;code>String&lt;/code> that is the database-specific&#xA;   * name for a built-in base type; or the fully-qualified SQL type&#xA;   * name for a base type that is a UDT&#xA;   * @exception SQLException if an error occurs while attempting&#xA;   * to access the type name&#xA;   * @since 1.2&#xA;   */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBaseType">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;   * Retrieves the JDBC type of the elements in the array designated&#xA;   * by this &lt;code>Array&lt;/code> object.&#xA;   *&#xA;   * @return a constant from the class {@link java.sql.Types} that is&#xA;   * the type code for the elements in the array designated by this&#xA;   * &lt;code>Array&lt;/code> object&#xA;   * @exception SQLException if an error occurs while attempting&#xA;   * to access the base type &#xA;   * @since 1.2&#xA;   */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getArray">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;   * Retrieves the contents of the SQL &lt;code>ARRAY&lt;/code> value designated &#xA;   * by this&#xA;   * &lt;code>Array&lt;/code> object in the form of an array in the Java&#xA;   * programming language. This version of the method &lt;code>getArray&lt;/code>&#xA;   * uses the type map associated with the connection for customizations of &#xA;   * the type mappings.&#xA;   *&#xA;   * @return an array in the Java programming language that contains &#xA;   * the ordered elements of the SQL &lt;code>ARRAY&lt;/code> value&#xA;   * designated by this &lt;code>Array&lt;/code> object&#xA;   * @exception SQLException if an error occurs while attempting to&#xA;   * access the array&#xA;   * @since 1.2&#xA;   */</comments>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getArray">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;   * Retrieves the contents of the SQL &lt;code>ARRAY&lt;/code> value designated by this &#xA;   * &lt;code>Array&lt;/code> object.&#xA;   * This method uses &#xA;   * the specified &lt;code>map&lt;/code> for type map customizations&#xA;   * unless the base type of the array does not match a user-defined &#xA;   * type in &lt;code>map&lt;/code>, in which case it &#xA;   * uses the standard mapping. This version of the method&#xA;   * &lt;code>getArray&lt;/code> uses either the given type map or the standard mapping;&#xA;   * it never uses the type map associated with the connection.&#xA;   *&#xA;   * @param map a &lt;code>java.util.Map&lt;/code> object that contains mappings&#xA;   *            of SQL type names to classes in the Java programming language&#xA;   * @return an array in the Java programming language that contains the ordered &#xA;   *         elements of the SQL array designated by this object&#xA;   * @exception SQLException if an error occurs while attempting to &#xA;   *                         access the array&#xA;   * @since 1.2&#xA;   */</comments>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="map">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>util</namespaces>
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:UnknownTypeArgument"/>
                  <target xsi:type="classifiers:Class" href="../lang/Class.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getArray">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;   * Retrieves a slice of the SQL &lt;code>ARRAY&lt;/code>&#xA;   * value designated by this &lt;code>Array&lt;/code> object, beginning with the&#xA;   * specified &lt;code>index&lt;/code> and containing up to &lt;code>count&lt;/code> &#xA;   * successive elements of the SQL array.  This method uses the type map&#xA;   * associated with the connection for customizations of the type mappings.&#xA;   *&#xA;   * @param index the array index of the first element to retrieve;&#xA;   *              the first element is at index 1&#xA;   * @param count the number of successive SQL array elements to retrieve&#xA;   * @return an array containing up to &lt;code>count&lt;/code> consecutive elements &#xA;   * of the SQL array, beginning with element &lt;code>index&lt;/code>&#xA;   * @exception SQLException if an error occurs while attempting to&#xA;   * access the array&#xA;   * @since 1.2&#xA;   */</comments>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getArray">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;   * Retreives a slice of the SQL &lt;code>ARRAY&lt;/code> value &#xA;   * designated by this &lt;code>Array&lt;/code> object, beginning with the specified&#xA;   * &lt;code>index&lt;/code> and containing up to &lt;code>count&lt;/code>&#xA;   * successive elements of the SQL array.  &#xA;   * &lt;P>&#xA;   * This method uses &#xA;   * the specified &lt;code>map&lt;/code> for type map customizations&#xA;   * unless the base type of the array does not match a user-defined &#xA;   * type in &lt;code>map&lt;/code>, in which case it &#xA;   * uses the standard mapping. This version of the method&#xA;   * &lt;code>getArray&lt;/code> uses either the given type map or the standard mapping;&#xA;   * it never uses the type map associated with the connection.&#xA;   *&#xA;   * @param index the array index of the first element to retrieve;&#xA;   *              the first element is at index 1&#xA;   * @param count the number of successive SQL array elements to &#xA;   * retrieve&#xA;   * @param map a &lt;code>java.util.Map&lt;/code> object&#xA;   * that contains SQL type names and the classes in&#xA;   * the Java programming language to which they are mapped&#xA;   * @return an array containing up to &lt;code>count&lt;/code>&#xA;   * consecutive elements of the SQL &lt;code>ARRAY&lt;/code> value designated by this&#xA;   * &lt;code>Array&lt;/code> object, beginning with element &#xA;   * &lt;code>index&lt;/code>&#xA;   * @exception SQLException if an error occurs while attempting to&#xA;   * access the array&#xA;   * @since 1.2&#xA;   */</comments>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="map">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>util</namespaces>
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:UnknownTypeArgument"/>
                  <target xsi:type="classifiers:Class" href="../lang/Class.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getResultSet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;   * Retrieves a result set that contains the elements of the SQL &#xA;   * &lt;code>ARRAY&lt;/code> value&#xA;   * designated by this &lt;code>Array&lt;/code> object.  If appropriate,&#xA;   * the elements of the array are mapped using the connection's type &#xA;   * map; otherwise, the standard mapping is used.&#xA;   * &lt;p>&#xA;   * The result set contains one row for each array element, with&#xA;   * two columns in each row.  The second column stores the element&#xA;   * value; the first column stores the index into the array for &#xA;   * that element (with the first array element being at index 1). &#xA;   * The rows are in ascending order corresponding to&#xA;   * the order of the indices.&#xA;   *&#xA;   * @return a {@link ResultSet} object containing one row for each&#xA;   * of the elements in the array designated by this &lt;code>Array&lt;/code>&#xA;   * object, with the rows in ascending order based on the indices.&#xA;   * @exception SQLException if an error occurs while attempting to&#xA;   * access the array&#xA;   * @since 1.2&#xA;   */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getResultSet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;   * Retrieves a result set that contains the elements of the SQL &#xA;   * &lt;code>ARRAY&lt;/code> value designated by this &lt;code>Array&lt;/code> object.&#xA;   * This method uses &#xA;   * the specified &lt;code>map&lt;/code> for type map customizations&#xA;   * unless the base type of the array does not match a user-defined &#xA;   * type in &lt;code>map&lt;/code>, in which case it &#xA;   * uses the standard mapping. This version of the method&#xA;   * &lt;code>getResultSet&lt;/code> uses either the given type map or the standard mapping;&#xA;   * it never uses the type map associated with the connection.&#xA;   * &lt;p>&#xA;   * The result set contains one row for each array element, with&#xA;   * two columns in each row.  The second column stores the element&#xA;   * value; the first column stores the index into the array for &#xA;   * that element (with the first array element being at index 1). &#xA;   * The rows are in ascending order corresponding to&#xA;   * the order of the indices.&#xA;   *&#xA;   * @param map contains the mapping of SQL user-defined types to &#xA;   * classes in the Java programming language&#xA;   * @return a &lt;code>ResultSet&lt;/code> object containing one row for each&#xA;   * of the elements in the array designated by this &lt;code>Array&lt;/code>&#xA;   * object, with the rows in ascending order based on the indices.&#xA;   * @exception SQLException if an error occurs while attempting to&#xA;   * access the array&#xA;   * @since 1.2&#xA;   */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="map">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>util</namespaces>
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:UnknownTypeArgument"/>
                  <target xsi:type="classifiers:Class" href="../lang/Class.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getResultSet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;   * Retrieves a result set holding the elements of the subarray that&#xA;   * starts at index &lt;code>index&lt;/code> and contains up to &#xA;   * &lt;code>count&lt;/code> successive elements.  This method uses&#xA;   * the connection's type map to map the elements of the array if&#xA;   * the map contains an entry for the base type. Otherwise, the&#xA;   * standard mapping is used.&#xA;   * &lt;P>&#xA;   * The result set has one row for each element of the SQL array&#xA;   * designated by this object, with the first row containing the &#xA;   * element at index &lt;code>index&lt;/code>.  The result set has&#xA;   * up to &lt;code>count&lt;/code> rows in ascending order based on the&#xA;   * indices.  Each row has two columns:  The second column stores&#xA;   * the element value; the first column stores the index into the&#xA;   * array for that element.&#xA;   *&#xA;   * @param index the array index of the first element to retrieve;&#xA;   *              the first element is at index 1&#xA;   * @param count the number of successive SQL array elements to retrieve&#xA;   * @return a &lt;code>ResultSet&lt;/code> object containing up to&#xA;   * &lt;code>count&lt;/code> consecutive elements of the SQL array&#xA;   * designated by this &lt;code>Array&lt;/code> object, starting at&#xA;   * index &lt;code>index&lt;/code>.&#xA;   * @exception SQLException if an error occurs while attempting to&#xA;   * access the array&#xA;   * @since 1.2&#xA;   */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getResultSet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;   * Retrieves a result set holding the elements of the subarray that&#xA;   * starts at index &lt;code>index&lt;/code> and contains up to&#xA;   * &lt;code>count&lt;/code> successive elements.&#xA;   * This method uses &#xA;   * the specified &lt;code>map&lt;/code> for type map customizations&#xA;   * unless the base type of the array does not match a user-defined &#xA;   * type in &lt;code>map&lt;/code>, in which case it &#xA;   * uses the standard mapping. This version of the method&#xA;   * &lt;code>getResultSet&lt;/code> uses either the given type map or the standard mapping;&#xA;   * it never uses the type map associated with the connection.&#xA;   * &lt;P>&#xA;   * The result set has one row for each element of the SQL array&#xA;   * designated by this object, with the first row containing the&#xA;   * element at index &lt;code>index&lt;/code>.  The result set has   &#xA;   * up to &lt;code>count&lt;/code> rows in ascending order based on the&#xA;   * indices.  Each row has two columns:  The second column stores  &#xA;   * the element value; the first column stroes the index into the&#xA;   * array for that element.&#xA;   *&#xA;   * @param index the array index of the first element to retrieve;&#xA;   *              the first element is at index 1&#xA;   * @param count the number of successive SQL array elements to retrieve&#xA;   * @param map the &lt;code>Map&lt;/code> object that contains the mapping&#xA;   * of SQL type names to classes in the Java(tm) programming language&#xA;   * @return a &lt;code>ResultSet&lt;/code> object containing up to               &#xA;   * &lt;code>count&lt;/code> consecutive elements of the SQL array&#xA;   * designated by this &lt;code>Array&lt;/code> object, starting at&#xA;   * index &lt;code>index&lt;/code>.&#xA;   * @exception SQLException if an error occurs while attempting to&#xA;   * access the array&#xA;   * @since 1.2&#xA;   */</comments>
          <target xsi:type="classifiers:Interface" href="ResultSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="map">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>util</namespaces>
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:UnknownTypeArgument"/>
                  <target xsi:type="classifiers:Class" href="../lang/Class.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The mapping in the Java programming language for the SQL type&#xA; * &lt;code>ARRAY&lt;/code>.&#xA; * By default, an &lt;code>Array&lt;/code> value is a transaction-duration &#xA; * reference to an SQL &lt;code>ARRAY&lt;/code> value.  By default, an &lt;code>Array&lt;/code>&#xA; * object is implemented using an SQL LOCATOR(array) internally, which&#xA; * means that an &lt;code>Array&lt;/code> object contains a logical pointer&#xA; * to the data in the SQL &lt;code>ARRAY&lt;/code> value rather&#xA; * than containing the &lt;code>ARRAY&lt;/code> value's data.&#xA; * &lt;p>&#xA; * The &lt;code>Array&lt;/code> interface provides methods for bringing an SQL&#xA; * &lt;code>ARRAY&lt;/code> value's data to the client as either an array or a&#xA; * &lt;code>ResultSet&lt;/code> object.&#xA; * If the elements of the SQL &lt;code>ARRAY&lt;/code>&#xA; * are a UDT, they may be custom mapped.  To create a custom mapping,&#xA; * a programmer must do two things:&#xA; * &lt;ul>&#xA; * &lt;li>create a class that implements the {@link SQLData}&#xA; * interface for the UDT to be custom mapped. &#xA; * &lt;li>make an entry in a type map that contains &#xA; *   &lt;ul>&#xA; *   &lt;li>the fully-qualified SQL type name of the UDT&#xA; *   &lt;li>the &lt;code>Class&lt;/code> object for the class implementing&#xA; *       &lt;code>SQLData&lt;/code>&#xA; *   &lt;/ul>&#xA; * &lt;/ul>&#xA; * &lt;p>&#xA; * When a type map with an entry for&#xA; * the base type is supplied to the methods &lt;code>getArray&lt;/code>&#xA; * and &lt;code>getResultSet&lt;/code>, the mapping&#xA; * it contains will be used to map the elements of the &lt;code>ARRAY&lt;/code> value.&#xA; * If no type map is supplied, which would typically be the case,&#xA; * the connection's type map is used by default.&#xA; * If the connection's type map or a type map supplied to a method has no entry&#xA; * for the base type, the elements are mapped according to the standard mapping.&#xA; * &lt;p>&#xA; * @since 1.2 &#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
