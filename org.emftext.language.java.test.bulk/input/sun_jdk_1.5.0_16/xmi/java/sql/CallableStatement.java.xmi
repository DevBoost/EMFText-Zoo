<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:annotations="http://www.emftext.org/java/annotations" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/annotations ../../java.ecore#/0 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="CallableStatement.java">
  <comments>/*&#xA; * @(#)CallableStatement.java&#x9;1.47 04/05/18&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>sql</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>math</namespaces>
    <classifier xsi:type="classifiers:Class" href="../math/BigDecimal.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="CallableStatement">
    <members xsi:type="members:InterfaceMethod" name="registerOutParameter">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Registers the OUT parameter in ordinal position &#xA;     * &lt;code>parameterIndex&lt;/code> to the JDBC type &#xA;     * &lt;code>sqlType&lt;/code>.  All OUT parameters must be registered&#xA;     * before a stored procedure is executed.&#xA;     * &lt;p>&#xA;     * The JDBC type specified by &lt;code>sqlType&lt;/code> for an OUT&#xA;     * parameter determines the Java type that must be used&#xA;     * in the &lt;code>get&lt;/code> method to read the value of that parameter.&#xA;     * &lt;p>&#xA;     * If the JDBC type expected to be returned to this output parameter&#xA;     * is specific to this particular database, &lt;code>sqlType&lt;/code>&#xA;     * should be &lt;code>java.sql.Types.OTHER&lt;/code>.  The method &#xA;     * {@link #getObject} retrieves the value.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     *        and so on&#xA;     * @param sqlType the JDBC type code defined by &lt;code>java.sql.Types&lt;/code>.&#xA;     *        If the parameter is of JDBC type &lt;code>NUMERIC&lt;/code>&#xA;     *        or &lt;code>DECIMAL&lt;/code>, the version of&#xA;     *        &lt;code>registerOutParameter&lt;/code> that accepts a scale value &#xA;     *        should be used.&#xA;     *&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Types &#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="registerOutParameter">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Registers the parameter in ordinal position&#xA;     * &lt;code>parameterIndex&lt;/code> to be of JDBC type&#xA;     * &lt;code>sqlType&lt;/code>.  This method must be called&#xA;     * before a stored procedure is executed.&#xA;     * &lt;p>&#xA;     * The JDBC type specified by &lt;code>sqlType&lt;/code> for an OUT&#xA;     * parameter determines the Java type that must be used&#xA;     * in the &lt;code>get&lt;/code> method to read the value of that parameter.&#xA;     * &lt;p>&#xA;     * This version of &lt;code>registerOutParameter&lt;/code> should be&#xA;     * used when the parameter is of JDBC type &lt;code>NUMERIC&lt;/code>&#xA;     * or &lt;code>DECIMAL&lt;/code>.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2,&#xA;     * and so on&#xA;     * @param sqlType the SQL type code defined by &lt;code>java.sql.Types&lt;/code>.&#xA;     * @param scale the desired number of digits to the right of the&#xA;     * decimal point.  It must be greater than or equal to zero.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Types &#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="wasNull">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves whether the last OUT parameter read had the value of&#xA;     * SQL &lt;code>NULL&lt;/code>.  Note that this method should be called only after&#xA;     * calling a getter method; otherwise, there is no value to use in &#xA;     * determining whether it is &lt;code>null&lt;/code> or not.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if the last parameter read was SQL&#xA;     * &lt;code>NULL&lt;/code>; &lt;code>false&lt;/code> otherwise &#xA;     * @exception SQLException if a database access error occurs&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>CHAR&lt;/code>, &#xA;     * &lt;code>VARCHAR&lt;/code>, or &lt;code>LONGVARCHAR&lt;/code> parameter as a &#xA;     * &lt;code>String&lt;/code> in the Java programming language.&#xA;     * &lt;p>&#xA;     * For the fixed-length type JDBC &lt;code>CHAR&lt;/code>,&#xA;     * the &lt;code>String&lt;/code> object&#xA;     * returned has exactly the same value the JDBC&#xA;     * &lt;code>CHAR&lt;/code> value had in the&#xA;     * database, including any padding added by the database.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     * and so on&#xA;     * @return the parameter value. If the value is SQL &lt;code>NULL&lt;/code>, &#xA;     *         the result &#xA;     *         is &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setString&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBoolean">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>BIT&lt;/code> parameter as a &#xA;     * &lt;code>boolean&lt;/code> in the Java programming language.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     *        and so on&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, &#xA;     *         the result is &lt;code>false&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setBoolean&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getByte">
      <typeReference xsi:type="types:Byte">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>TINYINT&lt;/code> parameter &#xA;     * as a &lt;code>byte&lt;/code> in the Java programming language.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     * and so on&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     * is &lt;code>0&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setByte&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getShort">
      <typeReference xsi:type="types:Short">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>SMALLINT&lt;/code> parameter &#xA;     * as a &lt;code>short&lt;/code> in the Java programming language.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     * and so on&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     * is &lt;code>0&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setShort&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getInt">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>INTEGER&lt;/code> parameter &#xA;     * as an &lt;code>int&lt;/code> in the Java programming language.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     * and so on&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     * is &lt;code>0&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setInt&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLong">
      <typeReference xsi:type="types:Long">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>BIGINT&lt;/code> parameter &#xA;     * as a &lt;code>long&lt;/code> in the Java programming language.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     * and so on&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     * is &lt;code>0&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setLong&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFloat">
      <typeReference xsi:type="types:Float">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>FLOAT&lt;/code> parameter &#xA;     * as a &lt;code>float&lt;/code> in the Java programming language.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     *        and so on&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     *         is &lt;code>0&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setFloat&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDouble">
      <typeReference xsi:type="types:Double">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>DOUBLE&lt;/code> parameter as a &lt;code>double&lt;/code>&#xA;     * in the Java programming language.&#xA;     * @param parameterIndex the first parameter is 1, the second is 2,&#xA;     *        and so on&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     *         is &lt;code>0&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setDouble&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBigDecimal">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../math/BigDecimal.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/** &#xA;     * Retrieves the value of the designated JDBC &lt;code>NUMERIC&lt;/code> parameter as a &#xA;     * &lt;code>java.math.BigDecimal&lt;/code> object with &lt;i>scale&lt;/i> digits to&#xA;     * the right of the decimal point.&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     *        and so on&#xA;     * @param scale the number of digits to the right of the decimal point &#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     *         is &lt;code>null&lt;/code>. &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @deprecated use &lt;code>getBigDecimal(int parameterIndex)&lt;/code>&#xA;     *             or &lt;code>getBigDecimal(String parameterName)&lt;/code>&#xA;     * @see #setBigDecimal&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="../lang/Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBytes">
      <typeReference xsi:type="types:Byte">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>BINARY&lt;/code> or &#xA;     * &lt;code>VARBINARY&lt;/code> parameter as an array of &lt;code>byte&lt;/code> &#xA;     * values in the Java programming language.&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     *        and so on&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     *         is &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setBytes&#xA;     */</comments>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>DATE&lt;/code> parameter as a &#xA;     * &lt;code>java.sql.Date&lt;/code> object.&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     *        and so on&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     *         is &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setDate&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTime">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>TIME&lt;/code> parameter as a &#xA;     * &lt;code>java.sql.Time&lt;/code> object.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     *        and so on&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     *         is &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setTime&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Time.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTimestamp">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>TIMESTAMP&lt;/code> parameter as a &#xA;     * &lt;code>java.sql.Timestamp&lt;/code> object.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     *        and so on&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     *         is &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setTimestamp&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Timestamp.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getObject">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>//----------------------------------------------------------------------</comments>
          <comments>// Advanced features:</comments>
          <comments>/**&#xA;     * Retrieves the value of the designated parameter as an &lt;code>Object&lt;/code> &#xA;     * in the Java programming language. If the value is an SQL &lt;code>NULL&lt;/code>,&#xA;     * the driver returns a Java &lt;code>null&lt;/code>.&#xA;     * &lt;p>&#xA;     * This method returns a Java object whose type corresponds to the JDBC&#xA;     * type that was registered for this parameter using the method&#xA;     * &lt;code>registerOutParameter&lt;/code>.  By registering the target JDBC&#xA;     * type as &lt;code>java.sql.Types.OTHER&lt;/code>, this method can be used&#xA;     * to read database-specific abstract data types.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     *        and so on&#xA;     * @return A &lt;code>java.lang.Object&lt;/code> holding the OUT parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Types &#xA;     * @see #setObject&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBigDecimal">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>//--------------------------JDBC 2.0-----------------------------</comments>
          <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>NUMERIC&lt;/code> parameter as a &#xA;     * &lt;code>java.math.BigDecimal&lt;/code> object with as many digits to the&#xA;     * right of the decimal point as the value contains.&#xA;     * @param parameterIndex the first parameter is 1, the second is 2,&#xA;     * and so on&#xA;     * @return the parameter value in full precision.  If the value is &#xA;     * SQL &lt;code>NULL&lt;/code>, the result is &lt;code>null&lt;/code>. &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setBigDecimal&#xA;     * @since 1.2&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../math/BigDecimal.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getObject">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns an object representing the value of OUT parameter &#xA;     * &lt;code>i&lt;/code> and uses &lt;code>map&lt;/code> for the custom&#xA;     * mapping of the parameter value.&#xA;     * &lt;p>&#xA;     * This method returns a Java object whose type corresponds to the&#xA;     * JDBC type that was registered for this parameter using the method&#xA;     * &lt;code>registerOutParameter&lt;/code>.  By registering the target&#xA;     * JDBC type as &lt;code>java.sql.Types.OTHER&lt;/code>, this method can&#xA;     * be used to read database-specific abstract data types.  &#xA;     * @param i the first parameter is 1, the second is 2, and so on&#xA;     * @param map the mapping from SQL type names to Java classes&#xA;     * @return a &lt;code>java.lang.Object&lt;/code> holding the OUT parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setObject&#xA;     * @since 1.2&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="map">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>util</namespaces>
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:UnknownTypeArgument"/>
                  <target xsi:type="classifiers:Class" href="../lang/Class.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getRef">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>REF(&amp;lt;structured-type&amp;gt;)&lt;/code>&#xA;     * parameter as a {@link Ref} object in the Java programming language.&#xA;     * @param i the first parameter is 1, the second is 2, &#xA;     * and so on&#xA;     * @return the parameter value as a &lt;code>Ref&lt;/code> object in the&#xA;     * Java programming language.  If the value was SQL &lt;code>NULL&lt;/code>, the value&#xA;     * &lt;code>null&lt;/code> is returned.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="Ref.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBlob">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>BLOB&lt;/code> parameter as a&#xA;     * {@link Blob} object in the Java programming language.&#xA;     * @param i the first parameter is 1, the second is 2, and so on&#xA;     * @return the parameter value as a &lt;code>Blob&lt;/code> object in the&#xA;     * Java programming language.  If the value was SQL &lt;code>NULL&lt;/code>, the value&#xA;     * &lt;code>null&lt;/code> is returned.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="Blob.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getClob">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>CLOB&lt;/code> parameter as a&#xA;     * &lt;code>Clob&lt;/code> object in the Java programming language.&#xA;     * @param i the first parameter is 1, the second is 2, and&#xA;     * so on&#xA;     * @return the parameter value as a &lt;code>Clob&lt;/code> object in the&#xA;     * Java programming language.  If the value was SQL &lt;code>NULL&lt;/code>, the&#xA;     * value &lt;code>null&lt;/code> is returned.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="Clob.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getArray">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     *&#xA;     * Retrieves the value of the designated JDBC &lt;code>ARRAY&lt;/code> parameter as an&#xA;     * {@link Array} object in the Java programming language.&#xA;     * @param i the first parameter is 1, the second is 2, and &#xA;     * so on&#xA;     * @return the parameter value as an &lt;code>Array&lt;/code> object in&#xA;     * the Java programming language.  If the value was SQL &lt;code>NULL&lt;/code>, the&#xA;     * value &lt;code>null&lt;/code> is returned.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.2&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="Array.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>DATE&lt;/code> parameter as a &#xA;     * &lt;code>java.sql.Date&lt;/code> object, using&#xA;     * the given &lt;code>Calendar&lt;/code> object&#xA;     * to construct the date.&#xA;     * With a &lt;code>Calendar&lt;/code> object, the driver&#xA;     * can calculate the date taking into account a custom timezone and locale.&#xA;     * If no &lt;code>Calendar&lt;/code> object is specified, the driver uses the&#xA;     * default timezone and locale.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     * and so on&#xA;     * @param cal the &lt;code>Calendar&lt;/code> object the driver will use&#xA;     *            to construct the date&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     *         is &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setDate&#xA;     * @since 1.2&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTime">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>TIME&lt;/code> parameter as a &#xA;     * &lt;code>java.sql.Time&lt;/code> object, using&#xA;     * the given &lt;code>Calendar&lt;/code> object&#xA;     * to construct the time.&#xA;     * With a &lt;code>Calendar&lt;/code> object, the driver&#xA;     * can calculate the time taking into account a custom timezone and locale.&#xA;     * If no &lt;code>Calendar&lt;/code> object is specified, the driver uses the&#xA;     * default timezone and locale.&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2,&#xA;     * and so on&#xA;     * @param cal the &lt;code>Calendar&lt;/code> object the driver will use&#xA;     *            to construct the time&#xA;     * @return the parameter value; if the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     *         is &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setTime&#xA;     * @since 1.2&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Time.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTimestamp">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>TIMESTAMP&lt;/code> parameter as a&#xA;     * &lt;code>java.sql.Timestamp&lt;/code> object, using&#xA;     * the given &lt;code>Calendar&lt;/code> object to construct&#xA;     * the &lt;code>Timestamp&lt;/code> object.&#xA;     * With a &lt;code>Calendar&lt;/code> object, the driver&#xA;     * can calculate the timestamp taking into account a custom timezone and locale.&#xA;     * If no &lt;code>Calendar&lt;/code> object is specified, the driver uses the&#xA;     * default timezone and locale.&#xA;     *&#xA;     *&#xA;     * @param parameterIndex the first parameter is 1, the second is 2, &#xA;     * and so on&#xA;     * @param cal the &lt;code>Calendar&lt;/code> object the driver will use&#xA;     *            to construct the timestamp&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     *         is &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setTimestamp&#xA;     * @since 1.2&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Timestamp.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="registerOutParameter">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Registers the designated output parameter.  This version of &#xA;     * the method &lt;code>registerOutParameter&lt;/code>&#xA;     * should be used for a user-defined or &lt;code>REF&lt;/code> output parameter.  Examples&#xA;     * of user-defined types include: &lt;code>STRUCT&lt;/code>, &lt;code>DISTINCT&lt;/code>,&#xA;     * &lt;code>JAVA_OBJECT&lt;/code>, and named array types.&#xA;     *&#xA;     * Before executing a stored procedure call, you must explicitly&#xA;     * call &lt;code>registerOutParameter&lt;/code> to register the type from&#xA;     * &lt;code>java.sql.Types&lt;/code> for each&#xA;     * OUT parameter.  For a user-defined parameter, the fully-qualified SQL&#xA;     * type name of the parameter should also be given, while a &lt;code>REF&lt;/code>&#xA;     * parameter requires that the fully-qualified type name of the&#xA;     * referenced type be given.  A JDBC driver that does not need the&#xA;     * type code and type name information may ignore it.   To be portable,&#xA;     * however, applications should always provide these values for&#xA;     * user-defined and &lt;code>REF&lt;/code> parameters.&#xA;     *&#xA;     * Although it is intended for user-defined and &lt;code>REF&lt;/code> parameters,&#xA;     * this method may be used to register a parameter of any JDBC type.&#xA;     * If the parameter does not have a user-defined or &lt;code>REF&lt;/code> type, the&#xA;     * &lt;i>typeName&lt;/i> parameter is ignored.&#xA;     *&#xA;     * &lt;P>&lt;B>Note:&lt;/B> When reading the value of an out parameter, you&#xA;     * must use the getter method whose Java type corresponds to the&#xA;     * parameter's registered SQL type.&#xA;     *&#xA;     * @param paramIndex the first parameter is 1, the second is 2,...&#xA;     * @param sqlType a value from {@link java.sql.Types}&#xA;     * @param typeName the fully-qualified name of an SQL structured type&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Types&#xA;     * @since 1.2&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="paramIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="typeName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="registerOutParameter">
      <typeReference xsi:type="types:Void">
        <comments>//--------------------------JDBC 3.0-----------------------------</comments>
        <comments>/**&#xA;     * Registers the OUT parameter named &#xA;     * &lt;code>parameterName&lt;/code> to the JDBC type &#xA;     * &lt;code>sqlType&lt;/code>.  All OUT parameters must be registered&#xA;     * before a stored procedure is executed.&#xA;     * &lt;p>&#xA;     * The JDBC type specified by &lt;code>sqlType&lt;/code> for an OUT&#xA;     * parameter determines the Java type that must be used&#xA;     * in the &lt;code>get&lt;/code> method to read the value of that parameter.&#xA;     * &lt;p>&#xA;     * If the JDBC type expected to be returned to this output parameter&#xA;     * is specific to this particular database, &lt;code>sqlType&lt;/code>&#xA;     * should be &lt;code>java.sql.Types.OTHER&lt;/code>.  The method &#xA;     * {@link #getObject} retrieves the value.&#xA;     * @param parameterName the name of the parameter&#xA;     * @param sqlType the JDBC type code defined by &lt;code>java.sql.Types&lt;/code>.&#xA;     * If the parameter is of JDBC type &lt;code>NUMERIC&lt;/code>&#xA;     * or &lt;code>DECIMAL&lt;/code>, the version of&#xA;     * &lt;code>registerOutParameter&lt;/code> that accepts a scale value &#xA;     * should be used.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     * @see Types &#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="registerOutParameter">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Registers the parameter named &#xA;     * &lt;code>parameterName&lt;/code> to be of JDBC type&#xA;     * &lt;code>sqlType&lt;/code>.  This method must be called&#xA;     * before a stored procedure is executed.&#xA;     * &lt;p>&#xA;     * The JDBC type specified by &lt;code>sqlType&lt;/code> for an OUT&#xA;     * parameter determines the Java type that must be used&#xA;     * in the &lt;code>get&lt;/code> method to read the value of that parameter.&#xA;     * &lt;p>&#xA;     * This version of &lt;code>registerOutParameter&lt;/code> should be&#xA;     * used when the parameter is of JDBC type &lt;code>NUMERIC&lt;/code>&#xA;     * or &lt;code>DECIMAL&lt;/code>.&#xA;     * @param parameterName the name of the parameter&#xA;     * @param sqlType SQL type code defined by &lt;code>java.sql.Types&lt;/code>.&#xA;     * @param scale the desired number of digits to the right of the&#xA;     * decimal point.  It must be greater than or equal to zero.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     * @see Types &#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="registerOutParameter">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Registers the designated output parameter.  This version of &#xA;     * the method &lt;code>registerOutParameter&lt;/code>&#xA;     * should be used for a user-named or REF output parameter.  Examples&#xA;     * of user-named types include: STRUCT, DISTINCT, JAVA_OBJECT, and&#xA;     * named array types.&#xA;     *&#xA;     * Before executing a stored procedure call, you must explicitly&#xA;     * call &lt;code>registerOutParameter&lt;/code> to register the type from&#xA;     * &lt;code>java.sql.Types&lt;/code> for each&#xA;     * OUT parameter.  For a user-named parameter the fully-qualified SQL&#xA;     * type name of the parameter should also be given, while a REF&#xA;     * parameter requires that the fully-qualified type name of the&#xA;     * referenced type be given.  A JDBC driver that does not need the&#xA;     * type code and type name information may ignore it.   To be portable,&#xA;     * however, applications should always provide these values for&#xA;     * user-named and REF parameters.&#xA;     *&#xA;     * Although it is intended for user-named and REF parameters,&#xA;     * this method may be used to register a parameter of any JDBC type.&#xA;     * If the parameter does not have a user-named or REF type, the&#xA;     * typeName parameter is ignored.&#xA;     *&#xA;     * &lt;P>&lt;B>Note:&lt;/B> When reading the value of an out parameter, you&#xA;     * must use the &lt;code>getXXX&lt;/code> method whose Java type XXX corresponds to the&#xA;     * parameter's registered SQL type.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param sqlType a value from {@link java.sql.Types}&#xA;     * @param typeName the fully-qualified name of an SQL structured type&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Types&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="typeName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getURL">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of the designated JDBC &lt;code>DATALINK&lt;/code> parameter as a&#xA;     * &lt;code>java.net.URL&lt;/code> object.&#xA;     * &#xA;     * @param parameterIndex the first parameter is 1, the second is 2,...&#xA;     * @return a &lt;code>java.net.URL&lt;/code> object that represents the &#xA;     *         JDBC &lt;code>DATALINK&lt;/code> value used as the designated&#xA;     *         parameter&#xA;     * @exception SQLException if a database access error occurs,&#xA;     *            or if the URL being returned is&#xA;     *            not a valid URL on the Java platform&#xA;     * @see #setURL&#xA;     * @since 1.4&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>net</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../net/URL.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setURL">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.net.URL&lt;/code> object.&#xA;     * The driver converts this to an SQL &lt;code>DATALINK&lt;/code> value when&#xA;     * it sends it to the database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param val the parameter value&#xA;     * @exception SQLException if a database access error occurs,&#xA;     *            or if a URL is malformed&#xA;     * @see #getURL&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="val">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>net</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../net/URL.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setNull">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to SQL &lt;code>NULL&lt;/code>.&#xA;     *&#xA;     * &lt;P>&lt;B>Note:&lt;/B> You must specify the parameter's SQL type.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param sqlType the SQL type code defined in &lt;code>java.sql.Types&lt;/code>&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setBoolean">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>boolean&lt;/code> value.&#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>BIT&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getBoolean&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setByte">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>byte&lt;/code> value.  &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>TINYINT&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getByte&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Byte"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setShort">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>short&lt;/code> value. &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>SMALLINT&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getShort&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Short"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setInt">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>int&lt;/code> value.  &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>INTEGER&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getInt&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setLong">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>long&lt;/code> value. &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>BIGINT&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getLong&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setFloat">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>float&lt;/code> value. &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>FLOAT&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getFloat&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setDouble">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>double&lt;/code> value.  &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>DOUBLE&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getDouble&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setBigDecimal">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given&#xA;     * &lt;code>java.math.BigDecimal&lt;/code> value.  &#xA;     * The driver converts this to an SQL &lt;code>NUMERIC&lt;/code> value when&#xA;     * it sends it to the database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getBigDecimal&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../math/BigDecimal.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setString">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java &lt;code>String&lt;/code> value. &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>VARCHAR&lt;/code> or &lt;code>LONGVARCHAR&lt;/code> value&#xA;     * (depending on the argument's&#xA;     * size relative to the driver's limits on &lt;code>VARCHAR&lt;/code> values)&#xA;     * when it sends it to the database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getString&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setBytes">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given Java array of bytes.  &#xA;     * The driver converts this to an SQL &lt;code>VARBINARY&lt;/code> or &#xA;     * &lt;code>LONGVARBINARY&lt;/code> (depending on the argument's size relative &#xA;     * to the driver's limits on &lt;code>VARBINARY&lt;/code> values) when it sends &#xA;     * it to the database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getBytes&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setDate">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.sql.Date&lt;/code> value.  &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>DATE&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getDate&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>sql</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setTime">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.sql.Time&lt;/code> value.  &#xA;     * The driver converts this&#xA;     * to an SQL &lt;code>TIME&lt;/code> value when it sends it to the database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getTime&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>sql</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Time.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setTimestamp">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.sql.Timestamp&lt;/code> value.  &#xA;     * The driver&#xA;     * converts this to an SQL &lt;code>TIMESTAMP&lt;/code> value when it sends it to the&#xA;     * database.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getTimestamp&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>sql</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Timestamp.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setAsciiStream">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given input stream, which will have &#xA;     * the specified number of bytes.&#xA;     * When a very large ASCII value is input to a &lt;code>LONGVARCHAR&lt;/code>&#xA;     * parameter, it may be more practical to send it via a&#xA;     * &lt;code>java.io.InputStream&lt;/code>. Data will be read from the stream&#xA;     * as needed until end-of-file is reached.  The JDBC driver will&#xA;     * do any necessary conversion from ASCII to the database char format.&#xA;     * &#xA;     * &lt;P>&lt;B>Note:&lt;/B> This stream object can either be a standard&#xA;     * Java stream object or your own subclass that implements the&#xA;     * standard interface.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the Java input stream that contains the ASCII parameter value&#xA;     * @param length the number of bytes in the stream &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setBinaryStream">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given input stream, which will have &#xA;     * the specified number of bytes.&#xA;     * When a very large binary value is input to a &lt;code>LONGVARBINARY&lt;/code>&#xA;     * parameter, it may be more practical to send it via a&#xA;     * &lt;code>java.io.InputStream&lt;/code> object. The data will be read from the stream&#xA;     * as needed until end-of-file is reached.&#xA;     * &#xA;     * &lt;P>&lt;B>Note:&lt;/B> This stream object can either be a standard&#xA;     * Java stream object or your own subclass that implements the&#xA;     * standard interface.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the java input stream which contains the binary parameter value&#xA;     * @param length the number of bytes in the stream &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setObject">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the value of the designated parameter with the given object. The second&#xA;     * argument must be an object type; for integral values, the&#xA;     * &lt;code>java.lang&lt;/code> equivalent objects should be used.&#xA;     *&#xA;     * &lt;p>The given Java object will be converted to the given targetSqlType&#xA;     * before being sent to the database.&#xA;     *&#xA;     * If the object has a custom mapping (is of a class implementing the &#xA;     * interface &lt;code>SQLData&lt;/code>),&#xA;     * the JDBC driver should call the method &lt;code>SQLData.writeSQL&lt;/code> to write it &#xA;     * to the SQL data stream.&#xA;     * If, on the other hand, the object is of a class implementing&#xA;     * &lt;code>Ref&lt;/code>, &lt;code>Blob&lt;/code>, &lt;code>Clob&lt;/code>, &lt;code>Struct&lt;/code>, &#xA;     * or &lt;code>Array&lt;/code>, the driver should pass it to the database as a &#xA;     * value of the corresponding SQL type.&#xA;     * &lt;P>&#xA;     * Note that this method may be used to pass datatabase-&#xA;     * specific abstract data types. &#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the object containing the input parameter value&#xA;     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be &#xA;     * sent to the database. The scale argument may further qualify this type.&#xA;     * @param scale for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types,&#xA;     *          this is the number of digits after the decimal point.  For all other&#xA;     *          types, this value will be ignored.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Types&#xA;     * @see #getObject&#xA;     * @since 1.4 &#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="targetSqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scale">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setObject">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the value of the designated parameter with the given object.&#xA;     * This method is like the method &lt;code>setObject&lt;/code>&#xA;     * above, except that it assumes a scale of zero.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the object containing the input parameter value&#xA;     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be &#xA;     *                      sent to the database&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getObject&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="targetSqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setObject">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the value of the designated parameter with the given object. &#xA;     * The second parameter must be of type &lt;code>Object&lt;/code>; therefore, the&#xA;     * &lt;code>java.lang&lt;/code> equivalent objects should be used for built-in types.&#xA;     *&#xA;     * &lt;p>The JDBC specification specifies a standard mapping from&#xA;     * Java &lt;code>Object&lt;/code> types to SQL types.  The given argument &#xA;     * will be converted to the corresponding SQL type before being&#xA;     * sent to the database.&#xA;     *&#xA;     * &lt;p>Note that this method may be used to pass datatabase-&#xA;     * specific abstract data types, by using a driver-specific Java&#xA;     * type.&#xA;     *&#xA;     * If the object is of a class implementing the interface &lt;code>SQLData&lt;/code>,&#xA;     * the JDBC driver should call the method &lt;code>SQLData.writeSQL&lt;/code>&#xA;     * to write it to the SQL data stream.&#xA;     * If, on the other hand, the object is of a class implementing&#xA;     * &lt;code>Ref&lt;/code>, &lt;code>Blob&lt;/code>, &lt;code>Clob&lt;/code>, &lt;code>Struct&lt;/code>, &#xA;     * or &lt;code>Array&lt;/code>, the driver should pass it to the database as a &#xA;     * value of the corresponding SQL type.&#xA;     * &lt;P>&#xA;     * This method throws an exception if there is an ambiguity, for example, if the&#xA;     * object is of a class implementing more than one of the interfaces named above.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the object containing the input parameter value &#xA;     * @exception SQLException if a database access error occurs or if the given&#xA;     *            &lt;code>Object&lt;/code> parameter is ambiguous&#xA;     * @see #getObject&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setCharacterStream">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>Reader&lt;/code>&#xA;     * object, which is the given number of characters long.&#xA;     * When a very large UNICODE value is input to a &lt;code>LONGVARCHAR&lt;/code>&#xA;     * parameter, it may be more practical to send it via a&#xA;     * &lt;code>java.io.Reader&lt;/code> object. The data will be read from the stream&#xA;     * as needed until end-of-file is reached.  The JDBC driver will&#xA;     * do any necessary conversion from UNICODE to the database char format.&#xA;     * &#xA;     * &lt;P>&lt;B>Note:&lt;/B> This stream object can either be a standard&#xA;     * Java stream object or your own subclass that implements the&#xA;     * standard interface.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param reader the &lt;code>java.io.Reader&lt;/code> object that&#xA;     *        contains the UNICODE data used as the designated parameter&#xA;     * @param length the number of characters in the stream &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="reader">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/Reader.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setDate">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.sql.Date&lt;/code> value,&#xA;     * using the given &lt;code>Calendar&lt;/code> object.  The driver uses&#xA;     * the &lt;code>Calendar&lt;/code> object to construct an SQL &lt;code>DATE&lt;/code> value,&#xA;     * which the driver then sends to the database.  With a&#xA;     * a &lt;code>Calendar&lt;/code> object, the driver can calculate the date&#xA;     * taking into account a custom timezone.  If no&#xA;     * &lt;code>Calendar&lt;/code> object is specified, the driver uses the default&#xA;     * timezone, which is that of the virtual machine running the application.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value&#xA;     * @param cal the &lt;code>Calendar&lt;/code> object the driver will use&#xA;     *            to construct the date&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getDate&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>sql</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setTime">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.sql.Time&lt;/code> value,&#xA;     * using the given &lt;code>Calendar&lt;/code> object.  The driver uses&#xA;     * the &lt;code>Calendar&lt;/code> object to construct an SQL &lt;code>TIME&lt;/code> value,&#xA;     * which the driver then sends to the database.  With a&#xA;     * a &lt;code>Calendar&lt;/code> object, the driver can calculate the time&#xA;     * taking into account a custom timezone.  If no&#xA;     * &lt;code>Calendar&lt;/code> object is specified, the driver uses the default&#xA;     * timezone, which is that of the virtual machine running the application.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value&#xA;     * @param cal the &lt;code>Calendar&lt;/code> object the driver will use&#xA;     *            to construct the time&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getTime&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>sql</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Time.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setTimestamp">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to the given &lt;code>java.sql.Timestamp&lt;/code> value,&#xA;     * using the given &lt;code>Calendar&lt;/code> object.  The driver uses&#xA;     * the &lt;code>Calendar&lt;/code> object to construct an SQL &lt;code>TIMESTAMP&lt;/code> value,&#xA;     * which the driver then sends to the database.  With a&#xA;     * a &lt;code>Calendar&lt;/code> object, the driver can calculate the timestamp&#xA;     * taking into account a custom timezone.  If no&#xA;     * &lt;code>Calendar&lt;/code> object is specified, the driver uses the default&#xA;     * timezone, which is that of the virtual machine running the application.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param x the parameter value &#xA;     * @param cal the &lt;code>Calendar&lt;/code> object the driver will use&#xA;     *            to construct the timestamp&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #getTimestamp&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>sql</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Timestamp.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setNull">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the designated parameter to SQL &lt;code>NULL&lt;/code>.&#xA;     * This version of the method &lt;code>setNull&lt;/code> should&#xA;     * be used for user-defined types and REF type parameters.  Examples&#xA;     * of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and &#xA;     * named array types.&#xA;     *&#xA;     * &lt;P>&lt;B>Note:&lt;/B> To be portable, applications must give the&#xA;     * SQL type code and the fully-qualified SQL type name when specifying&#xA;     * a NULL user-defined or REF parameter.  In the case of a user-defined type &#xA;     * the name is the type name of the parameter itself.  For a REF &#xA;     * parameter, the name is the type name of the referenced type.  If &#xA;     * a JDBC driver does not need the type code or type name information, &#xA;     * it may ignore it.     &#xA;     *&#xA;     * Although it is intended for user-defined and Ref parameters,&#xA;     * this method may be used to set a null parameter of any JDBC type.&#xA;     * If the parameter does not have a user-defined or REF type, the given&#xA;     * typeName is ignored.&#xA;     *&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param sqlType a value from &lt;code>java.sql.Types&lt;/code>&#xA;     * @param typeName the fully-qualified name of an SQL user-defined type;&#xA;     *        ignored if the parameter is not a user-defined type or &#xA;     *        SQL &lt;code>REF&lt;/code> value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sqlType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="typeName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>CHAR&lt;/code>, &lt;code>VARCHAR&lt;/code>, &#xA;     * or &lt;code>LONGVARCHAR&lt;/code> parameter as a &lt;code>String&lt;/code> in &#xA;     * the Java programming language.&#xA;     * &lt;p>&#xA;     * For the fixed-length type JDBC &lt;code>CHAR&lt;/code>,&#xA;     * the &lt;code>String&lt;/code> object&#xA;     * returned has exactly the same value the JDBC&#xA;     * &lt;code>CHAR&lt;/code> value had in the&#xA;     * database, including any padding added by the database.&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value. If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     * is &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setString&#xA;     * @since 1.4&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBoolean">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>BIT&lt;/code> parameter as a&#xA;     * &lt;code>boolean&lt;/code> in the Java programming language.&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     * is &lt;code>false&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setBoolean&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getByte">
      <typeReference xsi:type="types:Byte">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>TINYINT&lt;/code> parameter as a &lt;code>byte&lt;/code> &#xA;     * in the Java programming language.&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     * is &lt;code>0&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setByte&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getShort">
      <typeReference xsi:type="types:Short">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>SMALLINT&lt;/code> parameter as a &lt;code>short&lt;/code>&#xA;     * in the Java programming language.&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     * is &lt;code>0&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setShort&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getInt">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>INTEGER&lt;/code> parameter as an &lt;code>int&lt;/code>&#xA;     * in the Java programming language.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, &#xA;     *         the result is &lt;code>0&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setInt&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLong">
      <typeReference xsi:type="types:Long">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>BIGINT&lt;/code> parameter as a &lt;code>long&lt;/code>&#xA;     * in the Java programming language.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, &#xA;     *         the result is &lt;code>0&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setLong&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFloat">
      <typeReference xsi:type="types:Float">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>FLOAT&lt;/code> parameter as a &lt;code>float&lt;/code>&#xA;     * in the Java programming language.&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, &#xA;     *         the result is &lt;code>0&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setFloat&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDouble">
      <typeReference xsi:type="types:Double">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>DOUBLE&lt;/code> parameter as a &lt;code>double&lt;/code>&#xA;     * in the Java programming language.&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, &#xA;     *         the result is &lt;code>0&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setDouble&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBytes">
      <typeReference xsi:type="types:Byte">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>BINARY&lt;/code> or &lt;code>VARBINARY&lt;/code> &#xA;     * parameter as an array of &lt;code>byte&lt;/code> values in the Java&#xA;     * programming language.&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result is &#xA;     *  &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setBytes&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>DATE&lt;/code> parameter as a &#xA;     * &lt;code>java.sql.Date&lt;/code> object.&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     * is &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setDate&#xA;     * @since 1.4&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTime">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>TIME&lt;/code> parameter as a &#xA;     * &lt;code>java.sql.Time&lt;/code> object.&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     * is &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setTime&#xA;     * @since 1.4&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Time.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTimestamp">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>TIMESTAMP&lt;/code> parameter as a &#xA;     * &lt;code>java.sql.Timestamp&lt;/code> object.&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result &#xA;     * is &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setTimestamp&#xA;     * @since 1.4&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Timestamp.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getObject">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the value of a parameter as an &lt;code>Object&lt;/code> in the Java &#xA;     * programming language. If the value is an SQL &lt;code>NULL&lt;/code>, the &#xA;     * driver returns a Java &lt;code>null&lt;/code>.&#xA;     * &lt;p>&#xA;     * This method returns a Java object whose type corresponds to the JDBC&#xA;     * type that was registered for this parameter using the method&#xA;     * &lt;code>registerOutParameter&lt;/code>.  By registering the target JDBC&#xA;     * type as &lt;code>java.sql.Types.OTHER&lt;/code>, this method can be used&#xA;     * to read database-specific abstract data types.&#xA;     * @param parameterName the name of the parameter&#xA;     * @return A &lt;code>java.lang.Object&lt;/code> holding the OUT parameter value.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see Types&#xA;     * @see #setObject&#xA;     * @since 1.4&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBigDecimal">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>NUMERIC&lt;/code> parameter as a &#xA;     * &lt;code>java.math.BigDecimal&lt;/code> object with as many digits to the&#xA;     * right of the decimal point as the value contains.&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value in full precision.  If the value is &#xA;     * SQL &lt;code>NULL&lt;/code>, the result is &lt;code>null&lt;/code>. &#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setBigDecimal&#xA;     * @since 1.4&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../math/BigDecimal.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getObject">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns an object representing the value of OUT parameter &#xA;     * &lt;code>i&lt;/code> and uses &lt;code>map&lt;/code> for the custom&#xA;     * mapping of the parameter value.&#xA;     * &lt;p>&#xA;     * This method returns a Java object whose type corresponds to the&#xA;     * JDBC type that was registered for this parameter using the method&#xA;     * &lt;code>registerOutParameter&lt;/code>.  By registering the target&#xA;     * JDBC type as &lt;code>java.sql.Types.OTHER&lt;/code>, this method can&#xA;     * be used to read database-specific abstract data types.  &#xA;     * @param parameterName the name of the parameter&#xA;     * @param map the mapping from SQL type names to Java classes&#xA;     * @return a &lt;code>java.lang.Object&lt;/code> holding the OUT parameter value&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setObject&#xA;     * @since 1.4&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="map">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>util</namespaces>
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:UnknownTypeArgument"/>
                  <target xsi:type="classifiers:Class" href="../lang/Class.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getRef">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>REF(&amp;lt;structured-type&amp;gt;)&lt;/code>&#xA;     * parameter as a {@link Ref} object in the Java programming language.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value as a &lt;code>Ref&lt;/code> object in the&#xA;     *         Java programming language.  If the value was SQL &lt;code>NULL&lt;/code>, &#xA;     *         the value &lt;code>null&lt;/code> is returned.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="Ref.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBlob">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>BLOB&lt;/code> parameter as a&#xA;     * {@link Blob} object in the Java programming language.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value as a &lt;code>Blob&lt;/code> object in the&#xA;     *         Java programming language.  If the value was SQL &lt;code>NULL&lt;/code>, &#xA;     *         the value &lt;code>null&lt;/code> is returned.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="Blob.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getClob">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>CLOB&lt;/code> parameter as a&#xA;     * &lt;code>Clob&lt;/code> object in the Java programming language.&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value as a &lt;code>Clob&lt;/code> object in the&#xA;     *         Java programming language.  If the value was SQL &lt;code>NULL&lt;/code>, &#xA;     *         the value &lt;code>null&lt;/code> is returned.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="Clob.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getArray">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>ARRAY&lt;/code> parameter as an&#xA;     * {@link Array} object in the Java programming language.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value as an &lt;code>Array&lt;/code> object in&#xA;     *         Java programming language.  If the value was SQL &lt;code>NULL&lt;/code>, &#xA;     *         the value &lt;code>null&lt;/code> is returned.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @since 1.4&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="Array.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>DATE&lt;/code> parameter as a &#xA;     * &lt;code>java.sql.Date&lt;/code> object, using&#xA;     * the given &lt;code>Calendar&lt;/code> object&#xA;     * to construct the date.&#xA;     * With a &lt;code>Calendar&lt;/code> object, the driver&#xA;     * can calculate the date taking into account a custom timezone and locale.&#xA;     * If no &lt;code>Calendar&lt;/code> object is specified, the driver uses the&#xA;     * default timezone and locale.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param cal the &lt;code>Calendar&lt;/code> object the driver will use&#xA;     *            to construct the date&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, &#xA;     * the result is &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setDate&#xA;     * @since 1.4&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTime">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>TIME&lt;/code> parameter as a &#xA;     * &lt;code>java.sql.Time&lt;/code> object, using&#xA;     * the given &lt;code>Calendar&lt;/code> object&#xA;     * to construct the time.&#xA;     * With a &lt;code>Calendar&lt;/code> object, the driver&#xA;     * can calculate the time taking into account a custom timezone and locale.&#xA;     * If no &lt;code>Calendar&lt;/code> object is specified, the driver uses the&#xA;     * default timezone and locale.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param cal the &lt;code>Calendar&lt;/code> object the driver will use&#xA;     *            to construct the time&#xA;     * @return the parameter value; if the value is SQL &lt;code>NULL&lt;/code>, the result is &#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setTime&#xA;     * @since 1.4&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Time.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTimestamp">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>TIMESTAMP&lt;/code> parameter as a&#xA;     * &lt;code>java.sql.Timestamp&lt;/code> object, using&#xA;     * the given &lt;code>Calendar&lt;/code> object to construct&#xA;     * the &lt;code>Timestamp&lt;/code> object.&#xA;     * With a &lt;code>Calendar&lt;/code> object, the driver&#xA;     * can calculate the timestamp taking into account a custom timezone and locale.&#xA;     * If no &lt;code>Calendar&lt;/code> object is specified, the driver uses the&#xA;     * default timezone and locale.&#xA;     *&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @param cal the &lt;code>Calendar&lt;/code> object the driver will use&#xA;     *            to construct the timestamp&#xA;     * @return the parameter value.  If the value is SQL &lt;code>NULL&lt;/code>, the result is &#xA;     * &lt;code>null&lt;/code>.&#xA;     * @exception SQLException if a database access error occurs&#xA;     * @see #setTimestamp&#xA;     * @since 1.4&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>sql</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Timestamp.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cal">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Calendar.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getURL">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>/**&#xA;     * Retrieves the value of a JDBC &lt;code>DATALINK&lt;/code> parameter as a&#xA;     * &lt;code>java.net.URL&lt;/code> object.&#xA;     *&#xA;     * @param parameterName the name of the parameter&#xA;     * @return the parameter value as a &lt;code>java.net.URL&lt;/code> object in the&#xA;     * Java programming language.  If the value was SQL &lt;code>NULL&lt;/code>, the&#xA;     * value &lt;code>null&lt;/code> is returned.&#xA;     * @exception SQLException if a database access error occurs,&#xA;     *            or if there is a problem with the URL&#xA;     * @see #setURL&#xA;     * @since 1.4&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>net</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../net/URL.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parameterName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SQLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The interface used to execute SQL stored procedures.  The JDBC API &#xA; * provides a stored procedure SQL escape syntax that allows stored procedures &#xA; * to be called in a standard way for all RDBMSs. This escape syntax has one &#xA; * form that includes a result parameter and one that does not. If used, the result &#xA; * parameter must be registered as an OUT parameter. The other parameters&#xA; * can be used for input, output or both. Parameters are referred to &#xA; * sequentially, by number, with the first parameter being 1.&#xA; * &lt;PRE>&#xA; *   {?= call &amp;lt;procedure-name&amp;gt;[&amp;lt;arg1&amp;gt;,&amp;lt;arg2&amp;gt;, ...]}&#xA; *   {call &amp;lt;procedure-name&amp;gt;[&amp;lt;arg1&amp;gt;,&amp;lt;arg2&amp;gt;, ...]}&#xA; * &lt;/PRE>&#xA; * &lt;P>&#xA; * IN parameter values are set using the &lt;code>set&lt;/code> methods inherited from&#xA; * {@link PreparedStatement}.  The type of all OUT parameters must be&#xA; * registered prior to executing the stored procedure; their values&#xA; * are retrieved after execution via the &lt;code>get&lt;/code> methods provided here.&#xA; * &lt;P>&#xA; * A &lt;code>CallableStatement&lt;/code> can return one {@link ResultSet} object or &#xA; * multiple &lt;code>ResultSet&lt;/code> objects.  Multiple &#xA; * &lt;code>ResultSet&lt;/code> objects are handled using operations&#xA; * inherited from {@link Statement}.&#xA; * &lt;P>&#xA; * For maximum portability, a call's &lt;code>ResultSet&lt;/code> objects and &#xA; * update counts should be processed prior to getting the values of output&#xA; * parameters.&#xA; * &lt;P>&#xA; *&#xA; * @see Connection#prepareCall&#xA; * @see ResultSet &#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="PreparedStatement.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
