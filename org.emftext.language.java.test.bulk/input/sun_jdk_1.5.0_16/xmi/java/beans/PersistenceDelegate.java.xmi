<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="PersistenceDelegate.java">
  <comments>/*&#xA; * @(#)PersistenceDelegate.java&#x9;1.11 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>beans</namespaces>
  <classifiers xsi:type="classifiers:Class" name="PersistenceDelegate">
    <members xsi:type="members:ClassMethod" name="writeObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="oldInstance">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Encoder.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The &lt;code>writeObject&lt;/code> is a single entry point to the persistence&#xA;     * and is used by a &lt;code>Encoder&lt;/code> in the traditional&#xA;     * mode of delegation. Although this method is not final,&#xA;     * it should not need to be subclassed under normal circumstances.&#xA;     * &lt;p>&#xA;     * This implementation first checks to see if the stream&#xA;     * has already encountered this object. Next the&#xA;     * &lt;code>mutatesTo&lt;/code> method is called to see if&#xA;     * that candidate returned from the stream can&#xA;     * be mutated into an accurate copy of &lt;code>oldInstance&lt;/code>.&#xA;     * If it can, the &lt;code>initialize&lt;/code> method is called to&#xA;     * perform the initialization. If not, the candidate is removed&#xA;     * from the stream, and the &lt;code>instantiate&lt;/code> method&#xA;     * is called to create a new candidate for this object.&#xA;     *&#xA;     * @param oldInstance The instance that will be created by this expression.&#xA;     * @param out The stream to which this expression will be written.&#xA;     * @return An expression whose value is &lt;code>oldInstance&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newInstance">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Encoder.class.xmi#//@classifiers.0/@members.12"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Encoder.class.xmi#//@classifiers.0/@members.11"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.0"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Encoder.class.xmi#//@classifiers.0/@members.16"/>
                <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.2">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.1"/>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.1">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@statements.0/@variable"/>
          </child>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.3">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
                </next>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.1"/>
            </expression>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="mutatesTo">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="oldInstance">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newInstance">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns true if an &lt;em>equivalent&lt;/em> copy of &lt;code>oldInstance&lt;/code> may be&#xA;     * created by applying a series of statements to &lt;code>newInstance&lt;/code>.&#xA;     * In the specification of this method, we mean by equivalent that the modified instance&#xA;     * is indistinguishable from &lt;code>oldInstance&lt;/code> in the behavior&#xA;     * of the relevant methods in its public API. [Note: we use the&#xA;     * phrase &lt;em>relevant&lt;/em> methods rather than &lt;em>all&lt;/em> methods&#xA;     * here only because, to be strictly correct, methods like &lt;code>hashCode&lt;/code>&#xA;     * and &lt;code>toString&lt;/code> prevent most classes from producing truly&#xA;     * indistinguishable copies of their instances].&#xA;     * &lt;p>&#xA;     * The default behavior returns &lt;code>true&lt;/code>&#xA;     * if the classes of the two instances are the same.&#xA;     *&#xA;     * @param oldInstance The instance to be copied.&#xA;     * @param newInstance The instance that is to be modified.&#xA;     * @return True if an equivalent copy of &lt;code>newInstance&lt;/code> may be&#xA;     *         created by applying a series of mutations to &lt;code>oldInstance&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.1"/>
              <children xsi:type="literals:NullLiteral"/>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
                </next>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
                </next>
              </children>
            </children>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="instantiate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Expression.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="oldInstance">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Encoder.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns an expression whose value is &lt;code>oldInstance&lt;/code>.&#xA;     * This method is used to characterize the constructor&#xA;     * or factory method that should be used to create the given object.&#xA;     * For example, the &lt;code>instantiate&lt;/code> method of the persistence&#xA;     * delegate for the &lt;code>Field&lt;/code> class could be defined as follows:&#xA;     * &lt;pre>&#xA;     * Field f = (Field)oldInstance;&#xA;     * return new Expression(f, f.getDeclaringClass(), &quot;getField&quot;, new Object[]{f.getName()});&#xA;     * &lt;/pre>&#xA;     * Note that we declare the value of the returned expression so that&#xA;     * the value of the expression (as returned by &lt;code>getValue&lt;/code>)&#xA;     * will be identical to &lt;code>oldInstance&lt;/code>.&#xA;     *&#xA;     * @param oldInstance The instance that will be created by this expression.&#xA;     * @param out The stream to which this expression will be written.&#xA;     * @return An expression whose value is &lt;code>oldInstance&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="initialize">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Class" href="../lang/Class.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="oldInstance">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newInstance">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Encoder.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Produce a series of statements with side effects on &lt;code>newInstance&lt;/code>&#xA;     * so that the new instance becomes &lt;em>equivalent&lt;/em> to &lt;code>oldInstance&lt;/code>.&#xA;     * In the specification of this method, we mean by equivalent that, after the method&#xA;     * returns, the modified instance is indistinguishable from&#xA;     * &lt;code>newInstance&lt;/code> in the behavior of all methods in its&#xA;     * public API.&#xA;     * &lt;p>&#xA;     * The implementation typically achieves this goal by producing a series of&#xA;     * &quot;what happened&quot; statements involving the &lt;code>oldInstance&lt;/code>&#xA;     * and its publicly available state. These statements are sent&#xA;     * to the output stream using its &lt;code>writeExpression&lt;/code>&#xA;     * method which returns an expression involving elements in&#xA;     * a cloned environment simulating the state of an input stream during&#xA;     * reading. Each statement returned will have had all instances&#xA;     * the old environment replaced with objects which exist in the new&#xA;     * one. In particular, references to the target of these statements,&#xA;     * which start out as references to &lt;code>oldInstance&lt;/code> are returned&#xA;     * as references to the &lt;code>newInstance&lt;/code> instead.&#xA;     * Executing these statements effects an incremental&#xA;     * alignment of the state of the two objects as a series of&#xA;     * modifications to the objects in the new environment.&#xA;     * By the time the initialize method returns it should be impossible&#xA;     * to tell the two instances apart by using their public APIs.&#xA;     * Most importantly, the sequence of steps that were used to make&#xA;     * these objects appear equivalent will have been recorded&#xA;     * by the output stream and will form the actual output when&#xA;     * the stream is flushed.&#xA;     * &lt;p>&#xA;     * The default implementation, calls the &lt;code>initialize&lt;/code>&#xA;     * method of the type's superclass.&#xA;     *&#xA;     * @param oldInstance The instance to be copied.&#xA;     * @param newInstance The instance that is to be modified.&#xA;     * @param out The stream to which any initialization statements should be written.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="superType">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Class.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Class.class.xmi#//@classifiers.0/@members.49"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="info">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.3">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Encoder.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@statements.0/@variable"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@statements.1/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.3"/>
          </next>
        </expression>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The PersistenceDelegate class takes the responsibility&#xA; * for expressing the state of an instance of a given class&#xA; * in terms of the methods in the class's public API. Instead&#xA; * of associating the responsibility of persistence with&#xA; * the class itself as is done, for example, by the&#xA; * &lt;code>readObject&lt;/code> and &lt;code>writeObject&lt;/code>&#xA; * methods used by the &lt;code>ObjectOutputStream&lt;/code>, streams like&#xA; * the &lt;code>XMLEncoder&lt;/code> which&#xA; * use this delegation model can have their behavior controlled&#xA; * independently of the classes themselves. Normally, the class&#xA; * is the best place to put such information and conventions&#xA; * can easily be expressed in this delegation scheme to do just that.&#xA; * Sometimes however, it is the case that a minor problem&#xA; * in a single class prevents an entire object graph from&#xA; * being written and this can leave the application&#xA; * developer with no recourse but to attempt to shadow&#xA; * the problematic classes locally or use alternative&#xA; * persistence techniques. In situations like these, the&#xA; * delegation model gives a relatively clean mechanism for&#xA; * the application developer to intervene in all parts of the&#xA; * serialization process without requiring that modifications&#xA; * be made to the implementation of classes which are not part&#xA; * of the application itself.&#xA; * &lt;p>&#xA; * In addition to using a delegation model, this persistence&#xA; * scheme differs from traditional serialization schemes&#xA; * in requiring an analog of the &lt;code>writeObject&lt;/code>&#xA; * method without a corresponding &lt;code>readObject&lt;/code>&#xA; * method. The &lt;code>writeObject&lt;/code> analog encodes each&#xA; * instance in terms of its public API and there is no need to&#xA; * define a &lt;code>readObject&lt;/code> analog&#xA; * since the procedure for reading the serialized form&#xA; * is defined by the semantics of method invocation as laid&#xA; * out in the Java Language Specification.&#xA; * Breaking the dependency between &lt;code>writeObject&lt;/code>&#xA; * and &lt;code>readObject&lt;/code> implementations, which may&#xA; * change from version to version, is the key factor&#xA; * in making the archives produced by this technique immune&#xA; * to changes in the private implementations of the classes&#xA; * to which they refer.&#xA; * &lt;p>&#xA; * A persistence delegate, may take control of all&#xA; * aspects of the persistence of an object including:&#xA; * &lt;ul>&#xA; * &lt;li>&#xA; * Deciding whether or not an instance can be mutated&#xA; * into another instance of the same class.&#xA; * &lt;li>&#xA; * Instantiating the object, either by calling a&#xA; * public constructor or a public factory method.&#xA; * &lt;li>&#xA; * Performing the initialization of the object.&#xA; * &lt;/ul>&#xA; * @see XMLEncoder&#xA; *&#xA; * @since 1.4&#xA; *&#xA; * @version 1.11 05/05/04&#xA; * @author Philip Milne&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
