<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="PropertyEditor.java">
  <comments>/*&#xA; * @(#)PropertyEditor.java&#x9;1.37 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>beans</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="PropertyEditor">
    <members xsi:type="members:InterfaceMethod" name="setValue">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Set (or change) the object that is to be edited.  Primitive types such&#xA;     * as &quot;int&quot; must be wrapped as the corresponding object type such as&#xA;     * &quot;java.lang.Integer&quot;.&#xA;     *&#xA;     * @param value The new target object to be edited.  Note that this&#xA;     *     object should not be modified by the PropertyEditor, rather &#xA;     *     the PropertyEditor should create a new object to hold any&#xA;     *     modified value.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getValue">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Gets the property value.&#xA;     *&#xA;     * @return The value of the property.  Primitive types such as &quot;int&quot; will&#xA;     * be wrapped as the corresponding object type such as &quot;java.lang.Integer&quot;.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isPaintable">
      <typeReference xsi:type="types:Boolean">
        <comments>//----------------------------------------------------------------------</comments>
        <comments>/**&#xA;     * Determines whether this property editor is paintable.&#xA;     *&#xA;     * @return  True if the class will honor the paintValue method.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="paintValue">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Paint a representation of the value into a given area of screen&#xA;     * real estate.  Note that the propertyEditor is responsible for doing&#xA;     * its own clipping so that it fits into the given rectangle.&#xA;     * &lt;p>&#xA;     * If the PropertyEditor doesn't honor paint requests (see isPaintable)&#xA;     * this method should be a silent noop.&#xA;     * &lt;p>&#xA;     * The given Graphics object will have the default font, color, etc of&#xA;     * the parent container.  The PropertyEditor may change graphics attributes&#xA;     * such as font and color and doesn't need to restore the old values.&#xA;     *&#xA;     * @param gfx  Graphics object to paint into.&#xA;     * @param box  Rectangle within graphics object into which we should paint.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="gfx">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>awt</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../awt/Graphics.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="box">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>awt</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../awt/Rectangle.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getJavaInitializationString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>//----------------------------------------------------------------------</comments>
          <comments>/**&#xA;     * Returns a fragment of Java code that can be used to set a property&#xA;     * to match the editors current state. This method is intended&#xA;     * for use when generating Java code to reflect changes made through the &#xA;     * property editor.&#xA;     * &lt;p>&#xA;     * The code fragment should be context free and must be a legal Java &#xA;     * expression as specified by the JLS.&#xA;     * &lt;p>&#xA;     * Specifically, if the expression represents a computation then all&#xA;     * classes and static members should be fully qualified. This rule &#xA;     * applies to constructors, static methods and non primitive arguments.&#xA;     * &lt;p>&#xA;     * Caution should be used when evaluating the expression as it may throw&#xA;     * exceptions. In particular, code generators must ensure that generated&#xA;     * code will compile in the presence of an expression that can throw &#xA;     * checked exceptions.&#xA;     * &lt;p>&#xA;     * Example results are:&#xA;     * &lt;ul>&#xA;     * &lt;li>Primitive expresssion: &lt;code>2&lt;/code>&#xA;     * &lt;li>Class constructor: &lt;code>new java.awt.Color(127,127,34)&lt;/code>&#xA;     * &lt;li>Static field: &lt;code>java.awt.Color.orange&lt;/code>&#xA;     * &lt;li>Static method: &lt;code>javax.swing.Box.createRigidArea(new &#xA;     *                                   java.awt.Dimension(0, 5))&lt;/code>&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @return a fragment of Java code representing an initializer for the&#xA;     *         current value. It should not contain a semi-colon &#xA;     *         ('&lt;code>;&lt;/code>') to end the expression.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getAsText">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>//----------------------------------------------------------------------</comments>
          <comments>/**&#xA;     * Gets the property value as text.&#xA;     * &#xA;     * @return The property value as a human editable string.&#xA;     * &lt;p>   Returns null if the value can't be expressed as an editable string.&#xA;     * &lt;p>   If a non-null value is returned, then the PropertyEditor should&#xA;     *&#x9;     be prepared to parse that string back in setAsText().&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setAsText">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Set the property value by parsing a given String.  May raise&#xA;     * java.lang.IllegalArgumentException if either the String is&#xA;     * badly formatted or if this kind of property can't be expressed&#xA;     * as text.&#xA;     * @param text  The string to be parsed.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="text">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>java</namespaces>
        <namespaces>lang</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTags">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>//----------------------------------------------------------------------</comments>
          <comments>/**&#xA;     * If the property value must be one of a set of known tagged values, &#xA;     * then this method should return an array of the tags.  This can&#xA;     * be used to represent (for example) enum values.  If a PropertyEditor&#xA;     * supports tags, then it should support the use of setAsText with&#xA;     * a tag value as a way of setting the value and the use of getAsText&#xA;     * to identify the current value.&#xA;     *&#xA;     * @return The tag values for this property.  May be null if this &#xA;     *   property cannot be represented as a tagged value.&#xA;     *&#x9;&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCustomEditor">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <comments>//----------------------------------------------------------------------</comments>
        <comments>/**&#xA;     * A PropertyEditor may choose to make available a full custom Component&#xA;     * that edits its property value.  It is the responsibility of the&#xA;     * PropertyEditor to hook itself up to its editor Component itself and&#xA;     * to report property value changes by firing a PropertyChange event.&#xA;     * &lt;P>&#xA;     * The higher-level code that calls getCustomEditor may either embed&#xA;     * the Component in some larger property sheet, or it may put it in&#xA;     * its own individual dialog, or ...&#xA;     *&#xA;     * @return A java.awt.Component that will allow a human to directly&#xA;     *      edit the current property value.  May be null if this is&#xA;     *&#x9;    not supported.&#xA;     */</comments>
        <namespaces>java</namespaces>
        <namespaces>awt</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../awt/Component.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="supportsCustomEditor">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Determines whether this property editor supports a custom editor.&#xA;     *&#xA;     * @return  True if the propertyEditor can provide a custom editor.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addPropertyChangeListener">
      <typeReference xsi:type="types:Void">
        <comments>//----------------------------------------------------------------------</comments>
        <comments>/**&#xA;     * Register a listener for the PropertyChange event.  When a&#xA;     * PropertyEditor changes its value it should fire a PropertyChange&#xA;     * event on all registered PropertyChangeListeners, specifying the&#xA;     * null value for the property name and itself as the source.&#xA;     *&#xA;     * @param listener  An object to be invoked when a PropertyChange&#xA;     *&#x9;&#x9;event is fired.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="PropertyChangeListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removePropertyChangeListener">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Remove a listener for the PropertyChange event.&#xA;     *&#xA;     * @param listener  The PropertyChange listener to be removed.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="PropertyChangeListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A PropertyEditor class provides support for GUIs that want to&#xA; * allow users to edit a property value of a given type.&#xA; * &lt;p>&#xA; * PropertyEditor supports a variety of different kinds of ways of&#xA; * displaying and updating property values.  Most PropertyEditors will&#xA; * only need to support a subset of the different options available in&#xA; * this API.&#xA; * &lt;P>&#xA; * Simple PropertyEditors may only support the getAsText and setAsText&#xA; * methods and need not support (say) paintValue or getCustomEditor.  More&#xA; * complex types may be unable to support getAsText and setAsText but will&#xA; * instead support paintValue and getCustomEditor.&#xA; * &lt;p>&#xA; * Every propertyEditor must support one or more of the three simple&#xA; * display styles.  Thus it can either (1) support isPaintable or (2)&#xA; * both return a non-null String[] from getTags() and return a non-null&#xA; * value from getAsText or (3) simply return a non-null String from &#xA; * getAsText().&#xA; * &lt;p>&#xA; * Every property editor must support a call on setValue when the argument&#xA; * object is of the type for which this is the corresponding propertyEditor.&#xA; * In addition, each property editor must either support a custom editor,&#xA; * or support setAsText.&#xA; * &lt;p>&#xA; * Each PropertyEditor should have a null constructor.&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
