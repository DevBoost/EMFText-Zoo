<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="Pack200.java">
  <comments>/*&#xA; * @(#)Pack200.java&#x9;1.4 03/12/08&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <namespaces>jar</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../SortedMap.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../io/OutputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../io/File.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>beans</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../beans/PropertyChangeListener.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>beans</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../beans/PropertyChangeEvent.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../security/AccessController.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../security/PrivilegedAction.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Pack200">
    <members xsi:type="members:Constructor" name="Pack200">
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:ClassMethod" name="newPacker">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.3"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>//prevent instantiation</comments>
        <comments>// Static methods of the Pack200 class.</comments>
        <comments>/**&#xA;     * Obtain new instance of a class that implements Packer.&#xA;     *&#xA;     * &lt;li>&lt;p>If the system property &lt;tt>java.util.jar.Pack200.Packer&lt;/tt>&#xA;     * is defined, then the value is taken to be the fully-qualified name&#xA;     * of a concrete implementation class, which must implement Packer.&#xA;     * This class is loaded and instantiated.  If this process fails&#xA;     * then an unspecified error is thrown.&lt;/p>&lt;/li>&#xA;     *&#xA;     * &lt;li>&lt;p>If an implementation has not been specified with the system&#xA;     * property, then the system-default implementation class is instantiated,&#xA;     * and the result is returned.&lt;/p>&lt;/li>&#xA;     *&#xA;     * &lt;p>Note:  The returned object is not guaranteed to operate&#xA;     * correctly if multiple threads use it at the same time.&#xA;     * A multi-threaded application should either allocate multiple&#xA;     * packer engines, or else serialize use of one engine with a lock.&#xA;     *&#xA;     * @return  A newly allocated Packer engine.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.3"/>
          </typeReference>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.9">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newUnpacker">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.4"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Obtain new instance of a class that implements Unpacker.&#xA;     *&#xA;     * &lt;li>&lt;p>If the system property &lt;tt>java.util.jar.Pack200.Unpacker&lt;/tt>&#xA;     * is defined, then the value is taken to be the fully-qualified&#xA;     * name of a concrete implementation class, which must implement Unpacker.&#xA;     * The class is loaded and instantiated.  If this process fails&#xA;     * then an unspecified error is thrown.&lt;/p>&lt;/li>&#xA;     *&#xA;     * &lt;li>&lt;p>If an implementation has not been specified with the&#xA;     * system property, then the system-default implementation class&#xA;     * is instantiated, and the result is returned.&lt;/p>&lt;/li>&#xA;     *&#xA;     * &lt;p>Note:  The returned object is not guaranteed to operate&#xA;     * correctly if multiple threads use it at the same time.&#xA;     * A multi-threaded application should either allocate multiple&#xA;     * unpacker engines, or else serialize use of one engine with a lock.&#xA;     *&#xA;     * @return  A newly allocated Unpacker engine.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.4"/>
          </typeReference>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.9">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="classifiers:Interface" name="Packer">
      <members xsi:type="members:Field" name="SEGMENT_LIMIT">
        <initialValue xsi:type="references:StringReference" value="pack.segment.limit"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * This property is a numeral giving the estimated target size N&#xA;&#x9; * (in bytes) of each archive segment.&#xA;&#x9; * If a single input file requires more than N bytes,&#xA;&#x9; * it will be given its own archive segment.&#xA;&#x9; * &lt;p>&#xA;&#x9; * As a special case, a value of -1 will produce a single large&#xA;&#x9; * segment with all input files, while a value of 0 will&#xA;&#x9; * produce one segment for each class.&#xA;&#x9; * Larger archive segments result in less fragmentation and&#xA;&#x9; * better compression, but processing them requires more memory.&#xA;&#x9; * &lt;p>&#xA;&#x9; * The size of each segment is estimated by counting the size of each&#xA;&#x9; * input file to be transmitted in the segment, along with the size&#xA;&#x9; * of its name and other transmitted properties.&#xA;&#x9; * &lt;p>&#xA;&#x9; * The default is 1000000 (a million bytes).  This allows input JAR files&#xA;&#x9; * of moderate size to be transmitted in one segment.  It also puts&#xA;&#x9; * a limit on memory requirements for packers and unpackers.&#xA;&#x9; * &lt;p>&#xA;&#x9; * A 10Mb JAR packed without this limit will&#xA;&#x9; * typically pack about 10% smaller, but the packer may require&#xA;&#x9; * a larger Java heap (about ten times the segment limit).&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="KEEP_FILE_ORDER">
        <initialValue xsi:type="references:StringReference" value="pack.keep.file.order"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * If this property is set to {@link #TRUE}, the packer will transmit&#xA;&#x9; * all elements in their original order within the source archive.&#xA;&#x9; * &lt;p>&#xA;&#x9; * If it is set to {@link #FALSE}, the packer may reorder elements,&#xA;&#x9; * and also remove JAR directory entries, which carry no useful&#xA;&#x9; * information for Java applications.&#xA;&#x9; * (Typically this enables better compression.)&#xA;&#x9; * &lt;p>&#xA;&#x9; * The default is {@link #TRUE}, which preserves the input information,&#xA;&#x9; * but may cause the transmitted archive to be larger than necessary.&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="EFFORT">
        <initialValue xsi:type="references:StringReference" value="pack.effort"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * If this property is set to a single decimal digit, the packer will&#xA;&#x9; * use the indicated amount of effort in compressing the archive.&#xA;&#x9; * Level 1 may produce somewhat larger size and faster compression speed,&#xA;&#x9; * while level 9 will take much longer but may produce better compression.&#xA;&#x9; * &lt;p>&#xA;&#x9; * The special value 0 instructs the packer to copy through the&#xA;&#x9; * original JAR file directly, with no compression.  The JSR 200&#xA;&#x9; * standard requires any unpacker to understand this special case&#xA;&#x9; * as a pass-through of the entire archive.&#xA;&#x9; * &lt;p>&#xA;&#x9; * The default is 5, investing a modest amount of time to&#xA;&#x9; * produce reasonable compression.&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="DEFLATE_HINT">
        <initialValue xsi:type="references:StringReference" value="pack.deflate.hint"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * If this property is set to {@link #TRUE} or {@link #FALSE}, the packer&#xA;&#x9; * will set the deflation hint accordingly in the output archive, and&#xA;&#x9; * will not transmit the individual deflation hints of archive elements.&#xA;&#x9; * &lt;p>&#xA;&#x9; * If this property is set to the special string {@link #KEEP}, the packer&#xA;&#x9; * will attempt to determine an independent deflation hint for each&#xA;&#x9; * available element of the input archive, and transmit this hint separately.&#xA;&#x9; * &lt;p>&#xA;&#x9; * The default is {@link #KEEP}, which preserves the input information,&#xA;&#x9; * but may cause the transmitted archive to be larger than necessary.&#xA;&#x9; * &lt;p>&#xA;&#x9; * It is up to the unpacker implementation&#xA;&#x9; * to take action upon the hint to suitably compress the elements of&#xA;&#x9; * the resulting unpacked jar.&#xA;&#x9; * &lt;p>&#xA;&#x9; * The deflation hint of a ZIP or JAR element indicates&#xA;&#x9; * whether the element was deflated or stored directly.&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="MODIFICATION_TIME">
        <initialValue xsi:type="references:StringReference" value="pack.modification.time"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * If this property is set to the special string {@link #LATEST},&#xA;&#x9; * the packer will attempt to determine the latest modification time,&#xA;&#x9; * among all the available entries in the original archive or the latest&#xA;&#x9; * modification time of all the available entries in each segment.&#xA;&#x9; * This single value will be transmitted as part of the segment and applied&#xA;&#x9; * to all the entries in each segment, {@link #SEGMENT_LIMIT}.&#xA;&#x9; * &lt;p>&#xA;&#x9; * This can marginally decrease the transmitted size of the&#xA;&#x9; * archive, at the expense of setting all installed files to a single&#xA;&#x9; * date.&#xA;&#x9; * &lt;p>&#xA;&#x9; * If this property is set to the special string {@link #KEEP},&#xA;&#x9; * the packer transmits a separate modification time for each input&#xA;&#x9; * element.&#xA;&#x9; * &lt;p>&#xA;&#x9; * The default is {@link #KEEP}, which preserves the input information,&#xA;&#x9; * but may cause the transmitted archive to be larger than necessary.&#xA;&#x9; * &lt;p>&#xA;&#x9; * It is up to the unpacker implementation to take action to suitably&#xA;&#x9; * set the modification time of each element of its output file.&#xA;&#x9; * @see #SEGMENT_LIMIT&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="PASS_FILE_PFX">
        <initialValue xsi:type="references:StringReference" value="pack.pass.file."/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * Indicates that a file should be passed through bytewise, with no&#xA;&#x9; * compression.  Multiple files may be specified by specifying&#xA;&#x9; * additional properties with distinct strings appended, to&#xA;&#x9; * make a family of properties with the common prefix.&#xA;&#x9; * &lt;p>&#xA;&#x9; * There is no pathname transformation, except&#xA;&#x9; * that the system file separator is replaced by the JAR file&#xA;&#x9; * separator '/'.&#xA;&#x9; * &lt;p>&#xA;&#x9; * The resulting file names must match exactly as strings with their&#xA;&#x9; * occurrences in the JAR file.&#xA;&#x9; * &lt;p>&#xA;&#x9; * If a property value is a directory name, all files under that&#xA;&#x9; * directory will be passed also.&#xA;&#x9; * &lt;p>&#xA;&#x9; * Examples:&#xA;&#x9; * &lt;pre>&lt;code>&#xA;&#x9; *     Map p = packer.properties();&#xA;&#x9; *     p.put(PASS_FILE_PFX+0, &quot;mutants/Rogue.class&quot;);&#xA;&#x9; *     p.put(PASS_FILE_PFX+1, &quot;mutants/Wolverine.class&quot;);&#xA;&#x9; *     p.put(PASS_FILE_PFX+2, &quot;mutants/Storm.class&quot;);&#xA;&#x9; *     # Pass all files in an entire directory hierarchy:&#xA;&#x9; *     p.put(PASS_FILE_PFX+3, &quot;police/&quot;);&#xA;&#x9; * &lt;/pre>&lt;/code>.&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="UNKNOWN_ATTRIBUTE">
        <initialValue xsi:type="references:StringReference" value="pack.unknown.attribute"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/// Attribute control.</comments>
            <comments>/**&#xA;&#x9; * Indicates the action to take when a class-file containing an unknown&#xA;&#x9; * attribute is encountered.  Possible values are the strings {@link #ERROR},&#xA;&#x9; * {@link #STRIP}, and {@link #PASS}.&#xA;&#x9; * &lt;p>&#xA;&#x9; * The string {@link #ERROR} means that the pack operation&#xA;&#x9; * as a whole will fail, with a suitable explanation.&#xA;&#x9; * The string&#xA;&#x9; * {@link #STRIP} means that the attribute will be dropped.&#xA;&#x9; * The string&#xA;&#x9; * {@link #PASS} means that the whole class-file will be passed through&#xA;&#x9; * (as if it were a resource file) without compression, with  a suitable warning.&#xA;&#x9; * This is the default value for this property.&#xA;&#x9; * &lt;p>&#xA;&#x9; * Examples:&#xA;&#x9; * &lt;pre>&lt;code>&#xA;&#x9; *     Map p = pack200.getProperties();&#xA;&#x9; *     p.put(UNKNOWN_ATTRIBUTE, ERROR);&#xA;&#x9; *     p.put(UNKNOWN_ATTRIBUTE, STRIP);&#xA;&#x9; *     p.put(UNKNOWN_ATTRIBUTE, PASS);&#xA;&#x9; * &lt;/pre>&lt;/code>&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="CLASS_ATTRIBUTE_PFX">
        <initialValue xsi:type="references:StringReference" value="pack.class.attribute."/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * When concatenated with a class attribute name,&#xA;&#x9; * indicates the format of that attribute,&#xA;&#x9; * using the layout language specified in the JSR 200 specification.&#xA;&#x9; * &lt;p>&#xA;&#x9; * For example, the effect of this option is built in:&#xA;&#x9; * &lt;code>pack.class.attribute.SourceFile=RUH&lt;/code>.&#xA;&#x9; * &lt;p>&#xA;&#x9; * The special strings {@link #ERROR}, {@link #STRIP}, and {@link #PASS} are&#xA;&#x9; * also allowed, with the same meaning as {@link #UNKNOWN_ATTRIBUTE}.&#xA;&#x9; * This provides a way for users to request that specific attributes be&#xA;&#x9; * refused, stripped, or passed bitwise (with no class compression).&#xA;&#x9; * &lt;p>&#xA;&#x9; * Code like this might be used to support attributes for JCOV:&#xA;&#x9; * &lt;pre>&lt;code>&#xA;&#x9; *     Map p = packer.properties();&#xA;&#x9; *     p.put(CODE_ATTRIBUTE_PFX+&quot;CoverageTable&quot;,       &quot;NH[PHHII]&quot;);&#xA;&#x9; *     p.put(CODE_ATTRIBUTE_PFX+&quot;CharacterRangeTable&quot;, &quot;NH[PHPOHIIH]&quot;);&#xA;&#x9; *     p.put(CLASS_ATTRIBUTE_PFX+&quot;SourceID&quot;,           &quot;RUH&quot;);&#xA;&#x9; *     p.put(CLASS_ATTRIBUTE_PFX+&quot;CompilationID&quot;,      &quot;RUH&quot;);&#xA;&#x9; * &lt;/code>&lt;/pre>&#xA;&#x9; * &lt;p>&#xA;&#x9; * Code like this might be used to strip debugging attributes:&#xA;&#x9; * &lt;pre>&lt;code>&#xA;&#x9; *     Map p = packer.properties();&#xA;&#x9; *     p.put(CODE_ATTRIBUTE_PFX+&quot;LineNumberTable&quot;,    STRIP);&#xA;&#x9; *     p.put(CODE_ATTRIBUTE_PFX+&quot;LocalVariableTable&quot;, STRIP);&#xA;&#x9; *     p.put(CLASS_ATTRIBUTE_PFX+&quot;SourceFile&quot;,        STRIP);&#xA;&#x9; * &lt;/code>&lt;/pre>&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="FIELD_ATTRIBUTE_PFX">
        <initialValue xsi:type="references:StringReference" value="pack.field.attribute."/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * When concatenated with a field attribute name,&#xA;&#x9; * indicates the format of that attribute.&#xA;&#x9; * For example, the effect of this option is built in:&#xA;&#x9; * &lt;code>pack.field.attribute.Deprecated=&lt;/code>.&#xA;&#x9; * The special strings {@link #ERROR}, {@link #STRIP}, and&#xA;&#x9; * {@link #PASS} are also allowed.&#xA;&#x9; * @see #CLASS_ATTRIBUTE_PFX&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="METHOD_ATTRIBUTE_PFX">
        <initialValue xsi:type="references:StringReference" value="pack.method.attribute."/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * When concatenated with a method attribute name,&#xA;&#x9; * indicates the format of that attribute.&#xA;&#x9; * For example, the effect of this option is built in:&#xA;&#x9; * &lt;code>pack.method.attribute.Exceptions=NH[RCH]&lt;/code>.&#xA;&#x9; * The special strings {@link #ERROR}, {@link #STRIP}, and {@link #PASS}&#xA;&#x9; * are also allowed.&#xA;&#x9; * @see #CLASS_ATTRIBUTE_PFX&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="CODE_ATTRIBUTE_PFX">
        <initialValue xsi:type="references:StringReference" value="pack.code.attribute."/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * When concatenated with a code attribute name,&#xA;&#x9; * indicates the format of that attribute.&#xA;&#x9; * For example, the effect of this option is built in:&#xA;&#x9; * &lt;code>pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]&lt;/code>.&#xA;&#x9; * The special strings {@link #ERROR}, {@link #STRIP}, and {@link #PASS}&#xA;&#x9; * are also allowed.&#xA;&#x9; * @see #CLASS_ATTRIBUTE_PFX&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="PROGRESS">
        <initialValue xsi:type="references:StringReference" value="pack.progress"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * The unpacker's progress as a percentage, as periodically&#xA;&#x9; * updated by the unpacker.&#xA;&#x9; * Values of 0 - 100 are normal, and -1 indicates a stall.&#xA;&#x9; * Observe this property with a {@link PropertyChangeListener}.&#xA;&#x9; * &lt;p>&#xA;&#x9; * At a minimum, the unpacker must set progress to 0&#xA;&#x9; * at the beginning of a packing operation, and to 100&#xA;&#x9; * at the end.&#xA;&#x9; * @see  #addPropertyChangeListener&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="KEEP">
        <initialValue xsi:type="references:StringReference" value="keep"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/** The string &quot;keep&quot;, a possible value for certain properties.&#xA;&#x9; * @see #DEFLATE_HINT&#xA;&#x9; * @see #MODIFICATION_TIME&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="PASS">
        <initialValue xsi:type="references:StringReference" value="pass"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/** The string &quot;pass&quot;, a possible value for certain properties.&#xA;&#x9; * @see #UNKNOWN_ATTRIBUTE&#xA;&#x9; * @see #CLASS_ATTRIBUTE_PFX&#xA;&#x9; * @see #FIELD_ATTRIBUTE_PFX&#xA;&#x9; * @see #METHOD_ATTRIBUTE_PFX&#xA;&#x9; * @see #CODE_ATTRIBUTE_PFX&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="STRIP">
        <initialValue xsi:type="references:StringReference" value="strip"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/** The string &quot;strip&quot;, a possible value for certain properties.&#xA;&#x9; * @see #UNKNOWN_ATTRIBUTE&#xA;&#x9; * @see #CLASS_ATTRIBUTE_PFX&#xA;&#x9; * @see #FIELD_ATTRIBUTE_PFX&#xA;&#x9; * @see #METHOD_ATTRIBUTE_PFX&#xA;&#x9; * @see #CODE_ATTRIBUTE_PFX&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="ERROR">
        <initialValue xsi:type="references:StringReference" value="error"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/** The string &quot;error&quot;, a possible value for certain properties.&#xA;&#x9; * @see #UNKNOWN_ATTRIBUTE&#xA;&#x9; * @see #CLASS_ATTRIBUTE_PFX&#xA;&#x9; * @see #FIELD_ATTRIBUTE_PFX&#xA;&#x9; * @see #METHOD_ATTRIBUTE_PFX&#xA;&#x9; * @see #CODE_ATTRIBUTE_PFX&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="TRUE">
        <initialValue xsi:type="references:StringReference" value="true"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/** The string &quot;true&quot;, a possible value for certain properties.&#xA;&#x9; * @see #KEEP_FILE_ORDER&#xA;&#x9; * @see #DEFLATE_HINT&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="FALSE">
        <initialValue xsi:type="references:StringReference" value="false"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/** The string &quot;false&quot;, a possible value for certain properties.&#xA;&#x9; * @see #KEEP_FILE_ORDER&#xA;&#x9; * @see #DEFLATE_HINT&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="LATEST">
        <initialValue xsi:type="references:StringReference" value="latest"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/** The string &quot;latest&quot;, a possible value for certain properties.&#xA;&#x9; * @see #MODIFICATION_TIME&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:InterfaceMethod" name="properties">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * Get the set of this engine's properties.&#xA;&#x9; * This set is a &quot;live view&quot;, so that changing its&#xA;&#x9; * contents immediately affects the Packer engine, and&#xA;&#x9; * changes from the engine (such as progress indications)&#xA;&#x9; * are immediately visible in the map.&#xA;&#x9; *&#xA;&#x9; * &lt;p>The property map may contain pre-defined implementation&#xA;&#x9; * specific and default properties.  Users are encouraged to&#xA;&#x9; * read the information and fully understand the implications,&#xA;&#x9; * before modifying pre-existing properties.&#xA;&#x9; * &lt;p>&#xA;&#x9; * Implementation specific properties are prefixed with a&#xA;&#x9; * package name associated with the implementor, beginning&#xA;&#x9; * with &lt;tt>com.&lt;/tt> or a similar prefix.&#xA;&#x9; * All property names beginning with &lt;tt>pack.&lt;/tt> and&#xA;&#x9; * &lt;tt>unpack.&lt;/tt> are reserved for use by this API.&#xA;&#x9; * &lt;p>&#xA;&#x9; * Unknown properties may be ignored or rejected with an&#xA;&#x9; * unspecified error, and invalid entries may cause an&#xA;&#x9; * unspecified error to be thrown.&#xA;         *&#xA;&#x9; * &lt;p>&#xA;&#x9; * The returned map implements all optional {@link SortedMap} operations&#xA;&#x9; * @return A sorted association of property key strings to property &#xA;         * values.&#xA;&#x9; */</comments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../SortedMap.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:InterfaceMethod" name="pack">
        <typeReference xsi:type="types:Void">
          <comments>/**&#xA;&#x9; * Takes a JarFile and converts it into a Pack200 archive.&#xA;&#x9; * &lt;p>&#xA;&#x9; * Closes its input but not its output.  (Pack200 archives are appendable.)&#xA;&#x9; * @param in a JarFile&#xA;&#x9; * @param out an OutputStream&#xA;&#x9; * @exception IOException if an error is encountered.&#xA;&#x9; */</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="in">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="JarFile.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="out">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../io/OutputStream.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
      </members>
      <members xsi:type="members:InterfaceMethod" name="pack">
        <typeReference xsi:type="types:Void">
          <comments>/**&#xA;&#x9; * Takes a JarInputStream and converts it into a Pack200 archive.&#xA;&#x9; * &lt;p>&#xA;&#x9; * Closes its input but not its output.  (Pack200 archives are appendable.)&#xA;&#x9; * &lt;p>&#xA;&#x9; * The modification time and deflation hint attributes are not available,&#xA;&#x9; * for the JAR manifest file and its containing directory.&#xA;&#x9; *&#xA;&#x9; * @see #MODIFICATION_TIME&#xA;&#x9; * @see #DEFLATE_HINT&#xA;&#x9; * @param in a JarInputStream&#xA;&#x9; * @param out an OutputStream&#xA;&#x9; * @exception IOException if an error is encountered.&#xA;&#x9; */</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="in">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="JarInputStream.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="out">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../io/OutputStream.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
      </members>
      <members xsi:type="members:InterfaceMethod" name="addPropertyChangeListener">
        <typeReference xsi:type="types:Void">
          <comments>/**&#xA;&#x9; * Registers a listener for PropertyChange events on the properties map.&#xA;&#x9; * This is typically used by applications to update a progress bar.&#xA;&#x9; *&#xA;&#x9; * @see #properties&#xA;&#x9; * @see #PROGRESS&#xA;&#x9; * @param listener  An object to be invoked when a property is changed.&#xA;&#x9; */</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../beans/PropertyChangeListener.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
      </members>
      <members xsi:type="members:InterfaceMethod" name="removePropertyChangeListener">
        <typeReference xsi:type="types:Void">
          <comments>/**&#xA;&#x9; * Remove a listener for PropertyChange events, added by&#xA;&#x9; * the {@link #addPropertyChangeListener}.&#xA;&#x9; *&#xA;&#x9; * @see #addPropertyChangeListener&#xA;&#x9; * @param listener  The PropertyChange listener to be removed.&#xA;&#x9; */</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../beans/PropertyChangeListener.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Interfaces</comments>
        <comments>/**&#xA;     * The packer engine applies various transformations to the input JAR file,&#xA;     * making the pack stream highly compressible by a compressor such as&#xA;     * gzip or zip. An instance of the engine can be obtained&#xA;     * using {@link #newPacker}.&#xA;&#xA;     * The high degree of compression is achieved&#xA;     * by using a number of techniques described in the JSR 200 specification.&#xA;     * Some of the techniques are sorting, re-ordering and co-location of the&#xA;     * constant pool.&#xA;     * &lt;p>&#xA;     * The pack engine is initialized to an initial state as described&#xA;     * by their properties below.&#xA;     * The initial state can be manipulated by getting the&#xA;     * engine properties (using {@link #properties}) and storing&#xA;     * the modified properties on the map.&#xA;     * The resource files will be passed through with no changes at all.&#xA;     * The class files will not contain identical bytes, since the unpacker&#xA;     * is free to change minor class file features such as constant pool order.&#xA;     * However, the class files will be semantically identical,&#xA;     * as specified in the Java Virtual Machine Specification&#xA;     * &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/html/ClassFile.doc.html&quot;>http://java.sun.com/docs/books/vmspec/html/ClassFile.doc.html&lt;/a>.&#xA;     * &lt;p>&#xA;     * By default, the packer does not change the order of JAR elements.&#xA;     * Also, the modification time and deflation hint of each&#xA;     * JAR element is passed unchanged.&#xA;     * (Any other ZIP-archive information, such as extra attributes&#xA;     * giving Unix file permissions, are lost.)&#xA;     * &lt;p>&#xA;     * Note that packing and unpacking a JAR will in general alter the&#xA;     * bytewise contents of classfiles in the JAR.  This means that packing&#xA;     * and unpacking will in general invalidate any digital signatures&#xA;     * which rely on bytewise images of JAR elements.  In order both to sign&#xA;     * and to pack a JAR, you must first pack and unpack the JAR to&#xA;     * &quot;normalize&quot; it, then compute signatures on the unpacked JAR elements,&#xA;     * and finally repack the signed JAR.&#xA;     * Both packing steps should&#xA;     * use precisely the same options, and the segment limit may also&#xA;     * need to be set to &quot;-1&quot;, to prevent accidental variation of segment&#xA;     * boundaries as class file sizes change slightly.&#xA;     * &lt;p>&#xA;     * (Here's why this works:  Any reordering the packer does&#xA;     * of any classfile structures is idempotent, so the second packing&#xA;     * does not change the orderings produced by the first packing.&#xA;     * Also, the unpacker is guaranteed by the JSR 200 specification&#xA;     * to produce a specific bytewise image for any given transmission&#xA;     * ordering of archive elements.)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="classifiers:Interface" name="Unpacker">
      <members xsi:type="members:Field" name="KEEP">
        <initialValue xsi:type="references:StringReference" value="keep"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/** The string &quot;keep&quot;, a possible value for certain properties.&#xA;&#x9; * @see #DEFLATE_HINT&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="TRUE">
        <initialValue xsi:type="references:StringReference" value="true"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/** The string &quot;true&quot;, a possible value for certain properties.&#xA;&#x9; * @see #DEFLATE_HINT&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="FALSE">
        <initialValue xsi:type="references:StringReference" value="false"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/** The string &quot;false&quot;, a possible value for certain properties.&#xA;&#x9; * @see #DEFLATE_HINT&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="DEFLATE_HINT">
        <initialValue xsi:type="references:StringReference" value="unpack.deflate.hint"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * Property indicating that the unpacker should&#xA;&#x9; * ignore all transmitted values for DEFLATE_HINT,&#xA;&#x9; * replacing them by the given value, {@link #TRUE} or {@link #FALSE}.&#xA;&#x9; * The default value is the special string {@link #KEEP},&#xA;&#x9; * which asks the unpacker to preserve all transmitted&#xA;&#x9; * deflation hints.&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="PROGRESS">
        <initialValue xsi:type="references:StringReference" value="unpack.progress"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * The unpacker's progress as a percentage, as periodically&#xA;&#x9; * updated by the unpacker.&#xA;&#x9; * Values of 0 - 100 are normal, and -1 indicates a stall.&#xA;&#x9; * Observe this property with a {@link PropertyChangeListener}.&#xA;&#x9; * &lt;p>&#xA;&#x9; * At a minimum, the unpacker must set progress to 0&#xA;&#x9; * at the beginning of a packing operation, and to 100&#xA;&#x9; * at the end.&#xA;&#x9; * @see #addPropertyChangeListener&#xA;&#x9; */</comments>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:InterfaceMethod" name="properties">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <comments>/**&#xA;&#x9; * Get the set of this engine's properties. This set is &#xA;&#x9; * a &quot;live view&quot;, so that changing its&#xA;&#x9; * contents immediately affects the Packer engine, and&#xA;&#x9; * changes from the engine (such as progress indications)&#xA;&#x9; * are immediately visible in the map.&#xA;&#x9; *&#xA;&#x9; * &lt;p>The property map may contain pre-defined implementation&#xA;&#x9; * specific and default properties.  Users are encouraged to&#xA;&#x9; * read the information and fully understand the implications,&#xA;&#x9; * before modifying pre-existing properties.&#xA;&#x9; * &lt;p>&#xA;&#x9; * Implementation specific properties are prefixed with a&#xA;&#x9; * package name associated with the implementor, beginning&#xA;&#x9; * with &lt;tt>com.&lt;/tt> or a similar prefix.&#xA;&#x9; * All property names beginning with &lt;tt>pack.&lt;/tt> and&#xA;&#x9; * &lt;tt>unpack.&lt;/tt> are reserved for use by this API.&#xA;&#x9; * &lt;p>&#xA;&#x9; * Unknown properties may be ignored or rejected with an&#xA;&#x9; * unspecified error, and invalid entries may cause an&#xA;&#x9; * unspecified error to be thrown.&#xA;&#x9; *&#xA;&#x9; * @return A sorted association of option key strings to option values.&#xA;&#x9; */</comments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../SortedMap.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:InterfaceMethod" name="unpack">
        <typeReference xsi:type="types:Void">
          <comments>/**&#xA;&#x9; * Read a Pack200 archive, and write the encoded JAR to&#xA;&#x9; * a JarOutputStream.&#xA;&#x9; * The entire contents of the input stream will be read.&#xA;&#x9; * It may be more efficient to read the Pack200 archive&#xA;&#x9; * to a file and pass the File object, using the alternate&#xA;&#x9; * method described below.&#xA;&#x9; * &lt;p>&#xA;&#x9; * Closes its input but not its output.  (The output can accumulate more elements.)&#xA;&#x9; * @param in an InputStream.&#xA;&#x9; * @param out a JarOutputStream.&#xA;&#x9; * @exception IOException if an error is encountered.&#xA;&#x9; */</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="in">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="out">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="JarOutputStream.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
      </members>
      <members xsi:type="members:InterfaceMethod" name="unpack">
        <typeReference xsi:type="types:Void">
          <comments>/**&#xA;&#x9; * Read a Pack200 archive, and write the encoded JAR to&#xA;&#x9; * a JarOutputStream.&#xA;&#x9; * &lt;p>&#xA;&#x9; * Does not close its output.  (The output can accumulate more elements.)&#xA;&#x9; * @param in a File.&#xA;&#x9; * @param out a JarOutputStream.&#xA;&#x9; * @exception IOException if an error is encountered.&#xA;&#x9; */</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="in">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../io/File.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="out">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="JarOutputStream.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
      </members>
      <members xsi:type="members:InterfaceMethod" name="addPropertyChangeListener">
        <typeReference xsi:type="types:Void">
          <comments>/**&#xA;&#x9; * Registers a listener for PropertyChange events on the properties map.&#xA;&#x9; * This is typically used by applications to update a progress bar.&#xA;&#x9; *&#xA;&#x9; * @see #properties&#xA;&#x9; * @see #PROGRESS&#xA;&#x9; * @param listener  An object to be invoked when a property is changed.&#xA;&#x9; */</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../beans/PropertyChangeListener.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
      </members>
      <members xsi:type="members:InterfaceMethod" name="removePropertyChangeListener">
        <typeReference xsi:type="types:Void">
          <comments>/**&#xA;&#x9; * Remove a listener for PropertyChange events, added by&#xA;&#x9; * the {@link #addPropertyChangeListener}.&#xA;&#x9; *&#xA;&#x9; * @see #addPropertyChangeListener&#xA;&#x9; * @param listener  The PropertyChange listener to be removed.&#xA;&#x9; */</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="listener">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../../beans/PropertyChangeListener.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The unpacker engine converts the packed stream to a JAR file.&#xA;     * An instance of the engine can be obtained&#xA;     * using {@link #newUnpacker}.&#xA;     * &lt;p>&#xA;     * Every JAR file produced by this engine will include the string&#xA;     * &quot;&lt;tt>PACK200&lt;/tt>&quot; as a zip file comment.&#xA;     * This allows a deployer to detect if a JAR archive was packed and unpacked.&#xA;     * &lt;p>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="PACK_PROVIDER">
      <initialValue xsi:type="references:StringReference" value="java.util.jar.Pack200.Packer"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Private stuff....</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="UNPACK_PROVIDER">
      <initialValue xsi:type="references:StringReference" value="java.util.jar.Pack200.Unpacker"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="packerImpl">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/Class.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="unpackerImpl">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/Class.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="newInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prop">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="implName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:StringReference" value="(unknown)"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="impl">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/Class.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="expressions:ConditionalExpression">
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                </expression>
              </child>
              <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable">
                  <comments>// The first time, we must decide which class to use.</comments>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <next xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../../security/AccessController.class.xmi#//@classifiers.0/@members.1"/>
                          <arguments xsi:type="instantiations:NewConstructorCall">
                            <typeReference xsi:type="types:NamespaceClassifierReference">
                              <namespaces>sun</namespaces>
                              <namespaces>security</namespaces>
                              <namespaces>action</namespaces>
                              <classifierReferences>
                                <target xsi:type="classifiers:Class" href="../../../sun/security/action/GetPropertyAction.class.xmi#//@classifiers.0"/>
                              </classifierReferences>
                            </typeReference>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
                            <arguments xsi:type="references:StringReference" value=""/>
                          </arguments>
                        </next>
                        <target xsi:type="classifiers:Class" href="../../security/AccessController.class.xmi#//@classifiers.0"/>
                      </next>
                    </next>
                  </child>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../lang/Class.class.xmi#//@classifiers.0/@members.32"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../../lang/Class.class.xmi#//@classifiers.0"/>
                  </value>
                </expression>
              </statement>
              <condition xsi:type="expressions:ConditionalAndExpression">
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
                  <children xsi:type="literals:NullLiteral"/>
                </children>
                <children xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Negate"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                      <arguments xsi:type="references:StringReference" value=""/>
                    </next>
                  </child>
                </children>
              </condition>
              <elseStatement xsi:type="statements:Condition">
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@statements.0/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference">
                      <next xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <next xsi:type="references:IdentifierReference">
                            <next xsi:type="references:IdentifierReference">
                              <next xsi:type="references:IdentifierReference">
                                <next xsi:type="references:IdentifierReference">
                                  <next xsi:type="references:ReflectiveClassReference"/>
                                  <target xsi:type="classifiers:Class" href="../../../com/sun/java/util/jar/pack/PackerImpl.class.xmi#//@classifiers.0"/>
                                </next>
                              </next>
                            </next>
                          </next>
                        </next>
                      </next>
                    </value>
                  </expression>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                </condition>
                <elseStatement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@statements.0/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference">
                      <next xsi:type="references:IdentifierReference">
                        <next xsi:type="references:IdentifierReference">
                          <next xsi:type="references:IdentifierReference">
                            <next xsi:type="references:IdentifierReference">
                              <next xsi:type="references:IdentifierReference">
                                <next xsi:type="references:IdentifierReference">
                                  <next xsi:type="references:ReflectiveClassReference"/>
                                  <target xsi:type="classifiers:Class" href="../../../com/sun/java/util/jar/pack/UnpackerImpl.class.xmi#//@classifiers.0"/>
                                </next>
                              </next>
                            </next>
                          </next>
                        </next>
                      </next>
                    </value>
                  </expression>
                </elseStatement>
              </elseStatement>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@statements.0/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <comments>// We have a class.  Now instantiate it.</comments>
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Class.class.xmi#//@classifiers.0/@members.35"/>
            </next>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/Error.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Class not found: "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
                <children xsi:type="references:StringReference" value=":&#xA;check property "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
                <children xsi:type="references:StringReference" value=" in your properties file."/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@catcheBlocks.0/@parameter"/>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/ClassNotFoundException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/Error.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Could not instantiate: "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
                <children xsi:type="references:StringReference" value=":&#xA;check property "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
                <children xsi:type="references:StringReference" value=" in your properties file."/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@catcheBlocks.1/@parameter"/>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/InstantiationException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/Error.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Cannot access class: "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
                <children xsi:type="references:StringReference" value=":&#xA;check property "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
                <children xsi:type="references:StringReference" value=" in your properties file."/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@catcheBlocks.2/@parameter"/>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalAccessException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Transforms a JAR file to or from a packed stream in Pack200 format.&#xA; * Please refer to Network Trasfer Format JSR 200 Specification at &#xA; * http://jcp.org/aboutJava/communityprocess/review/jsr200/index.html&#xA; * &lt;p>&#xA; * Typically the packer engine is used by application developers&#xA; * to deploy or host JAR files on a website.&#xA; * The unpacker  engine is used by deployment applications to&#xA; * transform the byte-stream back to JAR format.&#xA; * &lt;p>&#xA; * Here is an example using  packer and unpacker:&lt;p>&#xA; * &lt;blockquote>&lt;pre>&#xA; *    import java.util.jar.Pack200;&#xA; *    import java.util.jar.Pack200.*;&#xA; *    ...&#xA; *    // Create the Packer object&#xA; *    Packer packer = Pack200.newPacker();&#xA; *&#xA; *    // Initialize the state by setting the desired properties&#xA; *    Map p = packer.properties();&#xA; *    // take more time choosing codings for better compression&#xA; *    p.put(Packer.EFFORT, &quot;7&quot;);  // default is &quot;5&quot;&#xA; *    // use largest-possible archive segments (>10% better compression).&#xA; *    p.put(Packer.SEGMENT_LIMIT, &quot;-1&quot;);&#xA; *    // reorder files for better compression.&#xA; *    p.put(Packer.KEEP_FILE_ORDER, Packer.FALSE);&#xA; *    // smear modification times to a single value.&#xA; *    p.put(Packer.MODIFICATION_TIME, Packer.LATEST);&#xA; *    // ignore all JAR deflation requests,&#xA; *    // transmitting a single request to use &quot;store&quot; mode.&#xA; *    p.put(Packer.DEFLATE_HINT, Packer.FALSE);&#xA; *    // discard debug attributes&#xA; *    p.put(Packer.CODE_ATTRIBUTE_PFX+&quot;LineNumberTable&quot;, Packer.STRIP);&#xA; *    // throw an error if an attribute is unrecognized&#xA; *    p.put(Packer.UNKNOWN_ATTRIBUTE, Packer.ERROR);&#xA; *    // pass one class file uncompressed:&#xA; *    p.put(Packer.PASS_FILE_PFX+0, &quot;mutants/Rogue.class&quot;);&#xA; *    try {&#xA; *        JarFile jarFile = new JarFile(&quot;/tmp/testref.jar&quot;);&#xA; *        FileOutputStream fos = new FileOutputStream(&quot;/tmp/test.pack&quot;);&#xA; *        // Call the packer&#xA; *        packer.pack(jarFile, fos);&#xA; *        jarFile.close();&#xA; *        fos.close();&#xA; *        &#xA; *        File f = new File(&quot;/tmp/test.pack&quot;);&#xA; *        FileOutputStream fostream = new FileOutputStream(&quot;/tmp/test.jar&quot;);&#xA; *        JarOutputStream jostream = new JarOutputStream(fostream);&#xA; *        Unpacker unpacker = Pack200.newUnpacker();&#xA; *        // Call the unpacker&#xA; *        unpacker.unpack(f, jostream);&#xA; *        // Must explicitly close the output.&#xA; *        jostream.close();&#xA; *    } catch (IOException ioe) {&#xA; *        ioe.printStackTrace();&#xA; *    }&#xA; * &lt;/pre>&lt;/blockquote>&#xA; * &lt;p>&#xA; * A Pack200 file compressed with gzip can be hosted on HTTP/1.1 web servers.&#xA; * The deployment applications can use &quot;Accept-Encoding=pack200-gzip&quot;. This &#xA; * indicates to the server that the client application desires a version of&#xA; * the file encoded with Pack200 and further compressed with gzip. Please &#xA; * refer to Java Deployment Guide &lt;TBD> for more details and techniques.&#xA; * &lt;p>&#xA; * Unless otherwise noted, passing a &lt;tt>null&lt;/tt> argument to a constructor or&#xA; * method in this class will cause a {@link NullPointerException} to be thrown.&#xA; *&#xA; * @author John Rose&#xA; * @author Kumar Srinivasan&#xA; * @version 1.4, 12/08/03&#xA; * @since 1.5&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
