<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="SortedSet.java">
  <comments>/*&#xA; * @(#)SortedSet.java&#x9;1.24 04/06/28&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="SortedSet">
    <typeParameters name="E"/>
    <members xsi:type="members:InterfaceMethod" name="comparator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns the comparator associated with this sorted set, or&#xA;     * &lt;tt>null&lt;/tt> if it uses its elements' natural ordering.&#xA;     *&#xA;     * @return the comparator associated with this sorted set, or&#xA;     * &#x9;       &lt;tt>null&lt;/tt> if it uses its elements' natural ordering.&#xA;     */</comments>
          <typeArguments xsi:type="generics:SuperTypeArgument">
            <superType xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </superType>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Comparator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="subSet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0">
          <comments>/**&#xA;     * Returns a view of the portion of this sorted set whose elements range&#xA;     * from &lt;tt>fromElement&lt;/tt>, inclusive, to &lt;tt>toElement&lt;/tt>, exclusive.&#xA;     * (If &lt;tt>fromElement&lt;/tt> and &lt;tt>toElement&lt;/tt> are equal, the returned&#xA;     * sorted set is empty.)  The returned sorted set is backed by this sorted&#xA;     * set, so changes in the returned sorted set are reflected in this sorted&#xA;     * set, and vice-versa.  The returned sorted set supports all optional set&#xA;     * operations that this sorted set supports.&lt;p>&#xA;     *&#xA;     * The sorted set returned by this method will throw an&#xA;     * &lt;tt>IllegalArgumentException&lt;/tt> if the user attempts to insert a&#xA;     * element outside the specified range.&lt;p>&#xA;     * &#xA;     * Note: this method always returns a &lt;i>half-open range&lt;/i> (which&#xA;     * includes its low endpoint but not its high endpoint).  If you need a&#xA;     * &lt;i>closed range&lt;/i> (which includes both endpoints), and the element&#xA;     * type allows for calculation of the successor a given value, merely&#xA;     * request the subrange from &lt;tt>lowEndpoint&lt;/tt> to&#xA;     * &lt;tt>successor(highEndpoint)&lt;/tt>.  For example, suppose that &lt;tt>s&lt;/tt>&#xA;     * is a sorted set of strings.  The following idiom obtains a view&#xA;     * containing all of the strings in &lt;tt>s&lt;/tt> from &lt;tt>low&lt;/tt> to&#xA;     * &lt;tt>high&lt;/tt>, inclusive: &lt;pre>&#xA;     * SortedSet sub = s.subSet(low, high+&quot;\0&quot;);&#xA;     * &lt;/pre>&#xA;     * &#xA;     * A similar technique can be used to generate an &lt;i>open range&lt;/i> (which&#xA;     * contains neither endpoint).  The following idiom obtains a view&#xA;     * containing all of the Strings in &lt;tt>s&lt;/tt> from &lt;tt>low&lt;/tt> to&#xA;     * &lt;tt>high&lt;/tt>, exclusive: &lt;pre>&#xA;     * SortedSet sub = s.subSet(low+&quot;\0&quot;, high);&#xA;     * &lt;/pre>&#xA;     *&#xA;     * @param fromElement low endpoint (inclusive) of the subSet.&#xA;     * @param toElement high endpoint (exclusive) of the subSet.&#xA;     * @return a view of the specified range within this sorted set.&#xA;     * &#xA;     * @throws ClassCastException if &lt;tt>fromElement&lt;/tt> and&#xA;     *         &lt;tt>toElement&lt;/tt> cannot be compared to one another using this&#xA;     *         set's comparator (or, if the set has no comparator, using&#xA;     *         natural ordering).  Implementations may, but are not required&#xA;     *&#x9;       to, throw this exception if &lt;tt>fromElement&lt;/tt> or&#xA;     *         &lt;tt>toElement&lt;/tt> cannot be compared to elements currently in&#xA;     *         the set.&#xA;     * @throws IllegalArgumentException if &lt;tt>fromElement&lt;/tt> is greater than&#xA;     *         &lt;tt>toElement&lt;/tt>; or if this set is itself a subSet, headSet,&#xA;     *         or tailSet, and &lt;tt>fromElement&lt;/tt> or &lt;tt>toElement&lt;/tt> are&#xA;     *         not within the specified range of the subSet, headSet, or&#xA;     *         tailSet.&#xA;     * @throws NullPointerException if &lt;tt>fromElement&lt;/tt> or&#xA;     *&#x9;       &lt;tt>toElement&lt;/tt> is &lt;tt>null&lt;/tt> and this sorted set does&#xA;     *&#x9;       not tolerate &lt;tt>null&lt;/tt> elements.&#xA;     */</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromElement">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toElement">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="headSet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0">
          <comments>/**&#xA;     * Returns a view of the portion of this sorted set whose elements are&#xA;     * strictly less than &lt;tt>toElement&lt;/tt>.  The returned sorted set is&#xA;     * backed by this sorted set, so changes in the returned sorted set are&#xA;     * reflected in this sorted set, and vice-versa.  The returned sorted set&#xA;     * supports all optional set operations.&lt;p>&#xA;     *&#xA;     * The sorted set returned by this method will throw an&#xA;     * &lt;tt>IllegalArgumentException&lt;/tt> if the user attempts to insert a&#xA;     * element outside the specified range.&lt;p>&#xA;     *&#xA;     * Note: this method always returns a view that does not contain its&#xA;     * (high) endpoint.  If you need a view that does contain this endpoint,&#xA;     * and the element type allows for calculation of the successor a given&#xA;     * value, merely request a headSet bounded by&#xA;     * &lt;tt>successor(highEndpoint)&lt;/tt>.  For example, suppose that &lt;tt>s&lt;/tt>&#xA;     * is a sorted set of strings.  The following idiom obtains a view&#xA;     * containing all of the strings in &lt;tt>s&lt;/tt> that are less than or equal&#xA;     * to &lt;tt>high&lt;/tt>:&#xA;     * &#x9;    &lt;pre>    SortedSet head = s.headSet(high+&quot;\0&quot;);&lt;/pre>&#xA;     *&#xA;     * @param toElement high endpoint (exclusive) of the headSet.&#xA;     * @return a view of the specified initial range of this sorted set.&#xA;     * @throws ClassCastException if &lt;tt>toElement&lt;/tt> is not compatible&#xA;     *         with this set's comparator (or, if the set has no comparator,&#xA;     *         if &lt;tt>toElement&lt;/tt> does not implement &lt;tt>Comparable&lt;/tt>).&#xA;     *         Implementations may, but are not required to, throw this&#xA;     *&#x9;       exception if &lt;tt>toElement&lt;/tt> cannot be compared to elements&#xA;     *         currently in the set.&#xA;     * @throws NullPointerException if &lt;tt>toElement&lt;/tt> is &lt;tt>null&lt;/tt> and&#xA;     *&#x9;       this sorted set does not tolerate &lt;tt>null&lt;/tt> elements.&#xA;     * @throws IllegalArgumentException if this set is itself a subSet,&#xA;     *         headSet, or tailSet, and &lt;tt>toElement&lt;/tt> is not within the&#xA;     *         specified range of the subSet, headSet, or tailSet.&#xA;     */</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toElement">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="tailSet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0">
          <comments>/**&#xA;     * Returns a view of the portion of this sorted set whose elements are&#xA;     * greater than or equal to &lt;tt>fromElement&lt;/tt>.  The returned sorted set&#xA;     * is backed by this sorted set, so changes in the returned sorted set are&#xA;     * reflected in this sorted set, and vice-versa.  The returned sorted set&#xA;     * supports all optional set operations.&lt;p>&#xA;     *&#xA;     * The sorted set returned by this method will throw an&#xA;     * &lt;tt>IllegalArgumentException&lt;/tt> if the user attempts to insert a&#xA;     * element outside the specified range.&lt;p>&#xA;     *&#xA;     * Note: this method always returns a view that contains its (low)&#xA;     * endpoint.  If you need a view that does not contain this endpoint, and&#xA;     * the element type allows for calculation of the successor a given value,&#xA;     * merely request a tailSet bounded by &lt;tt>successor(lowEndpoint)&lt;/tt>.&#xA;     * For example, suppose that &lt;tt>s&lt;/tt> is a sorted set of strings.  The&#xA;     * following idiom obtains a view containing all of the strings in&#xA;     * &lt;tt>s&lt;/tt> that are strictly greater than &lt;tt>low&lt;/tt>:&#xA;     * &#xA;     * &#x9;    &lt;pre>    SortedSet tail = s.tailSet(low+&quot;\0&quot;);&lt;/pre>&#xA;     *&#xA;     * @param fromElement low endpoint (inclusive) of the tailSet.&#xA;     * @return a view of the specified final range of this sorted set.&#xA;     * @throws ClassCastException if &lt;tt>fromElement&lt;/tt> is not compatible&#xA;     *         with this set's comparator (or, if the set has no comparator,&#xA;     *         if &lt;tt>fromElement&lt;/tt> does not implement &lt;tt>Comparable&lt;/tt>).&#xA;     *         Implementations may, but are not required to, throw this&#xA;     *&#x9;       exception if &lt;tt>fromElement&lt;/tt> cannot be compared to elements&#xA;     *         currently in the set.&#xA;     * @throws NullPointerException if &lt;tt>fromElement&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#x9;       and this sorted set does not tolerate &lt;tt>null&lt;/tt> elements.&#xA;     * @throws IllegalArgumentException if this set is itself a subSet,&#xA;     *         headSet, or tailSet, and &lt;tt>fromElement&lt;/tt> is not within the&#xA;     *         specified range of the subSet, headSet, or tailSet.&#xA;     */</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromElement">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="first">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0">
          <comments>/**&#xA;     * Returns the first (lowest) element currently in this sorted set.&#xA;     *&#xA;     * @return the first (lowest) element currently in this sorted set.&#xA;     * @throws    NoSuchElementException sorted set is empty.&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="last">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0">
          <comments>/**&#xA;     * Returns the last (highest) element currently in this sorted set.&#xA;     *&#xA;     * @return the last (highest) element currently in this sorted set.&#xA;     * @throws    NoSuchElementException sorted set is empty.&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A set that further guarantees that its iterator will traverse the set in&#xA; * ascending element order, sorted according to the &lt;i>natural ordering&lt;/i> of&#xA; * its elements (see Comparable), or by a Comparator provided at sorted set&#xA; * creation time.  Several additional operations are provided to take&#xA; * advantage of the ordering.  (This interface is the set analogue of&#xA; * SortedMap.)&lt;p>&#xA; *&#xA; * All elements inserted into an sorted set must implement the Comparable&#xA; * interface (or be accepted by the specified Comparator).  Furthermore, all&#xA; * such elements must be &lt;i>mutually comparable&lt;/i>: &lt;tt>e1.compareTo(e2)&lt;/tt>&#xA; * (or &lt;tt>comparator.compare(e1, e2)&lt;/tt>) must not throw a&#xA; * &lt;tt>ClassCastException&lt;/tt> for any elements &lt;tt>e1&lt;/tt> and &lt;tt>e2&lt;/tt> in&#xA; * the sorted set.  Attempts to violate this restriction will cause the&#xA; * offending method or constructor invocation to throw a&#xA; * &lt;tt>ClassCastException&lt;/tt>.&lt;p>&#xA; *&#xA; * Note that the ordering maintained by a sorted set (whether or not an&#xA; * explicit comparator is provided) must be &lt;i>consistent with equals&lt;/i> if&#xA; * the sorted set is to correctly implement the &lt;tt>Set&lt;/tt> interface.  (See&#xA; * the &lt;tt>Comparable&lt;/tt> interface or &lt;tt>Comparator&lt;/tt> interface for a&#xA; * precise definition of &lt;i>consistent with equals&lt;/i>.)  This is so because&#xA; * the &lt;tt>Set&lt;/tt> interface is defined in terms of the &lt;tt>equals&lt;/tt>&#xA; * operation, but a sorted set performs all element comparisons using its&#xA; * &lt;tt>compareTo&lt;/tt> (or &lt;tt>compare&lt;/tt>) method, so two elements that are&#xA; * deemed equal by this method are, from the standpoint of the sorted set,&#xA; * equal.  The behavior of a sorted set &lt;i>is&lt;/i> well-defined even if its&#xA; * ordering is inconsistent with equals; it just fails to obey the general&#xA; * contract of the &lt;tt>Set&lt;/tt> interface.&lt;p>&#xA; *&#xA; * All general-purpose sorted set implementation classes should provide four&#xA; * &quot;standard&quot; constructors: 1) A void (no arguments) constructor, which&#xA; * creates an empty sorted set sorted according to the &lt;i>natural order&lt;/i> of&#xA; * its elements.  2) A constructor with a single argument of type&#xA; * &lt;tt>Comparator&lt;/tt>, which creates an empty sorted set sorted according to&#xA; * the specified comparator.  3) A constructor with a single argument of type&#xA; * &lt;tt>Collection&lt;/tt>, which creates a new sorted set with the same elements&#xA; * as its argument, sorted according to the elements' natural ordering.  4) A&#xA; * constructor with a single argument of type &lt;tt>SortedSet&lt;/tt>, which&#xA; * creates a new sorted set with the same elements and the same ordering as&#xA; * the input sorted set.  There is no way to enforce this recommendation (as&#xA; * interfaces cannot contain constructors) but the JDK implementation (the&#xA; * &lt;tt>TreeSet&lt;/tt> class) complies.&lt;p>&#xA; *&#xA; * This interface is a member of the &#xA; * &lt;a href=&quot;{@docRoot}/../guide/collections/index.html&quot;>&#xA; * Java Collections Framework&lt;/a>.&#xA; *&#xA; * @author  Josh Bloch&#xA; * @version 1.24, 06/28/04&#xA; * @see Set&#xA; * @see TreeSet&#xA; * @see SortedMap&#xA; * @see Collection&#xA; * @see Comparable&#xA; * @see Comparator&#xA; * @see java.lang.ClassCastException&#xA; * @since 1.2&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="Set.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
