<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="Timer.java">
  <comments>/*&#xA; * @(#)Timer.java&#x9;1.17 04/04/12&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Timer">
    <members xsi:type="members:Field" name="queue">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.2"/>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.2"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The timer task queue.  This data structure is shared with the timer&#xA;     * thread.  The timer produces tasks, via its various schedule calls,&#xA;     * and the timer thread consumes, executing timer tasks as appropriate,&#xA;     * and removing them from the queue when they're obsolete.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="thread">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.1"/>
        </typeReference>
        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.1"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The timer thread.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="threadReaper">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <anonymousClass>
          <members xsi:type="members:ClassMethod" name="finalize">
            <typeReference xsi:type="types:Void"/>
            <exceptions>
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Throwable.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </exceptions>
            <annotationsAndModifiers xsi:type="modifiers:Protected"/>
            <statements xsi:type="statements:SynchronizedBlock">
              <comments>// In case queue is empty.</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0"/>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:BooleanLiteral"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.7"/>
                  </next>
                </expression>
              </statements>
              <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </statements>
          </members>
        </anonymousClass>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * This object causes the timer's task execution thread to exit&#xA;     * gracefully when there are no live references to the Timer object and no&#xA;     * tasks in the timer queue.  It is used in preference to a finalizer on&#xA;     * Timer as such a finalizer would be susceptible to a subclass's&#xA;     * finalizer forgetting to call it.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="nextSerialNumber">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * This ID is used to generate thread names.  (It could be replaced&#xA;     * by an AtomicInteger as soon as they become available.)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="serialNumber">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          <operator xsi:type="operators:PlusPlus"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Constructor" name="Timer">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:StringReference" value="Timer-"/>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new timer.  The associated thread does &lt;i>not&lt;/i> run as&#xA;     * a daemon.&#xA;     *&#xA;     * @see Thread&#xA;     * @see #cancel()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Timer">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:StringReference" value="Timer-"/>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="isDaemon">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new timer whose associated thread may be specified to &#xA;     * run as a daemon.  A daemon thread is called for if the timer will&#xA;     * be used to schedule repeating &quot;maintenance activities&quot;, which must&#xA;     * be performed as long as the application is running, but should not&#xA;     * prolong the lifetime of the application.&#xA;     *&#xA;     * @param isDaemon true if the associated thread should run as a daemon.&#xA;     *&#xA;     * @see Thread&#xA;     * @see #cancel()&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Timer">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.62"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.46"/>
          </next>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new timer whose associated thread has the specified name.&#xA;     * The associated thread does &lt;i>not&lt;/i> run as a daemon.&#xA;     *&#xA;     * @param name the name of the associated thread&#xA;     * @throws NullPointerException if name is null&#xA;     * @see Thread#getName()&#xA;     * @see Thread#isDaemon()&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Timer">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.62"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.72"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.1"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.46"/>
          </next>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="isDaemon">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new timer whose associated thread has the specified name,&#xA;     * and may be specified to run as a daemon.&#xA;     *&#xA;     * @param name the name of the associated thread&#xA;     * @param isDaemon true if the associated thread should run as a daemon&#xA;     * @throws NullPointerException if name is null&#xA;     * @see Thread#getName()&#xA;     * @see Thread#isDaemon()&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="schedule">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="task">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="delay">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Schedules the specified task for execution after the specified delay.&#xA;     *&#xA;     * @param task  task to be scheduled.&#xA;     * @param delay delay in milliseconds before task is to be executed.&#xA;     * @throws IllegalArgumentException if &lt;tt>delay&lt;/tt> is negative, or&#xA;     *         &lt;tt>delay + System.currentTimeMillis()&lt;/tt> is negative.&#xA;     * @throws IllegalStateException if task was already scheduled or&#xA;     *         cancelled, or timer was cancelled.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Negative delay."/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.18"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="schedule">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="task">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="time">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Schedules the specified task for execution at the specified time.  If&#xA;     * the time is in the past, the task is scheduled for immediate execution.&#xA;     *&#xA;     * @param task task to be scheduled.&#xA;     * @param time time at which task is to be executed.&#xA;     * @throws IllegalArgumentException if &lt;tt>time.getTime()&lt;/tt> is negative.&#xA;     * @throws IllegalStateException if task was already scheduled or&#xA;     *         cancelled, timer was cancelled, or timer thread terminated.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Date.class.xmi#//@classifiers.0/@members.30"/>
            </next>
          </arguments>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="schedule">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="task">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="delay">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="period">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Schedules the specified task for repeated &lt;i>fixed-delay execution&lt;/i>,&#xA;     * beginning after the specified delay.  Subsequent executions take place&#xA;     * at approximately regular intervals separated by the specified period.&#xA;     *&#xA;     * &lt;p>In fixed-delay execution, each execution is scheduled relative to&#xA;     * the actual execution time of the previous execution.  If an execution&#xA;     * is delayed for any reason (such as garbage collection or other&#xA;     * background activity), subsequent executions will be delayed as well.&#xA;     * In the long run, the frequency of execution will generally be slightly&#xA;     * lower than the reciprocal of the specified period (assuming the system&#xA;     * clock underlying &lt;tt>Object.wait(long)&lt;/tt> is accurate).&#xA;     *&#xA;     * &lt;p>Fixed-delay execution is appropriate for recurring activities&#xA;     * that require &quot;smoothness.&quot;  In other words, it is appropriate for&#xA;     * activities where it is more important to keep the frequency accurate&#xA;     * in the short run than in the long run.  This includes most animation&#xA;     * tasks, such as blinking a cursor at regular intervals.  It also includes&#xA;     * tasks wherein regular activity is performed in response to human&#xA;     * input, such as automatically repeating a character as long as a key&#xA;     * is held down.&#xA;     *&#xA;     * @param task   task to be scheduled.&#xA;     * @param delay  delay in milliseconds before task is to be executed.&#xA;     * @param period time in milliseconds between successive task executions.&#xA;     * @throws IllegalArgumentException if &lt;tt>delay&lt;/tt> is negative, or&#xA;     *         &lt;tt>delay + System.currentTimeMillis()&lt;/tt> is negative.&#xA;     * @throws IllegalStateException if task was already scheduled or&#xA;     *         cancelled, timer was cancelled, or timer thread terminated.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Negative delay."/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Non-positive period."/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.2"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.18"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.2"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="schedule">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="task">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="firstTime">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="period">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Schedules the specified task for repeated &lt;i>fixed-delay execution&lt;/i>,&#xA;     * beginning at the specified time. Subsequent executions take place at&#xA;     * approximately regular intervals, separated by the specified period.&#xA;     *&#xA;     * &lt;p>In fixed-delay execution, each execution is scheduled relative to&#xA;     * the actual execution time of the previous execution.  If an execution&#xA;     * is delayed for any reason (such as garbage collection or other&#xA;     * background activity), subsequent executions will be delayed as well.&#xA;     * In the long run, the frequency of execution will generally be slightly&#xA;     * lower than the reciprocal of the specified period (assuming the system&#xA;     * clock underlying &lt;tt>Object.wait(long)&lt;/tt> is accurate).&#xA;     *&#xA;     * &lt;p>Fixed-delay execution is appropriate for recurring activities&#xA;     * that require &quot;smoothness.&quot;  In other words, it is appropriate for&#xA;     * activities where it is more important to keep the frequency accurate&#xA;     * in the short run than in the long run.  This includes most animation&#xA;     * tasks, such as blinking a cursor at regular intervals.  It also includes&#xA;     * tasks wherein regular activity is performed in response to human&#xA;     * input, such as automatically repeating a character as long as a key&#xA;     * is held down.&#xA;     *&#xA;     * @param task   task to be scheduled.&#xA;     * @param firstTime First time at which task is to be executed.&#xA;     * @param period time in milliseconds between successive task executions.&#xA;     * @throws IllegalArgumentException if &lt;tt>time.getTime()&lt;/tt> is negative.&#xA;     * @throws IllegalStateException if task was already scheduled or&#xA;     *         cancelled, timer was cancelled, or timer thread terminated.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Non-positive period."/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.2"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Date.class.xmi#//@classifiers.0/@members.30"/>
            </next>
          </arguments>
          <arguments xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.2"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="scheduleAtFixedRate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="task">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="delay">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="period">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Schedules the specified task for repeated &lt;i>fixed-rate execution&lt;/i>,&#xA;     * beginning after the specified delay.  Subsequent executions take place&#xA;     * at approximately regular intervals, separated by the specified period.&#xA;     *&#xA;     * &lt;p>In fixed-rate execution, each execution is scheduled relative to the&#xA;     * scheduled execution time of the initial execution.  If an execution is&#xA;     * delayed for any reason (such as garbage collection or other background&#xA;     * activity), two or more executions will occur in rapid succession to&#xA;     * &quot;catch up.&quot;  In the long run, the frequency of execution will be&#xA;     * exactly the reciprocal of the specified period (assuming the system&#xA;     * clock underlying &lt;tt>Object.wait(long)&lt;/tt> is accurate).&#xA;     *&#xA;     * &lt;p>Fixed-rate execution is appropriate for recurring activities that&#xA;     * are sensitive to &lt;i>absolute&lt;/i> time, such as ringing a chime every&#xA;     * hour on the hour, or running scheduled maintenance every day at a&#xA;     * particular time.  It is also appropriate for recurring activities&#xA;     * where the total time to perform a fixed number of executions is&#xA;     * important, such as a countdown timer that ticks once every second for&#xA;     * ten seconds.  Finally, fixed-rate execution is appropriate for&#xA;     * scheduling multiple repeating timer tasks that must remain synchronized&#xA;     * with respect to one another.&#xA;     *&#xA;     * @param task   task to be scheduled.&#xA;     * @param delay  delay in milliseconds before task is to be executed.&#xA;     * @param period time in milliseconds between successive task executions.&#xA;     * @throws IllegalArgumentException if &lt;tt>delay&lt;/tt> is negative, or&#xA;     *         &lt;tt>delay + System.currentTimeMillis()&lt;/tt> is negative.&#xA;     * @throws IllegalStateException if task was already scheduled or&#xA;     *         cancelled, timer was cancelled, or timer thread terminated.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Negative delay."/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Non-positive period."/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.18"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="scheduleAtFixedRate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="task">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="firstTime">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="period">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Schedules the specified task for repeated &lt;i>fixed-rate execution&lt;/i>,&#xA;     * beginning at the specified time. Subsequent executions take place at&#xA;     * approximately regular intervals, separated by the specified period.&#xA;     *&#xA;     * &lt;p>In fixed-rate execution, each execution is scheduled relative to the&#xA;     * scheduled execution time of the initial execution.  If an execution is&#xA;     * delayed for any reason (such as garbage collection or other background&#xA;     * activity), two or more executions will occur in rapid succession to&#xA;     * &quot;catch up.&quot;  In the long run, the frequency of execution will be&#xA;     * exactly the reciprocal of the specified period (assuming the system&#xA;     * clock underlying &lt;tt>Object.wait(long)&lt;/tt> is accurate).&#xA;     *&#xA;     * &lt;p>Fixed-rate execution is appropriate for recurring activities that&#xA;     * are sensitive to &lt;i>absolute&lt;/i> time, such as ringing a chime every&#xA;     * hour on the hour, or running scheduled maintenance every day at a&#xA;     * particular time.  It is also appropriate for recurring activities&#xA;     * where the total time to perform a fixed number of executions is&#xA;     * important, such as a countdown timer that ticks once every second for&#xA;     * ten seconds.  Finally, fixed-rate execution is appropriate for&#xA;     * scheduling multiple repeating timer tasks that must remain synchronized&#xA;     * with respect to one another.&#xA;     *&#xA;     * @param task   task to be scheduled.&#xA;     * @param firstTime First time at which task is to be executed.&#xA;     * @param period time in milliseconds between successive task executions.&#xA;     * @throws IllegalArgumentException if &lt;tt>time.getTime()&lt;/tt> is negative.&#xA;     * @throws IllegalStateException if task was already scheduled or&#xA;     *         cancelled, timer was cancelled, or timer thread terminated.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Non-positive period."/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.2"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Date.class.xmi#//@classifiers.0/@members.30"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.2"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="sched">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="task">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="time">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="period">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Schedule the specified timer task for execution at the specified&#xA;     * time with the specified period, in milliseconds.  If period is&#xA;     * positive, the task is scheduled for repeated execution; if period is&#xA;     * zero, the task is scheduled for one-time execution. Time is specified&#xA;     * in Date.getTime() format.  This method checks timer state, task state,&#xA;     * and initial execution time, but not period.&#xA;     *&#xA;     * @throws IllegalArgumentException if &lt;tt>time()&lt;/tt> is negative.&#xA;     * @throws IllegalStateException if task was already scheduled or&#xA;     *         cancelled, timer was cancelled, or timer thread terminated.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Illegal execution time."/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Timer already cancelled."/>
            </throwable>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0"/>
            </child>
          </condition>
        </statements>
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="Task already scheduled or cancelled"/>
              </throwable>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </children>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.2"/>
                </next>
                <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.6"/>
                </next>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.7"/>
                </next>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.2"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.3"/>
                </next>
                <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
          <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </lockProvider>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.3">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
            </next>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.7"/>
              </next>
            </expression>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.4"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          </condition>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="cancel">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Terminates this timer, discarding any currently scheduled tasks.&#xA;     * Does not interfere with a currently executing task (if it exists).&#xA;     * Once a timer has been terminated, its execution thread terminates&#xA;     * gracefully, and no more tasks may be scheduled on it.&#xA;     *&#xA;     * &lt;p>Note that calling this method from within the run method of a&#xA;     * timer task that was invoked by this timer absolutely guarantees that&#xA;     * the ongoing task execution is the last task execution that will ever&#xA;     * be performed by this timer.&#xA;     *&#xA;     * &lt;p>This method may be called repeatedly; the second and subsequent &#xA;     * calls have no effect.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <comments>// In case queue was already empty.</comments>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:BooleanLiteral"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.10"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.7"/>
            </next>
          </expression>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="purge">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes all cancelled tasks from this timer's task queue.  &lt;i>Calling&#xA;     * this method has no effect on the behavior of the timer&lt;/i>, but&#xA;     * eliminates the references to the cancelled tasks from the queue.&#xA;     * If there are no external references to these tasks, they become&#xA;     * eligible for garbage collection.&#xA;     *&#xA;     * &lt;p>Most programs will have no need to call this method.&#xA;     * It is designed for use by the rare application that cancels a large&#xA;     * number of tasks.  Calling this method trades time for space: the&#xA;     * runtime of the method may be proportional to n + c log n, where n&#xA;     * is the number of tasks in the queue and c is the number of cancelled&#xA;     * tasks.&#xA;     *&#xA;     * &lt;p>Note that it is permissible to call this method from within a&#xA;     * a task scheduled on this timer.&#xA;     *&#xA;     * @return the number of tasks removed from the queue.&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                    <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.7">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.1/@statements.0/@init"/>
                    </next>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.5">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.1"/>
                    </next>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.1/@statements.0/@init"/>
                  </next>
                </children>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.5"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
                </children>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.1/@statements.0/@init"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
          <init xsi:type="variables:LocalVariable" name="i">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.2"/>
            </initialValue>
          </init>
          <updates xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.1/@statements.0/@init"/>
            <operator xsi:type="operators:MinusMinus"/>
          </updates>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.13"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </condition>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A facility for threads to schedule tasks for future execution in a&#xA; * background thread.  Tasks may be scheduled for one-time execution, or for&#xA; * repeated execution at regular intervals.&#xA; *&#xA; * &lt;p>Corresponding to each &lt;tt>Timer&lt;/tt> object is a single background&#xA; * thread that is used to execute all of the timer's tasks, sequentially.&#xA; * Timer tasks should complete quickly.  If a timer task takes excessive time&#xA; * to complete, it &quot;hogs&quot; the timer's task execution thread.  This can, in&#xA; * turn, delay the execution of subsequent tasks, which may &quot;bunch up&quot; and&#xA; * execute in rapid succession when (and if) the offending task finally&#xA; * completes.&#xA; *&#xA; * &lt;p>After the last live reference to a &lt;tt>Timer&lt;/tt> object goes away&#xA; * &lt;i>and&lt;/i> all outstanding tasks have completed execution, the timer's task&#xA; * execution thread terminates gracefully (and becomes subject to garbage&#xA; * collection).  However, this can take arbitrarily long to occur.  By&#xA; * default, the task execution thread does not run as a &lt;i>daemon thread&lt;/i>,&#xA; * so it is capable of keeping an application from terminating.  If a caller&#xA; * wants to terminate a timer's task execution thread rapidly, the caller&#xA; * should invoke the timer's &lt;tt>cancel&lt;/tt> method.&#xA; *&#xA; * &lt;p>If the timer's task execution thread terminates unexpectedly, for&#xA; * example, because its &lt;tt>stop&lt;/tt> method is invoked, any further&#xA; * attempt to schedule a task on the timer will result in an&#xA; * &lt;tt>IllegalStateException&lt;/tt>, as if the timer's &lt;tt>cancel&lt;/tt>&#xA; * method had been invoked.&#xA; *&#xA; * &lt;p>This class is thread-safe: multiple threads can share a single&#xA; * &lt;tt>Timer&lt;/tt> object without the need for external synchronization.&#xA; *&#xA; * &lt;p>This class does &lt;i>not&lt;/i> offer real-time guarantees: it schedules&#xA; * tasks using the &lt;tt>Object.wait(long)&lt;/tt> method.&#xA; *&#xA; * &lt;p>Implementation note: This class scales to large numbers of concurrently&#xA; * scheduled tasks (thousands should present no problem).  Internally,&#xA; * it uses a binary heap to represent its task queue, so the cost to schedule&#xA; * a task is O(log n), where n is the number of concurrently scheduled tasks.&#xA; *&#xA; * &lt;p>Implementation note: All constructors start a timer thread.&#xA; *&#xA; * @author  Josh Bloch&#xA; * @version 1.17, 04/12/04&#xA; * @see     TimerTask&#xA; * @see     Object#wait(long)&#xA; * @since   1.3&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
  <classifiers xsi:type="classifiers:Class" name="TimerThread">
    <comments>/**&#xA; * This &quot;helper class&quot; implements the timer's task execution thread, which&#xA; * waits for tasks on the timer queue, executions them when they fire,&#xA; * reschedules repeating tasks, and removes cancelled tasks and spent&#xA; * non-repeating tasks from the queue.&#xA; */</comments>
    <members xsi:type="members:Field" name="newTasksMayBeScheduled">
      <initialValue xsi:type="literals:BooleanLiteral" value="true"/>
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * This flag is set to false by the reaper to inform us that there&#xA;     * are no more live references to our Timer object.  Once this flag&#xA;     * is true and there are no more tasks in our queue, there is no&#xA;     * work left for us to do, so we terminate gracefully.  Note that&#xA;     * this field is protected by queue's monitor!&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="queue">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.2"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Our Timer's queue.  We store this reference in preference to&#xA;     * a reference to the Timer so the reference graph remains acyclic.&#xA;     * Otherwise, the Timer would never be garbage-collected and this&#xA;     * thread would never go away.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="TimerThread">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="queue">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.2"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:ClassMethod" name="run">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.1/@members.4"/>
        </statements>
        <finallyBlock>
          <statements xsi:type="statements:SynchronizedBlock">
            <comments>// Someone killed this Thread, behave as if Timer cancelled</comments>
            <comments>// Eliminate obsolete references</comments>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1">
                <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.10"/>
              </expression>
            </statements>
            <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
          </statements>
        </finallyBlock>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="mainLoop">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The main timer loop.  (See class comment.)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:TryBlock">
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="task">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </variable>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="taskFired">
                <typeReference xsi:type="types:Boolean"/>
              </variable>
            </statements>
            <statements xsi:type="statements:SynchronizedBlock">
              <statements xsi:type="statements:WhileLoop">
                <comments>// Wait for queue to become non-empty</comments>
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.11"/>
                    </next>
                  </expression>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1">
                    <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.9"/>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0"/>
                </condition>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Break"/>
                <condition xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1">
                  <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.9"/>
                </condition>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="currentTime">
                  <typeReference xsi:type="types:Long">
                    <comments>// Queue is empty and will forever remain; die</comments>
                    <comments>// Queue nonempty; look at first evt and do the right thing</comments>
                  </typeReference>
                  <additionalLocalVariables name="executionTime"/>
                </variable>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1">
                    <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.4"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:SynchronizedBlock">
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <comments>// No action required, poll queue again</comments>
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1">
                        <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.6"/>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:Continue"/>
                  </statement>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.0/@variable">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.1"/>
                      </next>
                    </children>
                    <children xsi:type="references:IdentifierReference">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.5"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
                    </children>
                  </condition>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.2/@statements.2/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.18"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
                    </value>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.2/@statements.2/@variable/@additionalLocalVariables.0"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.0/@variable">
                      <next xsi:type="references:IdentifierReference">
                        <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.6"/>
                      </next>
                    </value>
                  </expression>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:Condition">
                      <statement xsi:type="statements:Block">
                        <statements xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1">
                            <comments>// Non-repeating, remove</comments>
                            <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.6"/>
                          </expression>
                        </statements>
                        <statements xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="expressions:AssignmentExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.0/@variable">
                              <next xsi:type="references:IdentifierReference">
                                <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.1"/>
                              </next>
                            </child>
                            <assignmentOperator xsi:type="operators:Assignment"/>
                            <value xsi:type="references:IdentifierReference">
                              <next xsi:type="references:IdentifierReference">
                                <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.4"/>
                              </next>
                              <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
                            </value>
                          </expression>
                        </statements>
                      </statement>
                      <condition xsi:type="expressions:EqualityExpression">
                        <equalityOperators xsi:type="operators:Equal"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.0/@variable">
                          <next xsi:type="references:IdentifierReference">
                            <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.7"/>
                          </next>
                        </children>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      </condition>
                      <elseStatement xsi:type="statements:Block">
                        <statements xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1">
                            <comments>// Repeating task, reschedule</comments>
                            <next xsi:type="references:MethodCall" target="//@classifiers.2/@members.8">
                              <arguments xsi:type="expressions:ConditionalExpression">
                                <child xsi:type="expressions:RelationExpression">
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.0/@variable">
                                    <next xsi:type="references:IdentifierReference">
                                      <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.7"/>
                                    </next>
                                  </children>
                                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                                  <relationOperators xsi:type="operators:LessThan"/>
                                </child>
                                <expressionIf xsi:type="expressions:AdditiveExpression">
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.2/@statements.2/@variable"/>
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.0/@variable">
                                    <next xsi:type="references:IdentifierReference">
                                      <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.7"/>
                                    </next>
                                  </children>
                                  <additiveOperators xsi:type="operators:Subtraction"/>
                                </expressionIf>
                                <expressionElse xsi:type="expressions:AdditiveExpression">
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.2/@statements.2/@variable/@additionalLocalVariables.0"/>
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.0/@variable">
                                    <next xsi:type="references:IdentifierReference">
                                      <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.7"/>
                                    </next>
                                  </children>
                                  <additiveOperators xsi:type="operators:Addition"/>
                                </expressionElse>
                              </arguments>
                            </next>
                          </expression>
                        </statements>
                      </elseStatement>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.1/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.2/@statements.2/@variable/@additionalLocalVariables.0"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.2/@statements.2/@variable"/>
                        <relationOperators xsi:type="operators:LessThanOrEqual"/>
                      </expression>
                    </value>
                  </condition>
                </statements>
                <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.0/@variable">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                </lockProvider>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1">
                    <comments>// Task hasn't yet fired; wait</comments>
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.9"/>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.2/@statements.2/@variable/@additionalLocalVariables.0"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.2/@statements.2/@variable"/>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </arguments>
                    </next>
                  </expression>
                </statement>
                <condition xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Negate"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.1/@variable"/>
                </condition>
              </statements>
              <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.0/@variable">
                  <comments>// Task fired; run it, holding no locks</comments>
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="TimerTask.class.xmi#//@classifiers.0/@members.9"/>
                  </next>
                </expression>
              </statement>
              <condition xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@statements.0/@statement/@statements.0/@statements.1/@variable"/>
            </statements>
            <catcheBlocks>
              <parameter name="e">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/InterruptedException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </parameter>
            </catcheBlocks>
          </statements>
        </statement>
        <condition xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
  <classifiers xsi:type="classifiers:Class" name="TaskQueue">
    <comments>/**&#xA; * This class represents a timer task queue: a priority queue of TimerTasks,&#xA; * ordered on nextExecutionTime.  Each Timer object has one of these, which it&#xA; * shares with its TimerThread.  Internally this class uses a heap, which&#xA; * offers log(n) performance for the add, removeMin and rescheduleMin&#xA; * operations, and constant time performance for the getMin operation.&#xA; */</comments>
    <members xsi:type="members:Field" name="queue">
      <initialValue xsi:type="arrays:ArrayInstantiationBySize">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="128"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Priority queue represented as a balanced binary heap: the two children&#xA;     * of queue[n] are queue[2*n] and queue[2*n+1].  The priority queue is&#xA;     * ordered on the nextExecutionTime field: The TimerTask with the lowest&#xA;     * nextExecutionTime is in queue[1] (assuming the queue is nonempty).  For&#xA;     * each node n in the heap, and each descendant of n, d,&#xA;     * n.nextExecutionTime &lt;= d.nextExecutionTime. &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="size">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The number of tasks in the priority queue.  (The tasks are stored in&#xA;     * queue[1] up to queue[size]).&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="size">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Returns the number of tasks currently on the queue.&#xA;     */</comments>
      </typeReference>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="add">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Adds a new task to the priority queue.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="task">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <statements xsi:type="statements:Condition">
        <comments>// Grow backing store if necessary</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="newQueue">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arrayDimensionsBefore/>
              <initialValue xsi:type="arrays:ArrayInstantiationBySize">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <sizes xsi:type="expressions:MultiplicativeExpression">
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                    <next xsi:type="references:IdentifierReference"/>
                  </children>
                  <multiplicativeOperators xsi:type="operators:Multiplication"/>
                </sizes>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.20"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.3/@statements.0/@statement/@statements.0/@variable"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.3/@statements.0/@statement/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="expressions:PrefixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
            <operator xsi:type="operators:PlusPlus"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
            <next xsi:type="references:IdentifierReference"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.3/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.2/@members.11">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMin">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return the &quot;head task&quot; of the priority queue.  (The head task is an&#xA;     * task with the lowest nextExecutionTime.)&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
          <arraySelectors>
            <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </arraySelectors>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return the ith task in the priority queue, where i ranges from 1 (the&#xA;     * head task, which is returned by getMin) to the number of tasks on the&#xA;     * queue, inclusive.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
          <arraySelectors>
            <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.5/@parameters.0"/>
          </arraySelectors>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeMin">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Remove the head task from the priority queue.&#xA;     */</comments>
      </typeReference>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
            </arraySelectors>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
            <arraySelectors>
              <position xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
                <operator xsi:type="operators:MinusMinus"/>
              </position>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:NullLiteral"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.2/@members.12">
          <comments>// Drop extra reference to prevent memory leak</comments>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="quickRemove">
      <comments>// Drop extra ref to prevent memory leak</comments>
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Removes the ith element from queue without regard for maintaining&#xA;     * the heap invariant.  Recall that queue is one-based, so&#xA;     * 1 &lt;= i &lt;= size.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <statements xsi:type="statements:Assert">
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.7/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.7/@parameters.0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
            </arraySelectors>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
            <arraySelectors>
              <position xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
                <operator xsi:type="operators:MinusMinus"/>
              </position>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:NullLiteral"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="rescheduleMin">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the nextExecutionTime associated with the head task to the &#xA;     * specified value, and adjusts priority queue accordingly.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newTime">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.6"/>
            </next>
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.8/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.2/@members.12">
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isEmpty">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns true if the priority queue contains no elements.&#xA;     */</comments>
      </typeReference>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clear">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Removes all elements from the priority queue.&#xA;     */</comments>
      </typeReference>
      <statements xsi:type="statements:ForLoop">
        <comments>// Null out task references to prevent memory leak</comments>
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.10/@statements.0/@init"/>
              </arraySelectors>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:NullLiteral"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.10/@statements.0/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.10/@statements.0/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="fixUp">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="k">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Establishes the heap invariant (described above) assuming the heap&#xA;     * satisfies the invariant except possibly for the leaf-node indexed by k&#xA;     * (which may have a nextExecutionTime less than its parent's).&#xA;     *&#xA;     * This method functions by &quot;promoting&quot; queue[k] up the hierarchy&#xA;     * (by swapping it with its parent) repeatedly until queue[k]'s&#xA;     * nextExecutionTime is greater than or equal to that of its parent.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="j">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.11/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <shiftOperators xsi:type="operators:RightShift"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Break"/>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.6"/>
                </next>
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.11/@statements.0/@statement/@statements.0/@variable"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.6"/>
                </next>
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.11/@parameters.0"/>
                </arraySelectors>
              </children>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </condition>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="tmp">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.11/@statements.0/@statement/@statements.0/@variable"/>
                </arraySelectors>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.11/@statements.0/@statement/@statements.0/@variable"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.11/@parameters.0"/>
                </arraySelectors>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.11/@parameters.0"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.11/@statements.0/@statement/@statements.2/@variable"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.11/@parameters.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.11/@statements.0/@statement/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.11/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="fixDown">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="k">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Establishes the heap invariant (described above) in the subtree&#xA;     * rooted at k, which is assumed to satisfy the heap invariant except&#xA;     * possibly for node k itself (which may have a nextExecutionTime greater&#xA;     * than its children's).&#xA;     *&#xA;     * This method functions by &quot;demoting&quot; queue[k] down the hierarchy&#xA;     * (by swapping it with its smaller child) repeatedly until queue[k]'s&#xA;     * nextExecutionTime is less than or equal to those of its children.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="j">
          <typeReference xsi:type="types:Int"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@statements.0/@variable"/>
                <operator xsi:type="operators:PlusPlus"/>
              </expression>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@statements.0/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.6"/>
                  </next>
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@statements.0/@variable"/>
                  </arraySelectors>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.6"/>
                  </next>
                  <arraySelectors>
                    <position xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@statements.0/@variable"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </position>
                  </arraySelectors>
                </children>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// j indexes smallest kid</comments>
            <statement xsi:type="statements:Break"/>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.6"/>
                </next>
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@parameters.0"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="TimerTask.class.xmi#//@classifiers.0/@members.6"/>
                </next>
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@statements.0/@variable"/>
                </arraySelectors>
              </children>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </condition>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="tmp">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="TimerTask.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@statements.0/@variable"/>
                </arraySelectors>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@statements.0/@variable"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@parameters.0"/>
                </arraySelectors>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@parameters.0"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@statements.1/@statement/@statements.2/@variable"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@parameters.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <shiftOperators xsi:type="operators:LeftShift"/>
                </value>
              </expression>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.12/@statements.0/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="heapify">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Establishes the heap invariant (described above) in the entire tree,&#xA;     * assuming nothing about the order of the elements prior to the call.&#xA;     */</comments>
      </typeReference>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.2/@members.12">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.13/@statements.0/@init"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.13/@statements.0/@init"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
            <multiplicativeOperators xsi:type="operators:Division"/>
          </initialValue>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.13/@statements.0/@init"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
      </statements>
    </members>
  </classifiers>
</containers:CompilationUnit>
