<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="Executor.java">
  <comments>/*&#xA; * @(#)Executor.java&#x9;1.5 04/02/09&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <namespaces>concurrent</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Executor">
    <members xsi:type="members:InterfaceMethod" name="execute">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Executes the given command at some time in the future.  The command&#xA;     * may execute in a new thread, in a pooled thread, or in the calling&#xA;     * thread, at the discretion of the &lt;tt>Executor&lt;/tt> implementation.&#xA;     *&#xA;     * @param command the runnable task&#xA;     * @throws RejectedExecutionException if this task cannot be&#xA;     * accepted for execution.&#xA;     * @throws NullPointerException if command is null&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="command">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../lang/Runnable.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * An object that executes submitted {@link Runnable} tasks. This&#xA; * interface provides a way of decoupling task submission from the&#xA; * mechanics of how each task will be run, including details of thread&#xA; * use, scheduling, etc.  An &lt;tt>Executor&lt;/tt> is normally used&#xA; * instead of explicitly creating threads. For example, rather than&#xA; * invoking &lt;tt>new Thread(new(RunnableTask())).start()&lt;/tt> for each&#xA; * of a set of tasks, you might use:&#xA; *&#xA; * &lt;pre>&#xA; * Executor executor = &lt;em>anExecutor&lt;/em>;&#xA; * executor.execute(new RunnableTask1());&#xA; * executor.execute(new RunnableTask2());&#xA; * ...&#xA; * &lt;/pre>&#xA; * &#xA; * However, the &lt;tt>Executor&lt;/tt> interface does not strictly&#xA; * require that execution be asynchronous. In the simplest case, an&#xA; * executor can run the submitted task immediately in the caller's&#xA; * thread:&#xA; *&#xA; * &lt;pre>&#xA; * class DirectExecutor implements Executor {&#xA; *     public void execute(Runnable r) {&#xA; *         r.run();&#xA; *     }&#xA; * }&lt;/pre>&#xA; *&#xA; * More typically, tasks are executed in some thread other&#xA; * than the caller's thread.  The executor below spawns a new thread&#xA; * for each task.&#xA; *&#xA; * &lt;pre>&#xA; * class ThreadPerTaskExecutor implements Executor {&#xA; *     public void execute(Runnable r) {&#xA; *         new Thread(r).start();&#xA; *     }&#xA; * }&lt;/pre>&#xA; *&#xA; * Many &lt;tt>Executor&lt;/tt> implementations impose some sort of&#xA; * limitation on how and when tasks are scheduled.  The executor below&#xA; * serializes the submission of tasks to a second executor,&#xA; * illustrating a composite executor.&#xA; *&#xA; * &lt;pre>&#xA; * class SerialExecutor implements Executor {&#xA; *     final Queue&amp;lt;Runnable&amp;gt; tasks = new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;();&#xA; *     final Executor executor;&#xA; *     Runnable active;&#xA; *&#xA; *     SerialExecutor(Executor executor) {&#xA; *         this.executor = executor;&#xA; *     }&#xA; *&#xA; *     public synchronized void execute(final Runnable r) {&#xA; *         tasks.offer(new Runnable() {&#xA; *             public void run() {&#xA; *                 try {&#xA; *                     r.run();&#xA; *                 } finally {&#xA; *                     scheduleNext();&#xA; *                 }&#xA; *             }&#xA; *         });&#xA; *         if (active == null) {&#xA; *             scheduleNext();&#xA; *         }&#xA; *     }&#xA; *&#xA; *     protected synchronized void scheduleNext() {&#xA; *         if ((active = tasks.poll()) != null) {&#xA; *             executor.execute(active);&#xA; *         }&#xA; *     }&#xA; * }&lt;/pre>&#xA; *&#xA; * The &lt;tt>Executor&lt;/tt> implementations provided in this package&#xA; * implement {@link ExecutorService}, which is a more extensive&#xA; * interface.  The {@link ThreadPoolExecutor} class provides an&#xA; * extensible thread pool implementation. The {@link Executors} class&#xA; * provides convenient factory methods for these Executors.&#xA; *&#xA; * @since 1.5&#xA; * @author Doug Lea&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
