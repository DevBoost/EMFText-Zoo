<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="ConcurrentMap.java">
  <comments>/*&#xA; * @(#)ConcurrentMap.java&#x9;1.6 04/07/12&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <namespaces>concurrent</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../Map.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="ConcurrentMap">
    <typeParameters name="K"/>
    <typeParameters name="V"/>
    <members xsi:type="members:InterfaceMethod" name="putIfAbsent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.1">
          <comments>/**&#xA;     * If the specified key is not already associated&#xA;     * with a value, associate it with the given value.&#xA;     * This is equivalent to&#xA;     * &lt;pre>&#xA;     *   if (!map.containsKey(key)) &#xA;     *      return map.put(key, value);&#xA;     *   else&#xA;     *      return map.get(key);&#xA;     * &lt;/pre>&#xA;     * Except that the action is performed atomically.&#xA;     * @param key key with which the specified value is to be associated.&#xA;     * @param value value to be associated with the specified key.&#xA;     * @return previous value associated with specified key, or &lt;tt>null&lt;/tt>&#xA;     *         if there was no mapping for key.  A &lt;tt>null&lt;/tt> return can&#xA;     *         also indicate that the map previously associated &lt;tt>null&lt;/tt>&#xA;     *         with the specified key, if the implementation supports&#xA;     *         &lt;tt>null&lt;/tt> values.&#xA;     *&#xA;     * @throws UnsupportedOperationException if the &lt;tt>put&lt;/tt> operation is&#xA;     *            not supported by this map.&#xA;     * @throws ClassCastException if the class of the specified key or value&#xA;     *            prevents it from being stored in this map.&#xA;     * @throws IllegalArgumentException if some aspect of this key or value&#xA;     *            prevents it from being stored in this map.&#xA;     * @throws NullPointerException if this map does not permit &lt;tt>null&lt;/tt>&#xA;     *            keys or values, and the specified key or value is&#xA;     *            &lt;tt>null&lt;/tt>.&#xA;     *&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="remove">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Remove entry for key only if currently mapped to given value.&#xA;     * Acts as&#xA;     * &lt;pre> &#xA;     *  if ((map.containsKey(key) &amp;&amp; map.get(key).equals(value)) {&#xA;     *     map.remove(key);&#xA;     *     return true;&#xA;     * } else return false;&#xA;     * &lt;/pre>&#xA;     * except that the action is performed atomically.&#xA;     * @param key key with which the specified value is associated.&#xA;     * @param value value associated with the specified key.&#xA;     * @return true if the value was removed, false otherwise&#xA;     * @throws UnsupportedOperationException if the &lt;tt>remove&lt;/tt> operation is&#xA;     *            not supported by this map.&#xA;     * @throws NullPointerException if this map does not permit &lt;tt>null&lt;/tt>&#xA;     *            keys or values, and the specified key or value is&#xA;     *            &lt;tt>null&lt;/tt>.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="replace">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Replace entry for key only if currently mapped to given value.&#xA;     * Acts as&#xA;     * &lt;pre> &#xA;     *  if ((map.containsKey(key) &amp;&amp; map.get(key).equals(oldValue)) {&#xA;     *     map.put(key, newValue);&#xA;     *     return true;&#xA;     * } else return false;&#xA;     * &lt;/pre>&#xA;     * except that the action is performed atomically.&#xA;     * @param key key with which the specified value is associated.&#xA;     * @param oldValue value expected to be associated with the specified key.&#xA;     * @param newValue value to be associated with the specified key.&#xA;     * @return true if the value was replaced&#xA;     * @throws UnsupportedOperationException if the &lt;tt>put&lt;/tt> operation is&#xA;     *            not supported by this map.&#xA;     * @throws NullPointerException if this map does not permit &lt;tt>null&lt;/tt>&#xA;     *            keys or values, and the specified key or value is&#xA;     *            &lt;tt>null&lt;/tt>.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="oldValue">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newValue">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="replace">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.1">
          <comments>/**&#xA;     * Replace entry for key only if currently mapped to some value.&#xA;     * Acts as&#xA;     * &lt;pre> &#xA;     *  if ((map.containsKey(key)) {&#xA;     *     return map.put(key, value);&#xA;     * } else return null;&#xA;     * &lt;/pre>&#xA;     * except that the action is performed atomically.&#xA;     * @param key key with which the specified value is associated.&#xA;     * @param value value to be associated with the specified key.&#xA;     * @return previous value associated with specified key, or &lt;tt>null&lt;/tt>&#xA;     *         if there was no mapping for key.  A &lt;tt>null&lt;/tt> return can&#xA;     *         also indicate that the map previously associated &lt;tt>null&lt;/tt>&#xA;     *         with the specified key, if the implementation supports&#xA;     *         &lt;tt>null&lt;/tt> values.&#xA;     * @throws UnsupportedOperationException if the &lt;tt>put&lt;/tt> operation is&#xA;     *            not supported by this map.&#xA;     * @throws NullPointerException if this map does not permit &lt;tt>null&lt;/tt>&#xA;     *            keys or values, and the specified key or value is&#xA;     *            &lt;tt>null&lt;/tt>.&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
        </typeReference>
      </parameters>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A {@link java.util.Map} providing additional atomic&#xA; * &lt;tt>putIfAbsent&lt;/tt>, &lt;tt>remove&lt;/tt>, and &lt;tt>replace&lt;/tt> methods.&#xA; *&#xA; * &lt;p>This interface is a member of the&#xA; * &lt;a href=&quot;{@docRoot}/../guide/collections/index.html&quot;>&#xA; * Java Collections Framework&lt;/a>.&#xA; *  &#xA; * @since 1.5&#xA; * @author Doug Lea&#xA; * @param &lt;K> the type of keys maintained by this map&#xA; * @param &lt;V> the type of mapped values &#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="../Map.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
