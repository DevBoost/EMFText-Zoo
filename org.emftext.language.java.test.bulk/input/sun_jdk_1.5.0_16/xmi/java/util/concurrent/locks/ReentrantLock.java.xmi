<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../../java.ecore#/5 http://www.emftext.org/java/generics ../../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../../java.ecore#/9 http://www.emftext.org/java/members ../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../../java.ecore#/13 http://www.emftext.org/java/references ../../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../../java.ecore#/15 http://www.emftext.org/java/types ../../../../java.ecore#/16" name="ReentrantLock.java">
  <comments>/*&#xA; * @(#)ReentrantLock.java&#x9;1.7 04/07/13&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <namespaces>concurrent</namespaces>
  <namespaces>locks</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <namespaces>concurrent</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <namespaces>concurrent</namespaces>
    <namespaces>atomic</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="ReentrantLock">
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="7373984872572414699"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="sync">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.2"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** Synchronizer providing all implementation mechanics */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="classifiers:Class" name="Sync">
      <members xsi:type="members:Field" name="owner">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Transient">
          <comments>/** Current owner thread */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:InterfaceMethod" name="lock">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Abstract">
          <comments>/**&#xA;         * Perform {@link Lock#lock}. The main reason for subclassing&#xA;         * is to allow fast path for nonfair version.&#xA;         */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:ClassMethod" name="nonfairTryAcquire">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="acquires">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Final">
          <comments>/** &#xA;         * Perform non-fair tryLock.  tryAcquire is&#xA;         * implemented in subclasses, but both need nonfair&#xA;         * try for trylock method&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="current">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
            </initialValue>
            <annotationsAndModifiers xsi:type="modifiers:Final"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="c">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.0"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.2/@statements.0/@variable"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
                </statements>
              </statement>
              <condition xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.13"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.2/@parameters.0"/>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.2/@statements.1/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </condition>
          <elseStatement xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.12"/>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.2/@statements.1/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.2/@parameters.0"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </expression>
              </statements>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.2/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.0"/>
            </condition>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="tryRelease">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="releases">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="c">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.3/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../lang/IllegalMonitorStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.0"/>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="free">
            <typeReference xsi:type="types:Boolean"/>
            <initialValue xsi:type="literals:BooleanLiteral"/>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.3/@statements.2/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral" value="true"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.0"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:NullLiteral"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.3/@statements.0/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.12"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.3/@statements.0/@variable"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.3/@statements.2/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="isHeldExclusively">
        <typeReference xsi:type="types:Boolean"/>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.0"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </children>
            </children>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="newCondition">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getOwner">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final">
          <comments>// Methods relayed from outer class</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="c">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="o">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.6/@statements.0/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </expression>
            </child>
            <expressionIf xsi:type="literals:NullLiteral"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.6/@statements.1/@variable"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getHoldCount">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="c">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="o">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.7/@statements.1/@variable"/>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
                </children>
              </expression>
            </child>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.7/@statements.0/@variable"/>
            <expressionElse xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="isLocked">
        <typeReference xsi:type="types:Boolean"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="readObject">
        <comments>// reset to unlocked state</comments>
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <namespaces>java</namespaces>
            <namespaces>io</namespaces>
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../io/ObjectInputStream.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <exceptions>
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../io/IOException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/ClassNotFoundException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>/**&#xA;         * Reconstitute this lock instance from a stream&#xA;         * @param s the stream&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.9/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../io/ObjectInputStream.class.xmi#//@classifiers.0/@members.19"/>
            </next>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.12"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </expression>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Base of synchronization control for this lock. Subclassed&#xA;     * into fair and nonfair versions below. Uses AQS state to&#xA;     * represent the number of holds on the lock.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="NonfairSync">
      <members xsi:type="members:ClassMethod" name="lock">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Final">
          <comments>/**&#xA;         * Perform lock.  Try immediate barge, backing up to normal&#xA;         * acquire on failure.&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statement>
          <condition xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.13"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </condition>
          <elseStatement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.34"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </expression>
          </elseStatement>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="tryAcquire">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="acquires">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.2/@members.2">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@members.1/@parameters.0"/>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Sync object for non-fair locks&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.2"/>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="FairSync">
      <members xsi:type="members:ClassMethod" name="lock">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.34"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="tryAcquire">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="acquires">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected">
          <comments>/**&#xA;         * Fair version of tryAcquire.  Don't grant access unless&#xA;         * recursive call or no waiters or is first.&#xA;         */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="current">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
            </initialValue>
            <annotationsAndModifiers xsi:type="modifiers:Final"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="c">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="first">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <initialValue xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.44"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.0"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@members.1/@statements.0/@variable"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
                </statements>
              </statement>
              <condition xsi:type="expressions:ConditionalAndExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ConditionalOrExpression">
                    <children xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@members.1/@statements.2/@statement/@statements.0/@variable"/>
                      <children xsi:type="literals:NullLiteral"/>
                    </children>
                    <children xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@members.1/@statements.2/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@members.1/@statements.0/@variable"/>
                    </children>
                  </expression>
                </children>
                <children xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.13"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@members.1/@parameters.0"/>
                </children>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@members.1/@statements.1/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </condition>
          <elseStatement xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.12"/>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@members.1/@statements.1/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@members.1/@parameters.0"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </expression>
              </statements>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@members.1/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@members.0"/>
            </condition>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Sync object for fair locks&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.2"/>
      </extends>
    </members>
    <members xsi:type="members:Constructor" name="ReentrantLock">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.3"/>
            </typeReference>
          </value>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an instance of &lt;tt>ReentrantLock&lt;/tt>.&#xA;     * This is equivalent to using &lt;tt>ReentrantLock(false)&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="ReentrantLock">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
            </child>
            <expressionIf xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.4"/>
              </typeReference>
            </expressionIf>
            <expressionElse xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.3"/>
              </typeReference>
            </expressionElse>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fair">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an instance of &lt;tt>ReentrantLock&lt;/tt> with the&#xA;     * given fairness policy.&#xA;     * @param fair true if this lock will be fair; else false&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="lock">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Acquires the lock. &#xA;     *&#xA;     * &lt;p>Acquires the lock if it is not held by another thread and returns &#xA;     * immediately, setting the lock hold count to one.&#xA;     *&#xA;     * &lt;p>If the current thread&#xA;     * already holds the lock then the hold count is incremented by one and&#xA;     * the method returns immediately.&#xA;     *&#xA;     * &lt;p>If the lock is held by another thread then the&#xA;     * current thread becomes disabled for thread scheduling &#xA;     * purposes and lies dormant until the lock has been acquired,&#xA;     * at which time the lock hold count is set to one. &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2/@members.1"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lockInterruptibly">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Acquires the lock unless the current thread is &#xA;     * {@link Thread#interrupt interrupted}.&#xA;     *&#xA;     * &lt;p>Acquires the lock if it is not held by another thread and returns &#xA;     * immediately, setting the lock hold count to one.&#xA;     *&#xA;     * &lt;p>If the current thread already holds this lock then the hold count &#xA;     * is incremented by one and the method returns immediately.&#xA;     *&#xA;     * &lt;p>If the lock is held by another thread then the&#xA;     * current thread becomes disabled for thread scheduling &#xA;     * purposes and lies dormant until one of two things happens:&#xA;     *&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>The lock is acquired by the current thread; or&#xA;     *&#xA;     * &lt;li>Some other thread {@link Thread#interrupt interrupts} the current&#xA;     * thread.&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>If the lock is acquired by the current thread then the lock hold &#xA;     * count is set to one.&#xA;     *&#xA;     * &lt;p>If the current thread:&#xA;     *&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>has its interrupted status set on entry to this method; or &#xA;     *&#xA;     * &lt;li>is {@link Thread#interrupt interrupted} while acquiring &#xA;     * the lock,&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * then {@link InterruptedException} is thrown and the current thread's &#xA;     * interrupted status is cleared. &#xA;     *&#xA;     * &lt;p>In this implementation, as this method is an explicit interruption &#xA;     * point, preference is &#xA;     * given to responding to the interrupt over normal or reentrant &#xA;     * acquisition of the lock.&#xA;     *&#xA;     * @throws InterruptedException if the current thread is interrupted&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.35"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="tryLock">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Acquires the lock only if it is not held by another thread at the time&#xA;     * of invocation.&#xA;     *&#xA;     * &lt;p>Acquires the lock if it is not held by another thread and&#xA;     * returns immediately with the value &lt;tt>true&lt;/tt>, setting the&#xA;     * lock hold count to one. Even when this lock has been set to use a&#xA;     * fair ordering policy, a call to &lt;tt>tryLock()&lt;/tt> &lt;em>will&lt;/em>&#xA;     * immediately acquire the lock if it is available, whether or not&#xA;     * other threads are currently waiting for the lock. &#xA;     * This &amp;quot;barging&amp;quot; behavior can be useful in certain &#xA;     * circumstances, even though it breaks fairness. If you want to honor&#xA;     * the fairness setting for this lock, then use &#xA;     * {@link #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) }&#xA;     * which is almost equivalent (it also detects interruption).&#xA;     *&#xA;     * &lt;p> If the current thread&#xA;     * already holds this lock then the hold count is incremented by one and&#xA;     * the method returns &lt;tt>true&lt;/tt>.&#xA;     *&#xA;     * &lt;p>If the lock is held by another thread then this method will return &#xA;     * immediately with the value &lt;tt>false&lt;/tt>.  &#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if the lock was free and was acquired by the&#xA;     * current thread, or the lock was already held by the current thread; and&#xA;     * &lt;tt>false&lt;/tt> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2/@members.2">
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="tryLock">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeout">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="unit">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Enumeration" href="../TimeUnit.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Acquires the lock if it is not held by another thread within the given &#xA;     * waiting time and the current thread has not been &#xA;     * {@link Thread#interrupt interrupted}.&#xA;     *&#xA;     * &lt;p>Acquires the lock if it is not held by another thread and returns &#xA;     * immediately with the value &lt;tt>true&lt;/tt>, setting the lock hold count &#xA;     * to one. If this lock has been set to use a fair ordering policy then&#xA;     * an available lock &lt;em>will not&lt;/em> be acquired if any other threads&#xA;     * are waiting for the lock. This is in contrast to the {@link #tryLock()}&#xA;     * method. If you want a timed &lt;tt>tryLock&lt;/tt> that does permit barging on&#xA;     * a fair lock then combine the timed and un-timed forms together:&#xA;     *&#xA;     * &lt;pre>if (lock.tryLock() || lock.tryLock(timeout, unit) ) { ... }&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;p>If the current thread&#xA;     * already holds this lock then the hold count is incremented by one and&#xA;     * the method returns &lt;tt>true&lt;/tt>.&#xA;     *&#xA;     * &lt;p>If the lock is held by another thread then the&#xA;     * current thread becomes disabled for thread scheduling &#xA;     * purposes and lies dormant until one of three things happens:&#xA;     *&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>The lock is acquired by the current thread; or&#xA;     *&#xA;     * &lt;li>Some other thread {@link Thread#interrupt interrupts} the current&#xA;     * thread; or&#xA;     *&#xA;     * &lt;li>The specified waiting time elapses&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>If the lock is acquired then the value &lt;tt>true&lt;/tt> is returned and&#xA;     * the lock hold count is set to one.&#xA;     *&#xA;     * &lt;p>If the current thread:&#xA;     *&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>has its interrupted status set on entry to this method; or &#xA;     *&#xA;     * &lt;li>is {@link Thread#interrupt interrupted} while acquiring&#xA;     * the lock,&#xA;     *&#xA;     * &lt;/ul>&#xA;     * then {@link InterruptedException} is thrown and the current thread's &#xA;     * interrupted status is cleared. &#xA;     *&#xA;     * &lt;p>If the specified waiting time elapses then the value &lt;tt>false&lt;/tt>&#xA;     * is returned.&#xA;     * If the time is &#xA;     * less than or equal to zero, the method will not wait at all.&#xA;     *&#xA;     * &lt;p>In this implementation, as this method is an explicit interruption &#xA;     * point, preference is &#xA;     * given to responding to the interrupt over normal or reentrant &#xA;     * acquisition of the lock, and over reporting the elapse of the waiting&#xA;     * time.&#xA;     *&#xA;     * @param timeout the time to wait for the lock&#xA;     * @param unit the time unit of the timeout argument&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if the lock was free and was acquired by the&#xA;     * current thread, or the lock was already held by the current thread; and&#xA;     * &lt;tt>false&lt;/tt> if the waiting time elapsed before the lock could be &#xA;     * acquired.&#xA;     *&#xA;     * @throws InterruptedException if the current thread is interrupted&#xA;     * @throws NullPointerException if unit is null&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.36"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../TimeUnit.class.xmi#//@classifiers.0/@members.9"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
              </next>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="unlock">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Attempts to release this lock.  &#xA;     *&#xA;     * &lt;p>If the current thread is the&#xA;     * holder of this lock then the hold count is decremented. If the&#xA;     * hold count is now zero then the lock is released.  If the&#xA;     * current thread is not the holder of this lock then {@link&#xA;     * IllegalMonitorStateException} is thrown.&#xA;     * @throws IllegalMonitorStateException if the current thread does not&#xA;     * hold this lock.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.37"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newCondition">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Condition.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a {@link Condition} instance for use with this &#xA;     * {@link Lock} instance.&#xA;     *&#xA;     * &lt;p>The returned {@link Condition} instance supports the same&#xA;     * usages as do the {@link Object} monitor methods ({@link&#xA;     * Object#wait() wait}, {@link Object#notify notify}, and {@link&#xA;     * Object#notifyAll notifyAll}) when used with the built-in&#xA;     * monitor lock.&#xA;     *&#xA;     * &lt;ul>&#xA;     *&#xA;     * &lt;li>If this lock is not held when any of the {@link Condition}&#xA;     * {@link Condition#await() waiting} or {@link Condition#signal&#xA;     * signalling} methods are called, then an {@link&#xA;     * IllegalMonitorStateException} is thrown.&#xA;     *&#xA;     * &lt;li>When the condition {@link Condition#await() waiting}&#xA;     * methods are called the lock is released and, before they&#xA;     * return, the lock is reacquired and the lock hold count restored&#xA;     * to what it was when the method was called.&#xA;     *&#xA;     * &lt;li>If a thread is {@link Thread#interrupt interrupted} while&#xA;     * waiting then the wait will terminate, an {@link&#xA;     * InterruptedException} will be thrown, and the thread's&#xA;     * interrupted status will be cleared.&#xA;     *&#xA;     * &lt;li> Waiting threads are signalled in FIFO order&#xA;     *&#xA;     * &lt;li>The ordering of lock reacquisition for threads returning&#xA;     * from waiting methods is the same as for threads initially&#xA;     * acquiring the lock, which is in the default case not specified,&#xA;     * but for &lt;em>fair&lt;/em> locks favors those threads that have been&#xA;     * waiting the longest.&#xA;     * &#xA;     * &lt;/ul>&#xA;     *&#xA;     * @return the Condition object&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2/@members.5"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getHoldCount">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Queries the number of holds on this lock by the current thread.&#xA;     *&#xA;     * &lt;p>A thread has a hold on a lock for each lock action that is not &#xA;     * matched by an unlock action.&#xA;     *&#xA;     * &lt;p>The hold count information is typically only used for testing and&#xA;     * debugging purposes. For example, if a certain section of code should&#xA;     * not be entered with the lock already held then we can assert that&#xA;     * fact:&#xA;     *&#xA;     * &lt;pre>&#xA;     * class X {&#xA;     *   ReentrantLock lock = new ReentrantLock();&#xA;     *   // ...     &#xA;     *   public void m() { &#xA;     *     assert lock.getHoldCount() == 0;&#xA;     *     lock.lock();&#xA;     *     try {&#xA;     *       // ... method body&#xA;     *     } finally {&#xA;     *       lock.unlock();&#xA;     *     }&#xA;     *   }&#xA;     * }&#xA;     * &lt;/pre>&#xA;     *&#xA;     * @return the number of holds on this lock by the current thread,&#xA;     * or zero if this lock is not held by the current thread.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2/@members.7"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isHeldByCurrentThread">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Queries if this lock is held by the current thread.&#xA;     *&#xA;     * &lt;p>Analogous to the {@link Thread#holdsLock} method for built-in&#xA;     * monitor locks, this method is typically used for debugging and&#xA;     * testing. For example, a method that should only be called while&#xA;     * a lock is held can assert that this is the case:&#xA;     *&#xA;     * &lt;pre>&#xA;     * class X {&#xA;     *   ReentrantLock lock = new ReentrantLock();&#xA;     *   // ...&#xA;     *&#xA;     *   public void m() { &#xA;     *       assert lock.isHeldByCurrentThread();&#xA;     *       // ... method body&#xA;     *   }&#xA;     * }&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;p>It can also be used to ensure that a reentrant lock is used&#xA;     * in a non-reentrant manner, for example:&#xA;     *&#xA;     * &lt;pre>&#xA;     * class X {&#xA;     *   ReentrantLock lock = new ReentrantLock();&#xA;     *   // ...&#xA;     *&#xA;     *   public void m() { &#xA;     *       assert !lock.isHeldByCurrentThread();&#xA;     *       lock.lock();&#xA;     *       try {&#xA;     *           // ... method body&#xA;     *       } finally {&#xA;     *           lock.unlock();&#xA;     *       }&#xA;     *   }&#xA;     * }&#xA;     * &lt;/pre>&#xA;     * @return &lt;tt>true&lt;/tt> if current thread holds this lock and &#xA;     * &lt;tt>false&lt;/tt> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2/@members.4"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isLocked">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Queries if this lock is held by any thread. This method is&#xA;     * designed for use in monitoring of the system state, &#xA;     * not for synchronization control.&#xA;     * @return &lt;tt>true&lt;/tt> if any thread holds this lock and &#xA;     * &lt;tt>false&lt;/tt> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2/@members.8"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isFair">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns true if this lock has fairness set true.&#xA;     * @return true if this lock has fairness set true.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.4"/>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getOwner">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns the thread that currently owns this lock, or&#xA;     * &lt;tt>null&lt;/tt> if not owned. Note that the owner may be&#xA;     * momentarily &lt;tt>null&lt;/tt> even if there are threads trying to&#xA;     * acquire the lock but have not yet done so.  This method is&#xA;     * designed to facilitate construction of subclasses that provide&#xA;     * more extensive lock monitoring facilities.&#xA;     * @return the owner, or &lt;tt>null&lt;/tt> if not owned.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2/@members.6"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hasQueuedThreads">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Queries whether any threads are waiting to acquire this lock. Note that&#xA;     * because cancellations may occur at any time, a &lt;tt>true&lt;/tt>&#xA;     * return does not guarantee that any other thread will ever&#xA;     * acquire this lock.  This method is designed primarily for use in&#xA;     * monitoring of the system state.&#xA;     *&#xA;     * @return true if there may be other threads waiting to acquire&#xA;     * the lock.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.42"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hasQueuedThread">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="thread">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Queries whether the given thread is waiting to acquire this&#xA;     * lock. Note that because cancellations may occur at any time, a&#xA;     * &lt;tt>true&lt;/tt> return does not guarantee that this thread&#xA;     * will ever acquire this lock.  This method is designed primarily for use&#xA;     * in monitoring of the system state.&#xA;     *&#xA;     * @param thread the thread&#xA;     * @return true if the given thread is queued waiting for this lock.&#xA;     * @throws NullPointerException if thread is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.46"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getQueueLength">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an estimate of the number of threads waiting to&#xA;     * acquire this lock.  The value is only an estimate because the number of&#xA;     * threads may change dynamically while this method traverses&#xA;     * internal data structures.  This method is designed for use in&#xA;     * monitoring of the system state, not for synchronization&#xA;     * control.&#xA;     * @return the estimated number of threads waiting for this lock&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.47"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getQueuedThreads">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns a collection containing threads that may be waiting to&#xA;     * acquire this lock.  Because the actual set of threads may change&#xA;     * dynamically while constructing this result, the returned&#xA;     * collection is only a best-effort estimate.  The elements of the&#xA;     * returned collection are in no particular order.  This method is&#xA;     * designed to facilitate construction of subclasses that provide&#xA;     * more extensive monitoring facilities.&#xA;     * @return the collection of threads&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.48"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hasWaiters">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="condition">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Condition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Queries whether any threads are waiting on the given condition&#xA;     * associated with this lock. Note that because timeouts and&#xA;     * interrupts may occur at any time, a &lt;tt>true&lt;/tt> return does&#xA;     * not guarantee that a future &lt;tt>signal&lt;/tt> will awaken any&#xA;     * threads.  This method is designed primarily for use in&#xA;     * monitoring of the system state.&#xA;     * @param condition the condition&#xA;     * @return &lt;tt>true&lt;/tt> if there are any waiting threads.&#xA;     * @throws IllegalMonitorStateException if this lock &#xA;     * is not held&#xA;     * @throws IllegalArgumentException if the given condition is&#xA;     * not associated with this lock&#xA;     * @throws NullPointerException if condition null&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="not owner"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>AbstractQueuedSynchronizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.58"/>
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>AbstractQueuedSynchronizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getWaitQueueLength">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="condition">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Condition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an estimate of the number of threads waiting on the&#xA;     * given condition associated with this lock. Note that because&#xA;     * timeouts and interrupts may occur at any time, the estimate&#xA;     * serves only as an upper bound on the actual number of waiters.&#xA;     * This method is designed for use in monitoring of the system&#xA;     * state, not for synchronization control.&#xA;     * @param condition the condition&#xA;     * @return the estimated number of waiting threads.&#xA;     * @throws IllegalMonitorStateException if this lock &#xA;     * is not held&#xA;     * @throws IllegalArgumentException if the given condition is&#xA;     * not associated with this lock&#xA;     * @throws NullPointerException if condition null&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="not owner"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>AbstractQueuedSynchronizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.59"/>
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>AbstractQueuedSynchronizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getWaitingThreads">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="condition">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Condition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns a collection containing those threads that may be&#xA;     * waiting on the given condition associated with this lock.&#xA;     * Because the actual set of threads may change dynamically while&#xA;     * constructing this result, the returned collection is only a&#xA;     * best-effort estimate. The elements of the returned collection&#xA;     * are in no particular order.  This method is designed to&#xA;     * facilitate construction of subclasses that provide more&#xA;     * extensive condition monitoring facilities.&#xA;     * @param condition the condition&#xA;     * @return the collection of threads&#xA;     * @throws IllegalMonitorStateException if this lock &#xA;     * is not held&#xA;     * @throws IllegalArgumentException if the given condition is&#xA;     * not associated with this lock&#xA;     * @throws NullPointerException if condition null&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="not owner"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>AbstractQueuedSynchronizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.60"/>
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>AbstractQueuedSynchronizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string identifying this lock, as well as its lock&#xA;     * state.  The state, in brackets, includes either the String&#xA;     * &amp;quot;Unlocked&amp;quot; or the String &amp;quot;Locked by&amp;quot;&#xA;     * followed by the {@link Thread#getName} of the owning thread.&#xA;     * @return a string identifying this lock, as well as its lock state.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="owner">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2/@members.6"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../lang/Object.class.xmi#//@classifiers.0/@members.6"/>
            </next>
            <self xsi:type="literals:Super"/>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalExpression">
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable"/>
                  <children xsi:type="literals:NullLiteral"/>
                </expression>
              </child>
              <expressionIf xsi:type="references:StringReference" value="[Unlocked]"/>
              <expressionElse xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="[Locked by thread "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.63"/>
                  </next>
                </children>
                <children xsi:type="references:StringReference" value="]"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </expressionElse>
            </expression>
          </children>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A reentrant mutual exclusion {@link Lock} with the same basic&#xA; * behavior and semantics as the implicit monitor lock accessed using&#xA; * &lt;tt>synchronized&lt;/tt> methods and statements, but with extended&#xA; * capabilities.&#xA; *&#xA; * &lt;p> A &lt;tt>ReentrantLock&lt;/tt> is &lt;em>owned&lt;/em> by the thread last&#xA; * successfully locking, but not yet unlocking it. A thread invoking&#xA; * &lt;tt>lock&lt;/tt> will return, successfully acquiring the lock, when&#xA; * the lock is not owned by another thread. The method will return&#xA; * immediately if the current thread already owns the lock. This can&#xA; * be checked using methods {@link #isHeldByCurrentThread}, and {@link&#xA; * #getHoldCount}.  &#xA; *&#xA; * &lt;p> The constructor for this class accepts an optional&#xA; * &lt;em>fairness&lt;/em> parameter.  When set &lt;tt>true&lt;/tt>, under&#xA; * contention, locks favor granting access to the longest-waiting&#xA; * thread.  Otherwise this lock does not guarantee any particular&#xA; * access order.  Programs using fair locks accessed by many threads&#xA; * may display lower overall throughput (i.e., are slower; often much&#xA; * slower) than those using the default setting, but have smaller&#xA; * variances in times to obtain locks and guarantee lack of&#xA; * starvation. Note however, that fairness of locks does not guarantee&#xA; * fairness of thread scheduling. Thus, one of many threads using a&#xA; * fair lock may obtain it multiple times in succession while other&#xA; * active threads are not progressing and not currently holding the&#xA; * lock.&#xA; * Also note that the untimed {@link #tryLock() tryLock} method does not&#xA; * honor the fairness setting. It will succeed if the lock&#xA; * is available even if other threads are waiting.&#xA; *&#xA; * &lt;p> It is recommended practice to &lt;em>always&lt;/em> immediately&#xA; * follow a call to &lt;tt>lock&lt;/tt> with a &lt;tt>try&lt;/tt> block, most&#xA; * typically in a before/after construction such as:&#xA; *&#xA; * &lt;pre>&#xA; * class X {&#xA; *   private final ReentrantLock lock = new ReentrantLock();&#xA; *   // ...&#xA; *&#xA; *   public void m() { &#xA; *     lock.lock();  // block until condition holds&#xA; *     try {&#xA; *       // ... method body&#xA; *     } finally {&#xA; *       lock.unlock()&#xA; *     }&#xA; *   }&#xA; * }&#xA; * &lt;/pre>&#xA; *&#xA; * &lt;p>In addition to implementing the {@link Lock} interface, this&#xA; * class defines methods &lt;tt>isLocked&lt;/tt> and&#xA; * &lt;tt>getLockQueueLength&lt;/tt>, as well as some associated&#xA; * &lt;tt>protected&lt;/tt> access methods that may be useful for&#xA; * instrumentation and monitoring.&#xA; *&#xA; * &lt;p> Serialization of this class behaves in the same way as built-in&#xA; * locks: a deserialized lock is in the unlocked state, regardless of&#xA; * its state when serialized.&#xA; *&#xA; * &lt;p> This lock supports a maximum of 2147483648 recursive locks by&#xA; * the same thread. &#xA; *&#xA; * @since 1.5&#xA; * @author Doug Lea&#xA; * &#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Lock.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <namespaces>java</namespaces>
      <namespaces>io</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../../io/Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
