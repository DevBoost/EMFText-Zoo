<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../../java.ecore#/7 http://www.emftext.org/java/members ../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../../java.ecore#/13 http://www.emftext.org/java/types ../../../../java.ecore#/16" name="Lock.java">
  <comments>/*&#xA; * @(#)Lock.java&#x9;1.4 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <namespaces>concurrent</namespaces>
  <namespaces>locks</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <namespaces>concurrent</namespaces>
    <classifier xsi:type="classifiers:Enumeration" href="../TimeUnit.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="Lock">
    <members xsi:type="members:InterfaceMethod" name="lock">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Acquires the lock.&#xA;     * &lt;p>If the lock is not available then&#xA;     * the current thread becomes disabled for thread scheduling &#xA;     * purposes and lies dormant until the lock has been acquired.&#xA;     * &lt;p>&lt;b>Implementation Considerations&lt;/b>&#xA;     * &lt;p>A &lt;tt>Lock&lt;/tt> implementation may be able to detect &#xA;     * erroneous use of the lock, such as an invocation that would cause &#xA;     * deadlock, and may throw an (unchecked) exception in such circumstances. &#xA;     * The circumstances and the exception type must be documented by that &#xA;     * &lt;tt>Lock&lt;/tt> implementation.&#xA;     *&#xA;     **/</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="lockInterruptibly">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Acquires the lock unless the current thread is  &#xA;     * {@link Thread#interrupt interrupted}. &#xA;     * &lt;p>Acquires the lock if it is available and returns immediately.&#xA;     * &lt;p>If the lock is not available then&#xA;     * the current thread becomes disabled for thread scheduling &#xA;     * purposes and lies dormant until one of two things happens:&#xA;     * &lt;ul>&#xA;     * &lt;li>The lock is acquired by the current thread; or&#xA;     * &lt;li>Some other thread {@link Thread#interrupt interrupts} the current&#xA;     * thread, and interruption of lock acquisition is supported.&#xA;     * &lt;/ul>&#xA;     * &lt;p>If the current thread:&#xA;     * &lt;ul>&#xA;     * &lt;li>has its interrupted status set on entry to this method; or &#xA;     * &lt;li>is {@link Thread#interrupt interrupted} while acquiring &#xA;     * the lock, and interruption of lock acquisition is supported, &#xA;     * &lt;/ul>&#xA;     * then {@link InterruptedException} is thrown and the current thread's &#xA;     * interrupted status is cleared. &#xA;     *&#xA;     * &lt;p>&lt;b>Implementation Considerations&lt;/b>&#xA;     *&#xA;     * &lt;p>The ability to interrupt a lock acquisition in some&#xA;     * implementations may not be possible, and if possible may be an&#xA;     * expensive operation.  The programmer should be aware that this&#xA;     * may be the case. An implementation should document when this is&#xA;     * the case.&#xA;     *&#xA;     * &lt;p>An implementation can favor responding to an interrupt over&#xA;     * normal method return.&#xA;     *&#xA;     * &lt;p>A &lt;tt>Lock&lt;/tt> implementation may be able to detect&#xA;     * erroneous use of the lock, such as an invocation that would&#xA;     * cause deadlock, and may throw an (unchecked) exception in such&#xA;     * circumstances.  The circumstances and the exception type must&#xA;     * be documented by that &lt;tt>Lock&lt;/tt> implementation.&#xA;     *&#xA;     * @throws InterruptedException if the current thread is interrupted&#xA;     * while acquiring the lock (and interruption of lock acquisition is &#xA;     * supported).&#xA;     *&#xA;     * @see Thread#interrupt&#xA;     *&#xA;     **/</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="tryLock">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Acquires the lock only if it is free at the time of invocation.&#xA;     * &lt;p>Acquires the lock if it is available and returns immediately&#xA;     * with the value &lt;tt>true&lt;/tt>.&#xA;     * If the lock is not available then this method will return &#xA;     * immediately with the value &lt;tt>false&lt;/tt>.&#xA;     * &lt;p>A typical usage idiom for this method would be:&#xA;     * &lt;pre>&#xA;     *      Lock lock = ...;&#xA;     *      if (lock.tryLock()) {&#xA;     *          try {&#xA;     *              // manipulate protected state&#xA;     *          } finally {&#xA;     *              lock.unlock();&#xA;     *          }&#xA;     *      } else {&#xA;     *          // perform alternative actions&#xA;     *      }&#xA;     * &lt;/pre>&#xA;     * This usage ensures that the lock is unlocked if it was acquired, and&#xA;     * doesn't try to unlock if the lock was not acquired.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if the lock was acquired and &lt;tt>false&lt;/tt>&#xA;     * otherwise.&#xA;     **/</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="tryLock">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Acquires the lock if it is free within the given waiting time and the&#xA;     * current thread has not been {@link Thread#interrupt interrupted}.&#xA;     *&#xA;     * &lt;p>If the lock is available this method returns immediately&#xA;     * with the value &lt;tt>true&lt;/tt>.&#xA;     * If the lock is not available then&#xA;     * the current thread becomes disabled for thread scheduling &#xA;     * purposes and lies dormant until one of three things happens:&#xA;     * &lt;ul>&#xA;     * &lt;li>The lock is acquired by the current thread; or&#xA;     * &lt;li>Some other thread {@link Thread#interrupt interrupts} the current&#xA;     * thread, and interruption of lock acquisition is supported; or&#xA;     * &lt;li>The specified waiting time elapses&#xA;     * &lt;/ul>&#xA;     * &lt;p>If the lock is acquired then the value &lt;tt>true&lt;/tt> is returned.&#xA;     * &lt;p>If the current thread:&#xA;     * &lt;ul>&#xA;     * &lt;li>has its interrupted status set on entry to this method; or &#xA;     * &lt;li>is {@link Thread#interrupt interrupted} while acquiring &#xA;     * the lock, and interruption of lock acquisition is supported, &#xA;     * &lt;/ul>&#xA;     * then {@link InterruptedException} is thrown and the current thread's &#xA;     * interrupted status is cleared. &#xA;     * &lt;p>If the specified waiting time elapses then the value &lt;tt>false&lt;/tt>&#xA;     * is returned.&#xA;     * If the time is &#xA;     * less than or equal to zero, the method will not wait at all.&#xA;     *&#xA;     * &lt;p>&lt;b>Implementation Considerations&lt;/b>&#xA;     * &lt;p>The ability to interrupt a lock acquisition in some implementations&#xA;     * may not be possible, and if possible may &#xA;     * be an expensive operation. &#xA;     * The programmer should be aware that this may be the case. An&#xA;     * implementation should document when this is the case.&#xA;     * &lt;p>An implementation can favor responding to an interrupt over normal &#xA;     * method return, or reporting a timeout.&#xA;     * &lt;p>A &lt;tt>Lock&lt;/tt> implementation may be able to detect &#xA;     * erroneous use of the lock, such as an invocation that would cause &#xA;     * deadlock, and may throw an (unchecked) exception in such circumstances. &#xA;     * The circumstances and the exception type must be documented by that &#xA;     * &lt;tt>Lock&lt;/tt> implementation.&#xA;     *&#xA;     * @param time the maximum time to wait for the lock&#xA;     * @param unit the time unit of the &lt;tt>time&lt;/tt> argument.&#xA;     * @return &lt;tt>true&lt;/tt> if the lock was acquired and &lt;tt>false&lt;/tt>&#xA;     * if the waiting time elapsed before the lock was acquired.&#xA;     *&#xA;     * @throws InterruptedException if the current thread is interrupted&#xA;     * while acquiring the lock (and interruption of lock acquisition is &#xA;     * supported).&#xA;     *&#xA;     * @see Thread#interrupt&#xA;     *&#xA;     **/</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="time">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="unit">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Enumeration" href="../TimeUnit.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="unlock">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Releases the lock.&#xA;     * &lt;p>&lt;b>Implementation Considerations&lt;/b>&#xA;     * &lt;p>A &lt;tt>Lock&lt;/tt> implementation will usually impose&#xA;     * restrictions on which thread can release a lock (typically only the&#xA;     * holder of the lock can release it) and may throw&#xA;     * an (unchecked) exception if the restriction is violated.&#xA;     * Any restrictions and the exception&#xA;     * type must be documented by that &lt;tt>Lock&lt;/tt> implementation.&#xA;     **/</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="newCondition">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns a new {@link Condition} instance that is bound to this &#xA;     * &lt;tt>Lock&lt;/tt> instance.&#xA;     * &lt;p>Before waiting on the condition the lock must be held by the &#xA;     * current thread. &#xA;     * A call to {@link Condition#await()} will atomically release the lock &#xA;     * before waiting and re-acquire the lock before the wait returns.&#xA;     * &lt;p>&lt;b>Implementation Considerations&lt;/b>&#xA;     * &lt;p>The exact operation of the {@link Condition} instance depends on the&#xA;     * &lt;tt>Lock&lt;/tt> implementation and must be documented by that&#xA;     * implementation.&#xA;     * &#xA;     * @return A new {@link Condition} instance for this &lt;tt>Lock&lt;/tt> &#xA;     * instance.&#xA;     * @throws UnsupportedOperationException if this &lt;tt>Lock&lt;/tt> &#xA;     * implementation does not support conditions.&#xA;     **/</comments>
          <target xsi:type="classifiers:Interface" href="Condition.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;tt>Lock&lt;/tt> implementations provide more extensive locking&#xA; * operations than can be obtained using &lt;tt>synchronized&lt;/tt> methods&#xA; * and statements.  They allow more flexible structuring, may have&#xA; * quite different properties, and may support multiple associated&#xA; * {@link Condition} objects.&#xA; *&#xA; * &lt;p>A lock is a tool for controlling access to a shared resource by&#xA; * multiple threads. Commonly, a lock provides exclusive access to a&#xA; * shared resource: only one thread at a time can acquire the lock and&#xA; * all access to the shared resource requires that the lock be&#xA; * acquired first. However, some locks may allow concurrent access to&#xA; * a shared resource, such as the read lock of a {@link&#xA; * ReadWriteLock}.&#xA; *&#xA; * &lt;p>The use of &lt;tt>synchronized&lt;/tt> methods or statements provides &#xA; * access to the implicit monitor lock associated with every object, but&#xA; * forces all lock acquisition and release to occur in a block-structured way:&#xA; * when multiple locks are acquired they must be released in the opposite&#xA; * order, and all locks must be released in the same lexical scope in which&#xA; * they were acquired.&#xA; *&#xA; * &lt;p>While the scoping mechanism for &lt;tt>synchronized&lt;/tt> methods&#xA; * and statements makes it much easier to program with monitor locks,&#xA; * and helps avoid many common programming errors involving locks,&#xA; * there are occasions where you need to work with locks in a more&#xA; * flexible way. For example, some algorithms for traversing&#xA; * concurrently accessed data structures require the use of&#xA; * &amp;quot;hand-over-hand&amp;quot; or &amp;quot;chain locking&amp;quot;: you&#xA; * acquire the lock of node A, then node B, then release A and acquire&#xA; * C, then release B and acquire D and so on.  Implementations of the&#xA; * &lt;tt>Lock&lt;/tt> interface enable the use of such techniques by&#xA; * allowing a lock to be acquired and released in different scopes,&#xA; * and allowing multiple locks to be acquired and released in any&#xA; * order.&#xA; *&#xA; * &lt;p>With this increased flexibility comes additional&#xA; * responsibility. The absence of block-structured locking removes the&#xA; * automatic release of locks that occurs with &lt;tt>synchronized&lt;/tt>&#xA; * methods and statements. In most cases, the following idiom&#xA; * should be used:&#xA; *&#xA; * &lt;pre>&lt;tt>     Lock l = ...; &#xA; *     l.lock();&#xA; *     try {&#xA; *         // access the resource protected by this lock&#xA; *     } finally {&#xA; *         l.unlock();&#xA; *     }&#xA; * &lt;/tt>&lt;/pre>&#xA; *&#xA; * When locking and unlocking occur in different scopes, care must be&#xA; * taken to ensure that all code that is executed while the lock is&#xA; * held is protected by try-finally or try-catch to ensure that the&#xA; * lock is released when necessary.&#xA; *&#xA; * &lt;p>&lt;tt>Lock&lt;/tt> implementations provide additional functionality&#xA; * over the use of &lt;tt>synchronized&lt;/tt> methods and statements by&#xA; * providing a non-blocking attempt to acquire a lock ({@link&#xA; * #tryLock()}), an attempt to acquire the lock that can be&#xA; * interrupted ({@link #lockInterruptibly}, and an attempt to acquire&#xA; * the lock that can timeout ({@link #tryLock(long, TimeUnit)}).&#xA; *&#xA; * &lt;p>A &lt;tt>Lock&lt;/tt> class can also provide behavior and semantics&#xA; * that is quite different from that of the implicit monitor lock,&#xA; * such as guaranteed ordering, non-reentrant usage, or deadlock&#xA; * detection. If an implementation provides such specialized semantics&#xA; * then the implementation must document those semantics.&#xA; *&#xA; * &lt;p>Note that &lt;tt>Lock&lt;/tt> instances are just normal objects and can &#xA; * themselves be used as the target in a &lt;tt>synchronized&lt;/tt> statement.&#xA; * Acquiring the&#xA; * monitor lock of a &lt;tt>Lock&lt;/tt> instance has no specified relationship&#xA; * with invoking any of the {@link #lock} methods of that instance. &#xA; * It is recommended that to avoid confusion you never use &lt;tt>Lock&lt;/tt>&#xA; * instances in this way, except within their own implementation.&#xA; *&#xA; * &lt;p>Except where noted, passing a &lt;tt>null&lt;/tt> value for any&#xA; * parameter will result in a {@link NullPointerException} being&#xA; * thrown.&#xA; *&#xA; * &lt;h3>Memory Synchronization&lt;/h3>&#xA; * &lt;p>All &lt;tt>Lock&lt;/tt> implementations &lt;em>must&lt;/em> enforce the same&#xA; * memory synchronization semantics as provided by the built-in monitor lock:&#xA; * &lt;ul>&#xA; * &lt;li>A successful lock operation acts like a successful &#xA; * &lt;tt>monitorEnter&lt;/tt> action&#xA; * &lt;li>A successful &lt;tt>unlock&lt;/tt> operation acts like a successful&#xA; * &lt;tt>monitorExit&lt;/tt> action&#xA; * &lt;/ul>&#xA; *&#xA; * Unsuccessful locking and unlocking operations, and reentrant&#xA; * locking/unlocking operations, do not require any memory&#xA; * synchronization effects.&#xA; *&#xA; * &lt;h3>Implementation Considerations&lt;/h3>&#xA; *&#xA; * &lt;p> The three forms of lock acquisition (interruptible,&#xA; * non-interruptible, and timed) may differ in their performance&#xA; * characteristics, ordering guarantees, or other implementation&#xA; * qualities.  Further, the ability to interrupt the &lt;em>ongoing&lt;/em>&#xA; * acquisition of a lock may not be available in a given &lt;tt>Lock&lt;/tt>&#xA; * class.  Consequently, an implementation is not required to define&#xA; * exactly the same guarantees or semantics for all three forms of&#xA; * lock acquisition, nor is it required to support interruption of an&#xA; * ongoing lock acquisition.  An implementation is required to clearly&#xA; * document the semantics and guarantees provided by each of the&#xA; * locking methods. It must also obey the interruption semantics as&#xA; * defined in this interface, to the extent that interruption of lock&#xA; * acquisition is supported: which is either totally, or only on&#xA; * method entry.&#xA; *&#xA; * &lt;p>As interruption generally implies cancellation, and checks for &#xA; * interruption are often infrequent, an implementation can favor responding&#xA; * to an interrupt over normal method return. This is true even if it can be&#xA; * shown that the interrupt occurred after another action may have unblocked&#xA; * the thread. An implementation should document this behavior. &#xA; *&#xA; *&#xA; * @see ReentrantLock&#xA; * @see Condition&#xA; * @see ReadWriteLock&#xA; *&#xA; * @since 1.5&#xA; * @author Doug Lea&#xA; *&#xA; **/</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
