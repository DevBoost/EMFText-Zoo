<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../../java.ecore#/7 http://www.emftext.org/java/members ../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../../java.ecore#/13 http://www.emftext.org/java/types ../../../../java.ecore#/16" name="Condition.java">
  <comments>/*&#xA; * @(#)Condition.java&#x9;1.5 04/07/12&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <namespaces>concurrent</namespaces>
  <namespaces>locks</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <namespaces>concurrent</namespaces>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../Date.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="Condition">
    <members xsi:type="members:InterfaceMethod" name="await">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Causes the current thread to wait until it is signalled or &#xA;     * {@link Thread#interrupt interrupted}.&#xA;     *&#xA;     * &lt;p>The lock associated with this &lt;tt>Condition&lt;/tt> is atomically &#xA;     * released and the current thread becomes disabled for thread scheduling &#xA;     * purposes and lies dormant until &lt;em>one&lt;/em> of four things happens:&#xA;     * &lt;ul>&#xA;     * &lt;li>Some other thread invokes the {@link #signal} method for this &#xA;     * &lt;tt>Condition&lt;/tt> and the current thread happens to be chosen as the &#xA;     * thread to be awakened; or&#xA;     * &lt;li>Some other thread invokes the {@link #signalAll} method for this &#xA;     * &lt;tt>Condition&lt;/tt>; or&#xA;     * &lt;li>Some other thread {@link Thread#interrupt interrupts} the current&#xA;     * thread, and interruption of thread suspension is supported; or&#xA;     * &lt;li>A &amp;quot;&lt;em>spurious wakeup&lt;/em>&amp;quot; occurs&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>In all cases, before this method can return the current thread must&#xA;     * re-acquire the lock associated with this condition. When the&#xA;     * thread returns it is &lt;em>guaranteed&lt;/em> to hold this lock.&#xA;     *&#xA;     * &lt;p>If the current thread:&#xA;     * &lt;ul>&#xA;     * &lt;li>has its interrupted status set on entry to this method; or &#xA;     * &lt;li>is {@link Thread#interrupt interrupted} while waiting &#xA;     * and interruption of thread suspension is supported, &#xA;     * &lt;/ul>&#xA;     * then {@link InterruptedException} is thrown and the current thread's &#xA;     * interrupted status is cleared. It is not specified, in the first&#xA;     * case, whether or not the test for interruption occurs before the lock&#xA;     * is released.&#xA;     * &#xA;     * &lt;p>&lt;b>Implementation Considerations&lt;/b>&#xA;     * &lt;p>The current thread is assumed to hold the lock associated with this&#xA;     * &lt;tt>Condition&lt;/tt> when this method is called.&#xA;     * It is up to the implementation to determine if this is&#xA;     * the case and if not, how to respond. Typically, an exception will be &#xA;     * thrown (such as {@link IllegalMonitorStateException}) and the&#xA;     * implementation must document that fact.&#xA;     *&#xA;     * &lt;p>An implementation can favor responding to an interrupt over normal&#xA;     * method return in response to a signal. In that case the implementation&#xA;     * must ensure that the signal is redirected to another waiting thread, if&#xA;     * there is one.&#xA;     *&#xA;     * @throws InterruptedException if the current thread is interrupted (and&#xA;     * interruption of thread suspension is supported).&#xA;     **/</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="awaitUninterruptibly">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Causes the current thread to wait until it is signalled.&#xA;     *&#xA;     * &lt;p>The lock associated with this condition is atomically &#xA;     * released and the current thread becomes disabled for thread scheduling &#xA;     * purposes and lies dormant until &lt;em>one&lt;/em> of three things happens:&#xA;     * &lt;ul>&#xA;     * &lt;li>Some other thread invokes the {@link #signal} method for this &#xA;     * &lt;tt>Condition&lt;/tt> and the current thread happens to be chosen as the &#xA;     * thread to be awakened; or&#xA;     * &lt;li>Some other thread invokes the {@link #signalAll} method for this &#xA;     * &lt;tt>Condition&lt;/tt>; or&#xA;     * &lt;li>A &amp;quot;&lt;em>spurious wakeup&lt;/em>&amp;quot; occurs&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>In all cases, before this method can return the current thread must&#xA;     * re-acquire the lock associated with this condition. When the&#xA;     * thread returns it is &lt;em>guaranteed&lt;/em> to hold this lock.&#xA;     *&#xA;     * &lt;p>If the current thread's interrupted status is set when it enters&#xA;     * this method, or it is {@link Thread#interrupt interrupted} &#xA;     * while waiting, it will continue to wait until signalled. When it finally&#xA;     * returns from this method its interrupted status will still&#xA;     * be set.&#xA;     * &#xA;     * &lt;p>&lt;b>Implementation Considerations&lt;/b>&#xA;     * &lt;p>The current thread is assumed to hold the lock associated with this&#xA;     * &lt;tt>Condition&lt;/tt> when this method is called.&#xA;     * It is up to the implementation to determine if this is&#xA;     * the case and if not, how to respond. Typically, an exception will be &#xA;     * thrown (such as {@link IllegalMonitorStateException}) and the&#xA;     * implementation must document that fact.&#xA;     *&#xA;     **/</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="awaitNanos">
      <typeReference xsi:type="types:Long">
        <comments>/**&#xA;     * Causes the current thread to wait until it is signalled or interrupted,&#xA;     * or the specified waiting time elapses.&#xA;     *&#xA;     * &lt;p>The lock associated with this condition is atomically &#xA;     * released and the current thread becomes disabled for thread scheduling &#xA;     * purposes and lies dormant until &lt;em>one&lt;/em> of five things happens:&#xA;     * &lt;ul>&#xA;     * &lt;li>Some other thread invokes the {@link #signal} method for this &#xA;     * &lt;tt>Condition&lt;/tt> and the current thread happens to be chosen as the &#xA;     * thread to be awakened; or &#xA;     * &lt;li>Some other thread invokes the {@link #signalAll} method for this &#xA;     * &lt;tt>Condition&lt;/tt>; or&#xA;     * &lt;li>Some other thread {@link Thread#interrupt interrupts} the current&#xA;     * thread, and interruption of thread suspension is supported; or&#xA;     * &lt;li>The specified waiting time elapses; or&#xA;     * &lt;li>A &amp;quot;&lt;em>spurious wakeup&lt;/em>&amp;quot; occurs.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>In all cases, before this method can return the current thread must&#xA;     * re-acquire the lock associated with this condition. When the&#xA;     * thread returns it is &lt;em>guaranteed&lt;/em> to hold this lock.&#xA;     *&#xA;     * &lt;p>If the current thread:&#xA;     * &lt;ul>&#xA;     * &lt;li>has its interrupted status set on entry to this method; or &#xA;     * &lt;li>is {@link Thread#interrupt interrupted} while waiting &#xA;     * and interruption of thread suspension is supported, &#xA;     * &lt;/ul>&#xA;     * then {@link InterruptedException} is thrown and the current thread's &#xA;     * interrupted status is cleared. It is not specified, in the first&#xA;     * case, whether or not the test for interruption occurs before the lock&#xA;     * is released.&#xA;     *&#xA;     * &lt;p>The method returns an estimate of the number of nanoseconds&#xA;     * remaining to wait given the supplied &lt;tt>nanosTimeout&lt;/tt>&#xA;     * value upon return, or a value less than or equal to zero if it&#xA;     * timed out. This value can be used to determine whether and how&#xA;     * long to re-wait in cases where the wait returns but an awaited&#xA;     * condition still does not hold. Typical uses of this method take&#xA;     * the following form:&#xA;     *&#xA;     * &lt;pre>&#xA;     * synchronized boolean aMethod(long timeout, TimeUnit unit) {&#xA;     *   long nanosTimeout = unit.toNanos(timeout);&#xA;     *   while (!conditionBeingWaitedFor) {&#xA;     *     if (nanosTimeout &amp;gt; 0)&#xA;     *         nanosTimeout = theCondition.awaitNanos(nanosTimeout);&#xA;     *      else&#xA;     *        return false;&#xA;     *   }&#xA;     *   // ... &#xA;     * }&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;p> Design note: This method requires a nanosecond argument so&#xA;     * as to avoid truncation errors in reporting remaining times.&#xA;     * Such precision loss would make it difficult for programmers to&#xA;     * ensure that total waiting times are not systematically shorter&#xA;     * than specified when re-waits occur.&#xA;     *&#xA;     * &lt;p>&lt;b>Implementation Considerations&lt;/b>&#xA;     * &lt;p>The current thread is assumed to hold the lock associated with this&#xA;     * &lt;tt>Condition&lt;/tt> when this method is called.&#xA;     * It is up to the implementation to determine if this is&#xA;     * the case and if not, how to respond. Typically, an exception will be &#xA;     * thrown (such as {@link IllegalMonitorStateException}) and the&#xA;     * implementation must document that fact.&#xA;     *&#xA;     * &lt;p>An implementation can favor responding to an interrupt over normal&#xA;     * method return in response to a signal, or over indicating the elapse&#xA;     * of the specified waiting time. In either case the implementation&#xA;     * must ensure that the signal is redirected to another waiting thread, if&#xA;     * there is one.&#xA;     *&#xA;     * @param nanosTimeout the maximum time to wait, in nanoseconds&#xA;     * @return A value less than or equal to zero if the wait has&#xA;     * timed out; otherwise an estimate, that&#xA;     * is strictly less than the &lt;tt>nanosTimeout&lt;/tt> argument,&#xA;     * of the time still remaining when this method returned.&#xA;     *&#xA;     * @throws InterruptedException if the current thread is interrupted (and&#xA;     * interruption of thread suspension is supported).&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nanosTimeout">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="await">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Causes the current thread to wait until it is signalled or interrupted,&#xA;     * or the specified waiting time elapses. This method is behaviorally&#xA;     * equivalent to:&lt;br>&#xA;     * &lt;pre>&#xA;     *   awaitNanos(unit.toNanos(time)) &amp;gt; 0&#xA;     * &lt;/pre>&#xA;     * @param time the maximum time to wait&#xA;     * @param unit the time unit of the &lt;tt>time&lt;/tt> argument.&#xA;     * @return &lt;tt>false&lt;/tt> if the waiting time detectably elapsed&#xA;     * before return from the method, else &lt;tt>true&lt;/tt>.&#xA;     * @throws InterruptedException if the current thread is interrupted (and&#xA;     * interruption of thread suspension is supported).&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="time">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="unit">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Enumeration" href="../TimeUnit.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="awaitUntil">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Causes the current thread to wait until it is signalled or interrupted,&#xA;     * or the specified deadline elapses.&#xA;     *&#xA;     * &lt;p>The lock associated with this condition is atomically &#xA;     * released and the current thread becomes disabled for thread scheduling &#xA;     * purposes and lies dormant until &lt;em>one&lt;/em> of five things happens:&#xA;     * &lt;ul>&#xA;     * &lt;li>Some other thread invokes the {@link #signal} method for this &#xA;     * &lt;tt>Condition&lt;/tt> and the current thread happens to be chosen as the &#xA;     * thread to be awakened; or &#xA;     * &lt;li>Some other thread invokes the {@link #signalAll} method for this &#xA;     * &lt;tt>Condition&lt;/tt>; or&#xA;     * &lt;li>Some other thread {@link Thread#interrupt interrupts} the current&#xA;     * thread, and interruption of thread suspension is supported; or&#xA;     * &lt;li>The specified deadline elapses; or&#xA;     * &lt;li>A &amp;quot;&lt;em>spurious wakeup&lt;/em>&amp;quot; occurs.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p>In all cases, before this method can return the current thread must&#xA;     * re-acquire the lock associated with this condition. When the&#xA;     * thread returns it is &lt;em>guaranteed&lt;/em> to hold this lock.&#xA;     *&#xA;     *&#xA;     * &lt;p>If the current thread:&#xA;     * &lt;ul>&#xA;     * &lt;li>has its interrupted status set on entry to this method; or &#xA;     * &lt;li>is {@link Thread#interrupt interrupted} while waiting &#xA;     * and interruption of thread suspension is supported, &#xA;     * &lt;/ul>&#xA;     * then {@link InterruptedException} is thrown and the current thread's &#xA;     * interrupted status is cleared. It is not specified, in the first&#xA;     * case, whether or not the test for interruption occurs before the lock&#xA;     * is released.&#xA;     *&#xA;     *&#xA;     * &lt;p>The return value indicates whether the deadline has elapsed,&#xA;     * which can be used as follows:&#xA;     * &lt;pre>&#xA;     * synchronized boolean aMethod(Date deadline) {&#xA;     *   boolean stillWaiting = true;&#xA;     *   while (!conditionBeingWaitedFor) {&#xA;     *     if (stillwaiting)&#xA;     *         stillWaiting = theCondition.awaitUntil(deadline);&#xA;     *      else&#xA;     *        return false;&#xA;     *   }&#xA;     *   // ... &#xA;     * }&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;p>&lt;b>Implementation Considerations&lt;/b>&#xA;     * &lt;p>The current thread is assumed to hold the lock associated with this&#xA;     * &lt;tt>Condition&lt;/tt> when this method is called.&#xA;     * It is up to the implementation to determine if this is&#xA;     * the case and if not, how to respond. Typically, an exception will be &#xA;     * thrown (such as {@link IllegalMonitorStateException}) and the&#xA;     * implementation must document that fact.&#xA;     *&#xA;     * &lt;p>An implementation can favor responding to an interrupt over normal&#xA;     * method return in response to a signal, or over indicating the passing&#xA;     * of the specified deadline. In either case the implementation&#xA;     * must ensure that the signal is redirected to another waiting thread, if&#xA;     * there is one.&#xA;     *&#xA;     *&#xA;     * @param deadline the absolute time to wait until&#xA;     * @return &lt;tt>false&lt;/tt> if the deadline has&#xA;     * elapsed upon return, else &lt;tt>true&lt;/tt>.&#xA;     *&#xA;     * @throws InterruptedException if the current thread is interrupted (and&#xA;     * interruption of thread suspension is supported).&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="deadline">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="signal">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Wakes up one waiting thread.&#xA;     *&#xA;     * &lt;p>If any threads are waiting on this condition then one&#xA;     * is selected for waking up. That thread must then re-acquire the&#xA;     * lock before returning from &lt;tt>await&lt;/tt>.&#xA;     **/</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="signalAll">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Wakes up all waiting threads.&#xA;     *&#xA;     * &lt;p>If any threads are waiting on this condition then they are&#xA;     * all woken up. Each thread must re-acquire the lock before it can&#xA;     * return from &lt;tt>await&lt;/tt>.&#xA;     **/</comments>
      </typeReference>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;tt>Condition&lt;/tt> factors out the &lt;tt>Object&lt;/tt> monitor&#xA; * methods ({@link Object#wait() wait}, {@link Object#notify notify}&#xA; * and {@link Object#notifyAll notifyAll}) into distinct objects to&#xA; * give the effect of having multiple wait-sets per object, by&#xA; * combining them with the use of arbitrary {@link Lock} implementations.&#xA; * Where a &lt;tt>Lock&lt;/tt> replaces the use of &lt;tt>synchronized&lt;/tt> methods&#xA; * and statements, a &lt;tt>Condition&lt;/tt> replaces the use of the Object&#xA; * monitor methods.&#xA; *&#xA; * &lt;p>Conditions (also known as &lt;em>condition queues&lt;/em> or&#xA; * &lt;em>condition variables&lt;/em>) provide a means for one thread to&#xA; * suspend execution (to &amp;quot;wait&amp;quot;) until notified by another&#xA; * thread that some state condition may now be true.  Because access&#xA; * to this shared state information occurs in different threads, it&#xA; * must be protected, so a lock of some form is associated with the&#xA; * condition. The key property that waiting for a condition provides&#xA; * is that it &lt;em>atomically&lt;/em> releases the associated lock and&#xA; * suspends the current thread, just like &lt;tt>Object.wait&lt;/tt>.&#xA; *&#xA; * &lt;p>A &lt;tt>Condition&lt;/tt> instance is intrinsically bound to a lock.&#xA; * To obtain a &lt;tt>Condition&lt;/tt> instance for a particular {@link Lock} &#xA; * instance use its {@link Lock#newCondition newCondition()} method.&#xA; *&#xA; * &lt;p>As an example, suppose we have a bounded buffer which supports&#xA; * &lt;tt>put&lt;/tt> and &lt;tt>take&lt;/tt> methods.  If a&#xA; * &lt;tt>take&lt;/tt> is attempted on an empty buffer, then the thread will block&#xA; * until an item becomes available; if a &lt;tt>put&lt;/tt> is attempted on a&#xA; * full buffer, then the thread will block until a space becomes available.&#xA; * We would like to keep waiting &lt;tt>put&lt;/tt> threads and &lt;tt>take&lt;/tt>&#xA; * threads in separate wait-sets so that we can use the optimization of&#xA; * only notifying a single thread at a time when items or spaces become&#xA; * available in the buffer. This can be achieved using two &#xA; * {@link Condition} instances.&#xA; * &lt;pre>&#xA; * class BoundedBuffer {&#xA; *   &lt;b>final Lock lock = new ReentrantLock();&lt;/b>&#xA; *   final Condition notFull  = &lt;b>lock.newCondition(); &lt;/b>&#xA; *   final Condition notEmpty = &lt;b>lock.newCondition(); &lt;/b>&#xA; *&#xA; *   final Object[] items = new Object[100];&#xA; *   int putptr, takeptr, count;&#xA; *&#xA; *   public void put(Object x) throws InterruptedException {&#xA; *     &lt;b>lock.lock();&#xA; *     try {&lt;/b>&#xA; *       while (count == items.length) &#xA; *         &lt;b>notFull.await();&lt;/b>&#xA; *       items[putptr] = x; &#xA; *       if (++putptr == items.length) putptr = 0;&#xA; *       ++count;&#xA; *       &lt;b>notEmpty.signal();&lt;/b>&#xA; *     &lt;b>} finally {&#xA; *       lock.unlock();&#xA; *     }&lt;/b>&#xA; *   }&#xA; *&#xA; *   public Object take() throws InterruptedException {&#xA; *     &lt;b>lock.lock();&#xA; *     try {&lt;/b>&#xA; *       while (count == 0) &#xA; *         &lt;b>notEmpty.await();&lt;/b>&#xA; *       Object x = items[takeptr]; &#xA; *       if (++takeptr == items.length) takeptr = 0;&#xA; *       --count;&#xA; *       &lt;b>notFull.signal();&lt;/b>&#xA; *       return x;&#xA; *     &lt;b>} finally {&#xA; *       lock.unlock();&#xA; *     }&lt;/b>&#xA; *   } &#xA; * }&#xA; * &lt;/pre>&#xA; *&#xA; * (The {@link java.util.concurrent.ArrayBlockingQueue} class provides&#xA; * this functionality, so there is no reason to implement this&#xA; * sample usage class.)&#xA; *&#xA; * &lt;p>A &lt;tt>Condition&lt;/tt> implementation can provide behavior and semantics &#xA; * that is &#xA; * different from that of the &lt;tt>Object&lt;/tt> monitor methods, such as &#xA; * guaranteed ordering for notifications, or not requiring a lock to be held &#xA; * when performing notifications.&#xA; * If an implementation provides such specialized semantics then the &#xA; * implementation must document those semantics.&#xA; *&#xA; * &lt;p>Note that &lt;tt>Condition&lt;/tt> instances are just normal objects and can &#xA; * themselves be used as the target in a &lt;tt>synchronized&lt;/tt> statement,&#xA; * and can have their own monitor {@link Object#wait wait} and&#xA; * {@link Object#notify notification} methods invoked.&#xA; * Acquiring the monitor lock of a &lt;tt>Condition&lt;/tt> instance, or using its&#xA; * monitor methods, has no specified relationship with acquiring the&#xA; * {@link Lock} associated with that &lt;tt>Condition&lt;/tt> or the use of its&#xA; * {@link #await waiting} and {@link #signal signalling} methods.&#xA; * It is recommended that to avoid confusion you never use &lt;tt>Condition&lt;/tt>&#xA; * instances in this way, except perhaps within their own implementation.&#xA; *&#xA; * &lt;p>Except where noted, passing a &lt;tt>null&lt;/tt> value for any parameter &#xA; * will result in a {@link NullPointerException} being thrown.&#xA; *&#xA; * &lt;h3>Implementation Considerations&lt;/h3>&#xA; *&#xA; * &lt;p>When waiting upon a &lt;tt>Condition&lt;/tt>, a &amp;quot;&lt;em>spurious&#xA; * wakeup&lt;/em>&amp;quot; is permitted to occur, in &#xA; * general, as a concession to the underlying platform semantics.&#xA; * This has little practical impact on most application programs as a&#xA; * &lt;tt>Condition&lt;/tt> should always be waited upon in a loop, testing&#xA; * the state predicate that is being waited for.  An implementation is&#xA; * free to remove the possibility of spurious wakeups but it is &#xA; * recommended that applications programmers always assume that they can&#xA; * occur and so always wait in a loop.&#xA; *&#xA; * &lt;p>The three forms of condition waiting &#xA; * (interruptible, non-interruptible, and timed) may differ in their ease of &#xA; * implementation on some platforms and in their performance characteristics.&#xA; * In particular, it may be difficult to provide these features and maintain &#xA; * specific semantics such as ordering guarantees. &#xA; * Further, the ability to interrupt the actual suspension of the thread may &#xA; * not always be feasible to implement on all platforms.&#xA; * &lt;p>Consequently, an implementation is not required to define exactly the &#xA; * same guarantees or semantics for all three forms of waiting, nor is it &#xA; * required to support interruption of the actual suspension of the thread.&#xA; * &lt;p>An implementation is required to&#xA; * clearly document the semantics and guarantees provided by each of the &#xA; * waiting methods, and when an implementation does support interruption of &#xA; * thread suspension then it must obey the interruption semantics as defined &#xA; * in this interface.&#xA; * &lt;p>As interruption generally implies cancellation, and checks for &#xA; * interruption are often infrequent, an implementation can favor responding&#xA; * to an interrupt over normal method return. This is true even if it can be&#xA; * shown that the interrupt occurred after another action may have unblocked&#xA; * the thread. An implementation should document this behavior. &#xA; *&#xA; *&#xA; * @since 1.5&#xA; * @author Doug Lea&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
