<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../../java.ecore#/5 http://www.emftext.org/java/generics ../../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../../java.ecore#/9 http://www.emftext.org/java/members ../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../../java.ecore#/13 http://www.emftext.org/java/references ../../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../../java.ecore#/15 http://www.emftext.org/java/types ../../../../java.ecore#/16" name="ReentrantReadWriteLock.java">
  <comments>/*&#xA; * @(#)ReentrantReadWriteLock.java&#x9;1.7 04/07/14&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <namespaces>concurrent</namespaces>
  <namespaces>locks</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <namespaces>concurrent</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <namespaces>concurrent</namespaces>
    <namespaces>atomic</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="ReentrantReadWriteLock">
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="6992448646407690164"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="readerLock">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <namespaces>ReentrantReadWriteLock</namespaces>
        <classifierReferences target="//@classifiers.0/@members.16"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** Inner class providing readlock */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="writerLock">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <namespaces>ReentrantReadWriteLock</namespaces>
        <classifierReferences target="//@classifiers.0/@members.17"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** Inner class providing writelock */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="sync">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.13"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** Performs all synchronization mechanics */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="ReentrantReadWriteLock">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.14"/>
            </typeReference>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.16"/>
            </typeReference>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.17"/>
            </typeReference>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </value>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new &lt;tt>ReentrantReadWriteLock&lt;/tt> with&#xA;     * default ordering properties.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="ReentrantReadWriteLock">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
            </child>
            <expressionIf xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.15"/>
              </typeReference>
            </expressionIf>
            <expressionElse xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.14"/>
              </typeReference>
            </expressionElse>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.16"/>
            </typeReference>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.17"/>
            </typeReference>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fair">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new &lt;tt>ReentrantReadWriteLock&lt;/tt> with&#xA;     * the given fairness policy.&#xA;     *&#xA;     * @param fair true if this lock should use a fair ordering policy&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="writeLock">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <namespaces>ReentrantReadWriteLock</namespaces>
        <classifierReferences target="//@classifiers.0/@members.17"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readLock">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <namespaces>ReentrantReadWriteLock</namespaces>
        <classifierReferences target="//@classifiers.0/@members.16"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:Field" name="SHARED_SHIFT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/* &#xA;     * Read vs write count extraction constants and functions.&#xA;     * Lock state is logically divided into two shorts: The lower&#xA;     * one representing the exclusive (writer) lock hold count,&#xA;     * and the upper the shared (reader) hold count.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SHARED_UNIT">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="EXCLUSIVE_MASK">
      <initialValue xsi:type="expressions:AdditiveExpression">
        <children xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ShiftExpression">
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            <shiftOperators xsi:type="operators:LeftShift"/>
          </expression>
        </children>
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        <additiveOperators xsi:type="operators:Subtraction"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="sharedCount">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/** Returns the number of shared holds represented in count  */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ShiftExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          <shiftOperators xsi:type="operators:UnsignedRightShift"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="exclusiveCount">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/** Returns the number of exclusive holds represented in count  */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AndExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="classifiers:Class" name="Sync">
      <members xsi:type="members:Field" name="owner">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Transient">
          <comments>/** Current (exclusive) owner thread */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:InterfaceMethod" name="wlock">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Abstract">
          <comments>/**&#xA;         * Perform write lock. Allows fast path in non-fair version.&#xA;         */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:ClassMethod" name="nonfairTryAcquire">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="acquires">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Final">
          <comments>/** &#xA;         * Perform non-fair tryLock for write.  tryAcquire is&#xA;         * implemented in subclasses, but both versions need nonfair&#xA;         * try for trylock method&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2/@parameters.0">
              <comments>// mask out readlocks if called from condition methods</comments>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2/@parameters.0"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="current">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="c">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="w">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2/@statements.2/@variable"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../lang/Error.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Maximum lock count exceeded"/>
            </throwable>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2/@statements.3/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2/@statements.2/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ConditionalOrExpression">
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2/@statements.3/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </children>
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2/@statements.1/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                </children>
              </expression>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.13"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2/@statements.2/@variable"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2/@parameters.0"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </child>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2/@statements.1/@variable"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="nonfairTryAcquireShared">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="acquires">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Final">
          <comments>/** &#xA;         * Perform nonfair tryLock for read. &#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:Block">
            <comments>// Recheck count if lost CAS</comments>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="c">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="nextc">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@statements.0/@statement/@statements.0/@variable"/>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:ShiftExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@parameters.0"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                      <shiftOperators xsi:type="operators:LeftShift"/>
                    </expression>
                  </children>
                  <additiveOperators xsi:type="operators:Addition"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../lang/Error.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:StringReference" value="Maximum lock count exceeded"/>
                </throwable>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@statements.0/@statement/@statements.1/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@statements.0/@statement/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Subtraction"/>
                  <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </returnValue>
              </statement>
              <condition xsi:type="expressions:ConditionalAndExpression">
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@statements.0/@statement/@statements.0/@variable"/>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </children>
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
                  </children>
                </children>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </statement>
              <condition xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.13"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@statements.0/@statement/@statements.0/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@statements.0/@statement/@statements.1/@variable"/>
              </condition>
            </statements>
          </statement>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="tryRelease">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="releases">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="current">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="c">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../lang/IllegalMonitorStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@statements.0/@variable"/>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="nextc">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="free">
            <typeReference xsi:type="types:Boolean"/>
            <initialValue xsi:type="literals:BooleanLiteral"/>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@statements.4/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral" value="true"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:NullLiteral"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@statements.1/@variable"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@parameters.0"/>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.12"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@statements.3/@variable"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@statements.4/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="tryReleaseShared">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="releases">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="c">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="nextc">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.5/@statements.0/@statement/@statements.0/@variable"/>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:ShiftExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.5/@parameters.0"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                      <shiftOperators xsi:type="operators:LeftShift"/>
                    </expression>
                  </children>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../lang/IllegalMonitorStateException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </throwable>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.5/@statements.0/@statement/@statements.1/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.5/@statements.0/@statement/@statements.1/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </returnValue>
              </statement>
              <condition xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.13"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.5/@statements.0/@statement/@statements.0/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.5/@statements.0/@statement/@statements.1/@variable"/>
              </condition>
            </statements>
          </statement>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="isHeldExclusively">
        <typeReference xsi:type="types:Boolean"/>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
                <arguments xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
                </arguments>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </children>
            </children>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="newCondition">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final">
          <comments>// Methods relayed to outer class</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getOwner">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="c">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
              <arguments xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
              </arguments>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="o">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.8/@statements.0/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </expression>
            </child>
            <expressionIf xsi:type="literals:NullLiteral"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.8/@statements.1/@variable"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getReadLockCount">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
            <arguments xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
            </arguments>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="isWriteLocked">
        <typeReference xsi:type="types:Boolean"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
              <arguments xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
              </arguments>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getWriteHoldCount">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="c">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
              <arguments xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
              </arguments>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="o">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.11/@statements.1/@variable"/>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
                </children>
              </expression>
            </child>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.11/@statements.0/@variable"/>
            <expressionElse xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="readObject">
        <comments>// reset to unlocked state</comments>
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <namespaces>java</namespaces>
            <namespaces>io</namespaces>
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../io/ObjectInputStream.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <exceptions>
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../io/IOException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/ClassNotFoundException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>/**&#xA;         * Reconstitute this lock instance from a stream&#xA;         * @param s the stream&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.12/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../io/ObjectInputStream.class.xmi#//@classifiers.0/@members.19"/>
            </next>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.12"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="getCount">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/** &#xA;     * Synchronization implementation for ReentrantReadWriteLock.&#xA;     * Subclassed into fair and nonfair versions.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="NonfairSync">
      <members xsi:type="members:ClassMethod" name="tryAcquire">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="acquires">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.2">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0/@parameters.0"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="tryAcquireShared">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="acquires">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.3">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.1/@parameters.0"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="wlock">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Final">
          <comments>// Use fastpath for main write lock method</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statement>
          <condition xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.13"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </condition>
          <elseStatement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.34"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </expression>
          </elseStatement>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/** &#xA;     * Nonfair version of Sync&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.13"/>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="FairSync">
      <members xsi:type="members:ClassMethod" name="tryAcquire">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="acquires">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@parameters.0">
              <comments>// mask out readlocks if called from condition methods</comments>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@parameters.0"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="current">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="first">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="c">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="w">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@statements.3/@variable"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../lang/Error.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Maximum lock count exceeded"/>
            </throwable>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@statements.4/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ConditionalOrExpression">
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@statements.4/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </children>
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@statements.1/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                </children>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ConditionalOrExpression">
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@statements.3/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </children>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ConditionalAndExpression">
                    <children xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@statements.2/@variable"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.44"/>
                          </value>
                        </expression>
                      </children>
                      <children xsi:type="literals:NullLiteral"/>
                    </children>
                    <children xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@statements.2/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@statements.1/@variable"/>
                    </children>
                  </expression>
                </children>
              </expression>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.13"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@statements.3/@variable"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@statements.3/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@parameters.0"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </child>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@statements.1/@variable"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="tryAcquireShared">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="acquires">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="current">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:Block">
            <comments>// Recheck count if lost CAS</comments>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="c">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Return">
                    <returnValue xsi:type="expressions:UnaryExpression">
                      <operators xsi:type="operators:Subtraction"/>
                      <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    </returnValue>
                  </statement>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.1/@statements.0/@variable"/>
                  </condition>
                </statements>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.1/@statements.1/@statement/@statements.0/@variable"/>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
              <elseStatement xsi:type="statements:Block">
                <statements xsi:type="statements:LocalVariableStatement">
                  <variable name="first">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <initialValue xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.44"/>
                    </initialValue>
                  </variable>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Return">
                    <returnValue xsi:type="expressions:UnaryExpression">
                      <operators xsi:type="operators:Subtraction"/>
                      <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    </returnValue>
                  </statement>
                  <condition xsi:type="expressions:ConditionalAndExpression">
                    <children xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.1/@statements.1/@statement/@statements.1/@elseStatement/@statements.0/@variable"/>
                      <children xsi:type="literals:NullLiteral"/>
                    </children>
                    <children xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.1/@statements.1/@statement/@statements.1/@elseStatement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.1/@statements.0/@variable"/>
                    </children>
                  </condition>
                </statements>
              </elseStatement>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="nextc">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.1/@statements.1/@statement/@statements.0/@variable"/>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:ShiftExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.1/@parameters.0"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                      <shiftOperators xsi:type="operators:LeftShift"/>
                    </expression>
                  </children>
                  <additiveOperators xsi:type="operators:Addition"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../lang/Error.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:StringReference" value="Maximum lock count exceeded"/>
                </throwable>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.1/@statements.1/@statement/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.1/@statements.1/@statement/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </statement>
              <condition xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.13"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.1/@statements.1/@statement/@statements.0/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.1/@statements.1/@statement/@statements.2/@variable"/>
              </condition>
            </statements>
          </statement>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="wlock">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall">
            <comments>// no fast path</comments>
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.34"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </expression>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/** &#xA;     * Fair version of Sync&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.13"/>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="ReadLock">
      <members xsi:type="members:Field" name="serialVersionUID">
        <initialValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalLongLiteral" decimalValue="5992448646407690164"/>
        </initialValue>
        <typeReference xsi:type="types:Long"/>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="sync">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.13"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Constructor" name="ReadLock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.1"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.2/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            </value>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="lock">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected">
          <comments>/** &#xA;         * Constructor for use by subclasses &#xA;         * @param lock the outer lock object&#xA;         * @throws NullPointerException if lock null&#xA;         */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:ClassMethod" name="lock">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Acquires the read lock. &#xA;         *&#xA;         * &lt;p>Acquires the read lock if the write lock is not held by&#xA;         * another thread and returns immediately.&#xA;         *&#xA;         * &lt;p>If the write lock is held by another thread then&#xA;         * the current thread becomes disabled for thread scheduling&#xA;         * purposes and lies dormant until the read lock has been acquired.&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.38"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </next>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="lockInterruptibly">
        <typeReference xsi:type="types:Void"/>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Acquires the read lock unless the current thread is &#xA;         * {@link Thread#interrupt interrupted}.&#xA;         *&#xA;         * &lt;p>Acquires the read lock if the write lock is not held&#xA;         * by another thread and returns immediately.&#xA;         *&#xA;         * &lt;p>If the write lock is held by another thread then the&#xA;         * current thread becomes disabled for thread scheduling &#xA;         * purposes and lies dormant until one of two things happens:&#xA;         *&#xA;         * &lt;ul>&#xA;         *&#xA;         * &lt;li>The read lock is acquired by the current thread; or&#xA;         *&#xA;         * &lt;li>Some other thread {@link Thread#interrupt interrupts}&#xA;         * the current thread.&#xA;         *&#xA;         * &lt;/ul>&#xA;         *&#xA;         * &lt;p>If the current thread:&#xA;         *&#xA;         * &lt;ul>&#xA;         *&#xA;         * &lt;li>has its interrupted status set on entry to this method; or &#xA;         *&#xA;         * &lt;li>is {@link Thread#interrupt interrupted} while acquiring &#xA;         * the read lock,&#xA;         *&#xA;         * &lt;/ul>&#xA;         *&#xA;         * then {@link InterruptedException} is thrown and the current&#xA;         * thread's interrupted status is cleared.&#xA;         *&#xA;         * &lt;p>In this implementation, as this method is an explicit&#xA;         * interruption point, preference is given to responding to&#xA;         * the interrupt over normal or reentrant acquisition of the&#xA;         * lock.&#xA;         *&#xA;         * @throws InterruptedException if the current thread is interrupted&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.39"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </next>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="tryLock">
        <typeReference xsi:type="types:Boolean"/>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Acquires the read lock only if the write lock is not held by&#xA;         * another thread at the time of invocation.&#xA;         *&#xA;         * &lt;p>Acquires the read lock if the write lock is not held by&#xA;         * another thread and returns immediately with the value&#xA;         * &lt;tt>true&lt;/tt>. Even when this lock has been set to use a&#xA;         * fair ordering policy, a call to &lt;tt>tryLock()&lt;/tt>&#xA;         * &lt;em>will&lt;/em> immediately acquire the read lock if it is&#xA;         * available, whether or not other threads are currently&#xA;         * waiting for the read lock.  This &amp;quot;barging&amp;quot; behavior&#xA;         * can be useful in certain circumstances, even though it&#xA;         * breaks fairness. If you want to honor the fairness setting&#xA;         * for this lock, then use {@link #tryLock(long, TimeUnit)&#xA;         * tryLock(0, TimeUnit.SECONDS) } which is almost equivalent&#xA;         * (it also detects interruption).&#xA;         *&#xA;         * &lt;p>If the write lock is held by another thread then&#xA;         * this method will return immediately with the value&#xA;         * &lt;tt>false&lt;/tt>.&#xA;         *&#xA;         * @return &lt;tt>true&lt;/tt> if the read lock was acquired.&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.1">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.3">
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </next>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="tryLock">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="timeout">
          <typeReference xsi:type="types:Long"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="unit">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Enumeration" href="../TimeUnit.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Acquires the read lock if the write lock is not held by&#xA;         * another thread within the given waiting time and the&#xA;         * current thread has not been {@link Thread#interrupt&#xA;         * interrupted}.&#xA;         *&#xA;         * &lt;p>Acquires the read lock if the write lock is not held by&#xA;         * another thread and returns immediately with the value&#xA;         * &lt;tt>true&lt;/tt>. If this lock has been set to use a fair&#xA;         * ordering policy then an available lock &lt;em>will not&lt;/em> be&#xA;         * acquired if any other threads are waiting for the&#xA;         * lock. This is in contrast to the {@link #tryLock()}&#xA;         * method. If you want a timed &lt;tt>tryLock&lt;/tt> that does&#xA;         * permit barging on a fair lock then combine the timed and&#xA;         * un-timed forms together:&#xA;         *&#xA;         * &lt;pre>if (lock.tryLock() || lock.tryLock(timeout, unit) ) { ... }&#xA;         * &lt;/pre>&#xA;         *&#xA;         * &lt;p>If the write lock is held by another thread then the&#xA;         * current thread becomes disabled for thread scheduling &#xA;         * purposes and lies dormant until one of three things happens:&#xA;         *&#xA;         * &lt;ul>&#xA;         *&#xA;         * &lt;li>The read lock is acquired by the current thread; or&#xA;         *&#xA;         * &lt;li>Some other thread {@link Thread#interrupt interrupts} the current&#xA;         * thread; or&#xA;         *&#xA;         * &lt;li>The specified waiting time elapses&#xA;         *&#xA;         * &lt;/ul>&#xA;         *&#xA;         * &lt;p>If the read lock is acquired then the value &lt;tt>true&lt;/tt> is&#xA;         * returned.&#xA;         *&#xA;         * &lt;p>If the current thread:&#xA;         *&#xA;         * &lt;ul>&#xA;         *&#xA;         * &lt;li>has its interrupted status set on entry to this method; or &#xA;         *&#xA;         * &lt;li>is {@link Thread#interrupt interrupted} while acquiring&#xA;         * the read lock,&#xA;         *&#xA;         * &lt;/ul> then {@link InterruptedException} is thrown and the&#xA;         * current thread's interrupted status is cleared.&#xA;         *&#xA;         * &lt;p>If the specified waiting time elapses then the value&#xA;         * &lt;tt>false&lt;/tt> is returned.  If the time is less than or&#xA;         * equal to zero, the method will not wait at all.&#xA;         *&#xA;         * &lt;p>In this implementation, as this method is an explicit&#xA;         * interruption point, preference is given to responding to&#xA;         * the interrupt over normal or reentrant acquisition of the&#xA;         * lock, and over reporting the elapse of the waiting time.&#xA;         *&#xA;         * @param timeout the time to wait for the read lock&#xA;         * @param unit the time unit of the timeout argument&#xA;         *&#xA;         * @return &lt;tt>true&lt;/tt> if the read lock was acquired.&#xA;         *&#xA;         * @throws InterruptedException if the current thread is interrupted&#xA;         * @throws NullPointerException if unit is null&#xA;         *&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.40"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.6/@parameters.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../TimeUnit.class.xmi#//@classifiers.0/@members.9"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.6/@parameters.0"/>
                </next>
              </arguments>
            </next>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="unlock">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Attempts to release this lock.  &#xA;         *&#xA;         * &lt;p> If the number of readers is now zero then the lock&#xA;         * is made available for write lock attempts.&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.41"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </next>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="newCondition">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Condition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Throws &lt;tt>UnsupportedOperationException&lt;/tt> because&#xA;&#x9; * &lt;tt>ReadLocks&lt;/tt> do not support conditions.&#xA;         * @throws UnsupportedOperationException always&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="toString">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Returns a string identifying this lock, as well as its lock state.&#xA;         * The state, in brackets, includes the String &#xA;         * &amp;quot;Read locks =&amp;quot; followed by the number of held&#xA;         * read locks.&#xA;         * @return a string identifying this lock, as well as its lock state.&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="r">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.1">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.9"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../lang/Object.class.xmi#//@classifiers.0/@members.6"/>
              </next>
              <self xsi:type="literals:Super"/>
            </children>
            <children xsi:type="references:StringReference" value="[Read locks = "/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.9/@statements.0/@variable"/>
            <children xsi:type="references:StringReference" value="]"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The lock returned by method {@link ReentrantReadWriteLock#readLock}.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <implements xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Lock.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </implements>
      <implements xsi:type="types:NamespaceClassifierReference">
        <namespaces>java</namespaces>
        <namespaces>io</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../io/Serializable.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </implements>
    </members>
    <members xsi:type="classifiers:Class" name="WriteLock">
      <members xsi:type="members:Field" name="serialVersionUID">
        <initialValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalLongLiteral" decimalValue="4992448646407690164"/>
        </initialValue>
        <typeReference xsi:type="types:Long"/>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="sync">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.13"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Constructor" name="WriteLock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.2/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            </value>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="lock">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Protected">
          <comments>/** &#xA;         * Constructor for use by subclasses &#xA;         * @param lock the outer lock object&#xA;         * @throws NullPointerException if lock null&#xA;         */</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:ClassMethod" name="lock">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Acquire the write lock. &#xA;         *&#xA;         * &lt;p>Acquires the write lock if neither the read nor write lock&#xA;&#x9; * are held by another thread&#xA;         * and returns immediately, setting the write lock hold count to&#xA;         * one.&#xA;         *&#xA;         * &lt;p>If the current thread already holds the write lock then the&#xA;         * hold count is incremented by one and the method returns&#xA;         * immediately.&#xA;         *&#xA;         * &lt;p>If the lock is held by another thread then the current&#xA;         * thread becomes disabled for thread scheduling purposes and&#xA;         * lies dormant until the write lock has been acquired, at which&#xA;         * time the write lock hold count is set to one.&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.1"/>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="lockInterruptibly">
        <typeReference xsi:type="types:Void"/>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Acquires the write lock unless the current thread is {@link&#xA;         * Thread#interrupt interrupted}.&#xA;         *&#xA;         * &lt;p>Acquires the write lock if neither the read nor write lock&#xA;&#x9; * are held by another thread&#xA;         * and returns immediately, setting the write lock hold count to&#xA;         * one.&#xA;         *&#xA;         * &lt;p>If the current thread already holds this lock then the&#xA;         * hold count is incremented by one and the method returns&#xA;         * immediately.&#xA;         *&#xA;         * &lt;p>If the lock is held by another thread then the current&#xA;         * thread becomes disabled for thread scheduling purposes and&#xA;         * lies dormant until one of two things happens:&#xA;         *&#xA;         * &lt;ul>&#xA;         *&#xA;         * &lt;li>The write lock is acquired by the current thread; or&#xA;         *&#xA;         * &lt;li>Some other thread {@link Thread#interrupt interrupts}&#xA;         * the current thread.&#xA;         *&#xA;         * &lt;/ul>&#xA;         *&#xA;         * &lt;p>If the write lock is acquired by the current thread then the&#xA;         * lock hold count is set to one.&#xA;         *&#xA;         * &lt;p>If the current thread:&#xA;         *&#xA;         * &lt;ul>&#xA;         *&#xA;         * &lt;li>has its interrupted status set on entry to this method;&#xA;         * or&#xA;         *&#xA;         * &lt;li>is {@link Thread#interrupt interrupted} while acquiring&#xA;         * the write lock,&#xA;         *&#xA;         * &lt;/ul>&#xA;         *&#xA;         * then {@link InterruptedException} is thrown and the current&#xA;         * thread's interrupted status is cleared.&#xA;         *&#xA;         * &lt;p>In this implementation, as this method is an explicit&#xA;         * interruption point, preference is given to responding to&#xA;         * the interrupt over normal or reentrant acquisition of the&#xA;         * lock.&#xA;         *&#xA;         * @throws InterruptedException if the current thread is interrupted&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.35"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </next>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="tryLock">
        <typeReference xsi:type="types:Boolean"/>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Acquires the write lock only if it is not held by another thread&#xA;         * at the time of invocation.&#xA;         *&#xA;         * &lt;p>Acquires the write lock if neither the read nor write lock&#xA;&#x9; * are held by another thread&#xA;         * and returns immediately with the value &lt;tt>true&lt;/tt>,&#xA;         * setting the write lock hold count to one. Even when this lock has&#xA;         * been set to use a fair ordering policy, a call to&#xA;         * &lt;tt>tryLock()&lt;/tt> &lt;em>will&lt;/em> immediately acquire the&#xA;         * lock if it is available, whether or not other threads are&#xA;         * currently waiting for the write lock.  This &amp;quot;barging&amp;quot;&#xA;         * behavior can be useful in certain circumstances, even&#xA;         * though it breaks fairness. If you want to honor the&#xA;         * fairness setting for this lock, then use {@link&#xA;         * #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) }&#xA;         * which is almost equivalent (it also detects interruption).&#xA;         *&#xA;         * &lt;p> If the current thread already holds this lock then the&#xA;         * hold count is incremented by one and the method returns&#xA;         * &lt;tt>true&lt;/tt>.&#xA;         *&#xA;         * &lt;p>If the lock is held by another thread then this method&#xA;         * will return immediately with the value &lt;tt>false&lt;/tt>.&#xA;         *&#xA;         * @return &lt;tt>true&lt;/tt> if the lock was free and was acquired&#xA;         * by the current thread, or the write lock was already held&#xA;         * by the current thread; and &lt;tt>false&lt;/tt> otherwise.&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.2">
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </next>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="tryLock">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="timeout">
          <typeReference xsi:type="types:Long"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="unit">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Enumeration" href="../TimeUnit.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Acquires the write lock if it is not held by another thread&#xA;         * within the given waiting time and the current thread has&#xA;         * not been {@link Thread#interrupt interrupted}.&#xA;         *&#xA;         * &lt;p>Acquires the write lock if neither the read nor write lock&#xA;&#x9; * are held by another thread&#xA;         * and returns immediately with the value &lt;tt>true&lt;/tt>,&#xA;         * setting the write lock hold count to one. If this lock has been&#xA;         * set to use a fair ordering policy then an available lock&#xA;         * &lt;em>will not&lt;/em> be acquired if any other threads are&#xA;         * waiting for the write lock. This is in contrast to the {@link&#xA;         * #tryLock()} method. If you want a timed &lt;tt>tryLock&lt;/tt>&#xA;         * that does permit barging on a fair lock then combine the&#xA;         * timed and un-timed forms together:&#xA;         *&#xA;         * &lt;pre>if (lock.tryLock() || lock.tryLock(timeout, unit) ) { ... }&#xA;         * &lt;/pre>&#xA;         *&#xA;         * &lt;p>If the current thread already holds this lock then the&#xA;         * hold count is incremented by one and the method returns&#xA;         * &lt;tt>true&lt;/tt>.&#xA;         *&#xA;         * &lt;p>If the lock is held by another thread then the current&#xA;         * thread becomes disabled for thread scheduling purposes and&#xA;         * lies dormant until one of three things happens:&#xA;         *&#xA;         * &lt;ul>&#xA;         *&#xA;         * &lt;li>The write lock is acquired by the current thread; or&#xA;         *&#xA;         * &lt;li>Some other thread {@link Thread#interrupt interrupts}&#xA;         * the current thread; or&#xA;         *&#xA;         * &lt;li>The specified waiting time elapses&#xA;         *&#xA;         * &lt;/ul>&#xA;         *&#xA;         * &lt;p>If the write lock is acquired then the value &lt;tt>true&lt;/tt> is&#xA;         * returned and the write lock hold count is set to one.&#xA;         *&#xA;         * &lt;p>If the current thread:&#xA;         *&#xA;         * &lt;ul>&#xA;         *&#xA;         * &lt;li>has its interrupted status set on entry to this method;&#xA;         * or&#xA;         *&#xA;         * &lt;li>is {@link Thread#interrupt interrupted} while acquiring&#xA;         * the write lock,&#xA;         *&#xA;         * &lt;/ul> &#xA;         *&#xA;         * then {@link InterruptedException} is thrown and the current&#xA;         * thread's interrupted status is cleared.&#xA;         *&#xA;         * &lt;p>If the specified waiting time elapses then the value&#xA;         * &lt;tt>false&lt;/tt> is returned.  If the time is less than or&#xA;         * equal to zero, the method will not wait at all.&#xA;         *&#xA;         * &lt;p>In this implementation, as this method is an explicit&#xA;         * interruption point, preference is given to responding to&#xA;         * the interrupt over normal or reentrant acquisition of the&#xA;         * lock, and over reporting the elapse of the waiting time.&#xA;         *&#xA;         * @param timeout the time to wait for the write lock&#xA;         * @param unit the time unit of the timeout argument&#xA;         *&#xA;         * @return &lt;tt>true&lt;/tt> if the lock was free and was acquired&#xA;         * by the current thread, or the write lock was already held by the&#xA;         * current thread; and &lt;tt>false&lt;/tt> if the waiting time&#xA;         * elapsed before the lock could be acquired.&#xA;         *&#xA;         * @throws InterruptedException if the current thread is interrupted&#xA;         * @throws NullPointerException if unit is null&#xA;         *&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.36"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.6/@parameters.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../TimeUnit.class.xmi#//@classifiers.0/@members.9"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.6/@parameters.0"/>
                </next>
              </arguments>
            </next>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="unlock">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Attempts to release this lock.  &#xA;         *&#xA;         * &lt;p>If the current thread is the holder of this lock then&#xA;         * the hold count is decremented. If the hold count is now&#xA;         * zero then the lock is released.  If the current thread is&#xA;         * not the holder of this lock then {@link&#xA;         * IllegalMonitorStateException} is thrown.&#xA;         * @throws IllegalMonitorStateException if the current thread does not&#xA;         * hold this lock.&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.37"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </next>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="newCondition">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Condition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Returns a {@link Condition} instance for use with this&#xA;         * {@link Lock} instance. &#xA;         * &lt;p>The returned {@link Condition} instance supports the same&#xA;         * usages as do the {@link Object} monitor methods ({@link&#xA;         * Object#wait() wait}, {@link Object#notify notify}, and {@link&#xA;         * Object#notifyAll notifyAll}) when used with the built-in&#xA;         * monitor lock.&#xA;         *&#xA;         * &lt;ul>&#xA;         *&#xA;         * &lt;li>If this write lock is not held when any {@link&#xA;         * Condition} method is called then an {@link&#xA;         * IllegalMonitorStateException} is thrown.  (Read locks are&#xA;         * held independently of write locks, so are not checked or&#xA;         * affected. However it is essentially always an error to&#xA;         * invoke a condition waiting method when the current thread&#xA;         * has also acquired read locks, since other threads that&#xA;         * could unblock it will not be able to acquire the write&#xA;         * lock.)&#xA;         *&#xA;         * &lt;li>When the condition {@link Condition#await() waiting}&#xA;         * methods are called the write lock is released and, before&#xA;         * they return, the write lock is reacquired and the lock hold&#xA;         * count restored to what it was when the method was called.&#xA;         *&#xA;         * &lt;li>If a thread is {@link Thread#interrupt interrupted} while&#xA;         * waiting then the wait will terminate, an {@link&#xA;         * InterruptedException} will be thrown, and the thread's&#xA;         * interrupted status will be cleared.&#xA;         *&#xA;         * &lt;li> Waiting threads are signalled in FIFO order.&#xA;         *&#xA;         * &lt;li>The ordering of lock reacquisition for threads returning&#xA;         * from waiting methods is the same as for threads initially&#xA;         * acquiring the lock, which is in the default case not specified,&#xA;         * but for &lt;em>fair&lt;/em> locks favors those threads that have been&#xA;         * waiting the longest.&#xA;         * &#xA;         * &lt;/ul>&#xA;         * @return the Condition object&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.7"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="toString">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;         * Returns a string identifying this lock, as well as its lock&#xA;         * state.  The state, in brackets includes either the String&#xA;         * &amp;quot;Unlocked&amp;quot; or the String &amp;quot;Locked by&amp;quot;&#xA;         * followed by the {@link Thread#getName} of the owning thread.&#xA;         * @return a string identifying this lock, as well as its lock state.&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="owner">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.1">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.8"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../lang/Object.class.xmi#//@classifiers.0/@members.6"/>
              </next>
              <self xsi:type="literals:Super"/>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ConditionalExpression">
                <child xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.9/@statements.0/@variable"/>
                    <children xsi:type="literals:NullLiteral"/>
                  </expression>
                </child>
                <expressionIf xsi:type="references:StringReference" value="[Unlocked]"/>
                <expressionElse xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:StringReference" value="[Locked by thread "/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@members.9/@statements.0/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../../lang/Thread.class.xmi#//@classifiers.0/@members.63"/>
                    </next>
                  </children>
                  <children xsi:type="references:StringReference" value="]"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </expressionElse>
              </expression>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The lock returned by method {@link ReentrantReadWriteLock#writeLock}.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <implements xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Lock.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </implements>
      <implements xsi:type="types:NamespaceClassifierReference">
        <namespaces>java</namespaces>
        <namespaces>io</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../../../io/Serializable.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </implements>
    </members>
    <members xsi:type="members:ClassMethod" name="isFair">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Instrumentation and status</comments>
        <comments>/**&#xA;     * Returns true if this lock has fairness set true.&#xA;     * @return true if this lock has fairness set true.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.15"/>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getOwner">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns the thread that currently owns the write lock, or&#xA;     * &lt;tt>null&lt;/tt> if not owned. Note that the owner may be&#xA;     * momentarily &lt;tt>null&lt;/tt> even if there are threads trying to&#xA;     * acquire the lock but have not yet done so.  This method is&#xA;     * designed to facilitate construction of subclasses that provide&#xA;     * more extensive lock monitoring facilities.&#xA;     * @return the owner, or &lt;tt>null&lt;/tt> if not owned.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.8"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getReadLockCount">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Queries the number of read locks held for this lock. This&#xA;     * method is designed for use in monitoring system state, not for&#xA;     * synchronization control.&#xA;     * @return the number of read locks held.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.9"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isWriteLocked">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Queries if the write lock is held by any thread. This method is&#xA;     * designed for use in monitoring system state, not for&#xA;     * synchronization control.&#xA;     * @return &lt;tt>true&lt;/tt> if any thread holds the write lock and &#xA;     * &lt;tt>false&lt;/tt> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.10"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isWriteLockedByCurrentThread">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Queries if the write lock is held by the current thread. &#xA;     * @return &lt;tt>true&lt;/tt> if the current thread holds the write lock and &#xA;     * &lt;tt>false&lt;/tt> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.6"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getWriteHoldCount">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Queries the number of reentrant write holds on this lock by the&#xA;     * current thread.  A writer thread has a hold on a lock for&#xA;     * each lock action that is not matched by an unlock action.&#xA;     *&#xA;     * @return the number of holds on the write lock by the current thread,&#xA;     * or zero if the write lock is not held by the current thread.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.11"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getQueuedWriterThreads">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns a collection containing threads that may be waiting to&#xA;     * acquire the write lock.  Because the actual set of threads may&#xA;     * change dynamically while constructing this result, the returned&#xA;     * collection is only a best-effort estimate.  The elements of the&#xA;     * returned collection are in no particular order.  This method is&#xA;     * designed to facilitate construction of subclasses that provide&#xA;     * more extensive lock monitoring facilities.&#xA;     * @return the collection of threads&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.49"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getQueuedReaderThreads">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns a collection containing threads that may be waiting to&#xA;     * acquire the read lock.  Because the actual set of threads may&#xA;     * change dynamically while constructing this result, the returned&#xA;     * collection is only a best-effort estimate.  The elements of the&#xA;     * returned collection are in no particular order.  This method is&#xA;     * designed to facilitate construction of subclasses that provide&#xA;     * more extensive lock monitoring facilities.&#xA;     * @return the collection of threads&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.50"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hasQueuedThreads">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Queries whether any threads are waiting to acquire the read or&#xA;     * write lock. Note that because cancellations may occur at any&#xA;     * time, a &lt;tt>true&lt;/tt> return does not guarantee that any other&#xA;     * thread will ever acquire a lock.  This method is designed&#xA;     * primarily for use in monitoring of the system state.&#xA;     *&#xA;     * @return true if there may be other threads waiting to acquire&#xA;     * the lock.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.42"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hasQueuedThread">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="thread">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Queries whether the given thread is waiting to acquire either&#xA;     * the read or write lock. Note that because cancellations may&#xA;     * occur at any time, a &lt;tt>true&lt;/tt> return does not guarantee&#xA;     * that this thread will ever acquire a lock.  This method is&#xA;     * designed primarily for use in monitoring of the system state.&#xA;     *&#xA;     * @param thread the thread&#xA;     * @return true if the given thread is queued waiting for this lock.&#xA;     * @throws NullPointerException if thread is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.46"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getQueueLength">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an estimate of the number of threads waiting to acquire&#xA;     * either the read or write lock.  The value is only an estimate&#xA;     * because the number of threads may change dynamically while this&#xA;     * method traverses internal data structures.  This method is&#xA;     * designed for use in monitoring of the system state, not for&#xA;     * synchronization control.&#xA;     * @return the estimated number of threads waiting for this lock&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.47"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getQueuedThreads">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns a collection containing threads that may be waiting to&#xA;     * acquire either the read or write lock.  Because the actual set&#xA;     * of threads may change dynamically while constructing this&#xA;     * result, the returned collection is only a best-effort estimate.&#xA;     * The elements of the returned collection are in no particular&#xA;     * order.  This method is designed to facilitate construction of&#xA;     * subclasses that provide more extensive monitoring facilities.&#xA;     * @return the collection of threads&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.48"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hasWaiters">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="condition">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Condition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Queries whether any threads are waiting on the given condition&#xA;     * associated with the write lock. Note that because timeouts and&#xA;     * interrupts may occur at any time, a &lt;tt>true&lt;/tt> return does&#xA;     * not guarantee that a future &lt;tt>signal&lt;/tt> will awaken any&#xA;     * threads.  This method is designed primarily for use in&#xA;     * monitoring of the system state.&#xA;     * @param condition the condition&#xA;     * @return &lt;tt>true&lt;/tt> if there are any waiting threads.&#xA;     * @throws IllegalMonitorStateException if this lock &#xA;     * is not held&#xA;     * @throws IllegalArgumentException if the given condition is&#xA;     * not associated with this lock&#xA;     * @throws NullPointerException if condition null&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="not owner"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>AbstractQueuedSynchronizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.58"/>
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>AbstractQueuedSynchronizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getWaitQueueLength">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="condition">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Condition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an estimate of the number of threads waiting on the&#xA;     * given condition associated with the write lock. Note that because&#xA;     * timeouts and interrupts may occur at any time, the estimate&#xA;     * serves only as an upper bound on the actual number of waiters.&#xA;     * This method is designed for use in monitoring of the system&#xA;     * state, not for synchronization control.&#xA;     * @param condition the condition&#xA;     * @return the estimated number of waiting threads.&#xA;     * @throws IllegalMonitorStateException if this lock &#xA;     * is not held&#xA;     * @throws IllegalArgumentException if the given condition is&#xA;     * not associated with this lock&#xA;     * @throws NullPointerException if condition null&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="not owner"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>AbstractQueuedSynchronizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.59"/>
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>AbstractQueuedSynchronizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getWaitingThreads">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/Thread.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="condition">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Condition.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns a collection containing those threads that may be&#xA;     * waiting on the given condition associated with the write lock.&#xA;     * Because the actual set of threads may change dynamically while&#xA;     * constructing this result, the returned collection is only a&#xA;     * best-effort estimate. The elements of the returned collection&#xA;     * are in no particular order.  This method is designed to&#xA;     * facilitate construction of subclasses that provide more&#xA;     * extensive condition monitoring facilities.&#xA;     * @param condition the condition&#xA;     * @return the collection of threads&#xA;     * @throws IllegalMonitorStateException if this lock &#xA;     * is not held&#xA;     * @throws IllegalArgumentException if the given condition is&#xA;     * not associated with this lock&#xA;     * @throws NullPointerException if condition null&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="not owner"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>AbstractQueuedSynchronizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.60"/>
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>AbstractQueuedSynchronizer</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AbstractQueuedSynchronizer$ConditionObject.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string identifying this lock, as well as its lock state.&#xA;     * The state, in brackets, includes the String &amp;quot;Write locks =&amp;quot;&#xA;     * followed by the number of reentrantly held write locks, and the&#xA;     * String &amp;quot;Read locks =&amp;quot; followed by the number of held&#xA;     * read locks.&#xA;     * @return a string identifying this lock, as well as its lock state.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.13"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="w">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.0/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="r">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.0/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../lang/Object.class.xmi#//@classifiers.0/@members.6"/>
            </next>
            <self xsi:type="literals:Super"/>
          </children>
          <children xsi:type="references:StringReference" value="[Write locks = "/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.1/@variable"/>
          <children xsi:type="references:StringReference" value=", Read locks = "/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.2/@variable"/>
          <children xsi:type="references:StringReference" value="]"/>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * An implementation of {@link ReadWriteLock} supporting similar&#xA; * semantics to {@link ReentrantLock}.&#xA; * &lt;p>This class has the following properties:&#xA; *&#xA; * &lt;ul>&#xA; * &lt;li>&lt;b>Acquisition order&lt;/b>&#xA; *&#xA; * &lt;p> This class does not impose a reader or writer preference&#xA; * ordering for lock access.  However, it does support an optional&#xA; * &lt;em>fairness&lt;/em> policy.  When constructed as fair, threads&#xA; * contend for entry using an approximately arrival-order policy. When&#xA; * the write lock is released either the longest-waiting single writer&#xA; * will be assigned the write lock, or if there is a reader waiting&#xA; * longer than any writer, the set of readers will be assigned the&#xA; * read lock.  When constructed as non-fair, the order of entry to the&#xA; * lock need not be in arrival order.  In either case, if readers are&#xA; * active and a writer enters the lock then no subsequent readers will&#xA; * be granted the read lock until after that writer has acquired and&#xA; * released the write lock.&#xA; * &#xA; * &lt;li>&lt;b>Reentrancy&lt;/b>&#xA; * &lt;p>This lock allows both readers and writers to reacquire read or&#xA; * write locks in the style of a {@link ReentrantLock}. Readers are not&#xA; * allowed until all write locks held by the writing thread have been&#xA; * released.  &#xA; * &lt;p>Additionally, a writer can acquire the read lock - but not vice-versa.&#xA; * Among other applications, reentrancy can be useful when&#xA; * write locks are held during calls or callbacks to methods that&#xA; * perform reads under read locks. &#xA; * If a reader tries to acquire the write lock it will never succeed.&#xA; * &#xA; * &lt;li>&lt;b>Lock downgrading&lt;/b>&#xA; * &lt;p>Reentrancy also allows downgrading from the write lock to a read lock,&#xA; * by acquiring the write lock, then the read lock and then releasing the&#xA; * write lock. However, upgrading from a read lock to the write lock is&#xA; * &lt;b>not&lt;/b> possible.&#xA; *&#xA; * &lt;li>&lt;b>Interruption of lock acquisition&lt;/b>&#xA; * &lt;p>The read lock and write lock both support interruption during lock&#xA; * acquisition.&#xA; *&#xA; * &lt;li>&lt;b>{@link Condition} support&lt;/b>&#xA; * &lt;p>The write lock provides a {@link Condition} implementation that&#xA; * behaves in the same way, with respect to the write lock, as the &#xA; * {@link Condition} implementation provided by&#xA; * {@link ReentrantLock#newCondition} does for {@link ReentrantLock}.&#xA; * This {@link Condition} can, of course, only be used with the write lock.&#xA; * &lt;p>The read lock does not support a {@link Condition} and&#xA; * &lt;tt>readLock().newCondition()&lt;/tt> throws &#xA; * &lt;tt>UnsupportedOperationException&lt;/tt>.&#xA; *&#xA; * &lt;li>&lt;b>Instrumentation&lt;/b>&#xA; * &lt;P> This class supports methods to determine whether locks&#xA; * are held or contended. These methods are designed for monitoring&#xA; * system state, not for synchronization control.&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p> Serialization of this class behaves in the same way as built-in&#xA; * locks: a deserialized lock is in the unlocked state, regardless of&#xA; * its state when serialized.&#xA; *&#xA; * &lt;p>&lt;b>Sample usages&lt;/b>. Here is a code sketch showing how to exploit&#xA; * reentrancy to perform lock downgrading after updating a cache (exception&#xA; * handling is elided for simplicity):&#xA; * &lt;pre>&#xA; * class CachedData {&#xA; *   Object data;&#xA; *   volatile boolean cacheValid;&#xA; *   ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();&#xA; *&#xA; *   void processCachedData() {&#xA; *     rwl.readLock().lock();&#xA; *     if (!cacheValid) {&#xA; *        // upgrade lock manually&#xA; *        rwl.readLock().unlock();   // must unlock first to obtain writelock&#xA; *        rwl.writeLock().lock();&#xA; *        if (!cacheValid) { // recheck&#xA; *          data = ...&#xA; *          cacheValid = true;&#xA; *        }&#xA; *        // downgrade lock&#xA; *        rwl.readLock().lock();  // reacquire read without giving up write lock&#xA; *        rwl.writeLock().unlock(); // unlock write, still hold read&#xA; *     }&#xA; *&#xA; *     use(data);&#xA; *     rwl.readLock().unlock();&#xA; *   }&#xA; * }&#xA; * &lt;/pre>&#xA; *&#xA; * ReentrantReadWriteLocks can be used to improve concurrency in some&#xA; * uses of some kinds of Collections. This is typically worthwhile&#xA; * only when the collections are expected to be large, accessed by&#xA; * more reader threads than writer threads, and entail operations with&#xA; * overhead that outweighs synchronization overhead. For example, here&#xA; * is a class using a TreeMap that is expected to be large and &#xA; * concurrently accessed.&#xA; *&#xA; * &lt;pre>&#xA; * class RWDictionary {&#xA; *    private final Map&amp;lt;String, Data&amp;gt;  m = new TreeMap&amp;lt;String, Data&amp;gt;();&#xA; *    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();&#xA; *    private final Lock r = rwl.readLock();&#xA; *    private final Lock w = rwl.writeLock();&#xA; *&#xA; *    public Data get(String key) {&#xA; *        r.lock(); try { return m.get(key); } finally { r.unlock(); }&#xA; *    }&#xA; *    public String[] allKeys() {&#xA; *        r.lock(); try { return m.keySet().toArray(); } finally { r.unlock(); }&#xA; *    }&#xA; *    public Data put(String key, Data value) {&#xA; *        w.lock(); try { return m.put(key, value); } finally { w.unlock(); }&#xA; *    }&#xA; *    public void clear() {&#xA; *        w.lock(); try { m.clear(); } finally { w.unlock(); }&#xA; *    }&#xA; * }&#xA; * &lt;/pre>&#xA; * &#xA; *&#xA; * &lt;h3>Implementation Notes&lt;/h3>&#xA; *&#xA; * &lt;p>A reentrant write lock intrinsically defines an owner and can&#xA; * only be released by the thread that acquired it.  In contrast, in&#xA; * this implementation, the read lock has no concept of ownership, and&#xA; * there is no requirement that the thread releasing a read lock is&#xA; * the same as the one that acquired it.  However, this property is&#xA; * not guaranteed to hold in future implementations of this class.&#xA; *&#xA; * &lt;p> This lock supports a maximum of 65536 recursive write locks&#xA; * and 65536 read locks. Attempts to exceed these limits result in&#xA; * {@link Error} throws from locking methods.&#xA; *&#xA; * @since 1.5&#xA; * @author Doug Lea&#xA; *&#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="ReadWriteLock.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <namespaces>java</namespaces>
      <namespaces>io</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../../io/Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
