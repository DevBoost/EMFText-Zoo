<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../java.ecore#/4 http://www.emftext.org/java/members ../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../java.ecore#/11 http://www.emftext.org/java/types ../../../../java.ecore#/16" name="ReadWriteLock.java">
  <comments>/*&#xA; * @(#)ReadWriteLock.java&#x9;1.6 04/07/13&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <namespaces>concurrent</namespaces>
  <namespaces>locks</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="ReadWriteLock">
    <members xsi:type="members:InterfaceMethod" name="readLock">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns the lock used for reading.&#xA;     *&#xA;     * @return the lock used for reading.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="Lock.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeLock">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns the lock used for writing.&#xA;     *&#xA;     * @return the lock used for writing.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="Lock.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A &lt;tt>ReadWriteLock&lt;/tt> maintains a pair of associated {@link&#xA; * Lock locks}, one for read-only operations and one for writing.&#xA; * The {@link #readLock read lock} may be held simultaneously by&#xA; * multiple reader threads, so long as there are no writers.  The&#xA; * {@link #writeLock write lock} is exclusive.&#xA; * &#xA; * &lt;p>A read-write lock allows for a greater level of concurrency in&#xA; * accessing shared data than that permitted by a mutual exclusion lock.&#xA; * It exploits the fact that while only a single thread at a time (a&#xA; * &lt;em>writer&lt;/em> thread) can modify the shared data, in many cases any &#xA; * number of threads can concurrently read the data (hence &lt;em>reader&lt;/em>&#xA; * threads).&#xA; * In theory, the increase in concurrency permitted by the use of a read-write&#xA; * lock will lead to performance improvements over the use of a mutual&#xA; * exclusion lock. In practice this increase in concurrency will only be fully&#xA; * realized on a multi-processor, and then only if the access patterns for&#xA; * the shared data are suitable.&#xA; *&#xA; * &lt;p>Whether or not a read-write lock will improve performance over the use&#xA; * of a mutual exclusion lock depends on the frequency that the data is&#xA; * read compared to being modified, the duration of the read and write &#xA; * operations, and the contention for the data - that is, the number of&#xA; * threads that will try to read or write the data at the same time.&#xA; * For example, a collection that is initially populated with data and&#xA; * thereafter infrequently modified, while being frequently searched&#xA; * (such as a directory of some kind) is an ideal candidate for the use of&#xA; * a read-write lock. However, if updates become frequent then the data&#xA; * spends most of its time being exclusively locked and there is little, if any&#xA; * increase in concurrency. Further, if the read operations are too short&#xA; * the overhead of the read-write lock implementation (which is inherently&#xA; * more complex than a mutual exclusion lock) can dominate the execution&#xA; * cost, particularly as many read-write lock implementations still serialize&#xA; * all threads through a small section of code. Ultimately, only profiling&#xA; * and measurement will establish whether the use of a read-write lock is&#xA; * suitable for your application.&#xA; *&#xA; *&#xA; * &lt;p>Although the basic operation of a read-write lock is straight-forward,&#xA; * there are many policy decisions that an implementation must make, which&#xA; * may affect the effectiveness of the read-write lock in a given application.&#xA; * Examples of these policies include:&#xA; * &lt;ul>&#xA; * &lt;li>Determining whether to grant the read lock or the write lock, when&#xA; * both readers and writers are waiting, at the time that a writer releases&#xA; * the write lock. Writer preference is common, as writes are expected to be&#xA; * short and infrequent. Reader preference is less common as it can lead to&#xA; * lengthy delays for a write if the readers are frequent and long-lived as&#xA; * expected. Fair, or &amp;quot;in-order&amp;quot; implementations are also possible.&#xA; *&#xA; * &lt;li>Determining whether readers that request the read lock while a &#xA; * reader is active and a writer is waiting, are granted the read lock.&#xA; * Preference to the reader can delay the writer indefinitely, while&#xA; * preference to the writer can reduce the potential for concurrency.&#xA; *&#xA; * &lt;li>Determining whether the locks are reentrant: can a thread with the&#xA; * write lock reacquire it? Can it acquire a read lock while holding the&#xA; * write lock? Is the read lock itself reentrant?&#xA; *&#xA; * &lt;li>Can the write lock be downgraded to a read lock without allowing&#xA; * an intervening writer? Can a read lock be upgraded to a write lock,&#xA; * in preference to other waiting readers or writers?&#xA; *&#xA; * &lt;/ul>&#xA; * You should consider all of these things when evaluating the suitability&#xA; * of a given implementation for your application.&#xA; *&#xA; * @see ReentrantReadWriteLock&#xA; * @see Lock&#xA; * @see ReentrantLock&#xA; *&#xA; * @since 1.5&#xA; * @author Doug Lea&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
