<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="CountDownLatch.java">
  <comments>/*&#xA; * @(#)CountDownLatch.java&#x9;1.5 04/02/09&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <namespaces>concurrent</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <namespaces>concurrent</namespaces>
    <namespaces>locks</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <namespaces>concurrent</namespaces>
    <namespaces>atomic</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="CountDownLatch">
    <members xsi:type="classifiers:Class" name="Sync">
      <members xsi:type="members:Constructor" name="Sync">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="locks/AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.12"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@members.0/@parameters.0"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="count">
          <typeReference xsi:type="types:Int"/>
        </parameters>
      </members>
      <members xsi:type="members:ClassMethod" name="getCount">
        <typeReference xsi:type="types:Int"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="locks/AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="tryAcquireShared">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="acquires">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="locks/AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </child>
            <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <expressionElse xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </expressionElse>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="tryReleaseShared">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="releases">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:ForLoop">
          <comments>// Decrement count; signal when transition to zero</comments>
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="c">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="locks/AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.11"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral"/>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@members.3/@statements.0/@statement/@statements.0/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="nextc">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@members.3/@statements.0/@statement/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@members.3/@statements.0/@statement/@statements.2/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </returnValue>
              </statement>
              <condition xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="locks/AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.13"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@members.3/@statements.0/@statement/@statements.0/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@members.3/@statements.0/@statement/@statements.2/@variable"/>
              </condition>
            </statements>
          </statement>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Synchronization control For CountDownLatch.&#xA;     * Uses AQS state to represent count.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="locks/AbstractQueuedSynchronizer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </extends>
    </members>
    <members xsi:type="members:Field" name="sync">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="CountDownLatch">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="count &lt; 0"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a &lt;tt>CountDownLatch&lt;/tt> initialized with the given&#xA;     * count.&#xA;     * &#xA;     * @param count the number of times {@link #countDown} must be invoked&#xA;     * before threads can pass through {@link #await}.&#xA;     *&#xA;     * @throws IllegalArgumentException if &lt;tt>count&lt;/tt> is less than zero.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="await">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Causes the current thread to wait until the latch has counted down to &#xA;     * zero, unless the thread is {@link Thread#interrupt interrupted}.&#xA;     *&#xA;     * &lt;p>If the current {@link #getCount count} is zero then this method&#xA;     * returns immediately.&#xA;     * &lt;p>If the current {@link #getCount count} is greater than zero then&#xA;     * the current thread becomes disabled for thread scheduling &#xA;     * purposes and lies dormant until one of two things happen:&#xA;     * &lt;ul>&#xA;     * &lt;li>The count reaches zero due to invocations of the&#xA;     * {@link #countDown} method; or&#xA;     * &lt;li>Some other thread {@link Thread#interrupt interrupts} the current&#xA;     * thread.&#xA;     * &lt;/ul>&#xA;     * &lt;p>If the current thread:&#xA;     * &lt;ul>&#xA;     * &lt;li>has its interrupted status set on entry to this method; or &#xA;     * &lt;li>is {@link Thread#interrupt interrupted} while waiting, &#xA;     * &lt;/ul>&#xA;     * then {@link InterruptedException} is thrown and the current thread's &#xA;     * interrupted status is cleared. &#xA;     *&#xA;     * @throws InterruptedException if the current thread is interrupted&#xA;     * while waiting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="locks/AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.39"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="await">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeout">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="unit">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Enumeration" href="TimeUnit.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Causes the current thread to wait until the latch has counted down to &#xA;     * zero, unless the thread is {@link Thread#interrupt interrupted},&#xA;     * or the specified waiting time elapses.&#xA;     *&#xA;     * &lt;p>If the current {@link #getCount count} is zero then this method&#xA;     * returns immediately with the value &lt;tt>true&lt;/tt>.&#xA;     *&#xA;     * &lt;p>If the current {@link #getCount count} is greater than zero then&#xA;     * the current thread becomes disabled for thread scheduling &#xA;     * purposes and lies dormant until one of three things happen:&#xA;     * &lt;ul>&#xA;     * &lt;li>The count reaches zero due to invocations of the&#xA;     * {@link #countDown} method; or&#xA;     * &lt;li>Some other thread {@link Thread#interrupt interrupts} the current&#xA;     * thread; or&#xA;     * &lt;li>The specified waiting time elapses.&#xA;     * &lt;/ul>&#xA;     * &lt;p>If the count reaches zero then the method returns with the&#xA;     * value &lt;tt>true&lt;/tt>.&#xA;     * &lt;p>If the current thread:&#xA;     * &lt;ul>&#xA;     * &lt;li>has its interrupted status set on entry to this method; or &#xA;     * &lt;li>is {@link Thread#interrupt interrupted} while waiting, &#xA;     * &lt;/ul>&#xA;     * then {@link InterruptedException} is thrown and the current thread's &#xA;     * interrupted status is cleared. &#xA;     *&#xA;     * &lt;p>If the specified waiting time elapses then the value &lt;tt>false&lt;/tt>&#xA;     * is returned.&#xA;     * If the time is &#xA;     * less than or equal to zero, the method will not wait at all.&#xA;     *&#xA;     * @param timeout the maximum time to wait&#xA;     * @param unit the time unit of the &lt;tt>timeout&lt;/tt> argument.&#xA;     * @return &lt;tt>true&lt;/tt> if the count reached zero  and &lt;tt>false&lt;/tt>&#xA;     * if the waiting time elapsed before the count reached zero.&#xA;     *&#xA;     * @throws InterruptedException if the current thread is interrupted&#xA;     * while waiting.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="locks/AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.40"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="TimeUnit.class.xmi#//@classifiers.0/@members.9"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
              </next>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="countDown">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Decrements the count of the latch, releasing all waiting threads if&#xA;     * the count reaches zero.&#xA;     * &lt;p>If the current {@link #getCount count} is greater than zero then&#xA;     * it is decremented. If the new count is zero then all waiting threads&#xA;     * are re-enabled for thread scheduling purposes.&#xA;     * &lt;p>If the current {@link #getCount count} equals zero then nothing&#xA;     * happens.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="locks/AbstractQueuedSynchronizer.class.xmi#//@classifiers.0/@members.41"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCount">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current count.&#xA;     * &lt;p>This method is typically used for debugging and testing purposes.&#xA;     * @return the current count.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.0/@members.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string identifying this latch, as well as its state.&#xA;     * The state, in brackets, includes the String &#xA;     * &amp;quot;Count =&amp;quot; followed by the current count.&#xA;     * @return a string identifying this latch, as well as its&#xA;     * state&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Object.class.xmi#//@classifiers.0/@members.6"/>
            </next>
            <self xsi:type="literals:Super"/>
          </children>
          <children xsi:type="references:StringReference" value="[Count = "/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.0/@members.1"/>
          </children>
          <children xsi:type="references:StringReference" value="]"/>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A synchronization aid that allows one or more threads to wait until&#xA; * a set of operations being performed in other threads completes.&#xA; *&#xA; * &lt;p>A &lt;tt>CountDownLatch&lt;/tt> is initialized with a given&#xA; * &lt;em>count&lt;/em>.  The {@link #await await} methods block until the current&#xA; * {@link #getCount count} reaches zero due to invocations of the&#xA; * {@link #countDown} method, after which all waiting threads are&#xA; * released and any subsequent invocations of {@link #await await} return&#xA; * immediately. This is a one-shot phenomenon -- the count cannot be&#xA; * reset.  If you need a version that resets the count, consider using&#xA; * a {@link CyclicBarrier}.&#xA; *&#xA; * &lt;p>A &lt;tt>CountDownLatch&lt;/tt> is a versatile synchronization tool&#xA; * and can be used for a number of purposes.  A&#xA; * &lt;tt>CountDownLatch&lt;/tt> initialized with a count of one serves as a&#xA; * simple on/off latch, or gate: all threads invoking {@link #await await}&#xA; * wait at the gate until it is opened by a thread invoking {@link&#xA; * #countDown}.  A &lt;tt>CountDownLatch&lt;/tt> initialized to &lt;em>N&lt;/em>&#xA; * can be used to make one thread wait until &lt;em>N&lt;/em> threads have&#xA; * completed some action, or some action has been completed N times.&#xA; * &lt;p>A useful property of a &lt;tt>CountDownLatch&lt;/tt> is that it&#xA; * doesn't require that threads calling &lt;tt>countDown&lt;/tt> wait for&#xA; * the count to reach zero before proceeding, it simply prevents any&#xA; * thread from proceeding past an {@link #await await} until all&#xA; * threads could pass.&#xA; *&#xA; * &lt;p>&lt;b>Sample usage:&lt;/b> Here is a pair of classes in which a group&#xA; * of worker threads use two countdown latches:&#xA; * &lt;ul>&#xA; * &lt;li>The first is a start signal that prevents any worker from proceeding&#xA; * until the driver is ready for them to proceed;&#xA; * &lt;li>The second is a completion signal that allows the driver to wait&#xA; * until all workers have completed.&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;pre>&#xA; * class Driver { // ...&#xA; *   void main() throws InterruptedException {&#xA; *     CountDownLatch startSignal = new CountDownLatch(1);&#xA; *     CountDownLatch doneSignal = new CountDownLatch(N);&#xA; *&#xA; *     for (int i = 0; i &lt; N; ++i) // create and start threads&#xA; *       new Thread(new Worker(startSignal, doneSignal)).start();&#xA; *&#xA; *     doSomethingElse();            // don't let run yet&#xA; *     startSignal.countDown();      // let all threads proceed&#xA; *     doSomethingElse();&#xA; *     doneSignal.await();           // wait for all to finish&#xA; *   }&#xA; * }&#xA; *&#xA; * class Worker implements Runnable {&#xA; *   private final CountDownLatch startSignal;&#xA; *   private final CountDownLatch doneSignal;&#xA; *   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {&#xA; *      this.startSignal = startSignal;&#xA; *      this.doneSignal = doneSignal;&#xA; *   }&#xA; *   public void run() {&#xA; *      try {&#xA; *        startSignal.await();&#xA; *        doWork();&#xA; *        doneSignal.countDown();&#xA; *      } catch (InterruptedException ex) {} // return;&#xA; *   }&#xA; *&#xA; *   void doWork() { ... }&#xA; * }&#xA; *&#xA; * &lt;/pre>&#xA; *&#xA; * &lt;p>Another typical usage would be to divide a problem into N parts,&#xA; * describe each part with a Runnable that executes that portion and&#xA; * counts down on the latch, and queue all the Runnables to an&#xA; * Executor.  When all sub-parts are complete, the coordinating thread&#xA; * will be able to pass through await. (When threads must repeatedly&#xA; * count down in this way, instead use a {@link CyclicBarrier}.)&#xA; *&#xA; * &lt;pre>&#xA; * class Driver2 { // ...&#xA; *   void main() throws InterruptedException {&#xA; *     CountDownLatch doneSignal = new CountDownLatch(N);&#xA; *     Executor e = ...&#xA; *&#xA; *     for (int i = 0; i &lt; N; ++i) // create and start threads&#xA; *       e.execute(new WorkerRunnable(doneSignal, i));&#xA; *&#xA; *     doneSignal.await();           // wait for all to finish&#xA; *   }&#xA; * }&#xA; *&#xA; * class WorkerRunnable implements Runnable {&#xA; *   private final CountDownLatch doneSignal;&#xA; *   private final int i;&#xA; *   WorkerRunnable(CountDownLatch doneSignal, int i) {&#xA; *      this.doneSignal = doneSignal;&#xA; *      this.i = i;&#xA; *   }&#xA; *   public void run() {&#xA; *      try {&#xA; *        doWork(i);&#xA; *        doneSignal.countDown();&#xA; *      } catch (InterruptedException ex) {} // return;&#xA; *   }&#xA; *&#xA; *   void doWork() { ... }&#xA; * }&#xA; *&#xA; * &lt;/pre>&#xA; *&#xA; * @since 1.5&#xA; * @author Doug Lea&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
