<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="Future.java">
  <comments>/*&#xA; * @(#)Future.java&#x9;1.6 04/02/09&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <namespaces>concurrent</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Future">
    <typeParameters name="V"/>
    <members xsi:type="members:InterfaceMethod" name="cancel">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Attempts to cancel execution of this task.  This attempt will&#xA;     * fail if the task has already completed, already been cancelled,&#xA;     * or could not be cancelled for some other reason. If successful,&#xA;     * and this task has not started when &lt;tt>cancel&lt;/tt> is called,&#xA;     * this task should never run.  If the task has already started,&#xA;     * then the &lt;tt>mayInterruptIfRunning&lt;/tt> parameter determines&#xA;     * whether the thread executing this task should be interrupted in&#xA;     * an attempt to stop the task.&#xA;     *&#xA;     * @param mayInterruptIfRunning &lt;tt>true&lt;/tt> if the thread executing this&#xA;     * task should be interrupted; otherwise, in-progress tasks are allowed&#xA;     * to complete&#xA;     * @return &lt;tt>false&lt;/tt> if the task could not be cancelled,&#xA;     * typically because it has already completed normally;&#xA;     * &lt;tt>true&lt;/tt> otherwise&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mayInterruptIfRunning">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isCancelled">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this task was cancelled before it completed&#xA;     * normally.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if task was cancelled before it completed&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isDone">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this task completed.  &#xA;     *&#xA;     * Completion may be due to normal termination, an exception, or&#xA;     * cancellation -- in all of these cases, this method will return&#xA;     * &lt;tt>true&lt;/tt>.&#xA;     * &#xA;     * @return &lt;tt>true&lt;/tt> if this task completed.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0">
          <comments>/**&#xA;     * Waits if necessary for the computation to complete, and then&#xA;     * retrieves its result.&#xA;     *&#xA;     * @return the computed result&#xA;     * @throws CancellationException if the computation was cancelled&#xA;     * @throws ExecutionException if the computation threw an&#xA;     * exception&#xA;     * @throws InterruptedException if the current thread was interrupted&#xA;     * while waiting&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ExecutionException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0">
          <comments>/**&#xA;     * Waits if necessary for at most the given time for the computation&#xA;     * to complete, and then retrieves its result, if available.&#xA;     *&#xA;     * @param timeout the maximum time to wait&#xA;     * @param unit the time unit of the timeout argument&#xA;     * @return the computed result&#xA;     * @throws CancellationException if the computation was cancelled&#xA;     * @throws ExecutionException if the computation threw an&#xA;     * exception&#xA;     * @throws InterruptedException if the current thread was interrupted&#xA;     * while waiting&#xA;     * @throws TimeoutException if the wait timed out&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeout">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="unit">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Enumeration" href="TimeUnit.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ExecutionException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TimeoutException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A &lt;tt>Future&lt;/tt> represents the result of an asynchronous&#xA; * computation.  Methods are provided to check if the computation is&#xA; * complete, to wait for its completion, and to retrieve the result of&#xA; * the computation.  The result can only be retrieved using method&#xA; * &lt;tt>get&lt;/tt> when the computation has completed, blocking if&#xA; * necessary until it is ready.  Cancellation is performed by the&#xA; * &lt;tt>cancel&lt;/tt> method.  Additional methods are provided to&#xA; * determine if the task completed normally or was cancelled. Once a&#xA; * computation has completed, the computation cannot be cancelled.&#xA; * If you would like to use a &lt;tt>Future&lt;/tt> for the sake&#xA; * of cancellability but not provide a usable result, you can&#xA; * declare types of the form &lt;tt>Future&amp;lt;?&amp;gt;&lt;/tt> and&#xA; * return &lt;tt>null&lt;/tt> as a result of the underlying task.&#xA; *&#xA; * &lt;p>&#xA; * &lt;b>Sample Usage&lt;/b> (Note that the following classes are all&#xA; * made-up.) &lt;p>&#xA; * &lt;pre>&#xA; * interface ArchiveSearcher { String search(String target); }&#xA; * class App {&#xA; *   ExecutorService executor = ...&#xA; *   ArchiveSearcher searcher = ...&#xA; *   void showSearch(final String target) throws InterruptedException {&#xA; *     Future&amp;lt;String&amp;gt; future = executor.submit(new Callable&amp;lt;String&amp;gt;() {&#xA; *         public String call() { return searcher.search(target); }&#xA; *     });&#xA; *     displayOtherThings(); // do other things while searching&#xA; *     try {&#xA; *       displayText(future.get()); // use future&#xA; *     } catch (ExecutionException ex) { cleanup(); return; }&#xA; *   }&#xA; * }&#xA; * &lt;/pre>&#xA; *&#xA; * The {@link FutureTask} class is an implementation of &lt;tt>Future&lt;/tt> that &#xA; * implements &lt;tt>Runnable&lt;/tt>, and so may be executed by an &lt;tt>Executor&lt;/tt>. &#xA; * For example, the above construction with &lt;tt>submit&lt;/tt> could be replaced by:&#xA; * &lt;pre>&#xA; *     FutureTask&amp;lt;String&amp;gt; future =&#xA; *       new FutureTask&amp;lt;String&amp;gt;(new Callable&amp;lt;String&amp;gt;() {&#xA; *         public String call() {&#xA; *           return searcher.search(target);&#xA; *       }});&#xA; *     executor.execute(future);&#xA; * &lt;/pre>&#xA; * @see FutureTask&#xA; * @see Executor&#xA; * @since 1.5&#xA; * @author Doug Lea&#xA; * @param &lt;V> The result type returned by this Future's &lt;tt>get&lt;/tt> method&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
