<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="BlockingQueue.java">
  <comments>/*&#xA; * @(#)BlockingQueue.java&#x9;1.8 04/07/12&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <namespaces>concurrent</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../Collection.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../Queue.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="BlockingQueue">
    <typeParameters name="E"/>
    <members xsi:type="members:InterfaceMethod" name="offer">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Inserts the specified element into this queue, if possible.  When&#xA;     * using queues that may impose insertion restrictions (for&#xA;     * example capacity bounds), method &lt;tt>offer&lt;/tt> is generally&#xA;     * preferable to method {@link Collection#add}, which can fail to&#xA;     * insert an element only by throwing an exception.&#xA;     *&#xA;     * @param o the element to add.&#xA;     * @return &lt;tt>true&lt;/tt> if it was possible to add the element to&#xA;     *         this queue, else &lt;tt>false&lt;/tt>&#xA;     * @throws NullPointerException if the specified element is &lt;tt>null&lt;/tt>&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="offer">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Inserts the specified element into this queue, waiting if necessary&#xA;     * up to the specified wait time for space to become available.&#xA;     * @param o the element to add&#xA;     * @param timeout how long to wait before giving up, in units of&#xA;     * &lt;tt>unit&lt;/tt>&#xA;     * @param unit a &lt;tt>TimeUnit&lt;/tt> determining how to interpret the&#xA;     * &lt;tt>timeout&lt;/tt> parameter&#xA;     * @return &lt;tt>true&lt;/tt> if successful, or &lt;tt>false&lt;/tt> if&#xA;     * the specified waiting time elapses before space is available.&#xA;     * @throws InterruptedException if interrupted while waiting.&#xA;     * @throws NullPointerException if the specified element is &lt;tt>null&lt;/tt>.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeout">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="unit">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Enumeration" href="TimeUnit.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="poll">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0">
          <comments>/**&#xA;     * Retrieves and removes the head of this queue, waiting&#xA;     * if necessary up to the specified wait time if no elements are&#xA;     * present on this queue.&#xA;     * @param timeout how long to wait before giving up, in units of&#xA;     * &lt;tt>unit&lt;/tt>&#xA;     * @param unit a &lt;tt>TimeUnit&lt;/tt> determining how to interpret the&#xA;     * &lt;tt>timeout&lt;/tt> parameter&#xA;     * @return the head of this queue, or &lt;tt>null&lt;/tt> if the&#xA;     * specified waiting time elapses before an element is present.&#xA;     * @throws InterruptedException if interrupted while waiting.&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeout">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="unit">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Enumeration" href="TimeUnit.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="take">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0">
          <comments>/**&#xA;     * Retrieves and removes the head of this queue, waiting&#xA;     * if no elements are present on this queue.&#xA;     * @return the head of this queue&#xA;     * @throws InterruptedException if interrupted while waiting.&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="put">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Adds the specified element to this queue, waiting if necessary for&#xA;     * space to become available.&#xA;     * @param o the element to add&#xA;     * @throws InterruptedException if interrupted while waiting.&#xA;     * @throws NullPointerException if the specified element is &lt;tt>null&lt;/tt>.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="remainingCapacity">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Returns the number of elements that this queue can ideally (in&#xA;     * the absence of memory or resource constraints) accept without&#xA;     * blocking, or &lt;tt>Integer.MAX_VALUE&lt;/tt> if there is no&#xA;     * intrinsic limit.&#xA;     * &lt;p>Note that you &lt;em>cannot&lt;/em> always tell if&#xA;     * an attempt to &lt;tt>add&lt;/tt> an element will succeed by&#xA;     * inspecting &lt;tt>remainingCapacity&lt;/tt> because it may be the&#xA;     * case that another thread is about to &lt;tt>put&lt;/tt> or &lt;tt>take&lt;/tt> an&#xA;     * element.&#xA;     * @return the remaining capacity&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="add">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Adds the specified element to this queue if it is possible to&#xA;     * do so immediately, returning &lt;tt>true&lt;/tt> upon success, else&#xA;     * throwing an IllegalStateException.  &#xA;     * @param o the element&#xA;     * @return &lt;tt>true&lt;/tt> (as per the general contract of&#xA;     *         &lt;tt>Collection.add&lt;/tt>).&#xA;     *&#xA;     * @throws NullPointerException if the specified element is &lt;tt>null&lt;/tt>&#xA;     * @throws IllegalStateException if element cannot be added&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drainTo">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Removes all available elements from this queue and adds them&#xA;     * into the given collection.  This operation may be more&#xA;     * efficient than repeatedly polling this queue.  A failure&#xA;     * encountered while attempting to &lt;tt>add&lt;/tt> elements to&#xA;     * collection &lt;tt>c&lt;/tt> may result in elements being in neither,&#xA;     * either or both collections when the associated exception is&#xA;     * thrown. Attempts to drain a queue to itself result in&#xA;     * &lt;tt>IllegalArgumentException&lt;/tt>. Further, the behavior of&#xA;     * this operation is undefined if the specified collection is&#xA;     * modified while the operation is in progress.&#xA;     *&#xA;     * @param c the collection to transfer elements into&#xA;     * @return the number of elements transferred.&#xA;     * @throws NullPointerException if c is null&#xA;     * @throws IllegalArgumentException if c is this queue&#xA;     * &#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:SuperTypeArgument">
              <superType xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </superType>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drainTo">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Removes at most the given number of available elements from&#xA;     * this queue and adds them into the given collection.  A failure&#xA;     * encountered while attempting to &lt;tt>add&lt;/tt> elements to&#xA;     * collection &lt;tt>c&lt;/tt> may result in elements being in neither,&#xA;     * either or both collections when the associated exception is&#xA;     * thrown. Attempts to drain a queue to itself result in&#xA;     * &lt;tt>IllegalArgumentException&lt;/tt>. Further, the behavior of&#xA;     * this operation is undefined if the specified collection is&#xA;     * modified while the operation is in progress.&#xA;     *&#xA;     * @param c the collection to transfer elements into&#xA;     * @param maxElements the maximum number of elements to transfer&#xA;     * @return the number of elements transferred.&#xA;     * @throws NullPointerException if c is null&#xA;     * @throws IllegalArgumentException if c is this queue&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:SuperTypeArgument">
              <superType xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </superType>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="maxElements">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A {@link java.util.Queue} that additionally supports operations&#xA; * that wait for the queue to become non-empty when retrieving an element,&#xA; * and wait for space to become available in the queue when storing an &#xA; * element.&#xA; *&#xA; * &lt;p>A &lt;tt>BlockingQueue&lt;/tt> does not accept &lt;tt>null&lt;/tt> elements.&#xA; * Implementations throw &lt;tt>NullPointerException&lt;/tt> on attempts&#xA; * to &lt;tt>add&lt;/tt>, &lt;tt>put&lt;/tt> or &lt;tt>offer&lt;/tt> a &lt;tt>null&lt;/tt>.  A&#xA; * &lt;tt>null&lt;/tt> is used as a sentinel value to indicate failure of&#xA; * &lt;tt>poll&lt;/tt> operations.&#xA; *&#xA; * &lt;p>A &lt;tt>BlockingQueue&lt;/tt> may be capacity bounded. At any given&#xA; * time it may have a &lt;tt>remainingCapacity&lt;/tt> beyond which no&#xA; * additional elements can be &lt;tt>put&lt;/tt> without blocking.&#xA; * A &lt;tt>BlockingQueue&lt;/tt> without any intrinsic capacity constraints always&#xA; * reports a remaining capacity of &lt;tt>Integer.MAX_VALUE&lt;/tt>.&#xA; *&#xA; * &lt;p> &lt;tt>BlockingQueue&lt;/tt> implementations are designed to be used&#xA; * primarily for producer-consumer queues, but additionally support&#xA; * the {@link java.util.Collection} interface.  So, for example, it is&#xA; * possible to remove an arbitrary element from a queue using&#xA; * &lt;tt>remove(x)&lt;/tt>. However, such operations are in general&#xA; * &lt;em>not&lt;/em> performed very efficiently, and are intended for only&#xA; * occasional use, such as when a queued message is cancelled.&#xA; *&#xA; * &lt;p> &lt;tt>BlockingQueue&lt;/tt> implementations are thread-safe.  All&#xA; * queuing methods achieve their effects atomically using internal&#xA; * locks or other forms of concurrency control. However, the&#xA; * &lt;em>bulk&lt;/em> Collection operations &lt;tt>addAll&lt;/tt>,&#xA; * &lt;tt>containsAll&lt;/tt>, &lt;tt>retainAll&lt;/tt> and &lt;tt>removeAll&lt;/tt> are&#xA; * &lt;em>not&lt;/em> necessarily performed atomically unless specified&#xA; * otherwise in an implementation. So it is possible, for example, for&#xA; * &lt;tt>addAll(c)&lt;/tt> to fail (throwing an exception) after adding&#xA; * only some of the elements in &lt;tt>c&lt;/tt>.&#xA; *&#xA; * &lt;p>A &lt;tt>BlockingQueue&lt;/tt> does &lt;em>not&lt;/em> intrinsically support&#xA; * any kind of &amp;quot;close&amp;quot; or &amp;quot;shutdown&amp;quot; operation to&#xA; * indicate that no more items will be added.  The needs and usage of&#xA; * such features tend to be implementation-dependent. For example, a&#xA; * common tactic is for producers to insert special&#xA; * &lt;em>end-of-stream&lt;/em> or &lt;em>poison&lt;/em> objects, that are&#xA; * interpreted accordingly when taken by consumers.&#xA; *&#xA; * &lt;p>&#xA; * Usage example, based on a typical producer-consumer scenario.&#xA; * Note that a &lt;tt>BlockingQueue&lt;/tt> can safely be used with multiple&#xA; * producers and multiple consumers.&#xA; * &lt;pre>&#xA; * class Producer implements Runnable {&#xA; *   private final BlockingQueue queue;&#xA; *   Producer(BlockingQueue q) { queue = q; }&#xA; *   public void run() {&#xA; *     try {&#xA; *       while(true) { queue.put(produce()); }&#xA; *     } catch (InterruptedException ex) { ... handle ...}&#xA; *   }&#xA; *   Object produce() { ... }&#xA; * }&#xA; *&#xA; * class Consumer implements Runnable {&#xA; *   private final BlockingQueue queue;&#xA; *   Consumer(BlockingQueue q) { queue = q; }&#xA; *   public void run() {&#xA; *     try {&#xA; *       while(true) { consume(queue.take()); }&#xA; *     } catch (InterruptedException ex) { ... handle ...}&#xA; *   }&#xA; *   void consume(Object x) { ... }&#xA; * }&#xA; *&#xA; * class Setup {&#xA; *   void main() {&#xA; *     BlockingQueue q = new SomeQueueImplementation();&#xA; *     Producer p = new Producer(q);&#xA; *     Consumer c1 = new Consumer(q);&#xA; *     Consumer c2 = new Consumer(q);&#xA; *     new Thread(p).start();&#xA; *     new Thread(c1).start();&#xA; *     new Thread(c2).start();&#xA; *   }&#xA; * }&#xA; * &lt;/pre>&#xA; *&#xA; * &lt;p>This interface is a member of the&#xA; * &lt;a href=&quot;{@docRoot}/../guide/collections/index.html&quot;>&#xA; * Java Collections Framework&lt;/a>.&#xA; *  &#xA; * @since 1.5&#xA; * @author Doug Lea&#xA; * @param &lt;E> the type of elements held in this collection&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="../Queue.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
