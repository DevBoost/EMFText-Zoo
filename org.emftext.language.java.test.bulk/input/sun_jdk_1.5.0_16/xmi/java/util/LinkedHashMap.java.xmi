<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="LinkedHashMap.java">
  <comments>/*&#xA; * @(#)LinkedHashMap.java&#x9;1.18 04/02/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="LinkedHashMap">
    <typeParameters name="K"/>
    <typeParameters name="V"/>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="3801124242820219131"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="header">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.13">
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
            </typeReference>
          </typeArguments>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The head of the doubly linked list.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="accessOrder">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The iteration ordering method for this linked hash map: &lt;tt>true&lt;/tt>&#xA;     * for access-order, &lt;tt>false&lt;/tt> for insertion-order.&#xA;     *&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="LinkedHashMap">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.1"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="initialCapacity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="loadFactor">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs an empty insertion-ordered &lt;tt>LinkedHashMap&lt;/tt> instance&#xA;     * with the specified initial capacity and load factor.&#xA;     *&#xA;     * @param  initialCapacity the initial capacity.&#xA;     * @param  loadFactor      the load factor.&#xA;     * @throws IllegalArgumentException if the initial capacity is negative&#xA;     *         or the load factor is nonpositive.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="LinkedHashMap">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="initialCapacity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs an empty insertion-ordered &lt;tt>LinkedHashMap&lt;/tt> instance&#xA;     * with the specified initial capacity and a default load factor (0.75). &#xA;     *&#xA;     * @param  initialCapacity the initial capacity.&#xA;     * @throws IllegalArgumentException if the initial capacity is negative.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="LinkedHashMap">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs an empty insertion-ordered &lt;tt>LinkedHashMap&lt;/tt> instance&#xA;     * with a default capacity (16) and load factor (0.75).&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="LinkedHashMap">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="m">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </extendTypes>
            </typeArguments>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="Map.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs an insertion-ordered &lt;tt>LinkedHashMap&lt;/tt> instance with&#xA;     * the same mappings as the specified map.  The &lt;tt>LinkedHashMap&lt;/tt>&#xA;     * instance is created with a a default load factor (0.75) and an initial&#xA;     * capacity sufficient to hold the mappings in the specified map.&#xA;     *&#xA;     * @param  m the map whose mappings are to be placed in this map.&#xA;     * @throws NullPointerException if the specified map is null.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="LinkedHashMap">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.1"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.2"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="initialCapacity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="loadFactor">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="accessOrder">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs an empty &lt;tt>LinkedHashMap&lt;/tt> instance with the&#xA;     * specified initial capacity, load factor and ordering mode.&#xA;     *&#xA;     * @param  initialCapacity the initial capacity.&#xA;     * @param  loadFactor      the load factor.&#xA;     * @param  accessOrder     the ordering mode - &lt;tt>true&lt;/tt> for&#xA;     *         access-order, &lt;tt>false&lt;/tt> for insertion-order.&#xA;     * @throws IllegalArgumentException if the initial capacity is negative&#xA;     *         or the load factor is nonpositive.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="init">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Called by superclass constructors and pseudoconstructors (clone,&#xA;     * readObject) before any entries are inserted into the map.  Initializes&#xA;     * the chain.&#xA;     */</comments>
      </typeReference>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.13">
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                  </typeReference>
                </typeArguments>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
                  </typeReference>
                </typeArguments>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arguments>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="literals:NullLiteral"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="transfer">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Transfer all entries to new table array.  This method is called&#xA;     * by superclass resize.  It is overridden for performance, as it is&#xA;     * faster to iterate using our linked list.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newTable">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>HashMap</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="HashMap$Entry.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newCapacity">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="index">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="HashMap.class.xmi#//@classifiers.0/@members.24"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@init">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="HashMap$Entry.class.xmi#//@classifiers.0/@members.2"/>
                  </next>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@init">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="HashMap$Entry.class.xmi#//@classifiers.0/@members.3"/>
                </next>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@statement/@statements.0/@variable"/>
                </arraySelectors>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@statement/@statements.0/@variable"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@init"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="e">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.13">
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
                </typeReference>
              </typeArguments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
          </initialValue>
        </init>
        <updates xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@init"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@init">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
          </value>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="containsValue">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this map maps one or more keys to the&#xA;     * specified value.&#xA;     *&#xA;     * @param value value whose presence in this map is to be tested.&#xA;     * @return &lt;tt>true&lt;/tt> if this map maps one or more keys to the&#xA;     *         specified value.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// Overridden to take advantage of faster iterator</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.0/@init">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="HashMap$Entry.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                </children>
                <children xsi:type="literals:NullLiteral"/>
              </condition>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.0/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="e">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.13"/>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
              </initialValue>
            </init>
            <updates xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.0/@init"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.0/@init">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
              </value>
            </updates>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
              </statement>
              <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.4"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.0/@init">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="HashMap$Entry.class.xmi#//@classifiers.0/@members.1"/>
                    </next>
                  </arguments>
                </next>
              </condition>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.0/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="e">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.13"/>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
              </initialValue>
            </init>
            <updates xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.0/@init"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@elseStatement/@statements.0/@init">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
              </value>
            </updates>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value to which this map maps the specified key.  Returns&#xA;     * &lt;tt>null&lt;/tt> if the map contains no mapping for this key.  A return&#xA;     * value of &lt;tt>null&lt;/tt> does not &lt;i>necessarily&lt;/i> indicate that the&#xA;     * map contains no mapping for the key; it's also possible that the map&#xA;     * explicitly maps the key to &lt;tt>null&lt;/tt>.  The &lt;tt>containsKey&lt;/tt>&#xA;     * operation may be used to distinguish these two cases.&#xA;     *&#xA;     * @return the value to which this map maps the specified key.&#xA;     * @param key key whose associated value is to be returned.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="e">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.13">
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
                </typeReference>
              </typeArguments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.13">
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                  </typeReference>
                </typeArguments>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
                  </typeReference>
                </typeArguments>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="HashMap.class.xmi#//@classifiers.0/@members.30"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:NullLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.0/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.4">
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.0/@variable">
          <next xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="HashMap$Entry.class.xmi#//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clear">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes all mappings from this map.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="HashMap.class.xmi#//@classifiers.0/@members.41"/>
          </next>
          <self xsi:type="literals:Super"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="classifiers:Class" name="Entry">
      <typeParameters name="K"/>
      <typeParameters name="V"/>
      <members xsi:type="members:Field" name="before">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.13">
            <comments>// These fields comprise the doubly linked list used for iteration.</comments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.1"/>
              </typeReference>
            </typeArguments>
          </classifierReferences>
        </typeReference>
        <additionalFields name="after"/>
      </members>
      <members xsi:type="members:Constructor" name="Entry">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1/@parameters.3"/>
            <callTarget xsi:type="literals:Super"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="hash">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="key">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.0"/>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="value">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.1"/>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="next">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <namespaces>HashMap</namespaces>
            <classifierReferences>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.1"/>
                </typeReference>
              </typeArguments>
              <target xsi:type="classifiers:Class" href="HashMap$Entry.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
      </members>
      <members xsi:type="members:ClassMethod" name="remove">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>/**&#xA;         * Remove this entry from the linked list.&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="addBefore">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="existingEntry">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.13">
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.1"/>
                </typeReference>
              </typeArguments>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>/**                                             &#xA;         * Insert this entry before the specified existing entry in the list.&#xA;         */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.3/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </value>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="recordAccess">
        <typeReference xsi:type="types:Void">
          <comments>/**&#xA;         * This method is invoked by the superclass whenever the value&#xA;         * of a pre-existing entry is read by Map.get or modified by Map.set.&#xA;         * If the enclosing Map is access-ordered, it moves the entry&#xA;         * to the end of the list; otherwise, it does nothing. &#xA;         */</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="m">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.1"/>
                </typeReference>
              </typeArguments>
              <target xsi:type="classifiers:Class" href="HashMap.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="lm">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0">
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.0"/>
                  </typeReference>
                </typeArguments>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.1"/>
                  </typeReference>
                </typeArguments>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0">
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.0"/>
                    </typeReference>
                  </typeArguments>
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.1"/>
                    </typeReference>
                  </typeArguments>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@parameters.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@statements.0/@variable">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="HashMap.class.xmi#//@classifiers.0/@members.7"/>
                  </next>
                </child>
                <operator xsi:type="operators:PlusPlus"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.2"/>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.3">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@statements.0/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                </arguments>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </condition>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="recordRemoval">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="m">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.1"/>
                </typeReference>
              </typeArguments>
              <target xsi:type="classifiers:Class" href="HashMap.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.2"/>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * LinkedHashMap entry.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <namespaces>HashMap</namespaces>
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.13/@typeParameters.1"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Class" href="HashMap$Entry.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="LinkedHashIterator">
      <typeParameters name="T"/>
      <members xsi:type="members:Field" name="nextEntry">
        <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.13">
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
              </typeReference>
            </typeArguments>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="lastReturned">
        <initialValue xsi:type="literals:NullLiteral"/>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.13">
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
              </typeReference>
            </typeArguments>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="expectedModCount">
        <initialValue xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="HashMap.class.xmi#//@classifiers.0/@members.7"/>
        </initialValue>
        <typeReference xsi:type="types:Int">
          <comments>/**&#xA;&#x9; * The modCount value that the iterator believes that the backing&#xA;&#x9; * List should have.  If this expectation is violated, the iterator&#xA;&#x9; * has detected concurrent modification.&#xA;&#x9; */</comments>
        </typeReference>
      </members>
      <members xsi:type="members:ClassMethod" name="hasNext">
        <typeReference xsi:type="types:Boolean"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="remove">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.1"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="ConcurrentModificationException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="HashMap.class.xmi#//@classifiers.0/@members.7"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.2"/>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0">
            <next xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="HashMap.class.xmi#//@classifiers.0/@members.38"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.1">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="HashMap$Entry.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                </arguments>
              </next>
              <self xsi:type="literals:This"/>
            </next>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.1"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:NullLiteral"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.2"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="HashMap.class.xmi#//@classifiers.0/@members.7"/>
            </value>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="nextEntry">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.13">
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
              </typeReference>
            </typeArguments>
          </classifierReferences>
        </typeReference>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="ConcurrentModificationException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="HashMap.class.xmi#//@classifiers.0/@members.7"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.2"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="NoSuchElementException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.13">
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                  </typeReference>
                </typeArguments>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
                  </typeReference>
                </typeArguments>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.5/@statements.2/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.5/@statements.2/@variable"/>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
      <implements xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.14/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </implements>
    </members>
    <members xsi:type="classifiers:Class" name="KeyIterator">
      <members xsi:type="members:ClassMethod" name="next">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.14/@members.5">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="HashMap$Entry.class.xmi#//@classifiers.0/@members.5"/>
            </next>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.14">
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
        </classifierReferences>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="ValueIterator">
      <members xsi:type="members:ClassMethod" name="next">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.14/@members.5">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="HashMap$Entry.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </returnValue>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.14">
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
            </typeReference>
          </typeArguments>
        </classifierReferences>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="EntryIterator">
      <members xsi:type="members:ClassMethod" name="next">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>Map</namespaces>
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="Map$Entry.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.14/@members.5"/>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.14">
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <namespaces>Map</namespaces>
              <classifierReferences>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                  </typeReference>
                </typeArguments>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
                  </typeReference>
                </typeArguments>
                <target xsi:type="classifiers:Interface" href="Map$Entry.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
        </classifierReferences>
      </extends>
    </members>
    <members xsi:type="members:ClassMethod" name="newKeyIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>// These Overrides alter the behavior of superclass view iterator() methods</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.15"/>
          </typeReference>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newValueIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.16"/>
          </typeReference>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newEntryIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <namespaces>Map</namespaces>
              <classifierReferences>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                  </typeReference>
                </typeArguments>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
                  </typeReference>
                </typeArguments>
                <target xsi:type="classifiers:Interface" href="Map$Entry.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.17"/>
          </typeReference>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="addEntry">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * This override alters behavior of superclass put method. It causes newly&#xA;     * allocated entry to get inserted at the end of the linked list and&#xA;     * removes the eldest entry if appropriate.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hash">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bucketIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.3"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="eldest">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.13">
              <comments>// Remove eldest entry if instructed, else grow capacity if appropriate</comments>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
                </typeReference>
              </typeArguments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0/@additionalFields.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="HashMap.class.xmi#//@classifiers.0/@members.39"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="HashMap$Entry.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </arguments>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.1/@variable"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="HashMap.class.xmi#//@classifiers.0/@members.35"/>
                <arguments xsi:type="expressions:MultiplicativeExpression">
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference"/>
                    <target xsi:type="members:Field" href="HashMap.class.xmi#//@classifiers.0/@members.3"/>
                  </children>
                  <multiplicativeOperators xsi:type="operators:Multiplication"/>
                </arguments>
              </expression>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="HashMap.class.xmi#//@classifiers.0/@members.4"/>
              </children>
              <children xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="HashMap.class.xmi#//@classifiers.0/@members.5"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </condition>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createEntry">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * This override differs from addEntry in that it doesn't resize the&#xA;     * table or remove the eldest entry.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hash">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bucketIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="old">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <namespaces>HashMap</namespaces>
            <classifierReferences>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
                </typeReference>
              </typeArguments>
              <target xsi:type="classifiers:Class" href="HashMap$Entry.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.3"/>
            </arraySelectors>
            <target xsi:type="members:Field" href="HashMap.class.xmi#//@classifiers.0/@members.3"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="e">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.13">
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
                </typeReference>
              </typeArguments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.13">
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                  </typeReference>
                </typeArguments>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
                  </typeReference>
                </typeArguments>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.3"/>
            </arraySelectors>
            <target xsi:type="members:Field" href="HashMap.class.xmi#//@classifiers.0/@members.3"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.1/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.1/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.3">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="HashMap.class.xmi#//@classifiers.0/@members.4"/>
          </child>
          <operator xsi:type="operators:PlusPlus"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeEldestEntry">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="eldest">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>Map</namespaces>
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="Map$Entry.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this map should remove its eldest entry.&#xA;     * This method is invoked by &lt;tt>put&lt;/tt> and &lt;tt>putAll&lt;/tt> after&#xA;     * inserting a new entry into the map.  It provides the implementer&#xA;     * with the opportunity to remove the eldest entry each time a new one&#xA;     * is added.  This is useful if the map represents a cache: it allows&#xA;     * the map to reduce memory consumption by deleting stale entries.&#xA;     *&#xA;     * &lt;p>Sample use: this override will allow the map to grow up to 100&#xA;     * entries and then delete the eldest entry each time a new entry is&#xA;     * added, maintaining a steady state of 100 entries.&#xA;     * &lt;pre>&#xA;     *     private static final int MAX_ENTRIES = 100;&#xA;     *&#xA;     *     protected boolean removeEldestEntry(Map.Entry eldest) {&#xA;     *        return size() > MAX_ENTRIES;&#xA;     *     }&#xA;     * &lt;/pre>&#xA;     *&#xA;     * &lt;p>This method typically does not modify the map in any way,&#xA;     * instead allowing the map to modify itself as directed by its&#xA;     * return value.  It &lt;i>is&lt;/i> permitted for this method to modify&#xA;     * the map directly, but if it does so, it &lt;i>must&lt;/i> return&#xA;     * &lt;tt>false&lt;/tt> (indicating that the map should not attempt any&#xA;     * further modification).  The effects of returning &lt;tt>true&lt;/tt>&#xA;     * after modifying the map from within this method are unspecified.&#xA;     *&#xA;     * &lt;p>This implementation merely returns &lt;tt>false&lt;/tt> (so that this&#xA;     * map acts like a normal map - the eldest element is never removed).&#xA;     *&#xA;     * @param    eldest The least recently inserted entry in the map, or if &#xA;     *           this is an access-ordered map, the least recently accessed&#xA;     *           entry.  This is the entry that will be removed it this&#xA;     *           method returns &lt;tt>true&lt;/tt>.  If the map was empty prior&#xA;     *           to the &lt;tt>put&lt;/tt> or &lt;tt>putAll&lt;/tt> invocation resulting&#xA;     *           in this invocation, this will be the entry that was just&#xA;     *           inserted; in other words, if the map contains a single&#xA;     *           entry, the eldest entry is also the newest.&#xA;     * @return   &lt;tt>true&lt;/tt> if the eldest entry should be removed&#xA;     *           from the map; &lt;tt>false&lt;/t> if it should be retained.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;p>Hash table and linked list implementation of the &lt;tt>Map&lt;/tt> interface,&#xA; * with predictable iteration order.  This implementation differs from&#xA; * &lt;tt>HashMap&lt;/tt> in that it maintains a doubly-linked list running through&#xA; * all of its entries.  This linked list defines the iteration ordering,&#xA; * which is normally the order in which keys were inserted into the map&#xA; * (&lt;i>insertion-order&lt;/i>).  Note that insertion order is not affected&#xA; * if a key is &lt;i>re-inserted&lt;/i> into the map.  (A key &lt;tt>k&lt;/tt> is&#xA; * reinserted into a map &lt;tt>m&lt;/tt> if &lt;tt>m.put(k, v)&lt;/tt> is invoked when&#xA; * &lt;tt>m.containsKey(k)&lt;/tt> would return &lt;tt>true&lt;/tt> immediately prior to&#xA; * the invocation.)&#xA; *&#xA; * &lt;p>This implementation spares its clients from the unspecified, generally&#xA; * chaotic ordering provided by {@link HashMap} (and {@link Hashtable}),&#xA; * without incurring the increased cost associated with {@link TreeMap}.  It&#xA; * can be used to produce a copy of a map that has the same order as the&#xA; * original, regardless of the original map's implementation:&#xA; * &lt;pre>&#xA; *     void foo(Map m) {&#xA; *         Map copy = new LinkedHashMap(m);&#xA; *         ...&#xA; *     }&#xA; * &lt;/pre>&#xA; * This technique is particularly useful if a module takes a map on input,&#xA; * copies it, and later returns results whose order is determined by that of&#xA; * the copy.  (Clients generally appreciate having things returned in the same&#xA; * order they were presented.)&#xA; *&#xA; * &lt;p>A special {@link #LinkedHashMap(int,float,boolean) constructor} is&#xA; * provided to create a linked hash map whose order of iteration is the order&#xA; * in which its entries were last accessed, from least-recently accessed to&#xA; * most-recently (&lt;i>access-order&lt;/i>).  This kind of map is well-suited to&#xA; * building LRU caches.  Invoking the &lt;tt>put&lt;/tt> or &lt;tt>get&lt;/tt> method&#xA; * results in an access to the corresponding entry (assuming it exists after&#xA; * the invocation completes).  The &lt;tt>putAll&lt;/tt> method generates one entry&#xA; * access for each mapping in the specified map, in the order that key-value&#xA; * mappings are provided by the specified map's entry set iterator.  &lt;i>No&#xA; * other methods generate entry accesses.&lt;/i> In particular, operations on&#xA; * collection-views do &lt;i>not&lt;/i> affect the order of iteration of the backing&#xA; * map.&#xA; *&#xA; * &lt;p>The {@link #removeEldestEntry(Map.Entry)} method may be overridden to &#xA; * impose a policy for removing stale mappings automatically when new mappings&#xA; * are added to the map.&#xA; *&#xA; * &lt;p>This class provides all of the optional &lt;tt>Map&lt;/tt> operations, and&#xA; * permits null elements.  Like &lt;tt>HashMap&lt;/tt>, it provides constant-time&#xA; * performance for the basic operations (&lt;tt>add&lt;/tt>, &lt;tt>contains&lt;/tt> and&#xA; * &lt;tt>remove&lt;/tt>), assuming the hash function disperses elements&#xA; * properly among the buckets.  Performance is likely to be just slightly&#xA; * below that of &lt;tt>HashMap&lt;/tt>, due to the added expense of maintaining the&#xA; * linked list, with one exception: Iteration over the collection-views&#xA; * of a &lt;tt>LinkedHashMap&lt;/tt> requires time proportional to the &lt;i>size&lt;/i>&#xA; * of the map, regardless of its capacity.  Iteration over a &lt;tt>HashMap&lt;/tt>&#xA; * is likely to be more expensive, requiring time proportional to its&#xA; * &lt;i>capacity&lt;/i>.&#xA; *&#xA; * &lt;p>A linked hash map has two parameters that affect its performance:&#xA; * &lt;i>initial capacity&lt;/i> and &lt;i>load factor&lt;/i>.  They are defined precisely&#xA; * as for &lt;tt>HashMap&lt;/tt>.  Note, however, that the penalty for choosing an&#xA; * excessively high value for initial capacity is less severe for this class&#xA; * than for &lt;tt>HashMap&lt;/tt>, as iteration times for this class are unaffected&#xA; * by capacity.&#xA; * &#xA; * &lt;p>&lt;strong>Note that this implementation is not synchronized.&lt;/strong> If&#xA; * multiple threads access a linked hash map concurrently, and at least&#xA; * one of the threads modifies the map structurally, it &lt;em>must&lt;/em> be&#xA; * synchronized externally.  This is typically accomplished by synchronizing&#xA; * on some object that naturally encapsulates the map.  If no such object&#xA; * exists, the map should be &quot;wrapped&quot; using the&#xA; * &lt;tt>Collections.synchronizedMap&lt;/tt>method.  This is best done at creation&#xA; * time, to prevent accidental unsynchronized access:&#xA; * &lt;pre>&#xA; *    Map m = Collections.synchronizedMap(new LinkedHashMap(...));&#xA; * &lt;/pre>&#xA; * A structural modification is any operation that adds or deletes one or more&#xA; * mappings or, in the case of access-ordered linked hash maps, affects&#xA; * iteration order.  In insertion-ordered linked hash maps, merely changing&#xA; * the value associated with a key that is already contained in the map is not&#xA; * a structural modification.  &lt;strong>In access-ordered linked hash maps,&#xA; * merely querying the map with &lt;tt>get&lt;/tt> is a structural&#xA; * modification.&lt;/strong>)&#xA; *&#xA; * &lt;p>The iterators returned by the &lt;tt>iterator&lt;/tt> methods of the&#xA; * collections returned by all of this class's collection view methods are&#xA; * &lt;em>fail-fast&lt;/em>: if the map is structurally modified at any time after&#xA; * the iterator is created, in any way except through the iterator's own&#xA; * remove method, the iterator will throw a&#xA; * &lt;tt>ConcurrentModificationException&lt;/tt>.  Thus, in the face of concurrent&#xA; * modification, the Iterator fails quickly and cleanly, rather than risking&#xA; * arbitrary, non-deterministic behavior at an undetermined time in the&#xA; * future.&#xA; *&#xA; * &lt;p>Note that the fail-fast behavior of an iterator cannot be guaranteed&#xA; * as it is, generally speaking, impossible to make any hard guarantees in the&#xA; * presence of unsynchronized concurrent modification.  Fail-fast iterators&#xA; * throw &lt;tt>ConcurrentModificationException&lt;/tt> on a best-effort basis. &#xA; * Therefore, it would be wrong to write a program that depended on this&#xA; * exception for its correctness:   &lt;i>the fail-fast behavior of iterators&#xA; * should be used only to detect bugs.&lt;/i>&#xA; *&#xA; * &lt;p>This class is a member of the &#xA; * &lt;a href=&quot;{@docRoot}/../guide/collections/index.html&quot;>&#xA; * Java Collections Framework&lt;/a>.&#xA; *&#xA; * @author  Josh Bloch&#xA; * @version 1.18, 02/19/04&#xA; * @see     Object#hashCode()&#xA; * @see     Collection&#xA; * @see     Map&#xA; * @see     HashMap&#xA; * @see     TreeMap&#xA; * @see     Hashtable&#xA; * @since   JDK1.4&#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="Map.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Class" href="HashMap.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
