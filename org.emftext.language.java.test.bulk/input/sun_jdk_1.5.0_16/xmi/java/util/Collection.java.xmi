<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="Collection.java">
  <comments>/*&#xA; * @(#)Collection.java&#x9;1.49 04/06/28&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Collection">
    <typeParameters name="E"/>
    <members xsi:type="members:InterfaceMethod" name="size">
      <typeReference xsi:type="types:Int">
        <comments>// Query Operations</comments>
        <comments>/**&#xA;     * Returns the number of elements in this collection.  If this collection&#xA;     * contains more than &lt;tt>Integer.MAX_VALUE&lt;/tt> elements, returns&#xA;     * &lt;tt>Integer.MAX_VALUE&lt;/tt>.&#xA;     * &#xA;     * @return the number of elements in this collection&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isEmpty">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this collection contains no elements.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if this collection contains no elements&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="contains">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this collection contains the specified&#xA;     * element.  More formally, returns &lt;tt>true&lt;/tt> if and only if this&#xA;     * collection contains at least one element &lt;tt>e&lt;/tt> such that&#xA;     * &lt;tt>(o==null ? e==null : o.equals(e))&lt;/tt>.&#xA;     *&#xA;     * @param o element whose presence in this collection is to be tested.&#xA;     * @return &lt;tt>true&lt;/tt> if this collection contains the specified&#xA;     *         element&#xA;     * @throws ClassCastException if the type of the specified element&#xA;     * &#x9;       is incompatible with this collection (optional).&#xA;     * @throws NullPointerException if the specified element is null and this&#xA;     *         collection does not support null elements (optional).&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="iterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns an iterator over the elements in this collection.  There are no&#xA;     * guarantees concerning the order in which the elements are returned&#xA;     * (unless this collection is an instance of some class that provides a&#xA;     * guarantee).&#xA;     * &#xA;     * @return an &lt;tt>Iterator&lt;/tt> over the elements in this collection&#xA;     */</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toArray">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns an array containing all of the elements in this collection.  If&#xA;     * the collection makes any guarantees as to what order its elements are&#xA;     * returned by its iterator, this method must return the elements in the&#xA;     * same order.&lt;p>&#xA;     *&#xA;     * The returned array will be &quot;safe&quot; in that no references to it are&#xA;     * maintained by this collection.  (In other words, this method must&#xA;     * allocate a new array even if this collection is backed by an array).&#xA;     * The caller is thus free to modify the returned array.&lt;p>&#xA;     *&#xA;     * This method acts as bridge between array-based and collection-based&#xA;     * APIs.&#xA;     *&#xA;     * @return an array containing all of the elements in this collection&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toArray">
      <comments>/**&#xA;     * Returns an array containing all of the elements in this collection; &#xA;     * the runtime type of the returned array is that of the specified array.  &#xA;     * If the collection fits in the specified array, it is returned therein.  &#xA;     * Otherwise, a new array is allocated with the runtime type of the &#xA;     * specified array and the size of this collection.&lt;p>&#xA;     *&#xA;     * If this collection fits in the specified array with room to spare&#xA;     * (i.e., the array has more elements than this collection), the element&#xA;     * in the array immediately following the end of the collection is set to&#xA;     * &lt;tt>null&lt;/tt>.  This is useful in determining the length of this&#xA;     * collection &lt;i>only&lt;/i> if the caller knows that this collection does&#xA;     * not contain any &lt;tt>null&lt;/tt> elements.)&lt;p>&#xA;     *&#xA;     * If this collection makes any guarantees as to what order its elements&#xA;     * are returned by its iterator, this method must return the elements in&#xA;     * the same order.&lt;p>&#xA;     *&#xA;     * Like the &lt;tt>toArray&lt;/tt> method, this method acts as bridge between&#xA;     * array-based and collection-based APIs.  Further, this method allows&#xA;     * precise control over the runtime type of the output array, and may,&#xA;     * under certain circumstances, be used to save allocation costs&lt;p>&#xA;     *&#xA;     * Suppose &lt;tt>l&lt;/tt> is a &lt;tt>List&lt;/tt> known to contain only strings.&#xA;     * The following code can be used to dump the list into a newly allocated&#xA;     * array of &lt;tt>String&lt;/tt>:&#xA;     *&#xA;     * &lt;pre>&#xA;     *     String[] x = (String[]) v.toArray(new String[0]);&#xA;     * &lt;/pre>&lt;p>&#xA;     *&#xA;     * Note that &lt;tt>toArray(new Object[0])&lt;/tt> is identical in function to&#xA;     * &lt;tt>toArray()&lt;/tt>.&#xA;     *&#xA;     * @param a the array into which the elements of this collection are to be&#xA;     *        stored, if it is big enough; otherwise, a new array of the same&#xA;     *        runtime type is allocated for this purpose.&#xA;     * @return an array containing the elements of this collection&#xA;     * &#xA;     * @throws ArrayStoreException the runtime type of the specified array is&#xA;     *         not a supertype of the runtime type of every element in this&#xA;     *         collection.&#xA;     * @throws NullPointerException if the specified array is &lt;tt>null&lt;/tt>.&#xA;     */</comments>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.5/@typeParameters.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <typeParameters name="T"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.5/@typeParameters.0"/>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="add">
      <typeReference xsi:type="types:Boolean">
        <comments>// Modification Operations</comments>
        <comments>/**&#xA;     * Ensures that this collection contains the specified element (optional&#xA;     * operation).  Returns &lt;tt>true&lt;/tt> if this collection changed as a&#xA;     * result of the call.  (Returns &lt;tt>false&lt;/tt> if this collection does&#xA;     * not permit duplicates and already contains the specified element.)&lt;p>&#xA;     *&#xA;     * Collections that support this operation may place limitations on what&#xA;     * elements may be added to this collection.  In particular, some&#xA;     * collections will refuse to add &lt;tt>null&lt;/tt> elements, and others will&#xA;     * impose restrictions on the type of elements that may be added.&#xA;     * Collection classes should clearly specify in their documentation any&#xA;     * restrictions on what elements may be added.&lt;p>&#xA;     *&#xA;     * If a collection refuses to add a particular element for any reason&#xA;     * other than that it already contains the element, it &lt;i>must&lt;/i> throw&#xA;     * an exception (rather than returning &lt;tt>false&lt;/tt>).  This preserves&#xA;     * the invariant that a collection always contains the specified element&#xA;     * after this call returns.&#xA;     *&#xA;     * @param o element whose presence in this collection is to be ensured.&#xA;     * @return &lt;tt>true&lt;/tt> if this collection changed as a result of the&#xA;     *         call&#xA;     * &#xA;     * @throws UnsupportedOperationException &lt;tt>add&lt;/tt> is not supported by&#xA;     *         this collection.&#xA;     * @throws ClassCastException class of the specified element prevents it&#xA;     *         from being added to this collection.&#xA;     * @throws NullPointerException if the specified element is null and this&#xA;     *         collection does not support null elements.&#xA;     * @throws IllegalArgumentException some aspect of this element prevents&#xA;     *         it from being added to this collection.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="remove">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Removes a single instance of the specified element from this&#xA;     * collection, if it is present (optional operation).  More formally,&#xA;     * removes an element &lt;tt>e&lt;/tt> such that &lt;tt>(o==null ?  e==null :&#xA;     * o.equals(e))&lt;/tt>, if this collection contains one or more such&#xA;     * elements.  Returns true if this collection contained the specified&#xA;     * element (or equivalently, if this collection changed as a result of the&#xA;     * call).&#xA;     *&#xA;     * @param o element to be removed from this collection, if present.&#xA;     * @return &lt;tt>true&lt;/tt> if this collection changed as a result of the&#xA;     *         call&#xA;     * &#xA;     * @throws ClassCastException if the type of the specified element&#xA;     * &#x9;       is incompatible with this collection (optional).&#xA;     * @throws NullPointerException if the specified element is null and this&#xA;     *         collection does not support null elements (optional).&#xA;     * @throws UnsupportedOperationException remove is not supported by this&#xA;     *         collection.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="containsAll">
      <typeReference xsi:type="types:Boolean">
        <comments>// Bulk Operations</comments>
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this collection contains all of the elements&#xA;     * in the specified collection.&#xA;     *&#xA;     * @param  c collection to be checked for containment in this collection.&#xA;     * @return &lt;tt>true&lt;/tt> if this collection contains all of the elements&#xA;     *&#x9;       in the specified collection&#xA;     * @throws ClassCastException if the types of one or more elements&#xA;     *         in the specified collection are incompatible with this&#xA;     *         collection (optional).&#xA;     * @throws NullPointerException if the specified collection contains one&#xA;     *         or more null elements and this collection does not support null&#xA;     *         elements (optional).&#xA;     * @throws NullPointerException if the specified collection is&#xA;     *         &lt;tt>null&lt;/tt>.&#xA;     * @see    #contains(Object)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0">
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addAll">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Adds all of the elements in the specified collection to this collection&#xA;     * (optional operation).  The behavior of this operation is undefined if&#xA;     * the specified collection is modified while the operation is in progress.&#xA;     * (This implies that the behavior of this call is undefined if the&#xA;     * specified collection is this collection, and this collection is&#xA;     * nonempty.)&#xA;     *&#xA;     * @param c elements to be inserted into this collection.&#xA;     * @return &lt;tt>true&lt;/tt> if this collection changed as a result of the&#xA;     *         call&#xA;     * &#xA;     * @throws UnsupportedOperationException if this collection does not&#xA;     *         support the &lt;tt>addAll&lt;/tt> method.&#xA;     * @throws ClassCastException if the class of an element of the specified&#xA;     * &#x9;       collection prevents it from being added to this collection.&#xA;     * @throws NullPointerException if the specified collection contains one&#xA;     *         or more null elements and this collection does not support null&#xA;     *         elements, or if the specified collection is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException some aspect of an element of the&#xA;     *&#x9;       specified collection prevents it from being added to this&#xA;     *&#x9;       collection.&#xA;     * @see #add(Object)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0">
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </extendTypes>
            </typeArguments>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removeAll">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * &#xA;     * Removes all this collection's elements that are also contained in the&#xA;     * specified collection (optional operation).  After this call returns,&#xA;     * this collection will contain no elements in common with the specified&#xA;     * collection.&#xA;     *&#xA;     * @param c elements to be removed from this collection.&#xA;     * @return &lt;tt>true&lt;/tt> if this collection changed as a result of the&#xA;     *         call&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>removeAll&lt;/tt> method&#xA;     * &#x9;       is not supported by this collection.&#xA;     * @throws ClassCastException if the types of one or more elements&#xA;     *         in this collection are incompatible with the specified&#xA;     *         collection (optional).&#xA;     * @throws NullPointerException if this collection contains one or more&#xA;     *         null elements and the specified collection does not support&#xA;     *         null elements (optional).&#xA;     * @throws NullPointerException if the specified collection is&#xA;     *         &lt;tt>null&lt;/tt>.&#xA;     * @see #remove(Object)&#xA;     * @see #contains(Object)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0">
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="retainAll">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retains only the elements in this collection that are contained in the&#xA;     * specified collection (optional operation).  In other words, removes from&#xA;     * this collection all of its elements that are not contained in the&#xA;     * specified collection.&#xA;     *&#xA;     * @param c elements to be retained in this collection.&#xA;     * @return &lt;tt>true&lt;/tt> if this collection changed as a result of the&#xA;     *         call&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>retainAll&lt;/tt> method&#xA;     * &#x9;       is not supported by this Collection.&#xA;     * @throws ClassCastException if the types of one or more elements&#xA;     *         in this collection are incompatible with the specified&#xA;     *         collection (optional).&#xA;     * @throws NullPointerException if this collection contains one or more&#xA;     *         null elements and the specified collection does not support null &#xA;     *         elements (optional).&#xA;     * @throws NullPointerException if the specified collection is&#xA;     *         &lt;tt>null&lt;/tt>.&#xA;     * @see #remove(Object)&#xA;     * @see #contains(Object)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0">
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="clear">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Removes all of the elements from this collection (optional operation).&#xA;     * This collection will be empty after this method returns unless it&#xA;     * throws an exception.&#xA;     *&#xA;     * @throws UnsupportedOperationException if the &lt;tt>clear&lt;/tt> method is&#xA;     *         not supported by this collection.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="equals">
      <typeReference xsi:type="types:Boolean">
        <comments>// Comparison and hashing</comments>
        <comments>/**&#xA;     * Compares the specified object with this collection for equality. &lt;p>&#xA;     *&#xA;     * While the &lt;tt>Collection&lt;/tt> interface adds no stipulations to the&#xA;     * general contract for the &lt;tt>Object.equals&lt;/tt>, programmers who&#xA;     * implement the &lt;tt>Collection&lt;/tt> interface &quot;directly&quot; (in other words,&#xA;     * create a class that is a &lt;tt>Collection&lt;/tt> but is not a &lt;tt>Set&lt;/tt>&#xA;     * or a &lt;tt>List&lt;/tt>) must exercise care if they choose to override the&#xA;     * &lt;tt>Object.equals&lt;/tt>.  It is not necessary to do so, and the simplest&#xA;     * course of action is to rely on &lt;tt>Object&lt;/tt>'s implementation, but&#xA;     * the implementer may wish to implement a &quot;value comparison&quot; in place of&#xA;     * the default &quot;reference comparison.&quot;  (The &lt;tt>List&lt;/tt> and&#xA;     * &lt;tt>Set&lt;/tt> interfaces mandate such value comparisons.)&lt;p>&#xA;     *&#xA;     * The general contract for the &lt;tt>Object.equals&lt;/tt> method states that&#xA;     * equals must be symmetric (in other words, &lt;tt>a.equals(b)&lt;/tt> if and&#xA;     * only if &lt;tt>b.equals(a)&lt;/tt>).  The contracts for &lt;tt>List.equals&lt;/tt>&#xA;     * and &lt;tt>Set.equals&lt;/tt> state that lists are only equal to other lists,&#xA;     * and sets to other sets.  Thus, a custom &lt;tt>equals&lt;/tt> method for a&#xA;     * collection class that implements neither the &lt;tt>List&lt;/tt> nor&#xA;     * &lt;tt>Set&lt;/tt> interface must return &lt;tt>false&lt;/tt> when this collection&#xA;     * is compared to any list or set.  (By the same logic, it is not possible&#xA;     * to write a class that correctly implements both the &lt;tt>Set&lt;/tt> and&#xA;     * &lt;tt>List&lt;/tt> interfaces.)&#xA;     *&#xA;     * @param o Object to be compared for equality with this collection.&#xA;     * @return &lt;tt>true&lt;/tt> if the specified object is equal to this&#xA;     * collection&#xA;     * &#xA;     * @see Object#equals(Object)&#xA;     * @see Set#equals(Object)&#xA;     * @see List#equals(Object)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="hashCode">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Returns the hash code value for this collection.  While the&#xA;     * &lt;tt>Collection&lt;/tt> interface adds no stipulations to the general&#xA;     * contract for the &lt;tt>Object.hashCode&lt;/tt> method, programmers should&#xA;     * take note that any class that overrides the &lt;tt>Object.equals&lt;/tt>&#xA;     * method must also override the &lt;tt>Object.hashCode&lt;/tt> method in order&#xA;     * to satisfy the general contract for the &lt;tt>Object.hashCode&lt;/tt>method.&#xA;     * In particular, &lt;tt>c1.equals(c2)&lt;/tt> implies that&#xA;     * &lt;tt>c1.hashCode()==c2.hashCode()&lt;/tt>.&#xA;     *&#xA;     * @return the hash code value for this collection&#xA;     * &#xA;     * @see Object#hashCode()&#xA;     * @see Object#equals(Object)&#xA;     */</comments>
      </typeReference>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The root interface in the &lt;i>collection hierarchy&lt;/i>.  A collection&#xA; * represents a group of objects, known as its &lt;i>elements&lt;/i>.  Some&#xA; * collections allow duplicate elements and others do not.  Some are ordered&#xA; * and others unordered.  The JDK does not provide any &lt;i>direct&lt;/i>&#xA; * implementations of this interface: it provides implementations of more&#xA; * specific subinterfaces like &lt;tt>Set&lt;/tt> and &lt;tt>List&lt;/tt>.  This interface&#xA; * is typically used to pass collections around and manipulate them where&#xA; * maximum generality is desired.&#xA; *&#xA; * &lt;p>&lt;i>Bags&lt;/i> or &lt;i>multisets&lt;/i> (unordered collections that may contain&#xA; * duplicate elements) should implement this interface directly.&#xA; *&#xA; * &lt;p>All general-purpose &lt;tt>Collection&lt;/tt> implementation classes (which&#xA; * typically implement &lt;tt>Collection&lt;/tt> indirectly through one of its&#xA; * subinterfaces) should provide two &quot;standard&quot; constructors: a void (no&#xA; * arguments) constructor, which creates an empty collection, and a&#xA; * constructor with a single argument of type &lt;tt>Collection&lt;/tt>, which&#xA; * creates a new collection with the same elements as its argument.  In&#xA; * effect, the latter constructor allows the user to copy any collection,&#xA; * producing an equivalent collection of the desired implementation type.&#xA; * There is no way to enforce this convention (as interfaces cannot contain&#xA; * constructors) but all of the general-purpose &lt;tt>Collection&lt;/tt>&#xA; * implementations in the Java platform libraries comply.&#xA; *&#xA; * &lt;p>The &quot;destructive&quot; methods contained in this interface, that is, the&#xA; * methods that modify the collection on which they operate, are specified to&#xA; * throw &lt;tt>UnsupportedOperationException&lt;/tt> if this collection does not&#xA; * support the operation.  If this is the case, these methods may, but are not&#xA; * required to, throw an &lt;tt>UnsupportedOperationException&lt;/tt> if the&#xA; * invocation would have no effect on the collection.  For example, invoking&#xA; * the {@link #addAll(Collection)} method on an unmodifiable collection may,&#xA; * but is not required to, throw the exception if the collection to be added&#xA; * is empty.&#xA; *&#xA; * &lt;p>Some collection implementations have restrictions on the elements that&#xA; * they may contain.  For example, some implementations prohibit null elements,&#xA; * and some have restrictions on the types of their elements.  Attempting to&#xA; * add an ineligible element throws an unchecked exception, typically&#xA; * &lt;tt>NullPointerException&lt;/tt> or &lt;tt>ClassCastException&lt;/tt>.  Attempting&#xA; * to query the presence of an ineligible element may throw an exception,&#xA; * or it may simply return false; some implementations will exhibit the former&#xA; * behavior and some will exhibit the latter.  More generally, attempting an&#xA; * operation on an ineligible element whose completion would not result in&#xA; * the insertion of an ineligible element into the collection may throw an&#xA; * exception or it may succeed, at the option of the implementation.&#xA; * Such exceptions are marked as &quot;optional&quot; in the specification for this&#xA; * interface. &#xA; *&#xA; * &lt;p>This interface is a member of the &#xA; * &lt;a href=&quot;{@docRoot}/../guide/collections/index.html&quot;>&#xA; * Java Collections Framework&lt;/a>.&#xA; *&#xA; * &lt;p>Many methods in Collections Framework interfaces are defined in&#xA; * terms of the {@link Object#equals(Object) equals} method.  For example,&#xA; * the specification for the {@link #contains(Object) contains(Object o)}&#xA; * method says: &quot;returns &lt;tt>true&lt;/tt> if and only if this collection&#xA; * contains at least one element &lt;tt>e&lt;/tt> such that&#xA; * &lt;tt>(o==null ? e==null : o.equals(e))&lt;/tt>.&quot;  This specification should&#xA; * &lt;i>not&lt;/i> be construed to imply that invoking &lt;tt>Collection.contains&lt;/tt>&#xA; * with a non-null argument &lt;tt>o&lt;/tt> will cause &lt;tt>o.equals(e)&lt;/tt> to be&#xA; * invoked for any element &lt;tt>e&lt;/tt>.  Implementations are free to implement&#xA; * optimizations whereby the &lt;tt>equals&lt;/tt> invocation is avoided, for&#xA; * example, by first comparing the hash codes of the two elements.  (The&#xA; * {@link Object#hashCode()} specification guarantees that two objects with&#xA; * unequal hash codes cannot be equal.)  More generally, implementations of&#xA; * the various Collections Framework interfaces are free to take advantage of&#xA; * the specified behavior of underlying {@link Object} methods wherever the&#xA; * implementor deems it appropriate.&#xA; *&#xA; * @author  Josh Bloch&#xA; * @author  Neal Gafter&#xA; * @version 1.49, 06/28/04&#xA; * @see&#x9;    Set&#xA; * @see&#x9;    List&#xA; * @see&#x9;    Map&#xA; * @see&#x9;    SortedSet&#xA; * @see&#x9;    SortedMap&#xA; * @see&#x9;    HashSet&#xA; * @see&#x9;    TreeSet&#xA; * @see&#x9;    ArrayList&#xA; * @see&#x9;    LinkedList&#xA; * @see&#x9;    Vector&#xA; * @see     Collections&#xA; * @see&#x9;    Arrays&#xA; * @see&#x9;    AbstractCollection&#xA; * @since 1.2&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="../lang/Iterable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
