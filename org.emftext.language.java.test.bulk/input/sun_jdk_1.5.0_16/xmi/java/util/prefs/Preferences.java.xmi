<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="Preferences.java">
  <comments>/*&#xA; * @(#)Preferences.java&#x9;1.25 04/06/21&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <namespaces>prefs</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../io/OutputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../security/AccessController.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../security/Permission.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../security/PrivilegedAction.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../Iterator.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>misc</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../sun/misc/Service.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>misc</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../sun/misc/ServiceConfigurationError.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <comments>// These imports needed only as a workaround for a JavaDoc bug</comments>
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../lang/RuntimePermission.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../lang/Integer.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../lang/Long.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../lang/Float.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../lang/Double.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Preferences">
    <members xsi:type="members:Field" name="factory">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="PreferencesFactory.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="factory">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="PreferencesFactory.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="factoryName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// 1. Try user-specified system property</comments>
              <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../security/AccessController.class.xmi#//@classifiers.0/@members.1"/>
              <arguments xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <typeArguments xsi:type="generics:QualifiedTypeArgument">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                    </typeArguments>
                    <target xsi:type="classifiers:Interface" href="../../security/PrivilegedAction.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <anonymousClass>
                  <members xsi:type="members:ClassMethod" name="run">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <annotationsAndModifiers xsi:type="modifiers:Public"/>
                    <statements xsi:type="statements:Return">
                      <returnValue xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../../lang/System.class.xmi#//@classifiers.0/@members.25"/>
                          <arguments xsi:type="references:StringReference" value="java.util.prefs.PreferencesFactory"/>
                        </next>
                        <target xsi:type="classifiers:Class" href="../../lang/System.class.xmi#//@classifiers.0"/>
                      </returnValue>
                    </statements>
                  </members>
                </anonymousClass>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../security/AccessController.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:TryBlock">
            <comments>// FIXME: This code should be run in a doPrivileged and</comments>
            <comments>// not use the context classloader, to avoid being</comments>
            <comments>// dependent on the invoking thread.</comments>
            <comments>// Checking AllPermission also seems wrong.</comments>
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="PreferencesFactory.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../lang/Class.class.xmi#//@classifiers.0/@members.35"/>
                    </next>
                    <target xsi:type="members:ClassMethod" href="../../lang/Class.class.xmi#//@classifiers.0/@members.33"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.0/@variable"/>
                    <arguments xsi:type="literals:BooleanLiteral"/>
                    <arguments xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../lang/ClassLoader.class.xmi#//@classifiers.0/@members.64"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="../../lang/ClassLoader.class.xmi#//@classifiers.0"/>
                    </arguments>
                  </next>
                  <target xsi:type="classifiers:Class" href="../../lang/Class.class.xmi#//@classifiers.0"/>
                </child>
              </returnValue>
            </statements>
            <catcheBlocks>
              <statements xsi:type="statements:TryBlock">
                <statements xsi:type="statements:LocalVariableStatement">
                  <variable name="sm">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <comments>// workaround for javaws, plugin,</comments>
                        <comments>// load factory class using non-system classloader</comments>
                        <target xsi:type="classifiers:Class" href="../../lang/SecurityManager.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <initialValue xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../lang/System.class.xmi#//@classifiers.0/@members.17"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="../../lang/System.class.xmi#//@classifiers.0"/>
                    </initialValue>
                  </variable>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.1/@statement/@statements.0/@catcheBlocks.0/@statements.0/@statements.0/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../../lang/SecurityManager.class.xmi#//@classifiers.0/@members.22"/>
                          <arguments xsi:type="instantiations:NewConstructorCall">
                            <typeReference xsi:type="types:NamespaceClassifierReference">
                              <namespaces>java</namespaces>
                              <namespaces>security</namespaces>
                              <classifierReferences>
                                <target xsi:type="classifiers:Class" href="../../security/AllPermission.class.xmi#//@classifiers.0"/>
                              </classifierReferences>
                            </typeReference>
                          </arguments>
                        </next>
                      </expression>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.1/@statement/@statements.0/@catcheBlocks.0/@statements.0/@statements.0/@variable"/>
                    <children xsi:type="literals:NullLiteral"/>
                  </condition>
                </statements>
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Interface" href="PreferencesFactory.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <child xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../../lang/Class.class.xmi#//@classifiers.0/@members.35"/>
                        </next>
                        <target xsi:type="members:ClassMethod" href="../../lang/Class.class.xmi#//@classifiers.0/@members.33"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.0/@variable"/>
                        <arguments xsi:type="literals:BooleanLiteral"/>
                        <arguments xsi:type="references:IdentifierReference">
                          <next xsi:type="references:MethodCall">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../../lang/Thread.class.xmi#//@classifiers.0/@members.76"/>
                            </next>
                            <target xsi:type="members:ClassMethod" href="../../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
                          </next>
                          <target xsi:type="classifiers:Class" href="../../lang/Thread.class.xmi#//@classifiers.0"/>
                        </arguments>
                      </next>
                      <target xsi:type="classifiers:Class" href="../../lang/Class.class.xmi#//@classifiers.0"/>
                    </child>
                  </returnValue>
                </statements>
                <catcheBlocks>
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="error">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../../lang/InternalError.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <initialValue xsi:type="instantiations:NewConstructorCall">
                        <typeReference xsi:type="types:NamespaceClassifierReference">
                          <classifierReferences>
                            <target xsi:type="classifiers:Class" href="../../lang/InternalError.class.xmi#//@classifiers.0"/>
                          </classifierReferences>
                        </typeReference>
                        <arguments xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:StringReference" value="Can't instantiate Preferences factory "/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.0/@variable"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                        </arguments>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.1/@statement/@statements.0/@catcheBlocks.0/@statements.0/@catcheBlocks.0/@statements.0/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../lang/Throwable.class.xmi#//@classifiers.0/@members.12"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.1/@statement/@statements.0/@catcheBlocks.0/@statements.0/@catcheBlocks.0/@parameter"/>
                      </next>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:Throw">
                    <throwable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.1/@statement/@statements.0/@catcheBlocks.0/@statements.0/@catcheBlocks.0/@statements.0/@variable"/>
                  </statements>
                  <parameter name="e">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../lang/Exception.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                  </parameter>
                </catcheBlocks>
              </statements>
              <parameter name="ex">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../lang/Exception.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </parameter>
            </catcheBlocks>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../security/AccessController.class.xmi#//@classifiers.0/@members.1"/>
            <arguments xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Interface" href="PreferencesFactory.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                  </typeArguments>
                  <target xsi:type="classifiers:Interface" href="../../security/PrivilegedAction.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <anonymousClass>
                <members xsi:type="members:ClassMethod" name="run">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Interface" href="PreferencesFactory.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <annotationsAndModifiers xsi:type="modifiers:Public"/>
                  <statements xsi:type="statements:Return">
                    <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
                  </statements>
                </members>
              </anonymousClass>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="../../security/AccessController.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="factory1">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="PreferencesFactory.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="i">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// 2. Try service provider interface</comments>
              <target xsi:type="classifiers:Interface" href="../Iterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../../sun/misc/Service.class.xmi#//@classifiers.0/@members.7"/>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:ReflectiveClassReference"/>
                <target xsi:type="classifiers:Interface" href="PreferencesFactory.class.xmi#//@classifiers.0"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/ClassLoader.class.xmi#//@classifiers.0/@members.64"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../lang/ClassLoader.class.xmi#//@classifiers.0"/>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../../sun/misc/Service.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>// choose first provider instance</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:TryBlock">
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="PreferencesFactory.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../Iterator.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                </child>
              </returnValue>
            </statements>
            <catcheBlocks>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Continue">
                    <comments>// Ignore the security exception, try the next provider</comments>
                  </statements>
                </statement>
                <condition xsi:type="expressions:InstanceOfExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../lang/SecurityException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.1/@statement/@statements.0/@catcheBlocks.0/@parameter">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../../lang/Throwable.class.xmi#//@classifiers.0/@members.11"/>
                    </next>
                  </child>
                </condition>
              </statements>
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.1/@statement/@statements.0/@catcheBlocks.0/@parameter"/>
              </statements>
              <parameter name="sce">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../../sun/misc/ServiceConfigurationError.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </parameter>
            </catcheBlocks>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../Iterator.class.xmi#//@classifiers.0/@members.0"/>
          </next>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="platformFactory">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// 3. Use platform-specific system-wide default</comments>
              <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.42"/>
                  <arguments xsi:type="references:StringReference" value="Windows"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../../lang/System.class.xmi#//@classifiers.0/@members.25"/>
                <arguments xsi:type="references:StringReference" value="os.name"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../lang/System.class.xmi#//@classifiers.0"/>
            </child>
            <expressionIf xsi:type="references:StringReference" value="java.util.prefs.WindowsPreferencesFactory"/>
            <expressionElse xsi:type="references:StringReference" value="java.util.prefs.FileSystemPreferencesFactory"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Interface" href="PreferencesFactory.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/Class.class.xmi#//@classifiers.0/@members.35"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../../lang/Class.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.2/@variable"/>
                <arguments xsi:type="literals:BooleanLiteral"/>
                <arguments xsi:type="literals:NullLiteral"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../lang/Class.class.xmi#//@classifiers.0"/>
            </child>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="error">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/InternalError.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../lang/InternalError.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:StringReference" value="Can't instantiate platform default Preferences factory "/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.2/@variable"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.3/@catcheBlocks.0/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../lang/Throwable.class.xmi#//@classifiers.0/@members.12"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.3/@catcheBlocks.0/@parameter"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.3/@catcheBlocks.0/@statements.0/@variable"/>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/Exception.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:Field" name="MAX_KEY_LENGTH">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="80"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Maximum length of string allowed as a key (80 characters).&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MAX_VALUE_LENGTH">
      <initialValue xsi:type="expressions:MultiplicativeExpression">
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1024"/>
        <multiplicativeOperators xsi:type="operators:Multiplication"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Maximum length of string allowed as a value (8192 characters).&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MAX_NAME_LENGTH">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="80"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Maximum length of a node name (80 characters).&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="userNodeForPackage">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Class" href="../../lang/Class.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the preference node from the calling user's preference tree&#xA;     * that is associated (by convention) with the specified class's package.&#xA;     * The convention is as follows: the absolute path name of the node is the&#xA;     * fully qualified package name, preceded by a slash (&lt;tt>'/'&lt;/tt>), and&#xA;     * with each period (&lt;tt>'.'&lt;/tt>) replaced by a slash.  For example the&#xA;     * absolute path name of the node associated with the class&#xA;     * &lt;tt>com.acme.widget&lt;/tt> is &lt;tt>/com/acme/widget&lt;/tt>.&#xA;     *&#xA;     * &lt;p>This convention does not apply to the unnamed package, whose&#xA;     * associated preference node is &lt;tt>&amp;lt;unnamed&amp;gt;&lt;/tt>.  This node&#xA;     * is not intended for long term use, but for convenience in the early&#xA;     * development of programs that do not yet belong to a package, and &#xA;     * for &quot;throwaway&quot; programs.  &lt;i>Valuable data should not be stored&#xA;     * at this node as it is shared by all programs that use it.&lt;/i>&#xA;     *&#xA;     * &lt;p>A class &lt;tt>Foo&lt;/tt> wishing to access preferences pertaining to its&#xA;     * package can obtain a preference node as follows: &lt;pre>&#xA;     *    static Preferences prefs = Preferences.userNodeForPackage(Foo.class);&#xA;     * &lt;/pre>&#xA;     * This idiom obviates the need for using a string to describe the&#xA;     * preferences node and decreases the likelihood of a run-time failure.&#xA;     * (If the class name is misspelled, it will typically result in a&#xA;     * compile-time error.)&#xA;     *&#xA;     * &lt;p>Invoking this method will result in the creation of the returned&#xA;     * node and its ancestors if they do not already exist.  If the returned&#xA;     * node did not exist prior to this call, this node and any ancestors that&#xA;     * were created by this call are not guaranteed to become permanent until&#xA;     * the &lt;tt>flush&lt;/tt> method is called on the returned node (or one of its&#xA;     * ancestors or descendants).&#xA;     *&#xA;     * @param c the class for whose package a user preference node is desired.&#xA;     * @return the user preference node associated with the package of which&#xA;     *         &lt;tt>c&lt;/tt> is a member.&#xA;     * @throws NullPointerException if &lt;tt>c&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     * @throws SecurityException if a security manager is present and&#xA;     *         it denies &lt;tt>RuntimePermission(&quot;preferences&quot;)&lt;/tt>.&#xA;     * @see    RuntimePermission&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.10">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.32">
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.8">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="systemNodeForPackage">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Class" href="../../lang/Class.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the preference node from the system preference tree that is&#xA;     * associated (by convention) with the specified class's package.  The&#xA;     * convention is as follows: the absolute path name of the node is the&#xA;     * fully qualified package name, preceded by a slash (&lt;tt>'/'&lt;/tt>), and&#xA;     * with each period (&lt;tt>'.'&lt;/tt>) replaced by a slash.  For example the&#xA;     * absolute path name of the node associated with the class&#xA;     * &lt;tt>com.acme.widget&lt;/tt> is &lt;tt>/com/acme/widget&lt;/tt>.&#xA;     *&#xA;     * &lt;p>This convention does not apply to the unnamed package, whose&#xA;     * associated preference node is &lt;tt>&amp;lt;unnamed&amp;gt;&lt;/tt>.  This node&#xA;     * is not intended for long term use, but for convenience in the early&#xA;     * development of programs that do not yet belong to a package, and &#xA;     * for &quot;throwaway&quot; programs.  &lt;i>Valuable data should not be stored&#xA;     * at this node as it is shared by all programs that use it.&lt;/i>&#xA;     *&#xA;     * &lt;p>A class &lt;tt>Foo&lt;/tt> wishing to access preferences pertaining to its&#xA;     * package can obtain a preference node as follows: &lt;pre>&#xA;     *  static Preferences prefs = Preferences.systemNodeForPackage(Foo.class);&#xA;     * &lt;/pre>&#xA;     * This idiom obviates the need for using a string to describe the&#xA;     * preferences node and decreases the likelihood of a run-time failure.&#xA;     * (If the class name is misspelled, it will typically result in a&#xA;     * compile-time error.)&#xA;     *&#xA;     * &lt;p>Invoking this method will result in the creation of the returned&#xA;     * node and its ancestors if they do not already exist.  If the returned&#xA;     * node did not exist prior to this call, this node and any ancestors that&#xA;     * were created by this call are not guaranteed to become permanent until&#xA;     * the &lt;tt>flush&lt;/tt> method is called on the returned node (or one of its&#xA;     * ancestors or descendants).&#xA;     *&#xA;     * @param c the class for whose package a system preference node is desired.&#xA;     * @return the system preference node associated with the package of which&#xA;     *         &lt;tt>c&lt;/tt> is a member.&#xA;     * @throws NullPointerException if &lt;tt>c&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     * @throws SecurityException if a security manager is present and&#xA;     *         it denies &lt;tt>RuntimePermission(&quot;preferences&quot;)&lt;/tt>.&#xA;     * @see    RuntimePermission&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.32">
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.8">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="nodeName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/Class.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Returns the absolute path name of the node corresponding to the package&#xA;     * of the specified object.&#xA;     *&#xA;     * @throws IllegalArgumentException if the package has node preferences&#xA;     *         node associated with it. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Arrays have no associated preferences node."/>
          </throwable>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../lang/Class.class.xmi#//@classifiers.0/@members.40"/>
          </next>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="className">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Class.class.xmi#//@classifiers.0/@members.44"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="pkgEndIndex">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.47"/>
              <arguments xsi:type="literals:CharacterLiteral" value="46"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:StringReference" value="/&lt;unnamed>"/>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.2/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="packageName">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.56"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.2/@variable"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:StringReference" value="/"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.4/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.59"/>
              <arguments xsi:type="literals:CharacterLiteral" value="46"/>
              <arguments xsi:type="literals:CharacterLiteral" value="47"/>
            </next>
          </children>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="prefsPerm">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/RuntimePermission.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arguments xsi:type="references:StringReference" value="preferences"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../security/Permission.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * This permission object represents the permission required to get&#xA;     * access to the user or system root (which in turn allows for all&#xA;     * other operations).&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="userRoot">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the root preference node for the calling user.&#xA;     *&#xA;     * @return the root preference node for the calling user.&#xA;     * @throws SecurityException If a security manager is present and&#xA;     *         it denies &lt;tt>RuntimePermission(&quot;preferences&quot;)&lt;/tt>.&#xA;     * @see    RuntimePermission&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/SecurityManager.class.xmi#//@classifiers.0/@members.22"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
            </next>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="PreferencesFactory.class.xmi#//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="systemRoot">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the root preference node for the system.&#xA;     *&#xA;     * @return the root preference node for the system.&#xA;     * @throws SecurityException If a security manager is present and&#xA;     *         it denies &lt;tt>RuntimePermission(&quot;preferences&quot;)&lt;/tt>.&#xA;     * @see    RuntimePermission&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/SecurityManager.class.xmi#//@classifiers.0/@members.22"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
            </next>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="PreferencesFactory.class.xmi#//@classifiers.0/@members.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Constructor" name="Preferences">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Sole constructor. (For invocation by subclass constructors, typically&#xA;     * implicit.) &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="put">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Associates the specified value with the specified key in this&#xA;     * preference node.&#xA;     *&#xA;     * @param key key with which the specified value is to be associated.&#xA;     * @param value value to be associated with the specified key.&#xA;     * @throws NullPointerException if key or value is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if &lt;tt>key.length()&lt;/tt> exceeds&#xA;     *       &lt;tt>MAX_KEY_LENGTH&lt;/tt> or if &lt;tt>value.length&lt;/tt> exceeds&#xA;     *       &lt;tt>MAX_VALUE_LENGTH&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value associated with the specified key in this preference&#xA;     * node.  Returns the specified default if there is no value associated&#xA;     * with the key, or the backing store is inaccessible.&#xA;     *&#xA;     * &lt;p>Some implementations may store default values in their backing&#xA;     * stores.  If there is no value associated with the specified key&#xA;     * but there is such a &lt;i>stored default&lt;/i>, it is returned in&#xA;     * preference to the specified default.&#xA;     *&#xA;     * @param key key whose associated value is to be returned.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>.&#xA;     * @return the value associated with &lt;tt>key&lt;/tt>, or &lt;tt>def&lt;/tt>&#xA;     *         if no value is associated with &lt;tt>key&lt;/tt>, or the backing&#xA;     *         store is inaccessible.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.  (A &#xA;     *         &lt;tt>null&lt;/tt> value for &lt;tt>def&lt;/tt> &lt;i>is&lt;/i> permitted.)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="remove">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes the value associated with the specified key in this preference&#xA;     * node, if any.&#xA;     *&#xA;     * &lt;p>If this implementation supports &lt;i>stored defaults&lt;/i>, and there is&#xA;     * such a default for the specified preference, the stored default will be&#xA;     * &quot;exposed&quot; by this call, in the sense that it will be returned&#xA;     * by a succeeding call to &lt;tt>get&lt;/tt>.&#xA;     *&#xA;     * @param key key whose mapping is to be removed from the preference node.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="clear">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes all of the preferences (key-value associations) in this&#xA;     * preference node.  This call has no effect on any descendants&#xA;     * of this node.&#xA;     *&#xA;     * &lt;p>If this implementation supports &lt;i>stored defaults&lt;/i>, and this&#xA;     * node in the preferences hierarchy contains any such defaults,&#xA;     * the stored defaults will be &quot;exposed&quot; by this call, in the sense that&#xA;     * they will be returned by succeeding calls to &lt;tt>get&lt;/tt>.&#xA;     *&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #removeNode()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putInt">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Associates a string representing the specified int value with the&#xA;     * specified key in this preference node.  The associated string is the&#xA;     * one that would be returned if the int value were passed to&#xA;     * {@link Integer#toString(int)}.  This method is intended for use in&#xA;     * conjunction with {@link #getInt}.&#xA;     *&#xA;     * @param key key with which the string form of value is to be associated.&#xA;     * @param value value whose string form is to be associated with key.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if &lt;tt>key.length()&lt;/tt> exceeds&#xA;     *         &lt;tt>MAX_KEY_LENGTH&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #getInt(String,int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getInt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the int value represented by the string associated with the&#xA;     * specified key in this preference node.  The string is converted to&#xA;     * an integer as by {@link Integer#parseInt(String)}.  Returns the&#xA;     * specified default if there is no value associated with the key,&#xA;     * the backing store is inaccessible, or if&#xA;     * &lt;tt>Integer.parseInt(String)&lt;/tt> would throw a {@link&#xA;     * NumberFormatException} if the associated value were passed.  This&#xA;     * method is intended for use in conjunction with {@link #putInt}.&#xA;     *&#xA;     * &lt;p>If the implementation supports &lt;i>stored defaults&lt;/i> and such a&#xA;     * default exists, is accessible, and could be converted to an int&#xA;     * with &lt;tt>Integer.parseInt&lt;/tt>, this int is returned in preference to&#xA;     * the specified default.&#xA;     *&#xA;     * @param key key whose associated value is to be returned as an int.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>&#xA;     *        or the associated value cannot be interpreted as an int,&#xA;     *        or the backing store is inaccessible.&#xA;     * @return the int value represented by the string associated with&#xA;     *         &lt;tt>key&lt;/tt> in this preference node, or &lt;tt>def&lt;/tt> if the&#xA;     *         associated value does not exist or cannot be interpreted as&#xA;     *         an int.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     * @see #putInt(String,int)&#xA;     * @see #get(String,String)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putLong">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Associates a string representing the specified long value with the&#xA;     * specified key in this preference node.  The associated string is the&#xA;     * one that would be returned if the long value were passed to&#xA;     * {@link Long#toString(long)}.  This method is intended for use in&#xA;     * conjunction with {@link #getLong}.&#xA;     *&#xA;     * @param key key with which the string form of value is to be associated.&#xA;     * @param value value whose string form is to be associated with key.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if &lt;tt>key.length()&lt;/tt> exceeds&#xA;     *         &lt;tt>MAX_KEY_LENGTH&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #getLong(String,long)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLong">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the long value represented by the string associated with the&#xA;     * specified key in this preference node.  The string is converted to&#xA;     * a long as by {@link Long#parseLong(String)}.  Returns the&#xA;     * specified default if there is no value associated with the key,&#xA;     * the backing store is inaccessible, or if&#xA;     * &lt;tt>Long.parseLong(String)&lt;/tt> would throw a {@link&#xA;     * NumberFormatException} if the associated value were passed.  This&#xA;     * method is intended for use in conjunction with {@link #putLong}.&#xA;     *&#xA;     * &lt;p>If the implementation supports &lt;i>stored defaults&lt;/i> and such a&#xA;     * default exists, is accessible, and could be converted to a long&#xA;     * with &lt;tt>Long.parseLong&lt;/tt>, this long is returned in preference to&#xA;     * the specified default.&#xA;     *&#xA;     * @param key key whose associated value is to be returned as a long.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>&#xA;     *        or the associated value cannot be interpreted as a long,&#xA;     *        or the backing store is inaccessible.&#xA;     * @return the long value represented by the string associated with&#xA;     *         &lt;tt>key&lt;/tt> in this preference node, or &lt;tt>def&lt;/tt> if the&#xA;     *         associated value does not exist or cannot be interpreted as&#xA;     *         a long.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     * @see #putLong(String,long)&#xA;     * @see #get(String,String)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putBoolean">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Associates a string representing the specified boolean value with the&#xA;     * specified key in this preference node.  The associated string is&#xA;     * &lt;tt>&quot;true&quot;&lt;/tt> if the value is true, and &lt;tt>&quot;false&quot;&lt;/tt> if it is&#xA;     * false.  This method is intended for use in conjunction with&#xA;     * {@link #getBoolean}.&#xA;     *&#xA;     * @param key key with which the string form of value is to be associated.&#xA;     * @param value value whose string form is to be associated with key.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if &lt;tt>key.length()&lt;/tt> exceeds&#xA;     *         &lt;tt>MAX_KEY_LENGTH&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #getBoolean(String,boolean)&#xA;     * @see #get(String,String)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBoolean">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the boolean value represented by the string associated with the&#xA;     * specified key in this preference node.  Valid strings&#xA;     * are &lt;tt>&quot;true&quot;&lt;/tt>, which represents true, and &lt;tt>&quot;false&quot;&lt;/tt>, which&#xA;     * represents false.  Case is ignored, so, for example, &lt;tt>&quot;TRUE&quot;&lt;/tt>&#xA;     * and &lt;tt>&quot;False&quot;&lt;/tt> are also valid.  This method is intended for use in&#xA;     * conjunction with {@link #putBoolean}.&#xA;     *&#xA;     * &lt;p>Returns the specified default if there is no value&#xA;     * associated with the key, the backing store is inaccessible, or if the&#xA;     * associated value is something other than &lt;tt>&quot;true&quot;&lt;/tt> or&#xA;     * &lt;tt>&quot;false&quot;&lt;/tt>, ignoring case.&#xA;     *&#xA;     * &lt;p>If the implementation supports &lt;i>stored defaults&lt;/i> and such a&#xA;     * default exists and is accessible, it is used in preference to the&#xA;     * specified default, unless the stored default is something other than&#xA;     * &lt;tt>&quot;true&quot;&lt;/tt> or &lt;tt>&quot;false&quot;&lt;/tt>, ignoring case, in which case the&#xA;     * specified default is used.&#xA;     *&#xA;     * @param key key whose associated value is to be returned as a boolean.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>&#xA;     *        or the associated value cannot be interpreted as a boolean,&#xA;     *        or the backing store is inaccessible.&#xA;     * @return the boolean value represented by the string associated with&#xA;     *         &lt;tt>key&lt;/tt> in this preference node, or &lt;tt>def&lt;/tt> if the&#xA;     *         associated value does not exist or cannot be interpreted as&#xA;     *         a boolean.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     * @see #get(String,String)&#xA;     * @see #putBoolean(String,boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putFloat">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Associates a string representing the specified float value with the&#xA;     * specified key in this preference node.  The associated string is the&#xA;     * one that would be returned if the float value were passed to&#xA;     * {@link Float#toString(float)}.  This method is intended for use in&#xA;     * conjunction with {@link #getFloat}.&#xA;     *&#xA;     * @param key key with which the string form of value is to be associated.&#xA;     * @param value value whose string form is to be associated with key.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if &lt;tt>key.length()&lt;/tt> exceeds&#xA;     *         &lt;tt>MAX_KEY_LENGTH&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #getFloat(String,float)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFloat">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the float value represented by the string associated with the&#xA;     * specified key in this preference node.  The string is converted to an&#xA;     * integer as by {@link Float#parseFloat(String)}.  Returns the specified&#xA;     * default if there is no value associated with the key, the backing store&#xA;     * is inaccessible, or if &lt;tt>Float.parseFloat(String)&lt;/tt> would throw a&#xA;     * {@link NumberFormatException} if the associated value were passed.&#xA;     * This method is intended for use in conjunction with {@link #putFloat}.&#xA;     *&#xA;     * &lt;p>If the implementation supports &lt;i>stored defaults&lt;/i> and such a&#xA;     * default exists, is accessible, and could be converted to a float&#xA;     * with &lt;tt>Float.parseFloat&lt;/tt>, this float is returned in preference to&#xA;     * the specified default.&#xA;     *&#xA;     * @param key key whose associated value is to be returned as a float.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>&#xA;     *        or the associated value cannot be interpreted as a float,&#xA;     *        or the backing store is inaccessible.&#xA;     * @return the float value represented by the string associated with&#xA;     *         &lt;tt>key&lt;/tt> in this preference node, or &lt;tt>def&lt;/tt> if the&#xA;     *         associated value does not exist or cannot be interpreted as&#xA;     *         a float.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     * @see #putFloat(String,float)&#xA;     * @see #get(String,String)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putDouble">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Associates a string representing the specified double value with the&#xA;     * specified key in this preference node.  The associated string is the&#xA;     * one that would be returned if the double value were passed to&#xA;     * {@link Double#toString(double)}.  This method is intended for use in&#xA;     * conjunction with {@link #getDouble}.&#xA;     *&#xA;     * @param key key with which the string form of value is to be associated.&#xA;     * @param value value whose string form is to be associated with key.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if &lt;tt>key.length()&lt;/tt> exceeds&#xA;     *         &lt;tt>MAX_KEY_LENGTH&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #getDouble(String,double)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDouble">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the double value represented by the string associated with the&#xA;     * specified key in this preference node.  The string is converted to an&#xA;     * integer as by {@link Double#parseDouble(String)}.  Returns the specified&#xA;     * default if there is no value associated with the key, the backing store&#xA;     * is inaccessible, or if &lt;tt>Double.parseDouble(String)&lt;/tt> would throw a&#xA;     * {@link NumberFormatException} if the associated value were passed.&#xA;     * This method is intended for use in conjunction with {@link #putDouble}.&#xA;     *&#xA;     * &lt;p>If the implementation supports &lt;i>stored defaults&lt;/i> and such a&#xA;     * default exists, is accessible, and could be converted to a double&#xA;     * with &lt;tt>Double.parseDouble&lt;/tt>, this double is returned in preference&#xA;     * to the specified default.&#xA;     *&#xA;     * @param key key whose associated value is to be returned as a double.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>&#xA;     *        or the associated value cannot be interpreted as a double,&#xA;     *        or the backing store is inaccessible.&#xA;     * @return the double value represented by the string associated with&#xA;     *         &lt;tt>key&lt;/tt> in this preference node, or &lt;tt>def&lt;/tt> if the&#xA;     *         associated value does not exist or cannot be interpreted as&#xA;     *         a double.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     * @see #putDouble(String,double)&#xA;     * @see #get(String,String)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putByteArray">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Associates a string representing the specified byte array with the&#xA;     * specified key in this preference node.  The associated string is&#xA;     * the &lt;i>Base64&lt;/i> encoding of the byte array, as defined in &lt;a&#xA;     * href=http://www.ietf.org/rfc/rfc2045.txt>RFC 2045&lt;/a>, Section 6.8,&#xA;     * with one minor change: the string will consist solely of characters&#xA;     * from the &lt;i>Base64 Alphabet&lt;/i>; it will not contain any newline&#xA;     * characters.  Note that the maximum length of the byte array is limited&#xA;     * to three quarters of &lt;tt>MAX_VALUE_LENGTH&lt;/tt> so that the length&#xA;     * of the Base64 encoded String does not exceed &lt;tt>MAX_VALUE_LENGTH&lt;/tt>.&#xA;     * This method is intended for use in conjunction with&#xA;     * {@link #getByteArray}.&#xA;     *&#xA;     * @param key key with which the string form of value is to be associated.&#xA;     * @param value value whose string form is to be associated with key.&#xA;     * @throws NullPointerException if key or value is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if key.length() exceeds MAX_KEY_LENGTH&#xA;     *         or if value.length exceeds MAX_VALUE_LENGTH*3/4.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #getByteArray(String,byte[])&#xA;     * @see #get(String,String)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getByteArray">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the byte array value represented by the string associated with&#xA;     * the specified key in this preference node.  Valid strings are&#xA;     * &lt;i>Base64&lt;/i> encoded binary data, as defined in &lt;a&#xA;     * href=http://www.ietf.org/rfc/rfc2045.txt>RFC 2045&lt;/a>, Section 6.8, &#xA;     * with one minor change: the string must consist solely of characters&#xA;     * from the &lt;i>Base64 Alphabet&lt;/i>; no newline characters or&#xA;     * extraneous characters are permitted.  This method is intended for use&#xA;     * in conjunction with {@link #putByteArray}.&#xA;     *&#xA;     * &lt;p>Returns the specified default if there is no value&#xA;     * associated with the key, the backing store is inaccessible, or if the&#xA;     * associated value is not a valid Base64 encoded byte array&#xA;     * (as defined above).&#xA;     *&#xA;     * &lt;p>If the implementation supports &lt;i>stored defaults&lt;/i> and such a&#xA;     * default exists and is accessible, it is used in preference to the&#xA;     * specified default, unless the stored default is not a valid Base64&#xA;     * encoded byte array (as defined above), in which case the&#xA;     * specified default is used.&#xA;     *&#xA;     * @param key key whose associated value is to be returned as a byte array.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>&#xA;     *        or the associated value cannot be interpreted as a byte array,&#xA;     *        or the backing store is inaccessible.&#xA;     * @return the byte array value represented by the string associated with&#xA;     *         &lt;tt>key&lt;/tt> in this preference node, or &lt;tt>def&lt;/tt> if the&#xA;     *         associated value does not exist or cannot be interpreted as&#xA;     *         a byte array.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.  (A &#xA;     *         &lt;tt>null&lt;/tt> value for &lt;tt>def&lt;/tt> &lt;i>is&lt;/i> permitted.)&#xA;     * @see #get(String,String)&#xA;     * @see #putByteArray(String,byte[])&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="keys">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns all of the keys that have an associated value in this&#xA;     * preference node.  (The returned array will be of size zero if&#xA;     * this node has no preferences.)&#xA;     *&#xA;     * &lt;p>If the implementation supports &lt;i>stored defaults&lt;/i> and there&#xA;     * are any such defaults at this node that have not been overridden,&#xA;     * by explicit preferences, the defaults are returned in the array in&#xA;     * addition to any explicit preferences.&#xA;     *&#xA;     * @return an array of the keys that have an associated value in this&#xA;     *         preference node.&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="childrenNames">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the names of the children of this preference node, relative to&#xA;     * this node.  (The returned array will be of size zero if this node has&#xA;     * no children.)&#xA;     *&#xA;     * @return the names of the children of this preference node.&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="parent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the parent of this preference node, or &lt;tt>null&lt;/tt> if this is&#xA;     * the root.&#xA;     *&#xA;     * @return the parent of this preference node.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="node">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pathName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Returns the named preference node in the same tree as this node,&#xA;     * creating it and any of its ancestors if they do not already exist.&#xA;     * Accepts a relative or absolute path name.  Relative path names&#xA;     * (which do not begin with the slash character &lt;tt>('/')&lt;/tt>) are&#xA;     * interpreted relative to this preference node.&#xA;     *&#xA;     * &lt;p>If the returned node did not exist prior to this call, this node and&#xA;     * any ancestors that were created by this call are not guaranteed&#xA;     * to become permanent until the &lt;tt>flush&lt;/tt> method is called on&#xA;     * the returned node (or one of its ancestors or descendants).&#xA;     *&#xA;     * @param pathName the path name of the preference node to return.&#xA;     * @return the specified preference node.&#xA;     * @throws IllegalArgumentException if the path name is invalid (i.e.,&#xA;     *         it contains multiple consecutive slash characters, or ends&#xA;     *         with a slash character and is more than one character long).&#xA;     * @throws NullPointerException if path name is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #flush()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="nodeExists">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pathName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Returns true if the named preference node exists in the same tree&#xA;     * as this node.  Relative path names (which do not begin with the slash&#xA;     * character &lt;tt>('/')&lt;/tt>) are interpreted relative to this preference&#xA;     * node.&#xA;     *&#xA;     * &lt;p>If this node (or an ancestor) has already been removed with the &#xA;     * {@link #removeNode()} method, it &lt;i>is&lt;/i> legal to invoke this method,&#xA;     * but only with the path name &lt;tt>&quot;&quot;&lt;/tt>; the invocation will return&#xA;     * &lt;tt>false&lt;/tt>.  Thus, the idiom &lt;tt>p.nodeExists(&quot;&quot;)&lt;/tt> may be&#xA;     * used to test whether &lt;tt>p&lt;/tt> has been removed.&#xA;     *&#xA;     * @param pathName the path name of the node whose existence&#xA;     *        is to be checked.&#xA;     * @return true if the specified node exists.&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     * @throws IllegalArgumentException if the path name is invalid (i.e.,&#xA;     *         it contains multiple consecutive slash characters, or ends&#xA;     *         with a slash character and is more than one character long).&#xA;     * @throws NullPointerException if path name is &lt;tt>null&lt;/tt>.&#xA;s     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method and&#xA;     *         &lt;tt>pathName&lt;/tt> is not the empty string (&lt;tt>&quot;&quot;&lt;/tt>).&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removeNode">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Removes this preference node and all of its descendants, invalidating&#xA;     * any preferences contained in the removed nodes.  Once a node has been&#xA;     * removed, attempting any method other than {@link #name()},&#xA;     * {@link #absolutePath()}, {@link #isUserNode()}, {@link #flush()} or&#xA;     * {@link #node(String) nodeExists(&quot;&quot;)} on the corresponding&#xA;     * &lt;tt>Preferences&lt;/tt> instance will fail with an&#xA;     * &lt;tt>IllegalStateException&lt;/tt>.  (The methods defined on {@link Object}&#xA;     * can still be invoked on a node after it has been removed; they will not&#xA;     * throw &lt;tt>IllegalStateException&lt;/tt>.)&#xA;     *&#xA;     * &lt;p>The removal is not guaranteed to be persistent until the&#xA;     * &lt;tt>flush&lt;/tt> method is called on this node (or an ancestor).&#xA;     *&#xA;     * &lt;p>If this implementation supports &lt;i>stored defaults&lt;/i>, removing a&#xA;     * node exposes any stored defaults at or below this node.  Thus, a&#xA;     * subsequent call to &lt;tt>nodeExists&lt;/tt> on this node's path name may&#xA;     * return &lt;tt>true&lt;/tt>, and a subsequent call to &lt;tt>node&lt;/tt> on this&#xA;     * path name may return a (different) &lt;tt>Preferences&lt;/tt> instance&#xA;     * representing a non-empty collection of preferences and/or children.&#xA;     *&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has already&#xA;     *         been removed with the {@link #removeNode()} method.&#xA;     * @throws UnsupportedOperationException if this method is invoked on &#xA;     *         the root node.&#xA;     * @see #flush()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="name">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns this preference node's name, relative to its parent.&#xA;     *&#xA;     * @return this preference node's name, relative to its parent.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="absolutePath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns this preference node's absolute path name.&#xA;     *&#xA;     * @return this preference node's absolute path name.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isUserNode">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this preference node is in the user&#xA;     * preference tree, &lt;tt>false&lt;/tt> if it's in the system preference tree.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if this preference node is in the user&#xA;     *         preference tree, &lt;tt>false&lt;/tt> if it's in the system&#xA;     *         preference tree.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a string representation of this preferences node,&#xA;     * as if computed by the expression:&lt;tt>(this.isUserNode() ? &quot;User&quot; :&#xA;     * &quot;System&quot;) + &quot; Preference Node: &quot; + this.absolutePath()&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="flush">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Forces any changes in the contents of this preference node and its&#xA;     * descendants to the persistent store.  Once this method returns&#xA;     * successfully, it is safe to assume that all changes made in the&#xA;     * subtree rooted at this node prior to the method invocation have become&#xA;     * permanent.&#xA;     * &#xA;     * &lt;p>Implementations are free to flush changes into the persistent store&#xA;     * at any time.  They do not need to wait for this method to be called.&#xA;     *&#xA;     * &lt;p>When a flush occurs on a newly created node, it is made persistent,&#xA;     * as are any ancestors (and descendants) that have yet to be made&#xA;     * persistent.  Note however that any preference value changes in&#xA;     * ancestors are &lt;i>not&lt;/i> guaranteed to be made persistent.&#xA;     *&#xA;     * &lt;p> If this method is invoked on a node that has been removed with &#xA;     * the {@link #removeNode()} method, flushSpi() is invoked on this node, &#xA;     * but not on others.&#xA;     *&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     * @see    #sync()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="sync">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Ensures that future reads from this preference node and its&#xA;     * descendants reflect any changes that were committed to the persistent&#xA;     * store (from any VM) prior to the &lt;tt>sync&lt;/tt> invocation.  As a&#xA;     * side-effect, forces any changes in the contents of this preference node&#xA;     * and its descendants to the persistent store, as if the &lt;tt>flush&lt;/tt>&#xA;     * method had been invoked on this node.&#xA;     *&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see    #flush()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addPreferenceChangeListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pcl">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="PreferenceChangeListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Registers the specified listener to receive &lt;i>preference change&#xA;     * events&lt;/i> for this preference node.  A preference change event is&#xA;     * generated when a preference is added to this node, removed from this&#xA;     * node, or when the value associated with a preference is changed.&#xA;     * (Preference change events are &lt;i>not&lt;/i> generated by the {@link&#xA;     * #removeNode()} method, which generates a &lt;i>node change event&lt;/i>.&#xA;     * Preference change events &lt;i>are&lt;/i> generated by the &lt;tt>clear&lt;/tt>&#xA;     * method.)&#xA;     *&#xA;     * &lt;p>Events are only guaranteed for changes made within the same JVM&#xA;     * as the registered listener, though some implementations may generate&#xA;     * events for changes made outside this JVM.  Events may be generated&#xA;     * before the changes have been made persistent.  Events are not generated&#xA;     * when preferences are modified in descendants of this node; a caller&#xA;     * desiring such events must register with each descendant.&#xA;     * &#xA;     * @param pcl The preference change listener to add.&#xA;     * @throws NullPointerException if &lt;tt>pcl&lt;/tt> is null.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #removePreferenceChangeListener(PreferenceChangeListener)&#xA;     * @see #addNodeChangeListener(NodeChangeListener)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removePreferenceChangeListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pcl">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="PreferenceChangeListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes the specified preference change listener, so it no longer&#xA;     * receives preference change events.&#xA;     *&#xA;     * @param pcl The preference change listener to remove. &#xA;     * @throws IllegalArgumentException if &lt;tt>pcl&lt;/tt> was not a registered&#xA;     *         preference change listener on this node.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #addPreferenceChangeListener(PreferenceChangeListener)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addNodeChangeListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ncl">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="NodeChangeListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Registers the specified listener to receive &lt;i>node change events&lt;/i>&#xA;     * for this node.  A node change event is generated when a child node is&#xA;     * added to or removed from this node.  (A single {@link #removeNode()}&#xA;     * invocation results in multiple &lt;i>node change events&lt;/i>, one for every&#xA;     * node in the subtree rooted at the removed node.)&#xA;     *&#xA;     * &lt;p>Events are only guaranteed for changes made within the same JVM&#xA;     * as the registered listener, though some implementations may generate&#xA;     * events for changes made outside this JVM.  Events may be generated&#xA;     * before the changes have become permanent.  Events are not generated&#xA;     * when indirect descendants of this node are added or removed; a&#xA;     * caller desiring such events must register with each descendant.&#xA;     *&#xA;     * &lt;p>Few guarantees can be made regarding node creation.  Because nodes&#xA;     * are created implicitly upon access, it may not be feasible for an&#xA;     * implementation to determine whether a child node existed in the backing&#xA;     * store prior to access (for example, because the backing store is&#xA;     * unreachable or cached information is out of date).  Under these&#xA;     * circumstances, implementations are neither required to generate node&#xA;     * change events nor prohibited from doing so.&#xA;     * &#xA;     * @param ncl The &lt;tt>NodeChangeListener&lt;/tt> to add.&#xA;     * @throws NullPointerException if &lt;tt>ncl&lt;/tt> is null.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #removeNodeChangeListener(NodeChangeListener)&#xA;     * @see #addPreferenceChangeListener(PreferenceChangeListener)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removeNodeChangeListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ncl">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="NodeChangeListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes the specified &lt;tt>NodeChangeListener&lt;/tt>, so it no longer&#xA;     * receives change events.&#xA;     *&#xA;     * @param ncl The &lt;tt>NodeChangeListener&lt;/tt> to remove. &#xA;     * @throws IllegalArgumentException if &lt;tt>ncl&lt;/tt> was not a registered&#xA;     *         &lt;tt>NodeChangeListener&lt;/tt> on this node.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #addNodeChangeListener(NodeChangeListener)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="exportNode">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="os">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Emits on the specified output stream an XML document representing all&#xA;     * of the preferences contained in this node (but not its descendants).&#xA;     * This XML document is, in effect, an offline backup of the node.&#xA;     *&#xA;     * &lt;p>The XML document will have the following DOCTYPE declaration:&#xA;     * &lt;pre>&#xA;     * &amp;lt;!DOCTYPE preferences SYSTEM &quot;http://java.sun.com/dtd/preferences.dtd&quot;&amp;gt;&#xA;     * &lt;/pre>&#xA;     * The UTF-8 character encoding will be used.&#xA;     *&#xA;     * &lt;p>This method is an exception to the general rule that the results of&#xA;     * concurrently executing multiple methods in this class yields&#xA;     * results equivalent to some serial execution.  If the preferences&#xA;     * at this node are modified concurrently with an invocation of this&#xA;     * method, the exported preferences comprise a &quot;fuzzy snapshot&quot; of the&#xA;     * preferences contained in the node; some of the concurrent modifications&#xA;     * may be reflected in the exported data while others may not.&#xA;     *&#xA;     * @param os the output stream on which to emit the XML document.&#xA;     * @throws IOException if writing to the specified output stream&#xA;     *         results in an &lt;tt>IOException&lt;/tt>.&#xA;     * @throws BackingStoreException if preference data cannot be read from&#xA;     *         backing store.&#xA;     * @see    #importPreferences(InputStream)&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="exportSubtree">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="os">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Emits an XML document representing all of the preferences contained&#xA;     * in this node and all of its descendants.  This XML document is, in&#xA;     * effect, an offline backup of the subtree rooted at the node.&#xA;     *&#xA;     * &lt;p>The XML document will have the following DOCTYPE declaration:&#xA;     * &lt;pre>&#xA;     * &amp;lt;!DOCTYPE preferences SYSTEM &quot;http://java.sun.com/dtd/preferences.dtd&quot;&amp;gt;&#xA;     * &lt;/pre>&#xA;     * The UTF-8 character encoding will be used.&#xA;     *&#xA;     * &lt;p>This method is an exception to the general rule that the results of&#xA;     * concurrently executing multiple methods in this class yields&#xA;     * results equivalent to some serial execution.  If the preferences&#xA;     * or nodes in the subtree rooted at this node are modified concurrently&#xA;     * with an invocation of this method, the exported preferences comprise a&#xA;     * &quot;fuzzy snapshot&quot; of the subtree; some of the concurrent modifications&#xA;     * may be reflected in the exported data while others may not.&#xA;     *&#xA;     * @param os the output stream on which to emit the XML document.&#xA;     * @throws IOException if writing to the specified output stream&#xA;     *         results in an &lt;tt>IOException&lt;/tt>.&#xA;     * @throws BackingStoreException if preference data cannot be read from&#xA;     *         backing store.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see    #importPreferences(InputStream)&#xA;     * @see    #exportNode(OutputStream)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="importPreferences">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="is">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InvalidPreferencesFormatException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Imports all of the preferences represented by the XML document on the&#xA;     * specified input stream.  The document may represent user preferences or&#xA;     * system preferences.  If it represents user preferences, the preferences&#xA;     * will be imported into the calling user's preference tree (even if they&#xA;     * originally came from a different user's preference tree).  If any of&#xA;     * the preferences described by the document inhabit preference nodes that&#xA;     * do not exist, the nodes will be created.&#xA;     *&#xA;     * &lt;p>The XML document must have the following DOCTYPE declaration:&#xA;     * &lt;pre>&#xA;     * &amp;lt;!DOCTYPE preferences SYSTEM &quot;http://java.sun.com/dtd/preferences.dtd&quot;&amp;gt;&#xA;     * &lt;/pre>&#xA;     * (This method is designed for use in conjunction with&#xA;     * {@link #exportNode(OutputStream)} and&#xA;     * {@link #exportSubtree(OutputStream)}.&#xA;     *&#xA;     * &lt;p>This method is an exception to the general rule that the results of&#xA;     * concurrently executing multiple methods in this class yields&#xA;     * results equivalent to some serial execution.  The method behaves&#xA;     * as if implemented on top of the other public methods in this class,&#xA;     * notably {@link #node(String)} and {@link #put(String, String)}.&#xA;     *&#xA;     * @param is the input stream from which to read the XML document.&#xA;     * @throws IOException if reading from the specified output stream&#xA;     *         results in an &lt;tt>IOException&lt;/tt>.&#xA;     * @throws InvalidPreferencesFormatException Data on input stream does not&#xA;     *         constitute a valid XML document with the mandated document type.&#xA;     * @throws SecurityException If a security manager is present and&#xA;     *         it denies &lt;tt>RuntimePermission(&quot;preferences&quot;)&lt;/tt>.&#xA;     * @see    RuntimePermission&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="XmlSupport.class.xmi#//@classifiers.0/@members.7"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
          </next>
          <target xsi:type="classifiers:Class" href="XmlSupport.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A node in a hierarchical collection of preference data.  This class&#xA; * allows applications to store and retrieve user and system&#xA; * preference and configuration data.  This data is stored&#xA; * persistently in an implementation-dependent backing store.  Typical&#xA; * implementations include flat files, OS-specific registries,&#xA; * directory servers and SQL databases.  The user of this class needn't&#xA; * be concerned with details of the backing store.&#xA; * &#xA; * &lt;p>There are two separate trees of preference nodes, one for user&#xA; * preferences and one for system preferences.  Each user has a separate user&#xA; * preference tree, and all users in a given system share the same system&#xA; * preference tree.  The precise description of &quot;user&quot; and &quot;system&quot; will vary&#xA; * from implementation to implementation.  Typical information stored in the&#xA; * user preference tree might include font choice, color choice, or preferred&#xA; * window location and size for a particular application.  Typical information&#xA; * stored in the system preference tree might include installation&#xA; * configuration data for an application.&#xA; *&#xA; * &lt;p>Nodes in a preference tree are named in a similar fashion to&#xA; * directories in a hierarchical file system.   Every node in a preference&#xA; * tree has a &lt;i>node name&lt;/i> (which is not necessarily unique),&#xA; * a unique &lt;i>absolute path name&lt;/i>, and a path name &lt;i>relative&lt;/i> to each&#xA; * ancestor including itself.&#xA; *&#xA; * &lt;p>The root node has a node name of the empty string (&quot;&quot;).  Every other&#xA; * node has an arbitrary node name, specified at the time it is created.  The&#xA; * only restrictions on this name are that it cannot be the empty string, and&#xA; * it cannot contain the slash character ('/').&#xA; *&#xA; * &lt;p>The root node has an absolute path name of &lt;tt>&quot;/&quot;&lt;/tt>.  Children of&#xA; * the root node have absolute path names of &lt;tt>&quot;/&quot; + &lt;/tt>&lt;i>&amp;lt;node&#xA; * name&amp;gt;&lt;/i>.  All other nodes have absolute path names of &lt;i>&amp;lt;parent's&#xA; * absolute path name&amp;gt;&lt;/i>&lt;tt> + &quot;/&quot; + &lt;/tt>&lt;i>&amp;lt;node name&amp;gt;&lt;/i>.&#xA; * Note that all absolute path names begin with the slash character.&#xA; *&#xA; * &lt;p>A node &lt;i>n&lt;/i>'s path name relative to its ancestor &lt;i>a&lt;/i>&#xA; * is simply the string that must be appended to &lt;i>a&lt;/i>'s absolute path name&#xA; * in order to form &lt;i>n&lt;/i>'s absolute path name, with the initial slash&#xA; * character (if present) removed.  Note that:&#xA; * &lt;ul>&#xA; * &lt;li>No relative path names begin with the slash character.&#xA; * &lt;li>Every node's path name relative to itself is the empty string.&#xA; * &lt;li>Every node's path name relative to its parent is its node name (except&#xA; * for the root node, which does not have a parent).&#xA; * &lt;li>Every node's path name relative to the root is its absolute path name&#xA; * with the initial slash character removed.&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p>Note finally that:&#xA; * &lt;ul>&#xA; * &lt;li>No path name contains multiple consecutive slash characters.&#xA; * &lt;li>No path name with the exception of the root's absolute path name&#xA; * ends in the slash character.&#xA; * &lt;li>Any string that conforms to these two rules is a valid path name.&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p>All of the methods that modify preferences data are permitted to operate&#xA; * asynchronously; they may return immediately, and changes will eventually&#xA; * propagate to the persistent backing store with an implementation-dependent&#xA; * delay.  The &lt;tt>flush&lt;/tt> method may be used to synchronously force&#xA; * updates to the backing store.  Normal termination of the Java Virtual&#xA; * Machine will &lt;i>not&lt;/i> result in the loss of pending updates -- an explicit&#xA; * &lt;tt>flush&lt;/tt> invocation is &lt;i>not&lt;/i> required upon termination to ensure&#xA; * that pending updates are made persistent.&#xA; * &#xA; * &lt;p>All of the methods that read preferences from a &lt;tt>Preferences&lt;/tt>&#xA; * object require the invoker to provide a default value.  The default value is&#xA; * returned if no value has been previously set &lt;i>or if the backing store is&#xA; * unavailable&lt;/i>.  The intent is to allow applications to operate, albeit&#xA; * with slightly degraded functionality, even if the backing store becomes&#xA; * unavailable.  Several methods, like &lt;tt>flush&lt;/tt>, have semantics that&#xA; * prevent them from operating if the backing store is unavailable.  Ordinary&#xA; * applications should have no need to invoke any of these methods, which can&#xA; * be identified by the fact that they are declared to throw {@link&#xA; * BackingStoreException}.&#xA; *&#xA; * &lt;p>The methods in this class may be invoked concurrently by multiple threads&#xA; * in a single JVM without the need for external synchronization, and the&#xA; * results will be equivalent to some serial execution.  If this class is used&#xA; * concurrently &lt;i>by multiple JVMs&lt;/i> that store their preference data in&#xA; * the same backing store, the data store will not be corrupted, but no&#xA; * other guarantees are made concerning the consistency of the preference&#xA; * data.&#xA; *&#xA; * &lt;p>This class contains an export/import facility, allowing preferences&#xA; * to be &quot;exported&quot; to an XML document, and XML documents representing&#xA; * preferences to be &quot;imported&quot; back into the system.  This facility&#xA; * may be used to back up all or part of a preference tree, and&#xA; * subsequently restore from the backup.&#xA; *&#xA; * &lt;p>The XML document has the following DOCTYPE declaration:&#xA; * &lt;pre>&#xA; * &amp;lt;!DOCTYPE preferences SYSTEM &quot;http://java.sun.com/dtd/preferences.dtd&quot;&amp;gt;&#xA; * &lt;/pre>&#xA; * Note that the system URI (http://java.sun.com/dtd/preferences.dtd) is&#xA; * &lt;i>not&lt;/i> accessed when exporting or importing preferences; it merely&#xA; * serves as a string to uniquely identify the DTD, which is:&#xA; * &lt;pre>&#xA; *    &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&#xA; *&#xA; *    &amp;lt;!-- DTD for a Preferences tree. --&amp;gt;&#xA; *&#xA; *    &amp;lt;!-- The preferences element is at the root of an XML document&#xA; *         representing a Preferences tree. --&amp;gt;&#xA; *    &amp;lt;!ELEMENT preferences (root)&amp;gt;&#xA; *  &#xA; *    &amp;lt;!-- The preferences element contains an optional version attribute,&#xA; *          which specifies version of DTD. --&amp;gt;&#xA; *    &amp;lt;!ATTLIST preferences EXTERNAL_XML_VERSION CDATA &quot;0.0&quot; &amp;gt  &#xA; *&#xA; *    &amp;lt;!-- The root element has a map representing the root's preferences&#xA; *         (if any), and one node for each child of the root (if any). --&amp;gt;&#xA; *    &amp;lt;!ELEMENT root (map, node*) &amp;gt;&#xA; *&#xA; *    &amp;lt;!-- Additionally, the root contains a type attribute, which&#xA; *         specifies whether it's the system or user root. --&amp;gt;&#xA; *    &amp;lt;!ATTLIST root&#xA; *              type (system|user) #REQUIRED &amp;gt;&#xA; *&#xA; *    &amp;lt;!-- Each node has a map representing its preferences (if any),&#xA; *         and one node for each child (if any). --&amp;gt;&#xA; *    &amp;lt;!ELEMENT node (map, node*) &amp;gt;&#xA; *&#xA; *    &amp;lt;!-- Additionally, each node has a name attribute --&amp;gt;&#xA; *    &amp;lt;!ATTLIST node&#xA; *              name CDATA #REQUIRED &amp;gt;&#xA; *&#xA; *    &amp;lt;!-- A map represents the preferences stored at a node (if any). --&amp;gt;&#xA; *    &amp;lt;!ELEMENT map (entry*) &amp;gt;&#xA; *&#xA; *    &amp;lt;!-- An entry represents a single preference, which is simply&#xA; *          a key-value pair. --&amp;gt;&#xA; *    &amp;lt;!ELEMENT entry EMPTY &amp;gt;&#xA; *    &amp;lt;!ATTLIST entry&#xA; *              key   CDATA #REQUIRED&#xA; *              value CDATA #REQUIRED &amp;gt;&#xA; * &lt;/pre>&#xA; *&#xA; * Every &lt;tt>Preferences&lt;/tt> implementation must have an associated {@link&#xA; * PreferencesFactory} implementation.  Every J2SE implementation must provide&#xA; * some means of specifying which &lt;tt>PreferencesFactory&lt;/tt> implementation&#xA; * is used to generate the root preferences nodes.  This allows the&#xA; * administrator to replace the default preferences implementation with an&#xA; * alternative implementation.&#xA; *&#xA; * &lt;p>Implementation note: In Sun's JRE, the &lt;tt>PreferencesFactory&lt;/tt>&#xA; * implementation is located as follows:&#xA; *&#xA; * &lt;ol>&#xA; *&#xA; * &lt;li>&lt;p>If the system property&#xA; * &lt;tt>java.util.prefs.PreferencesFactory&lt;/tt> is defined, then it is&#xA; * taken to be the fully-qualified name of a class implementing the&#xA; * &lt;tt>PreferencesFactory&lt;/tt> interface.  The class is loaded and&#xA; * instantiated; if this process fails then an unspecified error is&#xA; * thrown.&lt;/p>&lt;/li>&#xA; *&#xA; * &lt;li>&lt;p> If a &lt;tt>PreferencesFactory&lt;/tt> implementation class file&#xA; * has been installed in a jar file that is visible to the&#xA; * {@link java.lang.ClassLoader#getSystemClassLoader system class loader},&#xA; * and that jar file contains a provider-configuration file named&#xA; * &lt;tt>java.util.prefs.PreferencesFactory&lt;/tt> in the resource&#xA; * directory &lt;tt>META-INF/services&lt;/tt>, then the first class name&#xA; * specified in that file is taken.  If more than one such jar file is&#xA; * provided, the first one found will be used.  The class is loaded&#xA; * and instantiated; if this process fails then an unspecified error&#xA; * is thrown.  &lt;/p>&lt;/li>&#xA; *&#xA; * &lt;li>&lt;p>Finally, if neither the above-mentioned system property nor&#xA; * an extension jar file is provided, then the system-wide default&#xA; * &lt;tt>PreferencesFactory&lt;/tt> implementation for the underlying&#xA; * platform is loaded and instantiated.&lt;/p>&lt;/li>&#xA; *&#xA; * &lt;/ol>&#xA; *&#xA; * @author  Josh Bloch&#xA; * @version 1.25, 06/21/04&#xA; * @since   1.4&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
