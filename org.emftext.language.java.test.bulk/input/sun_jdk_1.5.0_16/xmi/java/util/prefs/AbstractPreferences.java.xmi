<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16 http://www.emftext.org/java/variables ../../../java.ecore#/17" name="AbstractPreferences.java">
  <comments>/*&#xA; * @(#)AbstractPreferences.java&#x9;1.20 04/01/12&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <namespaces>prefs</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../security/AccessController.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../security/PrivilegedAction.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <comments>// These imports needed only as a workaround for a JavaDoc bug</comments>
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../lang/Integer.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../lang/Long.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../lang/Float.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../lang/Double.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="AbstractPreferences">
    <members xsi:type="members:Field" name="name">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Our name relative to parent.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="absolutePath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Our absolute path name.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="parent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Our parent node.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="root">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Our root node.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="newNode">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>// Relative to this node</comments>
        <comments>/**&#xA;     * This field should be &lt;tt>true&lt;/tt> if this node did not exist in the&#xA;     * backing store prior to the creation of this object.  The field&#xA;     * is initialized to false, but may be set to true by a subclass&#xA;     * constructor (and should not be modified thereafter).  This field&#xA;     * indicates whether a node change event should be fired when&#xA;     * creation is complete.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="kidCache">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../HashMap.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../Map.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * All known unremoved children of this node.  (This &quot;cache&quot; is consulted&#xA;     * prior to calling childSpi() or getChild().&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="removed">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * This field is used to keep track of whether or not this node has&#xA;     * been removed.  Once it's set to true, it will never be reset to false.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="prefListeners">
      <initialValue xsi:type="arrays:ArrayInstantiationBySize">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="PreferenceChangeListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="PreferenceChangeListener.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Registered preference change listeners.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="nodeListeners">
      <initialValue xsi:type="arrays:ArrayInstantiationBySize">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="NodeChangeListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="NodeChangeListener.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Registered node change listeners.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="lock">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * An object whose monitor is used to lock this node.  This object&#xA;     * is used in preference to the node itself to reduce the likelihood of&#xA;     * intentional or unintentional denial of service due to a locked node.&#xA;     * To avoid deadlock, a node is &lt;i>never&lt;/i> locked by a thread that&#xA;     * holds a lock on a descendant of that node.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="AbstractPreferences">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:StringReference" value="Root name '"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1"/>
                  <children xsi:type="references:StringReference" value="' must be &quot;&quot;"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
              </throwable>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                  <arguments xsi:type="references:StringReference" value=""/>
                </next>
              </child>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:StringReference" value="/"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:StringReference" value="Name '"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1"/>
                  <children xsi:type="references:StringReference" value="' contains '/'"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
              </throwable>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.45"/>
                  <arguments xsi:type="literals:CharacterLiteral" value="47"/>
                </next>
              </children>
              <children xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="Illegal name: empty string"/>
              </throwable>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:StringReference" value=""/>
              </next>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ConditionalExpression">
                  <child xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                  </child>
                  <expressionIf xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value="/"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </expressionIf>
                  <expressionElse xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.40"/>
                    </children>
                    <children xsi:type="references:StringReference" value="/"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </expressionElse>
                </expression>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parent">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Creates a preference node with the specified parent and the specified&#xA;     * name relative to its parent.&#xA;     *&#xA;     * @param parent the parent of this preference node, or null if this&#xA;     *               is the root.&#xA;     * @param name the name of this preference node, relative to its parent,&#xA;     *             or &lt;tt>&quot;&quot;&lt;/tt> if this is the root.&#xA;     * @throws IllegalArgumentException if &lt;tt>name&lt;/tt> contains a slash&#xA;     *          (&lt;tt>'/'&lt;/tt>),  or &lt;tt>parent&lt;/tt> is &lt;tt>null&lt;/tt> and&#xA;     *          name isn't &lt;tt>&quot;&quot;&lt;/tt>.  &#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>put&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#put(String,String)}.&#xA;     *&#xA;     * &lt;p>This implementation checks that the key and value are legal,&#xA;     * obtains this preference node's lock, checks that the node&#xA;     * has not been removed, invokes {@link #putSpi(String,String)}, and if&#xA;     * there are any preference change listeners, enqueues a notification&#xA;     * event for processing by the event dispatch thread.&#xA;     *&#xA;     * @param key key with which the specified value is to be associated.&#xA;     * @param value value to be associated with the specified key.&#xA;     * @throws NullPointerException if key or value is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if &lt;tt>key.length()&lt;/tt> exceeds&#xA;     *       &lt;tt>MAX_KEY_LENGTH&lt;/tt> or if &lt;tt>value.length&lt;/tt> exceeds&#xA;     *       &lt;tt>MAX_VALUE_LENGTH&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="Key too long: "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="Preferences.class.xmi#//@classifiers.0/@members.1"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="Value too long: "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="Preferences.class.xmi#//@classifiers.0/@members.2"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node has been removed."/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.46">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.70">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
          </expression>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>get&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#get(String,String)}.&#xA;     *&#xA;     * &lt;p>This implementation first checks to see if &lt;tt>key&lt;/tt> is&#xA;     * &lt;tt>null&lt;/tt> throwing a &lt;tt>NullPointerException&lt;/tt> if this is&#xA;     * the case.  Then it obtains this preference node's lock,&#xA;     * checks that the node has not been removed, invokes {@link&#xA;     * #getSpi(String)}, and returns the result, unless the &lt;tt>getSpi&lt;/tt>&#xA;     * invocation returns &lt;tt>null&lt;/tt> or throws an exception, in which case&#xA;     * this invocation returns &lt;tt>def&lt;/tt>.&#xA;     *&#xA;     * @param key key whose associated value is to be returned.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>.&#xA;     * @return the value associated with &lt;tt>key&lt;/tt>, or &lt;tt>def&lt;/tt>&#xA;     *         if no value is associated with &lt;tt>key&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if key is &lt;tt>null&lt;/tt>.  (A &#xA;     *         &lt;tt>null&lt;/tt> default &lt;i>is&lt;/i> permitted.)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Null key"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node has been removed."/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="result">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="literals:NullLiteral"/>
          </variable>
        </statements>
        <statements xsi:type="statements:TryBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@statements.1/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.47">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
              </value>
            </expression>
          </statements>
          <catcheBlocks>
            <comments>// Ignoring exception causes default to be returned</comments>
            <parameter name="e">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/Exception.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </parameter>
          </catcheBlocks>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalExpression">
              <child xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@statements.1/@statements.1/@variable"/>
                <children xsi:type="literals:NullLiteral"/>
              </child>
              <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
              <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@statements.1/@statements.1/@variable"/>
            </expression>
          </returnValue>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="remove">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>remove(String)&lt;/tt> method as per the specification&#xA;     * in {@link Preferences#remove(String)}.&#xA;     *&#xA;     * &lt;p>This implementation obtains this preference node's lock,&#xA;     * checks that the node has not been removed, invokes&#xA;     * {@link #removeSpi(String)} and if there are any preference&#xA;     * change listeners, enqueues a notification event for processing by the&#xA;     * event dispatch thread.&#xA;     *&#xA;     * @param key key whose mapping is to be removed from the preference node.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node has been removed."/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.48">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.70">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
            <arguments xsi:type="literals:NullLiteral"/>
          </expression>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clear">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>clear&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#clear()}.&#xA;     *&#xA;     * &lt;p>This implementation obtains this preference node's lock,&#xA;     * invokes {@link #keys()} to obtain an array of keys, and&#xA;     * iterates over the array invoking {@link #remove(String)} on each key.&#xA;     *&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="keys">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.27"/>
          </variable>
        </statements>
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@statements.0/@variable">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@statements.1/@init"/>
                </arraySelectors>
              </arguments>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@statements.1/@init"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
          <init xsi:type="variables:LocalVariable" name="i">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </init>
          <updates xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@statements.1/@init"/>
            <operator xsi:type="operators:PlusPlus"/>
          </updates>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="putInt">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>putInt&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#putInt(String,int)}.&#xA;     *&#xA;     * &lt;p>This implementation translates &lt;tt>value&lt;/tt> to a string with&#xA;     * {@link Integer#toString(int)} and invokes {@link #put(String,String)}&#xA;     * on the result.&#xA;     *&#xA;     * @param key key with which the string form of value is to be associated.&#xA;     * @param value value whose string form is to be associated with key.&#xA;     * @throws NullPointerException if key is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if &lt;tt>key.length()&lt;/tt> exceeds&#xA;     *         &lt;tt>MAX_KEY_LENGTH&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Integer.class.xmi#//@classifiers.0/@members.15"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/Integer.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>getInt&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#getInt(String,int)}.&#xA;     *&#xA;     * &lt;p>This implementation invokes {@link #get(String,String) &lt;tt>get(key,&#xA;     * null)&lt;/tt>}.  If the return value is non-null, the implementation&#xA;     * attempts to translate it to an &lt;tt>int&lt;/tt> with&#xA;     * {@link Integer#parseInt(String)}.  If the attempt succeeds, the return&#xA;     * value is returned by this method.  Otherwise, &lt;tt>def&lt;/tt> is returned.&#xA;     *&#xA;     * @param key key whose associated value is to be returned as an int.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>&#xA;     *        or the associated value cannot be interpreted as an int.&#xA;     * @return the int value represented by the string associated with&#xA;     *         &lt;tt>key&lt;/tt> in this preference node, or &lt;tt>def&lt;/tt> if the&#xA;     *         associated value does not exist or cannot be interpreted as&#xA;     *         an int.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="value">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
              <arguments xsi:type="literals:NullLiteral"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/Integer.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.1/@statements.0/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../lang/Integer.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.1/@statements.0/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <catcheBlocks>
          <comments>// Ignoring exception causes specified default to be returned</comments>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="putLong">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>putLong&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#putLong(String,long)}.&#xA;     *&#xA;     * &lt;p>This implementation translates &lt;tt>value&lt;/tt> to a string with&#xA;     * {@link Long#toString(long)} and invokes {@link #put(String,String)}&#xA;     * on the result.&#xA;     *&#xA;     * @param key key with which the string form of value is to be associated.&#xA;     * @param value value whose string form is to be associated with key.&#xA;     * @throws NullPointerException if key is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if &lt;tt>key.length()&lt;/tt> exceeds&#xA;     *         &lt;tt>MAX_KEY_LENGTH&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Long.class.xmi#//@classifiers.0/@members.11"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/Long.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLong">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>getLong&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#getLong(String,long)}.&#xA;     *&#xA;     * &lt;p>This implementation invokes {@link #get(String,String) &lt;tt>get(key,&#xA;     * null)&lt;/tt>}.  If the return value is non-null, the implementation&#xA;     * attempts to translate it to a &lt;tt>long&lt;/tt> with&#xA;     * {@link Long#parseLong(String)}.  If the attempt succeeds, the return&#xA;     * value is returned by this method.  Otherwise, &lt;tt>def&lt;/tt> is returned.&#xA;     *&#xA;     * @param key key whose associated value is to be returned as a long.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>&#xA;     *        or the associated value cannot be interpreted as a long.&#xA;     * @return the long value represented by the string associated with&#xA;     *         &lt;tt>key&lt;/tt> in this preference node, or &lt;tt>def&lt;/tt> if the&#xA;     *         associated value does not exist or cannot be interpreted as&#xA;     *         a long.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="value">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
              <arguments xsi:type="literals:NullLiteral"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/Long.class.xmi#//@classifiers.0/@members.15"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@statements.0/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../lang/Long.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@statements.0/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <catcheBlocks>
          <comments>// Ignoring exception causes specified default to be returned</comments>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="putBoolean">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>putBoolean&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#putBoolean(String,boolean)}.&#xA;     *&#xA;     * &lt;p>This implementation translates &lt;tt>value&lt;/tt> to a string with&#xA;     * {@link String#valueOf(boolean)} and invokes {@link #put(String,String)}&#xA;     * on the result.&#xA;     *&#xA;     * @param key key with which the string form of value is to be associated.&#xA;     * @param value value whose string form is to be associated with key.&#xA;     * @throws NullPointerException if key is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if &lt;tt>key.length()&lt;/tt> exceeds&#xA;     *         &lt;tt>MAX_KEY_LENGTH&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.81"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getBoolean">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>getBoolean&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#getBoolean(String,boolean)}.&#xA;     *&#xA;     * &lt;p>This implementation invokes {@link #get(String,String) &lt;tt>get(key,&#xA;     * null)&lt;/tt>}.  If the return value is non-null, it is compared with&#xA;     * &lt;tt>&quot;true&quot;&lt;/tt> using {@link String#equalsIgnoreCase(String)}.  If the&#xA;     * comparison returns &lt;tt>true&lt;/tt>, this invocation returns&#xA;     * &lt;tt>true&lt;/tt>.  Otherwise, the original return value is compared with&#xA;     * &lt;tt>&quot;false&quot;&lt;/tt>, again using {@link String#equalsIgnoreCase(String)}.&#xA;     * If the comparison returns &lt;tt>true&lt;/tt>, this invocation returns&#xA;     * &lt;tt>false&lt;/tt>.  Otherwise, this invocation returns &lt;tt>def&lt;/tt>.&#xA;     *&#xA;     * @param key key whose associated value is to be returned as a boolean.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>&#xA;     *        or the associated value cannot be interpreted as a boolean.&#xA;     * @return the boolean value represented by the string associated with&#xA;     *         &lt;tt>key&lt;/tt> in this preference node, or &lt;tt>def&lt;/tt> if the&#xA;     *         associated value does not exist or cannot be interpreted as&#xA;     *         a boolean.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="value">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
            <arguments xsi:type="literals:NullLiteral"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral" value="true"/>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.36"/>
                <arguments xsi:type="references:StringReference" value="true"/>
              </next>
            </condition>
            <elseStatement xsi:type="statements:Condition">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:BooleanLiteral"/>
                </expression>
              </statement>
              <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.36"/>
                  <arguments xsi:type="references:StringReference" value="false"/>
                </next>
              </condition>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="putFloat">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>putFloat&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#putFloat(String,float)}.&#xA;     *&#xA;     * &lt;p>This implementation translates &lt;tt>value&lt;/tt> to a string with&#xA;     * {@link Float#toString(float)} and invokes {@link #put(String,String)}&#xA;     * on the result.&#xA;     *&#xA;     * @param key key with which the string form of value is to be associated.&#xA;     * @param value value whose string form is to be associated with key.&#xA;     * @throws NullPointerException if key is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if &lt;tt>key.length()&lt;/tt> exceeds&#xA;     *         &lt;tt>MAX_KEY_LENGTH&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Float.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/Float.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getFloat">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>getFloat&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#getFloat(String,float)}.&#xA;     *&#xA;     * &lt;p>This implementation invokes {@link #get(String,String) &lt;tt>get(key,&#xA;     * null)&lt;/tt>}.  If the return value is non-null, the implementation&#xA;     * attempts to translate it to an &lt;tt>float&lt;/tt> with&#xA;     * {@link Float#parseFloat(String)}.  If the attempt succeeds, the return&#xA;     * value is returned by this method.  Otherwise, &lt;tt>def&lt;/tt> is returned.&#xA;     *&#xA;     * @param key key whose associated value is to be returned as a float.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>&#xA;     *        or the associated value cannot be interpreted as a float.&#xA;     * @return the float value represented by the string associated with&#xA;     *         &lt;tt>key&lt;/tt> in this preference node, or &lt;tt>def&lt;/tt> if the&#xA;     *         associated value does not exist or cannot be interpreted as&#xA;     *         a float.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Float"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="value">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
              <arguments xsi:type="literals:NullLiteral"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/Float.class.xmi#//@classifiers.0/@members.13"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.1/@statements.0/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../lang/Float.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.1/@statements.0/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <catcheBlocks>
          <comments>// Ignoring exception causes specified default to be returned</comments>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="putDouble">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>putDouble&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#putDouble(String,double)}.&#xA;     *&#xA;     * &lt;p>This implementation translates &lt;tt>value&lt;/tt> to a string with&#xA;     * {@link Double#toString(double)} and invokes {@link #put(String,String)}&#xA;     * on the result.&#xA;     *&#xA;     * @param key key with which the string form of value is to be associated.&#xA;     * @param value value whose string form is to be associated with key.&#xA;     * @throws NullPointerException if key is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if &lt;tt>key.length()&lt;/tt> exceeds&#xA;     *         &lt;tt>MAX_KEY_LENGTH&lt;/tt>.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Double.class.xmi#//@classifiers.0/@members.9"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/Double.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDouble">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>getDouble&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#getDouble(String,double)}.&#xA;     *&#xA;     * &lt;p>This implementation invokes {@link #get(String,String) &lt;tt>get(key,&#xA;     * null)&lt;/tt>}.  If the return value is non-null, the implementation&#xA;     * attempts to translate it to an &lt;tt>double&lt;/tt> with&#xA;     * {@link Double#parseDouble(String)}.  If the attempt succeeds, the return&#xA;     * value is returned by this method.  Otherwise, &lt;tt>def&lt;/tt> is returned.&#xA;     *&#xA;     * @param key key whose associated value is to be returned as a double.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>&#xA;     *        or the associated value cannot be interpreted as a double.&#xA;     * @return the double value represented by the string associated with&#xA;     *         &lt;tt>key&lt;/tt> in this preference node, or &lt;tt>def&lt;/tt> if the&#xA;     *         associated value does not exist or cannot be interpreted as&#xA;     *         a double.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Double"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="value">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
              <arguments xsi:type="literals:NullLiteral"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/Double.class.xmi#//@classifiers.0/@members.13"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.1/@statements.0/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../lang/Double.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.1/@statements.0/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <catcheBlocks>
          <comments>// Ignoring exception causes specified default to be returned</comments>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="putByteArray">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>putByteArray&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#putByteArray(String,byte[])}.&#xA;     *&#xA;     * @param key key with which the string form of value is to be associated.&#xA;     * @param value value whose string form is to be associated with key.&#xA;     * @throws NullPointerException if key or value is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if key.length() exceeds MAX_KEY_LENGTH&#xA;     *         or if value.length exceeds MAX_VALUE_LENGTH*3/4.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Base64.class.xmi#//@classifiers.0/@members.5"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="Base64.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getByteArray">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="def">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>getByteArray&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#getByteArray(String,byte[])}.&#xA;     *&#xA;     * @param key key whose associated value is to be returned as a byte array.&#xA;     * @param def the value to be returned in the event that this&#xA;     *        preference node has no value associated with &lt;tt>key&lt;/tt>&#xA;     *        or the associated value cannot be interpreted as a byte array.&#xA;     * @return the byte array value represented by the string associated with&#xA;     *         &lt;tt>key&lt;/tt> in this preference node, or &lt;tt>def&lt;/tt> if the&#xA;     *         associated value does not exist or cannot be interpreted as&#xA;     *         a byte array.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @throws NullPointerException if &lt;tt>key&lt;/tt> is &lt;tt>null&lt;/tt>.  (A &#xA;     *         &lt;tt>null&lt;/tt> value for &lt;tt>def&lt;/tt> &lt;i>is&lt;/i> permitted.)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Byte"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="value">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
            <arguments xsi:type="literals:NullLiteral"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Base64.class.xmi#//@classifiers.0/@members.8"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.1/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="Base64.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.1/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <catcheBlocks>
          <comments>// Ignoring exception causes specified default to be returned</comments>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/RuntimeException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="keys">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>keys&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#keys()}.&#xA;     *&#xA;     * &lt;p>This implementation obtains this preference node's lock, checks that&#xA;     * the node has not been removed and invokes {@link #keysSpi()}.&#xA;     *&#xA;     * @return an array of the keys that have an associated value in this&#xA;     *         preference node.&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node has been removed."/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.50"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="childrenNames">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>children&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#childrenNames()}.&#xA;     *&#xA;     * &lt;p>This implementation obtains this preference node's lock, checks that&#xA;     * the node has not been removed, constructs a &lt;tt>TreeSet&lt;/tt> initialized&#xA;     * to the names of children already cached (the children in this node's&#xA;     * &quot;child-cache&quot;), invokes {@link #childrenNamesSpi()}, and adds all of the&#xA;     * returned child-names into the set.  The elements of the tree set are&#xA;     * dumped into a &lt;tt>String&lt;/tt> array using the &lt;tt>toArray&lt;/tt> method,&#xA;     * and this array is returned.&#xA;     *&#xA;     * @return the names of the children of this preference node.&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #cachedChildren()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node has been removed."/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="s">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Interface" href="../Set.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../TreeSet.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../Map.class.xmi#//@classifiers.0/@members.9"/>
                </next>
              </arguments>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="kids">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.51"/>
          </variable>
        </statements>
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../Set.class.xmi#//@classifiers.0/@members.6"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@statements.2/@variable">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@statements.3/@init"/>
                  </arraySelectors>
                </arguments>
              </next>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@statements.3/@init"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@statements.2/@variable">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
          <init xsi:type="variables:LocalVariable" name="i">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </init>
          <updates xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@statements.3/@init"/>
            <operator xsi:type="operators:PlusPlus"/>
          </updates>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../Set.class.xmi#//@classifiers.0/@members.5"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29"/>
              </next>
            </child>
          </returnValue>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:Field" name="EMPTY_STRING_ARRAY">
      <initialValue xsi:type="arrays:ArrayInstantiationBySize">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="cachedChildren">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns all known unremoved children of this node.&#xA;     *&#xA;     * @return all known unremoved children of this node.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsBefore/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../Collection.class.xmi#//@classifiers.0/@members.5"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31"/>
              </next>
              <target xsi:type="members:InterfaceMethod" href="../Map.class.xmi#//@classifiers.0/@members.10"/>
            </next>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="EMPTY_ABSTRACT_PREFS_ARRAY">
      <initialValue xsi:type="arrays:ArrayInstantiationBySize">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="parent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Preferences.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>parent&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#parent()}.&#xA;     *&#xA;     * &lt;p>This implementation obtains this preference node's lock, checks that&#xA;     * the node has not been removed and returns the parent value that was&#xA;     * passed to this node's constructor.&#xA;     *&#xA;     * @return the parent of this preference node.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node has been removed."/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="node">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Preferences.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>node&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#node(String)}.&#xA;     *&#xA;     * &lt;p>This implementation obtains this preference node's lock and checks&#xA;     * that the node has not been removed.  If &lt;tt>path&lt;/tt> is &lt;tt>&quot;&quot;&lt;/tt>,&#xA;     * this node is returned; if &lt;tt>path&lt;/tt> is &lt;tt>&quot;/&quot;&lt;/tt>, this node's&#xA;     * root is returned.  If the first character in &lt;tt>path&lt;/tt> is &#xA;     * not &lt;tt>'/'&lt;/tt>, the implementation breaks &lt;tt>path&lt;/tt> into&#xA;     * tokens and recursively traverses the path from this node to the&#xA;     * named node, &quot;consuming&quot; a name and a slash from &lt;tt>path&lt;/tt> at&#xA;     * each step of the traversal.  At each step, the current node is locked&#xA;     * and the node's child-cache is checked for the named node.  If it is&#xA;     * not found, the name is checked to make sure its length does not&#xA;     * exceed &lt;tt>MAX_NAME_LENGTH&lt;/tt>.  Then the {@link #childSpi(String)}&#xA;     * method is invoked, and the result stored in this node's child-cache.&#xA;     * If the newly created &lt;tt>Preferences&lt;/tt> object's {@link #newNode}&#xA;     * field is &lt;tt>true&lt;/tt> and there are any node change listeners,&#xA;     * a notification event is enqueued for processing by the event dispatch&#xA;     * thread. &#xA;     *&#xA;     * &lt;p>When there are no more tokens, the last value found in the&#xA;     * child-cache or returned by &lt;tt>childSpi&lt;/tt> is returned by this&#xA;     * method.  If during the traversal, two &lt;tt>&quot;/&quot;&lt;/tt> tokens occur&#xA;     * consecutively, or the final token is &lt;tt>&quot;/&quot;&lt;/tt> (rather than a name),&#xA;     * an appropriate &lt;tt>IllegalArgumentException&lt;/tt> is thrown.&#xA;     *&#xA;     * &lt;p> If the first character of &lt;tt>path&lt;/tt> is &lt;tt>'/'&lt;/tt>&#xA;     * (indicating an absolute path name name) this preference node's&#xA;     * lock is dropped prior to breaking &lt;tt>path&lt;/tt> into tokens, and &#xA;     * this method recursively traverses the path starting from the root&#xA;     * (rather than starting from this node).  The traversal is otherwise&#xA;     * identical to the one described for relative path names.  Dropping&#xA;     * the lock on this node prior to commencing the traversal at the root&#xA;     * node is essential to avoid the possibility of deadlock, as per the&#xA;     * {@link #lock locking invariant}.&#xA;     *&#xA;     * @param path the path name of the preference node to return.&#xA;     * @return the specified preference node.&#xA;     * @throws IllegalArgumentException if the path name is invalid (i.e.,&#xA;     *         it contains multiple consecutive slash characters, or ends&#xA;     *         with a slash character and is more than one character long).&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node has been removed."/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </returnValue>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:StringReference" value=""/>
            </next>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:StringReference" value="/"/>
            </next>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.34">
              <arguments xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../StringTokenizer.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
                <arguments xsi:type="references:StringReference" value="/"/>
                <arguments xsi:type="literals:BooleanLiteral" value="true"/>
              </arguments>
            </returnValue>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </next>
            </children>
            <children xsi:type="literals:CharacterLiteral" value="47"/>
          </condition>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// Absolute path.  Note that we've dropped our lock to avoid deadlock</comments>
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.34">
            <arguments xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../StringTokenizer.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.55"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </next>
              </arguments>
              <arguments xsi:type="references:StringReference" value="/"/>
              <arguments xsi:type="literals:BooleanLiteral" value="true"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="node">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Preferences.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../StringTokenizer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * tokenizer contains &lt;name> {'/' &lt;name>}*&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="token">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../StringTokenizer.class.xmi#//@classifiers.0/@members.18"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <comments>// Check for consecutive slashes</comments>
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Consecutive slashes in path"/>
          </throwable>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.33"/>
            <arguments xsi:type="references:StringReference" value="/"/>
          </next>
        </condition>
      </statements>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="child">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <initialValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../Map.class.xmi#//@classifiers.0/@members.4"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
                </next>
              </child>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value="Node name "/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
                    <children xsi:type="references:StringReference" value=" too long"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </throwable>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                  </next>
                </children>
                <children xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Preferences.class.xmi#//@classifiers.0/@members.3"/>
                </children>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.2/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.53">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.71">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.2/@statements.0/@variable"/>
                </expression>
              </statement>
              <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.2/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../Map.class.xmi#//@classifiers.0/@members.5"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.2/@statements.0/@variable"/>
                </next>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.2/@statements.0/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.2/@statements.0/@variable"/>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../StringTokenizer.class.xmi#//@classifiers.0/@members.17"/>
              </next>
            </child>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../StringTokenizer.class.xmi#//@classifiers.0/@members.18"/>
            </next>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <comments>// Consume slash</comments>
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Path ends with slash"/>
            </throwable>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../StringTokenizer.class.xmi#//@classifiers.0/@members.17"/>
              </next>
            </child>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.2/@statements.0/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.34">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
            </next>
          </returnValue>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="nodeExists">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>nodeExists&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#nodeExists(String)}.&#xA;     *&#xA;     * &lt;p>This implementation is very similar to {@link #node(String)},&#xA;     * except that {@link #getChild(String)} is used instead of {@link&#xA;     * #childSpi(String)}.&#xA;     *&#xA;     * @param path the path name of the node whose existence is to be checked.&#xA;     * @return true if the specified node exists.&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     * @throws IllegalArgumentException if the path name is invalid (i.e.,&#xA;     *         it contains multiple consecutive slash characters, or ends&#xA;     *         with a slash character and is more than one character long).&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method and&#xA;     *         &lt;tt>pathname&lt;/tt> is not the empty string (&lt;tt>&quot;&quot;&lt;/tt>).&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
            </returnValue>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:StringReference" value=""/>
            </next>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node has been removed."/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:StringReference" value="/"/>
            </next>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.36">
              <arguments xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../StringTokenizer.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
                <arguments xsi:type="references:StringReference" value="/"/>
                <arguments xsi:type="literals:BooleanLiteral" value="true"/>
              </arguments>
            </returnValue>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </next>
            </children>
            <children xsi:type="literals:CharacterLiteral" value="47"/>
          </condition>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// Absolute path.  Note that we've dropped our lock to avoid deadlock</comments>
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.36">
            <arguments xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../StringTokenizer.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.55"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </next>
              </arguments>
              <arguments xsi:type="references:StringReference" value="/"/>
              <arguments xsi:type="literals:BooleanLiteral" value="true"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="nodeExists">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../StringTokenizer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * tokenizer contains &lt;name> {'/' &lt;name>}*&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="token">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../StringTokenizer.class.xmi#//@classifiers.0/@members.18"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <comments>// Check for consecutive slashes</comments>
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Consecutive slashes in path"/>
          </throwable>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.33"/>
            <arguments xsi:type="references:StringReference" value="/"/>
          </next>
        </condition>
      </statements>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="child">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <initialValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../Map.class.xmi#//@classifiers.0/@members.4"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.0/@variable"/>
                </next>
              </child>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.2/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.52">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.0/@variable"/>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.2/@statements.0/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.2/@statements.0/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../StringTokenizer.class.xmi#//@classifiers.0/@members.17"/>
              </next>
            </child>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../StringTokenizer.class.xmi#//@classifiers.0/@members.18"/>
            </next>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <comments>// Consume slash</comments>
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Path ends with slash"/>
            </throwable>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../StringTokenizer.class.xmi#//@classifiers.0/@members.17"/>
              </next>
            </child>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.2/@statements.0/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.36">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
            </next>
          </returnValue>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeNode">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;&#xA;     * Implements the &lt;tt>removeNode()&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#removeNode()}.&#xA;     *&#xA;     * &lt;p>This implementation checks to see that this node is the root; if so,&#xA;     * it throws an appropriate exception.  Then, it locks this node's parent,&#xA;     * and calls a recursive helper method that traverses the subtree rooted at&#xA;     * this node.  The recursive method locks the node on which it was called,&#xA;     * checks that it has not already been removed, and then ensures that all&#xA;     * of its children are cached: The {@link #childrenNamesSpi()} method is&#xA;     * invoked and each returned child name is checked for containment in the&#xA;     * child-cache.  If a child is not already cached, the {@link&#xA;     * #childSpi(String)} method is invoked to create a &lt;tt>Preferences&lt;/tt>&#xA;     * instance for it, and this instance is put into the child-cache.  Then&#xA;     * the helper method calls itself recursively on each node contained in its&#xA;     * child-cache.  Next, it invokes {@link #removeNodeSpi()}, marks itself&#xA;     * as removed, and removes itself from its parent's child-cache.  Finally,&#xA;     * if there are any node change listeners, it enqueues a notification&#xA;     * event for processing by the event dispatch thread.&#xA;     *&#xA;     * &lt;p>Note that the helper method is always invoked with all ancestors up&#xA;     * to the &quot;closest non-removed ancestor&quot; locked.&#xA;     *&#xA;     * @throws IllegalStateException if this node (or an ancestor) has already&#xA;     *         been removed with the {@link #removeNode()} method.&#xA;     * @throws UnsupportedOperationException if this method is invoked on &#xA;     *         the root node.&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Can't remove the root!"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
        </condition>
      </statements>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.38"/>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../Map.class.xmi#//@classifiers.0/@members.6"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              </next>
            </next>
          </expression>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
          <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeNode2">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/*&#xA;     * Called with locks on all nodes on path from parent of &quot;removal root&quot;&#xA;     * to this (including the former but excluding the latter).&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node already removed."/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="kidNames">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <comments>// Ensure that all children are cached</comments>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.51"/>
          </variable>
        </statements>
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../Map.class.xmi#//@classifiers.0/@members.5"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@statements.1/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@statements.2/@init"/>
                    </arraySelectors>
                  </arguments>
                  <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.53">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@statements.1/@variable">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@statements.2/@init"/>
                      </arraySelectors>
                    </arguments>
                  </arguments>
                </next>
              </expression>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../Map.class.xmi#//@classifiers.0/@members.2"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@statements.1/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@statements.2/@init"/>
                    </arraySelectors>
                  </arguments>
                </next>
              </child>
            </condition>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@statements.2/@init"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@statements.1/@variable">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
          <init xsi:type="variables:LocalVariable" name="i">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </init>
          <updates xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@statements.2/@init"/>
            <operator xsi:type="operators:PlusPlus"/>
          </updates>
        </statements>
        <statements xsi:type="statements:ForLoop">
          <comments>// Recursively remove all cached children</comments>
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:NestedExpression">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.38"/>
              <expression xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@statements.3/@init">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../Iterator.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                </child>
              </expression>
            </expression>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@statements.3/@init">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../Iterator.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </condition>
          <init xsi:type="variables:LocalVariable" name="i">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Interface" href="../Iterator.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../Collection.class.xmi#//@classifiers.0/@members.3"/>
                </next>
                <target xsi:type="members:InterfaceMethod" href="../Map.class.xmi#//@classifiers.0/@members.10"/>
              </next>
            </initialValue>
          </init>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../Map.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.49">
            <comments>// Now we have no descendants - it's time to die!</comments>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:BooleanLiteral" value="true"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.72">
              <arguments xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
          </expression>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="name">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>name&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#name()}.&#xA;     *&#xA;     * &lt;p>This implementation merely returns the name that was&#xA;     * passed to this node's constructor.&#xA;     *&#xA;     * @return this preference node's name, relative to its parent.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="absolutePath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>absolutePath&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#absolutePath()}.&#xA;     *&#xA;     * &lt;p>This implementation merely returns the absolute path name that&#xA;     * was computed at the time that this node was constructed (based on&#xA;     * the name that was passed to this node's constructor, and the names&#xA;     * that were passed to this node's ancestors' constructors).&#xA;     *&#xA;     * @return this preference node's absolute path name.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isUserNode">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>isUserNode&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#isUserNode()}.&#xA;     *&#xA;     * &lt;p>This implementation compares this node's root node (which is stored&#xA;     * in a private field) with the value returned by&#xA;     * {@link Preferences#userRoot()}.  If the two object references are&#xA;     * identical, this method returns true.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if this preference node is in the user&#xA;     *         preference tree, &lt;tt>false&lt;/tt> if it's in the system&#xA;     *         preference tree.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/Boolean.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/Boolean.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../security/AccessController.class.xmi#//@classifiers.0/@members.1"/>
                <arguments xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Interface" href="../../security/PrivilegedAction.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <anonymousClass>
                    <members xsi:type="members:ClassMethod" name="run">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <annotationsAndModifiers xsi:type="modifiers:Public"/>
                      <statements xsi:type="statements:Return">
                        <returnValue xsi:type="instantiations:NewConstructorCall">
                          <typeReference xsi:type="types:NamespaceClassifierReference">
                            <classifierReferences>
                              <target xsi:type="classifiers:Class" href="../../lang/Boolean.class.xmi#//@classifiers.0"/>
                            </classifierReferences>
                          </typeReference>
                          <arguments xsi:type="expressions:EqualityExpression">
                            <equalityOperators xsi:type="operators:Equal"/>
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                            <children xsi:type="references:IdentifierReference">
                              <next xsi:type="references:MethodCall">
                                <target xsi:type="members:ClassMethod" href="Preferences.class.xmi#//@classifiers.0/@members.10"/>
                              </next>
                              <target xsi:type="classifiers:Class" href="Preferences.class.xmi#//@classifiers.0"/>
                            </children>
                          </arguments>
                        </returnValue>
                      </statements>
                    </members>
                  </anonymousClass>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../../security/AccessController.class.xmi#//@classifiers.0"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../lang/Boolean.class.xmi#//@classifiers.0/@members.8"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="addPreferenceChangeListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pcl">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="PreferenceChangeListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Change listener is null."/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node has been removed."/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="old">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <comments>// Copy-on-write</comments>
                <target xsi:type="classifiers:Interface" href="PreferenceChangeListener.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="arrays:ArrayInstantiationBySize">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="PreferenceChangeListener.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <sizes xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.1/@statements.1/@variable">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </sizes>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/System.class.xmi#//@classifiers.0/@members.20"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.1/@statements.1/@variable"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.1/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference"/>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/System.class.xmi#//@classifiers.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.1/@statements.1/@variable">
                  <next xsi:type="references:IdentifierReference"/>
                </position>
              </arraySelectors>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
          </expression>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.67"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removePreferenceChangeListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pcl">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="PreferenceChangeListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node has been removed."/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Listener not registered."/>
            </throwable>
          </statement>
          <condition xsi:type="expressions:ConditionalOrExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
                <children xsi:type="literals:NullLiteral"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </expression>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="newPl">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <comments>// Copy-on-write</comments>
                <target xsi:type="classifiers:Interface" href="PreferenceChangeListener.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <initialValue xsi:type="arrays:ArrayInstantiationBySize">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="PreferenceChangeListener.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <sizes xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </sizes>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="i">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:WhileLoop">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.2/@variable">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.3/@variable"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.3/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.3/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.2/@variable">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.3/@variable"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Listener not registered."/>
            </throwable>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.3/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.2/@variable">
                <next xsi:type="references:IdentifierReference"/>
              </children>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.3/@variable"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:WhileLoop">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.2/@variable">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.3/@variable"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                <arraySelectors>
                  <position xsi:type="expressions:PrefixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.3/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.3/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.2/@variable">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.0/@statements.2/@variable"/>
          </expression>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="addNodeChangeListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ncl">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="NodeChangeListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Change listener is null."/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node has been removed."/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:Condition">
          <comments>// Copy-on-write</comments>
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="arrays:ArrayInstantiationBySize">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Interface" href="NodeChangeListener.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
                  <arraySelectors>
                    <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </arraySelectors>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="old">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Interface" href="NodeChangeListener.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arrayDimensionsBefore/>
                <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
              </variable>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="arrays:ArrayInstantiationBySize">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Interface" href="NodeChangeListener.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <sizes xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.1/@statements.1/@elseStatement/@statements.0/@variable">
                      <next xsi:type="references:IdentifierReference"/>
                    </children>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </sizes>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/System.class.xmi#//@classifiers.0/@members.20"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.1/@statements.1/@elseStatement/@statements.0/@variable"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.1/@statements.1/@elseStatement/@statements.0/@variable">
                    <next xsi:type="references:IdentifierReference"/>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../../lang/System.class.xmi#//@classifiers.0"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.1/@statements.1/@elseStatement/@statements.0/@variable">
                      <next xsi:type="references:IdentifierReference"/>
                    </position>
                  </arraySelectors>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
              </expression>
            </statements>
          </elseStatement>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.67"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeNodeChangeListener">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ncl">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="NodeChangeListener.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node has been removed."/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Listener not registered."/>
            </throwable>
          </statement>
          <condition xsi:type="expressions:ConditionalOrExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                <children xsi:type="literals:NullLiteral"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </expression>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="newNl">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <comments>// Copy-on-write</comments>
                <target xsi:type="classifiers:Interface" href="NodeChangeListener.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <initialValue xsi:type="arrays:ArrayInstantiationBySize">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="NodeChangeListener.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <sizes xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </sizes>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="i">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:WhileLoop">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@statements.2/@variable">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@statements.3/@variable"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@statements.3/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@statements.3/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@statements.3/@variable"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Listener not registered."/>
            </throwable>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@statements.3/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
              <next xsi:type="references:IdentifierReference"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:WhileLoop">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@statements.2/@variable">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@statements.3/@variable"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
                <arraySelectors>
                  <position xsi:type="expressions:PrefixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@statements.3/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@statements.3/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@statements.2/@variable">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.0/@statements.2/@variable"/>
          </expression>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putSpi">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>// &quot;SPI&quot; METHODS</comments>
        <comments>/**&#xA;     * Put the given key-value association into this preference node.  It is&#xA;     * guaranteed that &lt;tt>key&lt;/tt> and &lt;tt>value&lt;/tt> are non-null and of&#xA;     * legal length.  Also, it is guaranteed that this node has not been&#xA;     * removed.  (The implementor needn't check for any of these things.)&#xA;     *&#xA;     * &lt;p>This method is invoked with the lock on this node held.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSpi">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Return the value associated with the specified key at this preference&#xA;     * node, or &lt;tt>null&lt;/tt> if there is no association for this key, or the&#xA;     * association cannot be determined at this time.  It is guaranteed that&#xA;     * &lt;tt>key&lt;/tt> is non-null.  Also, it is guaranteed that this node has&#xA;     * not been removed.  (The implementor needn't check for either of these&#xA;     * things.) &#xA;     *&#xA;     * &lt;p> Generally speaking, this method should not throw an exception&#xA;     * under any circumstances.  If, however, if it does throw an exception,&#xA;     * the exception will be intercepted and treated as a &lt;tt>null&lt;/tt>&#xA;     * return value.&#xA;     *&#xA;     * &lt;p>This method is invoked with the lock on this node held.&#xA;     *&#xA;     * @return the value associated with the specified key at this preference&#xA;     *          node, or &lt;tt>null&lt;/tt> if there is no association for this&#xA;     *          key, or the association cannot be determined at this time.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removeSpi">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Remove the association (if any) for the specified key at this &#xA;     * preference node.  It is guaranteed that &lt;tt>key&lt;/tt> is non-null.&#xA;     * Also, it is guaranteed that this node has not been removed.&#xA;     * (The implementor needn't check for either of these things.)&#xA;     *&#xA;     * &lt;p>This method is invoked with the lock on this node held.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removeNodeSpi">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/** &#xA;     * Removes this preference node, invalidating it and any preferences that&#xA;     * it contains.  The named child will have no descendants at the time this&#xA;     * invocation is made (i.e., the {@link Preferences#removeNode()} method&#xA;     * invokes this method repeatedly in a bottom-up fashion, removing each of&#xA;     * a node's descendants before removing the node itself).&#xA;     *&#xA;     * &lt;p>This method is invoked with the lock held on this node and its&#xA;     * parent (and all ancestors that are being removed as a&#xA;     * result of a single invocation to {@link Preferences#removeNode()}).&#xA;     *&#xA;     * &lt;p>The removal of a node needn't become persistent until the&#xA;     * &lt;tt>flush&lt;/tt> method is invoked on this node (or an ancestor).&#xA;     *&#xA;     * &lt;p>If this node throws a &lt;tt>BackingStoreException&lt;/tt>, the exception&#xA;     * will propagate out beyond the enclosing {@link #removeNode()}&#xA;     * invocation.&#xA;     *&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="keysSpi">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns all of the keys that have an associated value in this&#xA;     * preference node.  (The returned array will be of size zero if&#xA;     * this node has no preferences.)  It is guaranteed that this node has not&#xA;     * been removed.&#xA;     *&#xA;     * &lt;p>This method is invoked with the lock on this node held.&#xA;     *&#xA;     * &lt;p>If this node throws a &lt;tt>BackingStoreException&lt;/tt>, the exception&#xA;     * will propagate out beyond the enclosing {@link #keys()} invocation.&#xA;     *&#xA;     * @return an array of the keys that have an associated value in this&#xA;     *         preference node.&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="childrenNamesSpi">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns the names of the children of this preference node.  (The&#xA;     * returned array will be of size zero if this node has no children.)&#xA;     * This method need not return the names of any nodes already cached,&#xA;     * but may do so without harm.&#xA;     *&#xA;     * &lt;p>This method is invoked with the lock on this node held.&#xA;     *&#xA;     * &lt;p>If this node throws a &lt;tt>BackingStoreException&lt;/tt>, the exception&#xA;     * will propagate out beyond the enclosing {@link #childrenNames()}&#xA;     * invocation.&#xA;     *&#xA;     * @return an array containing the names of the children of this&#xA;     *         preference node.&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getChild">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nodeName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/** &#xA;     * Returns the named child if it exists, or &lt;tt>null&lt;/tt> if it does not.&#xA;     * It is guaranteed that &lt;tt>nodeName&lt;/tt> is non-null, non-empty,&#xA;     * does not contain the slash character ('/'), and is no longer than&#xA;     * {@link #MAX_NAME_LENGTH} characters.  Also, it is guaranteed&#xA;     * that this node has not been removed.  (The implementor needn't check&#xA;     * for any of these things if he chooses to override this method.)&#xA;     *&#xA;     * &lt;p>Finally, it is guaranteed that the named node has not been returned&#xA;     * by a previous invocation of this method or {@link #childSpi} after the&#xA;     * last time that it was removed.  In other words, a cached value will&#xA;     * always be used in preference to invoking this method.  (The implementor&#xA;     * needn't maintain his own cache of previously returned children if he&#xA;     * chooses to override this method.)&#xA;     *&#xA;     * &lt;p>This implementation obtains this preference node's lock, invokes&#xA;     * {@link #childrenNames()} to get an array of the names of this node's&#xA;     * children, and iterates over the array comparing the name of each child&#xA;     * with the specified node name.  If a child node has the correct name,&#xA;     * the {@link #childSpi(String)} method is invoked and the resulting&#xA;     * node is returned.  If the iteration completes without finding the&#xA;     * specified name, &lt;tt>null&lt;/tt> is returned.&#xA;     *&#xA;     * @param nodeName name of the child to be searched for.&#xA;     * @return the named child if it exists, or null if it does not.&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="kidNames">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <comments>// assert kidCache.get(nodeName)==null;</comments>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arrayDimensionsBefore/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.28"/>
          </variable>
        </statements>
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.53">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.0/@statements.0/@variable">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.0/@statements.1/@init"/>
                  </arraySelectors>
                </arguments>
              </returnValue>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.0/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0"/>
              </next>
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.0/@statements.1/@init"/>
              </arraySelectors>
            </condition>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.0/@statements.1/@init"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.0/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
          <init xsi:type="variables:LocalVariable" name="i">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </init>
          <updates xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.0/@statements.1/@init"/>
            <operator xsi:type="operators:PlusPlus"/>
          </updates>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="childSpi">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/** &#xA;     * Returns the named child of this preference node, creating it if it does&#xA;     * not already exist.  It is guaranteed that &lt;tt>name&lt;/tt> is non-null,&#xA;     * non-empty, does not contain the slash character ('/'), and is no longer&#xA;     * than {@link #MAX_NAME_LENGTH} characters.  Also, it is guaranteed that&#xA;     * this node has not been removed.  (The implementor needn't check for any&#xA;     * of these things.)&#xA;     *&#xA;     * &lt;p>Finally, it is guaranteed that the named node has not been returned&#xA;     * by a previous invocation of this method or {@link #getChild(String)}&#xA;     * after the last time that it was removed.  In other words, a cached&#xA;     * value will always be used in preference to invoking this method.&#xA;     * Subclasses need not maintain their own cache of previously returned&#xA;     * children.&#xA;     *&#xA;     * &lt;p>The implementer must ensure that the returned node has not been&#xA;     * removed.  If a like-named child of this node was previously removed, the&#xA;     * implementer must return a newly constructed &lt;tt>AbstractPreferences&lt;/tt>&#xA;     * node; once removed, an &lt;tt>AbstractPreferences&lt;/tt> node&#xA;     * cannot be &quot;resuscitated.&quot;&#xA;     * &#xA;     * &lt;p>If this method causes a node to be created, this node is not&#xA;     * guaranteed to be persistent until the &lt;tt>flush&lt;/tt> method is &#xA;     * invoked on this node or one of its ancestors (or descendants).&#xA;     *&#xA;     * &lt;p>This method is invoked with the lock on this node held.&#xA;     *&#xA;     * @param name The name of the child node to return, relative to&#xA;     *        this preference node.&#xA;     * @return The named child node.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the absolute path name of this preferences node.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.41"/>
                <self xsi:type="literals:This"/>
              </child>
              <expressionIf xsi:type="references:StringReference" value="User"/>
              <expressionElse xsi:type="references:StringReference" value="System"/>
            </expression>
          </children>
          <children xsi:type="references:StringReference" value=" Preference Node: "/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.40"/>
            <self xsi:type="literals:This"/>
          </children>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="sync">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>sync&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#sync()}.&#xA;     *&#xA;     * &lt;p>This implementation calls a recursive helper method that locks this&#xA;     * node, invokes syncSpi() on it, unlocks this node, and recursively&#xA;     * invokes this method on each &quot;cached child.&quot;  A cached child is a child&#xA;     * of this node that has been created in this VM and not subsequently&#xA;     * removed.  In effect, this method does a depth first traversal of the&#xA;     * &quot;cached subtree&quot; rooted at this node, calling syncSpi() on each node in&#xA;     * the subTree while only that node is locked. Note that syncSpi() is&#xA;     * invoked top-down.&#xA;     *&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     * @throws IllegalStateException if this node (or an ancestor) has been&#xA;     *         removed with the {@link #removeNode()} method.&#xA;     * @see #flush()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.56"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="sync2">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cachedKids">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsBefore/>
        </variable>
      </statements>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Node has been removed"/>
            </throwable>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.57"/>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.30"/>
          </expression>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.0/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.56"/>
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@init"/>
            </arraySelectors>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.2/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="syncSpi">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * This method is invoked with this node locked.  The contract of this&#xA;     * method is to synchronize any cached preferences stored at this node&#xA;     * with any stored in the backing store.  (It is perfectly possible that&#xA;     * this node does not exist on the backing store, either because it has&#xA;     * been deleted by another VM, or because it has not yet been created.)&#xA;     * Note that this method should &lt;i>not&lt;/i> synchronize the preferences in&#xA;     * any subnodes of this node.  If the backing store naturally syncs an&#xA;     * entire subtree at once, the implementer is encouraged to override&#xA;     * sync(), rather than merely overriding this method.&#xA;     *&#xA;     * &lt;p>If this node throws a &lt;tt>BackingStoreException&lt;/tt>, the exception&#xA;     * will propagate out beyond the enclosing {@link #sync()} invocation.&#xA;     *&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="flush">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>flush&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#flush()}.&#xA;     *&#xA;     * &lt;p>This implementation calls a recursive helper method that locks this&#xA;     * node, invokes flushSpi() on it, unlocks this node, and recursively&#xA;     * invokes this method on each &quot;cached child.&quot;  A cached child is a child&#xA;     * of this node that has been created in this VM and not subsequently&#xA;     * removed.  In effect, this method does a depth first traversal of the&#xA;     * &quot;cached subtree&quot; rooted at this node, calling flushSpi() on each node in&#xA;     * the subTree while only that node is locked. Note that flushSpi() is&#xA;     * invoked top-down.&#xA;     *&#xA;     * &lt;p> If this method is invoked on a node that has been removed with &#xA;     * the {@link #removeNode()} method, flushSpi() is invoked on this node, &#xA;     * but not on others.&#xA;     *&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     * @see #flush()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.59"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="flush2">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cachedKids">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsBefore/>
        </variable>
      </statements>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.60"/>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return"/>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.30"/>
          </expression>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.0/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.59"/>
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.2/@init"/>
            </arraySelectors>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.2/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="flushSpi">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * This method is invoked with this node locked.  The contract of this&#xA;     * method is to force any cached changes in the contents of this&#xA;     * preference node to the backing store, guaranteeing their persistence.&#xA;     * (It is perfectly possible that this node does not exist on the backing&#xA;     * store, either because it has been deleted by another VM, or because it&#xA;     * has not yet been created.)  Note that this method should &lt;i>not&lt;/i>&#xA;     * flush the preferences in any subnodes of this node.  If the backing&#xA;     * store naturally flushes an entire subtree at once, the implementer is&#xA;     * encouraged to override flush(), rather than merely overriding this&#xA;     * method.&#xA;     *&#xA;     * &lt;p>If this node throws a &lt;tt>BackingStoreException&lt;/tt>, the exception&#xA;     * will propagate out beyond the enclosing {@link #flush()} invocation.&#xA;     *&#xA;     * @throws BackingStoreException if this operation cannot be completed&#xA;     *         due to a failure in the backing store, or inability to &#xA;     *         communicate with it.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="isRemoved">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> iff this node (or an ancestor) has been&#xA;     * removed with the {@link #removeNode()} method.  This method&#xA;     * locks this node prior to returning the contents of the private&#xA;     * field used to track this state.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> iff this node (or an ancestor) has been&#xA;     *       removed with the {@link #removeNode()} method.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:Field" name="eventQueue">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../LinkedList.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../List.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Queue of pending notification events.  When a preference or node&#xA;     * change event for which there are one or more listeners occurs,&#xA;     * it is placed on this queue and the queue is notified.  A background&#xA;     * thread waits on this queue and delivers the events.  This decouples&#xA;     * event delivery from preference activity, greatly simplifying&#xA;     * locking and reducing opportunity for deadlock.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="classifiers:Class" name="NodeAddedEvent">
      <members xsi:type="members:Field" name="serialVersionUID">
        <initialValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalLongLiteral" decimalValue="6743557530157328528"/>
        </initialValue>
        <typeReference xsi:type="types:Long"/>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Constructor" name="NodeAddedEvent">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@members.1/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@members.1/@parameters.1"/>
            <callTarget xsi:type="literals:Super"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="parent">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Preferences.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="child">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Preferences.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * These two classes are used to distinguish NodeChangeEvents on&#xA;     * eventQueue so the event dispatch thread knows whether to call&#xA;     * childAdded or childRemoved.&#xA;     */</comments>
      </annotationsAndModifiers>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NodeChangeEvent.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="NodeRemovedEvent">
      <members xsi:type="members:Field" name="serialVersionUID">
        <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="8735497392918824837"/>
        <typeReference xsi:type="types:Long"/>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Constructor" name="NodeRemovedEvent">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@members.1/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@members.1/@parameters.1"/>
            <callTarget xsi:type="literals:Super"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="parent">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Preferences.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="child">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Preferences.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="NodeChangeEvent.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </extends>
    </members>
    <members xsi:type="classifiers:Class" name="EventDispatchThread">
      <members xsi:type="members:ClassMethod" name="run">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:WhileLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="event">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <comments>// Wait on eventQueue till an event is present</comments>
                    <target xsi:type="classifiers:Class" href="../EventObject.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <initialValue xsi:type="literals:NullLiteral"/>
              </variable>
            </statements>
            <statements xsi:type="statements:SynchronizedBlock">
              <statements xsi:type="statements:TryBlock">
                <statements xsi:type="statements:WhileLoop">
                  <statement xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../lang/Object.class.xmi#//@classifiers.0/@members.11"/>
                      </next>
                    </expression>
                  </statement>
                  <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="../List.class.xmi#//@classifiers.0/@members.1"/>
                    </next>
                  </condition>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.0/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="expressions:CastExpression">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../EventObject.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:InterfaceMethod" href="../List.class.xmi#//@classifiers.0/@members.19"/>
                          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        </next>
                      </child>
                    </value>
                  </expression>
                </statements>
                <catcheBlocks>
                  <statements xsi:type="statements:Return">
                    <comments>// XXX Log &quot;Event dispatch thread interrupted. Exiting&quot;</comments>
                  </statements>
                  <parameter name="e">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../lang/InterruptedException.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                  </parameter>
                </catcheBlocks>
              </statements>
              <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62"/>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="src">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0">
                    <comments>// Now we have event &amp; hold no locks; deliver evt to listeners</comments>
                  </classifierReferences>
                </typeReference>
                <initialValue xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0"/>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.0/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../EventObject.class.xmi#//@classifiers.0/@members.3"/>
                    </next>
                  </child>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:LocalVariableStatement">
                  <variable name="pce">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="PreferenceChangeEvent.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <initialValue xsi:type="expressions:CastExpression">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="PreferenceChangeEvent.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.0/@variable"/>
                    </initialValue>
                  </variable>
                </statements>
                <statements xsi:type="statements:LocalVariableStatement">
                  <variable name="listeners">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Interface" href="PreferenceChangeListener.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arrayDimensionsBefore/>
                    <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.2/@variable">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.68"/>
                    </initialValue>
                  </variable>
                </statements>
                <statements xsi:type="statements:ForLoop">
                  <statement xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@statement/@statements.1/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:InterfaceMethod" href="PreferenceChangeListener.class.xmi#//@classifiers.0/@members.0"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@statement/@statements.0/@variable"/>
                      </next>
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@statement/@statements.2/@init"/>
                      </arraySelectors>
                    </expression>
                  </statement>
                  <condition xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@statement/@statements.2/@init"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@statement/@statements.1/@variable">
                      <next xsi:type="references:IdentifierReference"/>
                    </children>
                    <relationOperators xsi:type="operators:LessThan"/>
                  </condition>
                  <init xsi:type="variables:LocalVariable" name="i">
                    <typeReference xsi:type="types:Int"/>
                    <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </init>
                  <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@statement/@statements.2/@init"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </updates>
                </statements>
              </statement>
              <condition xsi:type="expressions:InstanceOfExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="PreferenceChangeEvent.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.0/@variable"/>
              </condition>
              <elseStatement xsi:type="statements:Block">
                <statements xsi:type="statements:LocalVariableStatement">
                  <variable name="nce">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="NodeChangeEvent.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <initialValue xsi:type="expressions:CastExpression">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="NodeChangeEvent.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.0/@variable"/>
                    </initialValue>
                  </variable>
                </statements>
                <statements xsi:type="statements:LocalVariableStatement">
                  <variable name="listeners">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Interface" href="NodeChangeListener.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arrayDimensionsBefore/>
                    <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.2/@variable">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.69"/>
                    </initialValue>
                  </variable>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ForLoop">
                      <statement xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@elseStatement/@statements.1/@variable">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:InterfaceMethod" href="NodeChangeListener.class.xmi#//@classifiers.0/@members.0"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@elseStatement/@statements.0/@variable"/>
                          </next>
                          <arraySelectors>
                            <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@elseStatement/@statements.2/@statement/@statements.0/@init"/>
                          </arraySelectors>
                        </expression>
                      </statement>
                      <condition xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@elseStatement/@statements.2/@statement/@statements.0/@init"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@elseStatement/@statements.1/@variable">
                          <next xsi:type="references:IdentifierReference"/>
                        </children>
                        <relationOperators xsi:type="operators:LessThan"/>
                      </condition>
                      <init xsi:type="variables:LocalVariable" name="i">
                        <typeReference xsi:type="types:Int"/>
                        <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      </init>
                      <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@elseStatement/@statements.2/@statement/@statements.0/@init"/>
                        <operator xsi:type="operators:PlusPlus"/>
                      </updates>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:InstanceOfExpression">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0/@members.63"/>
                    </typeReference>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@elseStatement/@statements.0/@variable"/>
                  </condition>
                  <elseStatement xsi:type="statements:Block">
                    <statements xsi:type="statements:ForLoop">
                      <comments>// assert nce instanceof NodeRemovedEvent;</comments>
                      <statement xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@elseStatement/@statements.1/@variable">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:InterfaceMethod" href="NodeChangeListener.class.xmi#//@classifiers.0/@members.1"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@elseStatement/@statements.0/@variable"/>
                          </next>
                          <arraySelectors>
                            <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@elseStatement/@statements.2/@elseStatement/@statements.0/@init"/>
                          </arraySelectors>
                        </expression>
                      </statement>
                      <condition xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@elseStatement/@statements.2/@elseStatement/@statements.0/@init"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@elseStatement/@statements.1/@variable">
                          <next xsi:type="references:IdentifierReference"/>
                        </children>
                        <relationOperators xsi:type="operators:LessThan"/>
                      </condition>
                      <init xsi:type="variables:LocalVariable" name="i">
                        <typeReference xsi:type="types:Int"/>
                        <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      </init>
                      <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@members.0/@statements.0/@statement/@statements.3/@elseStatement/@statements.2/@elseStatement/@statements.0/@init"/>
                        <operator xsi:type="operators:PlusPlus"/>
                      </updates>
                    </statements>
                  </elseStatement>
                </statements>
              </elseStatement>
            </statements>
          </statement>
          <condition xsi:type="literals:BooleanLiteral" value="true"/>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * A single background thread (&quot;the event notification thread&quot;) monitors&#xA;     * the event queue and delivers events that are placed on the queue.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/Thread.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </extends>
    </members>
    <members xsi:type="members:Field" name="eventDispatchThread">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/Thread.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="startEventDispatchThreadIfNecessary">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * This method starts the event dispatch thread the first time it&#xA;     * is called.  The event dispatch thread will be started only&#xA;     * if someone registers a listener.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66">
                <comments>// XXX Log &quot;Starting event dispatch thread&quot;</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@members.65"/>
                </typeReference>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../lang/Thread.class.xmi#//@classifiers.0/@members.72"/>
                <arguments xsi:type="literals:BooleanLiteral" value="true"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../lang/Thread.class.xmi#//@classifiers.0/@members.46"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="prefListeners">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Return this node's preference/node change listeners.  Even though&#xA;     * we're using a copy-on-write lists, we use synchronized accessors to&#xA;     * ensure information transmission from the writing thread to the&#xA;     * reading thread.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="PreferenceChangeListener.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="nodeListeners">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="NodeChangeListener.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="enqueuePreferenceChangeEvent">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newValue">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Enqueue a preference change event for delivery to registered&#xA;     * preference change listeners unless there are no registered&#xA;     * listeners.  Invoked with this.lock held.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:SynchronizedBlock">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../List.class.xmi#//@classifiers.0/@members.6"/>
                  <arguments xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="PreferenceChangeEvent.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="references:SelfReference">
                      <self xsi:type="literals:This"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1"/>
                  </arguments>
                </next>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/Object.class.xmi#//@classifiers.0/@members.7"/>
                </next>
              </expression>
            </statements>
            <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="enqueueNodeAddedEvent">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="child">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Preferences.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Enqueue a &quot;node added&quot; event for delivery to registered node change&#xA;     * listeners unless there are no registered listeners.  Invoked with&#xA;     * this.lock held.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:SynchronizedBlock">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../List.class.xmi#//@classifiers.0/@members.6"/>
                  <arguments xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0/@members.63"/>
                    </typeReference>
                    <arguments xsi:type="references:SelfReference">
                      <self xsi:type="literals:This"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0"/>
                  </arguments>
                </next>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/Object.class.xmi#//@classifiers.0/@members.7"/>
                </next>
              </expression>
            </statements>
            <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="enqueueNodeRemovedEvent">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="child">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Preferences.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Enqueue a &quot;node removed&quot; event for delivery to registered node change&#xA;     * listeners unless there are no registered listeners.  Invoked with&#xA;     * this.lock held.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:SynchronizedBlock">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="../List.class.xmi#//@classifiers.0/@members.6"/>
                  <arguments xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0/@members.64"/>
                    </typeReference>
                    <arguments xsi:type="references:SelfReference">
                      <self xsi:type="literals:This"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.0"/>
                  </arguments>
                </next>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../lang/Object.class.xmi#//@classifiers.0/@members.7"/>
                </next>
              </expression>
            </statements>
            <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="exportNode">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="os">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>exportNode&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#exportNode(OutputStream)}.&#xA;     *&#xA;     * @param os the output stream on which to emit the XML document.&#xA;     * @throws IOException if writing to the specified output stream&#xA;     *         results in an &lt;tt>IOException&lt;/tt>.&#xA;     * @throws BackingStoreException if preference data cannot be read from&#xA;     *         backing store.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="XmlSupport.class.xmi#//@classifiers.0/@members.5"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.0"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="literals:BooleanLiteral"/>
          </next>
          <target xsi:type="classifiers:Class" href="XmlSupport.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="exportSubtree">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="os">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BackingStoreException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Implements the &lt;tt>exportSubtree&lt;/tt> method as per the specification in&#xA;     * {@link Preferences#exportSubtree(OutputStream)}.&#xA;     *&#xA;     * @param os the output stream on which to emit the XML document.&#xA;     * @throws IOException if writing to the specified output stream&#xA;     *         results in an &lt;tt>IOException&lt;/tt>.&#xA;     * @throws BackingStoreException if preference data cannot be read from&#xA;     *         backing store.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="XmlSupport.class.xmi#//@classifiers.0/@members.5"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.0"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          </next>
          <target xsi:type="classifiers:Class" href="XmlSupport.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This class provides a skeletal implementation of the {@link Preferences}&#xA; * class, greatly easing the task of implementing it.&#xA; *&#xA; * &lt;p>&lt;strong>This class is for &lt;tt>Preferences&lt;/tt> implementers only.&#xA; * Normal users of the &lt;tt>Preferences&lt;/tt> facility should have no need to&#xA; * consult this documentation.  The {@link Preferences} documentation&#xA; * should suffice.&lt;/strong>&#xA; *&#xA; * &lt;p>Implementors must override the nine abstract service-provider interface&#xA; * (SPI) methods: {@link #getSpi(String)}, {@link #putSpi(String,String)},&#xA; * {@link #removeSpi(String)}, {@link #childSpi(String)}, {@link&#xA; * #removeNodeSpi()}, {@link #keysSpi()}, {@link #childrenNamesSpi()}, {@link&#xA; * #syncSpi()} and {@link #flushSpi()}.  All of the concrete methods specify&#xA; * precisely how they are implemented atop these SPI methods.  The implementor&#xA; * may, at his discretion, override one or more of the concrete methods if the&#xA; * default implementation is unsatisfactory for any reason, such as&#xA; * performance.&#xA; *&#xA; * &lt;p>The SPI methods fall into three groups concerning exception&#xA; * behavior. The &lt;tt>getSpi&lt;/tt> method should never throw exceptions, but it&#xA; * doesn't really matter, as any exception thrown by this method will be&#xA; * intercepted by {@link #get(String,String)}, which will return the specified&#xA; * default value to the caller.  The &lt;tt>removeNodeSpi, keysSpi,&#xA; * childrenNamesSpi, syncSpi&lt;/tt> and &lt;tt>flushSpi&lt;/tt> methods are specified&#xA; * to throw {@link BackingStoreException}, and the implementation is required&#xA; * to throw this checked exception if it is unable to perform the operation.&#xA; * The exception propagates outward, causing the corresponding API method&#xA; * to fail.&#xA; *&#xA; * &lt;p>The remaining SPI methods {@link #putSpi(String,String)}, {@link&#xA; * #removeSpi(String)} and {@link #childSpi(String)} have more complicated&#xA; * exception behavior.  They are not specified to throw&#xA; * &lt;tt>BackingStoreException&lt;/tt>, as they can generally obey their contracts&#xA; * even if the backing store is unavailable.  This is true because they return&#xA; * no information and their effects are not required to become permanent until&#xA; * a subsequent call to {Preferences#flush()} or&#xA; * {Preferences#sync()}. Generally speaking, these SPI methods should not&#xA; * throw exceptions.  In some implementations, there may be circumstances&#xA; * under which these calls cannot even enqueue the requested operation for&#xA; * later processing.  Even under these circumstances it is generally better to&#xA; * simply ignore the invocation and return, rather than throwing an&#xA; * exception.  Under these circumstances, however, all subsequent invocations&#xA; * of &lt;tt>flush()&lt;/tt> and &lt;tt>sync&lt;/tt> should return &lt;tt>false&lt;/tt>, as&#xA; * returning &lt;tt>true&lt;/tt> would imply that all previous operations had&#xA; * successfully been made permanent.&#xA; *&#xA; * &lt;p>There is one circumstance under which &lt;tt>putSpi, removeSpi and&#xA; * childSpi&lt;/tt> &lt;i>should&lt;/i> throw an exception: if the caller lacks&#xA; * sufficient privileges on the underlying operating system to perform the&#xA; * requested operation.  This will, for instance, occur on most systems&#xA; * if a non-privileged user attempts to modify system preferences.&#xA; * (The required privileges will vary from implementation to&#xA; * implementation.  On some implementations, they are the right to modify the&#xA; * contents of some directory in the file system; on others they are the right&#xA; * to modify contents of some key in a registry.)  Under any of these&#xA; * circumstances, it would generally be undesirable to let the program&#xA; * continue executing as if these operations would become permanent at a later&#xA; * time.  While implementations are not required to throw an exception under&#xA; * these circumstances, they are encouraged to do so.  A {@link&#xA; * SecurityException} would be appropriate.&#xA; *&#xA; * &lt;p>Most of the SPI methods require the implementation to read or write&#xA; * information at a preferences node.  The implementor should beware of the&#xA; * fact that another VM may have concurrently deleted this node from the&#xA; * backing store.  It is the implementation's responsibility to recreate the&#xA; * node if it has been deleted.&#xA; *&#xA; * &lt;p>Implementation note: In Sun's default &lt;tt>Preferences&lt;/tt>&#xA; * implementations, the user's identity is inherited from the underlying&#xA; * operating system and does not change for the lifetime of the virtual&#xA; * machine.  It is recognized that server-side &lt;tt>Preferences&lt;/tt>&#xA; * implementations may have the user identity change from request to request,&#xA; * implicitly passed to &lt;tt>Preferences&lt;/tt> methods via the use of a&#xA; * static {@link ThreadLocal} instance.  Authors of such implementations are&#xA; * &lt;i>strongly&lt;/i> encouraged to determine the user at the time preferences&#xA; * are accessed (for example by the {@link #get(String,String)} or {@link&#xA; * #put(String,String)} method) rather than permanently associating a user&#xA; * with each &lt;tt>Preferences&lt;/tt> instance.  The latter behavior conflicts&#xA; * with normal &lt;tt>Preferences&lt;/tt> usage and would lead to great confusion.&#xA; *&#xA; * @author  Josh Bloch&#xA; * @version 1.20, 01/12/04&#xA; * @see     Preferences&#xA; * @since   1.4&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="Preferences.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
