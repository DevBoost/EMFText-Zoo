<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="List.java">
  <comments>/*&#xA; * @(#)List.java&#x9;1.44 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="List">
    <typeParameters name="E"/>
    <members xsi:type="members:InterfaceMethod" name="size">
      <typeReference xsi:type="types:Int">
        <comments>// Query Operations</comments>
        <comments>/**&#xA;     * Returns the number of elements in this list.  If this list contains&#xA;     * more than &lt;tt>Integer.MAX_VALUE&lt;/tt> elements, returns&#xA;     * &lt;tt>Integer.MAX_VALUE&lt;/tt>.&#xA;     *&#xA;     * @return the number of elements in this list.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isEmpty">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this list contains no elements.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if this list contains no elements.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="contains">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * &#xA;     * Returns &lt;tt>true&lt;/tt> if this list contains the specified element.&#xA;     * More formally, returns &lt;tt>true&lt;/tt> if and only if this list contains&#xA;     * at least one element &lt;tt>e&lt;/tt> such that&#xA;     * &lt;tt>(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt>.&#xA;     *&#xA;     * @param o element whose presence in this list is to be tested.&#xA;     * @return &lt;tt>true&lt;/tt> if this list contains the specified element.&#xA;     * @throws ClassCastException if the type of the specified element&#xA;     * &#x9;       is incompatible with this list (optional).&#xA;     * @throws NullPointerException if the specified element is null and this&#xA;     *         list does not support null elements (optional).&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="iterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns an iterator over the elements in this list in proper sequence.&#xA;     *&#xA;     * @return an iterator over the elements in this list in proper sequence.&#xA;     */</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toArray">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns an array containing all of the elements in this list in proper&#xA;     * sequence.  Obeys the general contract of the&#xA;     * &lt;tt>Collection.toArray&lt;/tt> method.&#xA;     *&#xA;     * @return an array containing all of the elements in this list in proper&#xA;     *&#x9;       sequence.&#xA;     * @see Arrays#asList(Object[])&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toArray">
      <comments>/**&#xA;     * Returns an array containing all of the elements in this list in proper&#xA;     * sequence; the runtime type of the returned array is that of the&#xA;     * specified array.  Obeys the general contract of the&#xA;     * &lt;tt>Collection.toArray(Object[])&lt;/tt> method.&#xA;     *&#xA;     * @param a the array into which the elements of this list are to&#xA;     *&#x9;&#x9;be stored, if it is big enough; otherwise, a new array of the&#xA;     * &#x9;&#x9;same runtime type is allocated for this purpose.&#xA;     * @return  an array containing the elements of this list.&#xA;     * &#xA;     * @throws ArrayStoreException if the runtime type of the specified array&#xA;     * &#x9;&#x9;  is not a supertype of the runtime type of every element in&#xA;     * &#x9;&#x9;  this list.&#xA;     * @throws NullPointerException if the specified array is &lt;tt>null&lt;/tt>.&#xA;     */</comments>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.5/@typeParameters.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <typeParameters name="T"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.5/@typeParameters.0"/>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="add">
      <typeReference xsi:type="types:Boolean">
        <comments>// Modification Operations</comments>
        <comments>/**&#xA;     * Appends the specified element to the end of this list (optional&#xA;     * operation). &lt;p>&#xA;     *&#xA;     * Lists that support this operation may place limitations on what&#xA;     * elements may be added to this list.  In particular, some&#xA;     * lists will refuse to add null elements, and others will impose&#xA;     * restrictions on the type of elements that may be added.  List&#xA;     * classes should clearly specify in their documentation any restrictions&#xA;     * on what elements may be added.&#xA;     *&#xA;     * @param o element to be appended to this list.&#xA;     * @return &lt;tt>true&lt;/tt> (as per the general contract of the&#xA;     *            &lt;tt>Collection.add&lt;/tt> method).&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>add&lt;/tt> method is not&#xA;     * &#x9;&#x9;  supported by this list.&#xA;     * @throws ClassCastException if the class of the specified element&#xA;     * &#x9;&#x9;  prevents it from being added to this list.&#xA;     * @throws NullPointerException if the specified element is null and this&#xA;     *           list does not support null elements.&#xA;     * @throws IllegalArgumentException if some aspect of this element&#xA;     *            prevents it from being added to this list.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="remove">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Removes the first occurrence in this list of the specified element &#xA;     * (optional operation).  If this list does not contain the element, it is&#xA;     * unchanged.  More formally, removes the element with the lowest index i&#xA;     * such that &lt;tt>(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt> (if&#xA;     * such an element exists).&#xA;     *&#xA;     * @param o element to be removed from this list, if present.&#xA;     * @return &lt;tt>true&lt;/tt> if this list contained the specified element.&#xA;     * @throws ClassCastException if the type of the specified element&#xA;     * &#x9;          is incompatible with this list (optional).&#xA;     * @throws NullPointerException if the specified element is null and this&#xA;     *            list does not support null elements (optional).&#xA;     * @throws UnsupportedOperationException if the &lt;tt>remove&lt;/tt> method is&#xA;     *&#x9;&#x9;  not supported by this list.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="containsAll">
      <typeReference xsi:type="types:Boolean">
        <comments>// Bulk Modification Operations</comments>
        <comments>/**&#xA;     * &#xA;     * Returns &lt;tt>true&lt;/tt> if this list contains all of the elements of the&#xA;     * specified collection.&#xA;     *&#xA;     * @param  c collection to be checked for containment in this list.&#xA;     * @return &lt;tt>true&lt;/tt> if this list contains all of the elements of the&#xA;     * &#x9;       specified collection.&#xA;     * @throws ClassCastException if the types of one or more elements&#xA;     *         in the specified collection are incompatible with this&#xA;     *         list (optional).&#xA;     * @throws NullPointerException if the specified collection contains one&#xA;     *         or more null elements and this list does not support null&#xA;     *         elements (optional).&#xA;     * @throws NullPointerException if the specified collection is&#xA;     *         &lt;tt>null&lt;/tt>.&#xA;     * @see #contains(Object)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addAll">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Appends all of the elements in the specified collection to the end of&#xA;     * this list, in the order that they are returned by the specified&#xA;     * collection's iterator (optional operation).  The behavior of this&#xA;     * operation is unspecified if the specified collection is modified while&#xA;     * the operation is in progress.  (Note that this will occur if the&#xA;     * specified collection is this list, and it's nonempty.)&#xA;     *&#xA;     * @param c collection whose elements are to be added to this list.&#xA;     * @return &lt;tt>true&lt;/tt> if this list changed as a result of the call.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>addAll&lt;/tt> method is&#xA;     *         not supported by this list.&#xA;     * @throws ClassCastException if the class of an element in the specified&#xA;     * &#x9;       collection prevents it from being added to this list.&#xA;     * @throws NullPointerException if the specified collection contains one&#xA;     *         or more null elements and this list does not support null&#xA;     *         elements, or if the specified collection is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if some aspect of an element in the&#xA;     *         specified collection prevents it from being added to this&#xA;     *         list.&#xA;     * @see #add(Object)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addAll">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Inserts all of the elements in the specified collection into this&#xA;     * list at the specified position (optional operation).  Shifts the&#xA;     * element currently at that position (if any) and any subsequent&#xA;     * elements to the right (increases their indices).  The new elements&#xA;     * will appear in this list in the order that they are returned by the&#xA;     * specified collection's iterator.  The behavior of this operation is&#xA;     * unspecified if the specified collection is modified while the&#xA;     * operation is in progress.  (Note that this will occur if the specified&#xA;     * collection is this list, and it's nonempty.)&#xA;     *&#xA;     * @param index index at which to insert first element from the specified&#xA;     *&#x9;            collection.&#xA;     * @param c elements to be inserted into this list.&#xA;     * @return &lt;tt>true&lt;/tt> if this list changed as a result of the call.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>addAll&lt;/tt> method is&#xA;     *&#x9;&#x9;  not supported by this list.&#xA;     * @throws ClassCastException if the class of one of elements of the&#xA;     * &#x9;&#x9;  specified collection prevents it from being added to this&#xA;     * &#x9;&#x9;  list.&#xA;     * @throws NullPointerException if the specified collection contains one&#xA;     *           or more null elements and this list does not support null&#xA;     *           elements, or if the specified collection is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if some aspect of one of elements of&#xA;     *&#x9;&#x9;  the specified collection prevents it from being added to&#xA;     *&#x9;&#x9;  this list.&#xA;     * @throws IndexOutOfBoundsException if the index is out of range (index&#xA;     *&#x9;&#x9;  &amp;lt; 0 || index &amp;gt; size()).&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removeAll">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Removes from this list all the elements that are contained in the&#xA;     * specified collection (optional operation).&#xA;     *&#xA;     * @param c collection that defines which elements will be removed from&#xA;     *          this list.&#xA;     * @return &lt;tt>true&lt;/tt> if this list changed as a result of the call.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>removeAll&lt;/tt> method&#xA;     * &#x9;&#x9;  is not supported by this list.&#xA;     * @throws ClassCastException if the types of one or more elements&#xA;     *            in this list are incompatible with the specified&#xA;     *            collection (optional).&#xA;     * @throws NullPointerException if this list contains one or more&#xA;     *            null elements and the specified collection does not support&#xA;     *            null elements (optional).&#xA;     * @throws NullPointerException if the specified collection is&#xA;     *            &lt;tt>null&lt;/tt>.&#xA;     * @see #remove(Object)&#xA;     * @see #contains(Object)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="retainAll">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retains only the elements in this list that are contained in the&#xA;     * specified collection (optional operation).  In other words, removes&#xA;     * from this list all the elements that are not contained in the specified&#xA;     * collection.&#xA;     *&#xA;     * @param c collection that defines which elements this set will retain.&#xA;     * &#xA;     * @return &lt;tt>true&lt;/tt> if this list changed as a result of the call.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>retainAll&lt;/tt> method&#xA;     * &#x9;&#x9;  is not supported by this list.&#xA;     * @throws ClassCastException if the types of one or more elements&#xA;     *            in this list are incompatible with the specified&#xA;     *            collection (optional).&#xA;     * @throws NullPointerException if this list contains one or more&#xA;     *            null elements and the specified collection does not support&#xA;     *            null elements (optional).&#xA;     * @throws NullPointerException if the specified collection is&#xA;     *         &lt;tt>null&lt;/tt>.&#xA;     * @see #remove(Object)&#xA;     * @see #contains(Object)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="clear">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Removes all of the elements from this list (optional operation).  This&#xA;     * list will be empty after this call returns (unless it throws an&#xA;     * exception).&#xA;     *&#xA;     * @throws UnsupportedOperationException if the &lt;tt>clear&lt;/tt> method is&#xA;     * &#x9;&#x9;  not supported by this list.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="equals">
      <typeReference xsi:type="types:Boolean">
        <comments>// Comparison and hashing</comments>
        <comments>/**&#xA;     * Compares the specified object with this list for equality.  Returns&#xA;     * &lt;tt>true&lt;/tt> if and only if the specified object is also a list, both&#xA;     * lists have the same size, and all corresponding pairs of elements in&#xA;     * the two lists are &lt;i>equal&lt;/i>.  (Two elements &lt;tt>e1&lt;/tt> and&#xA;     * &lt;tt>e2&lt;/tt> are &lt;i>equal&lt;/i> if &lt;tt>(e1==null ? e2==null :&#xA;     * e1.equals(e2))&lt;/tt>.)  In other words, two lists are defined to be&#xA;     * equal if they contain the same elements in the same order.  This&#xA;     * definition ensures that the equals method works properly across&#xA;     * different implementations of the &lt;tt>List&lt;/tt> interface.&#xA;     *&#xA;     * @param o the object to be compared for equality with this list.&#xA;     * @return &lt;tt>true&lt;/tt> if the specified object is equal to this list.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="hashCode">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Returns the hash code value for this list.  The hash code of a list&#xA;     * is defined to be the result of the following calculation:&#xA;     * &lt;pre>&#xA;     *  hashCode = 1;&#xA;     *  Iterator i = list.iterator();&#xA;     *  while (i.hasNext()) {&#xA;     *      Object obj = i.next();&#xA;     *      hashCode = 31*hashCode + (obj==null ? 0 : obj.hashCode());&#xA;     *  }&#xA;     * &lt;/pre>&#xA;     * This ensures that &lt;tt>list1.equals(list2)&lt;/tt> implies that&#xA;     * &lt;tt>list1.hashCode()==list2.hashCode()&lt;/tt> for any two lists,&#xA;     * &lt;tt>list1&lt;/tt> and &lt;tt>list2&lt;/tt>, as required by the general&#xA;     * contract of &lt;tt>Object.hashCode&lt;/tt>.&#xA;     *&#xA;     * @return the hash code value for this list.&#xA;     * @see Object#hashCode()&#xA;     * @see Object#equals(Object)&#xA;     * @see #equals(Object)&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0">
          <comments>// Positional Access Operations</comments>
          <comments>/**&#xA;     * Returns the element at the specified position in this list.&#xA;     *&#xA;     * @param index index of element to return.&#xA;     * @return the element at the specified position in this list.&#xA;     * &#xA;     * @throws IndexOutOfBoundsException if the index is out of range (index&#xA;     * &#x9;&#x9;  &amp;lt; 0 || index &amp;gt;= size()).&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="set">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0">
          <comments>/**&#xA;     * Replaces the element at the specified position in this list with the&#xA;     * specified element (optional operation).&#xA;     *&#xA;     * @param index index of element to replace.&#xA;     * @param element element to be stored at the specified position.&#xA;     * @return the element previously at the specified position.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>set&lt;/tt> method is not&#xA;     *&#x9;&#x9;  supported by this list.&#xA;     * @throws    ClassCastException if the class of the specified element&#xA;     * &#x9;&#x9;  prevents it from being added to this list.&#xA;     * @throws    NullPointerException if the specified element is null and&#xA;     *            this list does not support null elements.&#xA;     * @throws    IllegalArgumentException if some aspect of the specified&#xA;     *&#x9;&#x9;  element prevents it from being added to this list.&#xA;     * @throws    IndexOutOfBoundsException if the index is out of range&#xA;     *&#x9;&#x9;  (index &amp;lt; 0 || index &amp;gt;= size()).&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="element">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="add">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Inserts the specified element at the specified position in this list&#xA;     * (optional operation).  Shifts the element currently at that position&#xA;     * (if any) and any subsequent elements to the right (adds one to their&#xA;     * indices).&#xA;     *&#xA;     * @param index index at which the specified element is to be inserted.&#xA;     * @param element element to be inserted.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>add&lt;/tt> method is not&#xA;     *&#x9;&#x9;  supported by this list.&#xA;     * @throws    ClassCastException if the class of the specified element&#xA;     * &#x9;&#x9;  prevents it from being added to this list.&#xA;     * @throws    NullPointerException if the specified element is null and&#xA;     *            this list does not support null elements.&#xA;     * @throws    IllegalArgumentException if some aspect of the specified&#xA;     *&#x9;&#x9;  element prevents it from being added to this list.&#xA;     * @throws    IndexOutOfBoundsException if the index is out of range&#xA;     *&#x9;&#x9;  (index &amp;lt; 0 || index &amp;gt; size()).&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="element">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="remove">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0">
          <comments>/**&#xA;     * Removes the element at the specified position in this list (optional&#xA;     * operation).  Shifts any subsequent elements to the left (subtracts one&#xA;     * from their indices).  Returns the element that was removed from the&#xA;     * list.&#xA;     *&#xA;     * @param index the index of the element to removed.&#xA;     * @return the element previously at the specified position.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>remove&lt;/tt> method is&#xA;     *&#x9;&#x9;  not supported by this list.&#xA;     * @throws IndexOutOfBoundsException if the index is out of range (index&#xA;     *            &amp;lt; 0 || index &amp;gt;= size()).&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="indexOf">
      <typeReference xsi:type="types:Int">
        <comments>// Search Operations</comments>
        <comments>/**&#xA;     * Returns the index in this list of the first occurrence of the specified&#xA;     * element, or -1 if this list does not contain this element.&#xA;     * More formally, returns the lowest index &lt;tt>i&lt;/tt> such that&#xA;     * &lt;tt>(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt>,&#xA;     * or -1 if there is no such index.&#xA;     *&#xA;     * @param o element to search for.&#xA;     * @return the index in this list of the first occurrence of the specified&#xA;     * &#x9;       element, or -1 if this list does not contain this element.&#xA;     * @throws ClassCastException if the type of the specified element&#xA;     * &#x9;       is incompatible with this list (optional).&#xA;     * @throws NullPointerException if the specified element is null and this&#xA;     *         list does not support null elements (optional).&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="lastIndexOf">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Returns the index in this list of the last occurrence of the specified&#xA;     * element, or -1 if this list does not contain this element.&#xA;     * More formally, returns the highest index &lt;tt>i&lt;/tt> such that&#xA;     * &lt;tt>(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt>,&#xA;     * or -1 if there is no such index.&#xA;     *&#xA;     * @param o element to search for.&#xA;     * @return the index in this list of the last occurrence of the specified&#xA;     * &#x9;       element, or -1 if this list does not contain this element.&#xA;     * @throws ClassCastException if the type of the specified element&#xA;     * &#x9;       is incompatible with this list (optional).&#xA;     * @throws NullPointerException if the specified element is null and this&#xA;     *         list does not support null elements (optional).&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="listIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>// List Iterators</comments>
          <comments>/**&#xA;     * Returns a list iterator of the elements in this list (in proper&#xA;     * sequence).&#xA;     *&#xA;     * @return a list iterator of the elements in this list (in proper&#xA;     * &#x9;       sequence).&#xA;     */</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="ListIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="listIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns a list iterator of the elements in this list (in proper&#xA;     * sequence), starting at the specified position in this list.  The&#xA;     * specified index indicates the first element that would be returned by&#xA;     * an initial call to the &lt;tt>next&lt;/tt> method.  An initial call to&#xA;     * the &lt;tt>previous&lt;/tt> method would return the element with the&#xA;     * specified index minus one.&#xA;     *&#xA;     * @param index index of first element to be returned from the&#xA;     *&#x9;&#x9;    list iterator (by a call to the &lt;tt>next&lt;/tt> method).&#xA;     * @return a list iterator of the elements in this list (in proper&#xA;     * &#x9;       sequence), starting at the specified position in this list.&#xA;     * @throws IndexOutOfBoundsException if the index is out of range (index&#xA;     *         &amp;lt; 0 || index &amp;gt; size()).&#xA;     */</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="ListIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="subList">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0">
          <comments>// View</comments>
          <comments>/**&#xA;     * Returns a view of the portion of this list between the specified&#xA;     * &lt;tt>fromIndex&lt;/tt>, inclusive, and &lt;tt>toIndex&lt;/tt>, exclusive.  (If&#xA;     * &lt;tt>fromIndex&lt;/tt> and &lt;tt>toIndex&lt;/tt> are equal, the returned list is&#xA;     * empty.)  The returned list is backed by this list, so non-structural&#xA;     * changes in the returned list are reflected in this list, and vice-versa.&#xA;     * The returned list supports all of the optional list operations supported&#xA;     * by this list.&lt;p>&#xA;     *&#xA;     * This method eliminates the need for explicit range operations (of&#xA;     * the sort that commonly exist for arrays).   Any operation that expects&#xA;     * a list can be used as a range operation by passing a subList view&#xA;     * instead of a whole list.  For example, the following idiom&#xA;     * removes a range of elements from a list:&#xA;     * &lt;pre>&#xA;     *&#x9;    list.subList(from, to).clear();&#xA;     * &lt;/pre>&#xA;     * Similar idioms may be constructed for &lt;tt>indexOf&lt;/tt> and&#xA;     * &lt;tt>lastIndexOf&lt;/tt>, and all of the algorithms in the&#xA;     * &lt;tt>Collections&lt;/tt> class can be applied to a subList.&lt;p>&#xA;     *&#xA;     * The semantics of the list returned by this method become undefined if&#xA;     * the backing list (i.e., this list) is &lt;i>structurally modified&lt;/i> in&#xA;     * any way other than via the returned list.  (Structural modifications are&#xA;     * those that change the size of this list, or otherwise perturb it in such&#xA;     * a fashion that iterations in progress may yield incorrect results.)&#xA;     *&#xA;     * @param fromIndex low endpoint (inclusive) of the subList.&#xA;     * @param toIndex high endpoint (exclusive) of the subList.&#xA;     * @return a view of the specified range within this list.&#xA;     * &#xA;     * @throws IndexOutOfBoundsException for an illegal endpoint index value&#xA;     *     (fromIndex &amp;lt; 0 || toIndex &amp;gt; size || fromIndex &amp;gt; toIndex).&#xA;     */</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * An ordered collection (also known as a &lt;i>sequence&lt;/i>).  The user of this&#xA; * interface has precise control over where in the list each element is&#xA; * inserted.  The user can access elements by their integer index (position in&#xA; * the list), and search for elements in the list.&lt;p>&#xA; *&#xA; * Unlike sets, lists typically allow duplicate elements.  More formally,&#xA; * lists typically allow pairs of elements &lt;tt>e1&lt;/tt> and &lt;tt>e2&lt;/tt>&#xA; * such that &lt;tt>e1.equals(e2)&lt;/tt>, and they typically allow multiple&#xA; * null elements if they allow null elements at all.  It is not inconceivable&#xA; * that someone might wish to implement a list that prohibits duplicates, by&#xA; * throwing runtime exceptions when the user attempts to insert them, but we&#xA; * expect this usage to be rare.&lt;p>&#xA; *&#xA; * The &lt;tt>List&lt;/tt> interface places additional stipulations, beyond those&#xA; * specified in the &lt;tt>Collection&lt;/tt> interface, on the contracts of the&#xA; * &lt;tt>iterator&lt;/tt>, &lt;tt>add&lt;/tt>, &lt;tt>remove&lt;/tt>, &lt;tt>equals&lt;/tt>, and&#xA; * &lt;tt>hashCode&lt;/tt> methods.  Declarations for other inherited methods are&#xA; * also included here for convenience.&lt;p>&#xA; *&#xA; * The &lt;tt>List&lt;/tt> interface provides four methods for positional (indexed)&#xA; * access to list elements.  Lists (like Java arrays) are zero based.  Note&#xA; * that these operations may execute in time proportional to the index value&#xA; * for some implementations (the &lt;tt>LinkedList&lt;/tt> class, for&#xA; * example). Thus, iterating over the elements in a list is typically&#xA; * preferable to indexing through it if the caller does not know the&#xA; * implementation.&lt;p>&#xA; *&#xA; * The &lt;tt>List&lt;/tt> interface provides a special iterator, called a&#xA; * &lt;tt>ListIterator&lt;/tt>, that allows element insertion and replacement, and&#xA; * bidirectional access in addition to the normal operations that the&#xA; * &lt;tt>Iterator&lt;/tt> interface provides.  A method is provided to obtain a&#xA; * list iterator that starts at a specified position in the list.&lt;p>&#xA; *&#xA; * The &lt;tt>List&lt;/tt> interface provides two methods to search for a specified&#xA; * object.  From a performance standpoint, these methods should be used with&#xA; * caution.  In many implementations they will perform costly linear&#xA; * searches.&lt;p>&#xA; *&#xA; * The &lt;tt>List&lt;/tt> interface provides two methods to efficiently insert and&#xA; * remove multiple elements at an arbitrary point in the list.&lt;p>&#xA; *&#xA; * Note: While it is permissible for lists to contain themselves as elements,&#xA; * extreme caution is advised: the &lt;tt>equals&lt;/tt> and &lt;tt>hashCode&lt;/tt>&#xA; * methods are no longer well defined on a such a list.&#xA; *&#xA; * &lt;p>Some list implementations have restrictions on the elements that&#xA; * they may contain.  For example, some implementations prohibit null elements,&#xA; * and some have restrictions on the types of their elements.  Attempting to&#xA; * add an ineligible element throws an unchecked exception, typically&#xA; * &lt;tt>NullPointerException&lt;/tt> or &lt;tt>ClassCastException&lt;/tt>.  Attempting&#xA; * to query the presence of an ineligible element may throw an exception,&#xA; * or it may simply return false; some implementations will exhibit the former&#xA; * behavior and some will exhibit the latter.  More generally, attempting an&#xA; * operation on an ineligible element whose completion would not result in&#xA; * the insertion of an ineligible element into the list may throw an&#xA; * exception or it may succeed, at the option of the implementation.&#xA; * Such exceptions are marked as &quot;optional&quot; in the specification for this&#xA; * interface. &#xA; *&#xA; * &lt;p>This interface is a member of the &#xA; * &lt;a href=&quot;{@docRoot}/../guide/collections/index.html&quot;>&#xA; * Java Collections Framework&lt;/a>.&#xA; *&#xA; * @author  Josh Bloch&#xA; * @author  Neal Gafter&#xA; * @version 1.44, 12/19/03&#xA; * @see Collection&#xA; * @see Set&#xA; * @see ArrayList&#xA; * @see LinkedList&#xA; * @see Vector&#xA; * @see Arrays#asList(Object[])&#xA; * @see Collections#nCopies(int, Object)&#xA; * @see Collections#EMPTY_LIST&#xA; * @see AbstractList&#xA; * @see AbstractSequentialList&#xA; * @since 1.2&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
