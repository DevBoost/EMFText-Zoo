<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="TreeSet.java">
  <comments>/*&#xA; * @(#)TreeSet.java&#x9;1.32 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <classifiers xsi:type="classifiers:Class" name="TreeSet">
    <typeParameters name="E"/>
    <members xsi:type="members:Field" name="m">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="SortedMap.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="keySet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Set.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// The backing Map</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="PRESENT">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// The keySet view of the backing Map</comments>
        <comments>// Dummy value to associate with an Object in the backing Map</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="TreeSet">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="Map.class.xmi#//@classifiers.0/@members.9"/>
            </next>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="m">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="SortedMap.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Constructs a set backed by the specified sorted map.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="TreeSet">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                  </typeReference>
                </typeArguments>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </typeArguments>
                <target xsi:type="classifiers:Class" href="TreeMap.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new, empty set, sorted according to the elements' natural&#xA;     * order.  All elements inserted into the set must implement the&#xA;     * &lt;tt>Comparable&lt;/tt> interface.  Furthermore, all such elements must be&#xA;     * &lt;i>mutually comparable&lt;/i>: &lt;tt>e1.compareTo(e2)&lt;/tt> must not throw a&#xA;     * &lt;tt>ClassCastException&lt;/tt> for any elements &lt;tt>e1&lt;/tt> and&#xA;     * &lt;tt>e2&lt;/tt> in the set.  If the user attempts to add an element to the&#xA;     * set that violates this constraint (for example, the user attempts to&#xA;     * add a string element to a set whose elements are integers), the&#xA;     * &lt;tt>add(Object)&lt;/tt> call will throw a &lt;tt>ClassCastException&lt;/tt>.&#xA;     *&#xA;     * @see Comparable&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="TreeSet">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                  </typeReference>
                </typeArguments>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </typeArguments>
                <target xsi:type="classifiers:Class" href="TreeMap.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:SuperTypeArgument">
              <superType xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </superType>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="Comparator.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new, empty set, sorted according to the specified&#xA;     * comparator.  All elements inserted into the set must be &lt;i>mutually&#xA;     * comparable&lt;/i> by the specified comparator: &lt;tt>comparator.compare(e1,&#xA;     * e2)&lt;/tt> must not throw a &lt;tt>ClassCastException&lt;/tt> for any elements&#xA;     * &lt;tt>e1&lt;/tt> and &lt;tt>e2&lt;/tt> in the set.  If the user attempts to add&#xA;     * an element to the set that violates this constraint, the&#xA;     * &lt;tt>add(Object)&lt;/tt> call will throw a &lt;tt>ClassCastException&lt;/tt>.&#xA;     *&#xA;     * @param c the comparator that will be used to sort this set.  A&#xA;     *        &lt;tt>null&lt;/tt> value indicates that the elements' &lt;i>natural&#xA;     *        ordering&lt;/i> should be used.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="TreeSet">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new set containing the elements in the specified&#xA;     * collection, sorted according to the elements' &lt;i>natural order&lt;/i>.&#xA;     * All keys inserted into the set must implement the &lt;tt>Comparable&lt;/tt>&#xA;     * interface.  Furthermore, all such keys must be &lt;i>mutually&#xA;     * comparable&lt;/i>: &lt;tt>k1.compareTo(k2)&lt;/tt> must not throw a&#xA;     * &lt;tt>ClassCastException&lt;/tt> for any elements &lt;tt>k1&lt;/tt> and&#xA;     * &lt;tt>k2&lt;/tt> in the set.&#xA;     *&#xA;     * @param c The elements that will comprise the new set.&#xA;     *&#xA;     * @throws ClassCastException if the keys in the specified collection are&#xA;     *         not comparable, or are not mutually comparable.&#xA;     * @throws NullPointerException if the specified collection is null.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="TreeSet">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="SortedSet.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="SortedSet.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new set containing the same elements as the specified&#xA;     * sorted set, sorted according to the same ordering.&#xA;     *&#xA;     * @param s sorted set whose elements will comprise the new set.&#xA;     * @throws NullPointerException if the specified sorted set is null.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="iterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an iterator over the elements in this set.  The elements&#xA;     * are returned in ascending order.&#xA;     *&#xA;     * @return an iterator over the elements in this set.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="Set.class.xmi#//@classifiers.0/@members.3"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="size">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the number of elements in this set (its cardinality).&#xA;     *&#xA;     * @return the number of elements in this set (its cardinality).&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="Map.class.xmi#//@classifiers.0/@members.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isEmpty">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this set contains no elements.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if this set contains no elements.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="Map.class.xmi#//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="contains">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this set contains the specified element.&#xA;     *&#xA;     * @param o the object to be checked for containment in this set.&#xA;     * @return &lt;tt>true&lt;/tt> if this set contains the specified element.&#xA;     *&#xA;     * @throws ClassCastException if the specified object cannot be compared&#xA;     * &#x9;&#x9;  with the elements currently in the set.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="Map.class.xmi#//@classifiers.0/@members.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="add">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds the specified element to this set if it is not already present.&#xA;     *&#xA;     * @param o element to be added to this set.&#xA;     * @return &lt;tt>true&lt;/tt> if the set did not already contain the specified&#xA;     *         element.&#xA;     *&#xA;     * @throws ClassCastException if the specified object cannot be compared&#xA;     * &#x9;&#x9;  with the elements currently in the set.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="Map.class.xmi#//@classifiers.0/@members.5"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            </next>
          </children>
          <children xsi:type="literals:NullLiteral"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="remove">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes the specified element from this set if it is present.&#xA;     *&#xA;     * @param o object to be removed from this set, if present.&#xA;     * @return &lt;tt>true&lt;/tt> if the set contained the specified element.&#xA;     *&#xA;     * @throws ClassCastException if the specified object cannot be compared&#xA;     * &#x9;&#x9;  with the elements currently in the set.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="Map.class.xmi#//@classifiers.0/@members.6"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clear">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes all of the elements from this set.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="Map.class.xmi#//@classifiers.0/@members.8"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="addAll">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds all of the elements in the specified collection to this set.&#xA;     *&#xA;     * @param c elements to be added&#xA;     * @return &lt;tt>true&lt;/tt> if this set changed as a result of the call.&#xA;     *&#xA;     * @throws ClassCastException if the elements provided cannot be compared&#xA;     *&#x9;&#x9;  with the elements currently in the set.&#xA;     * @throws NullPointerException of the specified collection is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// Use linear-time version if applicable</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="set">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <namespaces>Map</namespaces>
                      <classifierReferences>
                        <typeArguments xsi:type="generics:QualifiedTypeArgument">
                          <typeReference xsi:type="types:NamespaceClassifierReference">
                            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                          </typeReference>
                        </typeArguments>
                        <typeArguments xsi:type="generics:QualifiedTypeArgument">
                          <typeReference xsi:type="types:NamespaceClassifierReference">
                            <classifierReferences>
                              <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                            </classifierReferences>
                          </typeReference>
                        </typeArguments>
                        <target xsi:type="classifiers:Interface" href="Map$Entry.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                  </typeArguments>
                  <target xsi:type="classifiers:Interface" href="SortedSet.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <typeArguments xsi:type="generics:QualifiedTypeArgument">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <namespaces>Map</namespaces>
                        <classifierReferences>
                          <typeArguments xsi:type="generics:QualifiedTypeArgument">
                            <typeReference xsi:type="types:NamespaceClassifierReference">
                              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                            </typeReference>
                          </typeArguments>
                          <typeArguments xsi:type="generics:QualifiedTypeArgument">
                            <typeReference xsi:type="types:NamespaceClassifierReference">
                              <classifierReferences>
                                <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                              </classifierReferences>
                            </typeReference>
                          </typeArguments>
                          <target xsi:type="classifiers:Interface" href="Map$Entry.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                    </typeArguments>
                    <target xsi:type="classifiers:Interface" href="SortedSet.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Interface" href="SortedSet.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="map">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                    </typeReference>
                  </typeArguments>
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                  </typeArguments>
                  <target xsi:type="classifiers:Class" href="TreeMap.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <typeArguments xsi:type="generics:QualifiedTypeArgument">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                      </typeReference>
                    </typeArguments>
                    <typeArguments xsi:type="generics:QualifiedTypeArgument">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                    </typeArguments>
                    <target xsi:type="classifiers:Class" href="TreeMap.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="cc">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:SuperTypeArgument">
                    <superType xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                    </superType>
                  </typeArguments>
                  <target xsi:type="classifiers:Interface" href="Comparator.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <typeArguments xsi:type="generics:QualifiedTypeArgument">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                      </typeReference>
                    </typeArguments>
                    <target xsi:type="classifiers:Interface" href="Comparator.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@statement/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="SortedSet.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="mc">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:SuperTypeArgument">
                    <superType xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                    </superType>
                  </typeArguments>
                  <target xsi:type="classifiers:Interface" href="Comparator.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@statement/@statements.1/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="TreeMap.class.xmi#//@classifiers.0/@members.20"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@statement/@statements.1/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="TreeMap.class.xmi#//@classifiers.0/@members.56"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@statement/@statements.0/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@statement/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@statement/@statements.3/@variable"/>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@statement/@statements.2/@variable"/>
                    <children xsi:type="literals:NullLiteral"/>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@statement/@statements.2/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="Comparator.class.xmi#//@classifiers.0/@members.1"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@statement/@statements.3/@variable"/>
                    </next>
                  </children>
                </expression>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="Map.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="Collection.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
          <children xsi:type="expressions:InstanceOfExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Interface" href="SortedSet.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
              <comments>// FIXME(VFORCE) Work-around for bug in compiler</comments>
            </child>
          </children>
          <children xsi:type="expressions:InstanceOfExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="TreeMap.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractCollection.class.xmi#//@classifiers.0/@members.10"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          </next>
          <self xsi:type="literals:Super"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="subSet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="SortedSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromElement">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toElement">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a view of the portion of this set whose elements range from&#xA;     * &lt;tt>fromElement&lt;/tt>, inclusive, to &lt;tt>toElement&lt;/tt>, exclusive.  (If&#xA;     * &lt;tt>fromElement&lt;/tt> and &lt;tt>toElement&lt;/tt> are equal, the returned&#xA;     * sorted set is empty.)  The returned sorted set is backed by this set,&#xA;     * so changes in the returned sorted set are reflected in this set, and&#xA;     * vice-versa.  The returned sorted set supports all optional Set&#xA;     * operations.&lt;p>&#xA;     *&#xA;     * The sorted set returned by this method will throw an&#xA;     * &lt;tt>IllegalArgumentException&lt;/tt> if the user attempts to insert an&#xA;     * element outside the specified range.&lt;p>&#xA;     *&#xA;     * Note: this method always returns a &lt;i>half-open range&lt;/i> (which&#xA;     * includes its low endpoint but not its high endpoint).  If you need a&#xA;     * &lt;i>closed range&lt;/i> (which includes both endpoints), and the element&#xA;     * type allows for calculation of the successor of a specified value,&#xA;     * merely request the subrange from &lt;tt>lowEndpoint&lt;/tt> to&#xA;     * &lt;tt>successor(highEndpoint)&lt;/tt>.  For example, suppose that &lt;tt>s&lt;/tt>&#xA;     * is a sorted set of strings.  The following idiom obtains a view&#xA;     * containing all of the strings in &lt;tt>s&lt;/tt> from &lt;tt>low&lt;/tt> to&#xA;     * &lt;tt>high&lt;/tt>, inclusive: &lt;pre>&#xA;     *     SortedSet sub = s.subSet(low, high+&quot;\0&quot;);&#xA;     * &lt;/pre>&#xA;     *&#xA;     * A similar technique can be used to generate an &lt;i>open range&lt;/i> (which&#xA;     * contains neither endpoint).  The following idiom obtains a view&#xA;     * containing all of the strings in &lt;tt>s&lt;/tt> from &lt;tt>low&lt;/tt> to&#xA;     * &lt;tt>high&lt;/tt>, exclusive: &lt;pre>&#xA;     *     SortedSet sub = s.subSet(low+&quot;\0&quot;, high);&#xA;     * &lt;/pre>&#xA;     *&#xA;     * @param fromElement low endpoint (inclusive) of the subSet.&#xA;     * @param toElement high endpoint (exclusive) of the subSet.&#xA;     * @return a view of the portion of this set whose elements range from&#xA;     * &#x9;       &lt;tt>fromElement&lt;/tt>, inclusive, to &lt;tt>toElement&lt;/tt>,&#xA;     * &#x9;       exclusive.&#xA;     * @throws ClassCastException if &lt;tt>fromElement&lt;/tt> and&#xA;     *         &lt;tt>toElement&lt;/tt> cannot be compared to one another using&#xA;     *         this set's comparator (or, if the set has no comparator,&#xA;     *         using natural ordering).&#xA;     * @throws IllegalArgumentException if &lt;tt>fromElement&lt;/tt> is greater than&#xA;     *         &lt;tt>toElement&lt;/tt>.&#xA;     * @throws NullPointerException if &lt;tt>fromElement&lt;/tt> or&#xA;     *&#x9;       &lt;tt>toElement&lt;/tt> is &lt;tt>null&lt;/tt> and this set uses natural&#xA;     *&#x9;       order, or its comparator does not tolerate &lt;tt>null&lt;/tt>&#xA;     *         elements.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="SortedMap.class.xmi#//@classifiers.0/@members.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="headSet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="SortedSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toElement">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a view of the portion of this set whose elements are strictly&#xA;     * less than &lt;tt>toElement&lt;/tt>.  The returned sorted set is backed by&#xA;     * this set, so changes in the returned sorted set are reflected in this&#xA;     * set, and vice-versa.  The returned sorted set supports all optional set&#xA;     * operations.&lt;p>&#xA;     *&#xA;     * The sorted set returned by this method will throw an&#xA;     * &lt;tt>IllegalArgumentException&lt;/tt> if the user attempts to insert an&#xA;     * element greater than or equal to &lt;tt>toElement&lt;/tt>.&lt;p>&#xA;     *&#xA;     * Note: this method always returns a view that does not contain its&#xA;     * (high) endpoint.  If you need a view that does contain this endpoint,&#xA;     * and the element type allows for calculation of the successor of a&#xA;     * specified value, merely request a headSet bounded by&#xA;     * &lt;tt>successor(highEndpoint)&lt;/tt>.  For example, suppose that &lt;tt>s&lt;/tt>&#xA;     * is a sorted set of strings.  The following idiom obtains a view&#xA;     * containing all of the strings in &lt;tt>s&lt;/tt> that are less than or equal&#xA;     * to &lt;tt>high&lt;/tt>: &lt;pre> SortedSet head = s.headSet(high+&quot;\0&quot;);&lt;/pre>&#xA;     *&#xA;     * @param toElement high endpoint (exclusive) of the headSet.&#xA;     * @return a view of the portion of this set whose elements are strictly&#xA;     * &#x9;       less than toElement.&#xA;     * @throws ClassCastException if &lt;tt>toElement&lt;/tt> is not compatible&#xA;     *         with this set's comparator (or, if the set has no comparator,&#xA;     *         if &lt;tt>toElement&lt;/tt> does not implement &lt;tt>Comparable&lt;/tt>).&#xA;     * @throws IllegalArgumentException if this set is itself a subSet,&#xA;     *         headSet, or tailSet, and &lt;tt>toElement&lt;/tt> is not within the&#xA;     *         specified range of the subSet, headSet, or tailSet.&#xA;     * @throws NullPointerException if &lt;tt>toElement&lt;/tt> is &lt;tt>null&lt;/tt> and&#xA;     *&#x9;       this set uses natural ordering, or its comparator does&#xA;     *         not tolerate &lt;tt>null&lt;/tt> elements.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="SortedMap.class.xmi#//@classifiers.0/@members.2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="tailSet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="SortedSet.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromElement">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a view of the portion of this set whose elements are&#xA;     * greater than or equal to &lt;tt>fromElement&lt;/tt>.  The returned sorted set&#xA;     * is backed by this set, so changes in the returned sorted set are&#xA;     * reflected in this set, and vice-versa.  The returned sorted set&#xA;     * supports all optional set operations.&lt;p>&#xA;     *&#xA;     * The sorted set returned by this method will throw an&#xA;     * &lt;tt>IllegalArgumentException&lt;/tt> if the user attempts to insert an&#xA;     * element less than &lt;tt>fromElement&lt;/tt>.&#xA;     *&#xA;     * Note: this method always returns a view that contains its (low)&#xA;     * endpoint.  If you need a view that does not contain this endpoint, and&#xA;     * the element type allows for calculation of the successor of a specified&#xA;     * value, merely request a tailSet bounded by&#xA;     * &lt;tt>successor(lowEndpoint)&lt;/tt>.  For example, suppose that &lt;tt>s&lt;/tt>&#xA;     * is a sorted set of strings.  The following idiom obtains a view&#xA;     * containing all of the strings in &lt;tt>s&lt;/tt> that are strictly greater&#xA;     * than &lt;tt>low&lt;/tt>: &lt;pre>&#xA;     *     SortedSet tail = s.tailSet(low+&quot;\0&quot;);&#xA;     * &lt;/pre>&#xA;     *&#xA;     * @param fromElement low endpoint (inclusive) of the tailSet.&#xA;     * @return a view of the portion of this set whose elements are&#xA;     * &#x9;       greater than or equal to &lt;tt>fromElement&lt;/tt>.&#xA;     * @throws ClassCastException if &lt;tt>fromElement&lt;/tt> is not compatible&#xA;     *         with this set's comparator (or, if the set has no comparator,&#xA;     *         if &lt;tt>fromElement&lt;/tt> does not implement &lt;tt>Comparable&lt;/tt>).&#xA;     * @throws IllegalArgumentException if this set is itself a subSet,&#xA;     *         headSet, or tailSet, and &lt;tt>fromElement&lt;/tt> is not within the&#xA;     *         specified range of the subSet, headSet, or tailSet.&#xA;     * @throws NullPointerException if &lt;tt>fromElement&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#x9;       and this set uses natural ordering, or its comparator does&#xA;     *         not tolerate &lt;tt>null&lt;/tt> elements.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="SortedMap.class.xmi#//@classifiers.0/@members.3"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="comparator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:SuperTypeArgument">
            <superType xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </superType>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Comparator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the comparator used to order this sorted set, or &lt;tt>null&lt;/tt>&#xA;     * if this tree set uses its elements natural ordering.&#xA;     *&#xA;     * @return the comparator used to order this sorted set, or &lt;tt>null&lt;/tt>&#xA;     * if this tree set uses its elements natural ordering.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="SortedMap.class.xmi#//@classifiers.0/@members.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="first">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the first (lowest) element currently in this sorted set.&#xA;     *&#xA;     * @return the first (lowest) element currently in this sorted set.&#xA;     * @throws    NoSuchElementException sorted set is empty.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="SortedMap.class.xmi#//@classifiers.0/@members.4"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="last">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the last (highest) element currently in this sorted set.&#xA;     *&#xA;     * @return the last (highest) element currently in this sorted set.&#xA;     * @throws    NoSuchElementException sorted set is empty.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="SortedMap.class.xmi#//@classifiers.0/@members.5"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a shallow copy of this &lt;tt>TreeSet&lt;/tt> instance. (The elements&#xA;     * themselves are not cloned.)&#xA;     *&#xA;     * @return a shallow copy of this set.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="clone">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0">
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                    </typeReference>
                  </typeArguments>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.5"/>
                </next>
                <self xsi:type="literals:Super"/>
              </child>
            </value>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/InternalError.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/CloneNotSupportedException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                  </typeReference>
                </typeArguments>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </typeArguments>
                <target xsi:type="classifiers:Class" href="TreeMap.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="Map.class.xmi#//@classifiers.0/@members.9"/>
              </next>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>java</namespaces>
        <namespaces>io</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Save the state of the &lt;tt>TreeSet&lt;/tt> instance to a stream (that is,&#xA;     * serialize it).&#xA;     *&#xA;     * @serialData Emits the comparator used to order this set, or&#xA;     *&#x9;&#x9;   &lt;tt>null&lt;/tt> if it obeys its elements' natural ordering&#xA;     *&#x9;&#x9;   (Object), followed by the size of the set (the number of&#xA;     *&#x9;&#x9;   elements it contains) (int), followed by all of its&#xA;     *&#x9;&#x9;   elements (each an Object) in order (as determined by the&#xA;     *&#x9;&#x9;   set's Comparator, or by the elements' natural ordering if&#xA;     *             the set has no Comparator).&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
          <comments>// Write out any hidden stuff</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.17"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
          <comments>// Write out Comparator</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="SortedMap.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
          <comments>// Write out size</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.37"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="Map.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <comments>// Write out all elements in the proper order.</comments>
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.14"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.3/@init">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="Iterator.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </arguments>
            </next>
          </expression>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.3/@init">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="Iterator.class.xmi#//@classifiers.0/@members.0"/>
          </next>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="Set.class.xmi#//@classifiers.0/@members.3"/>
              </next>
              <target xsi:type="members:InterfaceMethod" href="Map.class.xmi#//@classifiers.0/@members.9"/>
            </next>
          </initialValue>
        </init>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/ObjectInputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <namespaces>java</namespaces>
        <namespaces>io</namespaces>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/ClassNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Reconstitute the &lt;tt>TreeSet&lt;/tt> instance from a stream (that is,&#xA;     * deserialize it).&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0">
          <comments>// Read in any hidden stuff</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectInputStream.class.xmi#//@classifiers.0/@members.19"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Read in Comparator</comments>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <target xsi:type="classifiers:Interface" href="Comparator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                  </typeReference>
                </typeArguments>
                <target xsi:type="classifiers:Interface" href="Comparator.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../io/ObjectInputStream.class.xmi#//@classifiers.0/@members.16"/>
              </next>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="tm">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Create backing TreeMap and keySet view</comments>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </typeArguments>
              <target xsi:type="classifiers:Class" href="TreeMap.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.2/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                    </typeReference>
                  </typeArguments>
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                  </typeArguments>
                  <target xsi:type="classifiers:Class" href="TreeMap.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.1/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.2/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                    </typeReference>
                  </typeArguments>
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                  </typeArguments>
                  <target xsi:type="classifiers:Class" href="TreeMap.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.1/@variable"/>
            </value>
          </expression>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.2/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="Map.class.xmi#//@classifiers.0/@members.9"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="size">
          <typeReference xsi:type="types:Int">
            <comments>// Read in size</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../io/ObjectInputStream.class.xmi#//@classifiers.0/@members.38"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.2/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="TreeMap.class.xmi#//@classifiers.0/@members.55"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.6/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="2479143000061671589"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This class implements the &lt;tt>Set&lt;/tt> interface, backed by a&#xA; * &lt;tt>TreeMap&lt;/tt> instance.  This class guarantees that the sorted set will&#xA; * be in ascending element order, sorted according to the &lt;i>natural order&lt;/i>&#xA; * of the elements (see &lt;tt>Comparable&lt;/tt>), or by the comparator provided at&#xA; * set creation time, depending on which constructor is used.&lt;p>&#xA; *&#xA; * This implementation provides guaranteed log(n) time cost for the basic&#xA; * operations (&lt;tt>add&lt;/tt>, &lt;tt>remove&lt;/tt> and &lt;tt>contains&lt;/tt>).&lt;p>&#xA; *&#xA; * Note that the ordering maintained by a set (whether or not an explicit&#xA; * comparator is provided) must be &lt;i>consistent with equals&lt;/i> if it is to&#xA; * correctly implement the &lt;tt>Set&lt;/tt> interface.  (See &lt;tt>Comparable&lt;/tt>&#xA; * or &lt;tt>Comparator&lt;/tt> for a precise definition of &lt;i>consistent with&#xA; * equals&lt;/i>.)  This is so because the &lt;tt>Set&lt;/tt> interface is defined in&#xA; * terms of the &lt;tt>equals&lt;/tt> operation, but a &lt;tt>TreeSet&lt;/tt> instance&#xA; * performs all key comparisons using its &lt;tt>compareTo&lt;/tt> (or&#xA; * &lt;tt>compare&lt;/tt>) method, so two keys that are deemed equal by this method&#xA; * are, from the standpoint of the set, equal.  The behavior of a set&#xA; * &lt;i>is&lt;/i> well-defined even if its ordering is inconsistent with equals; it&#xA; * just fails to obey the general contract of the &lt;tt>Set&lt;/tt> interface.&lt;p>&#xA; *&#xA; * &lt;b>Note that this implementation is not synchronized.&lt;/b> If multiple&#xA; * threads access a set concurrently, and at least one of the threads modifies&#xA; * the set, it &lt;i>must&lt;/i> be synchronized externally.  This is typically&#xA; * accomplished by synchronizing on some object that naturally encapsulates&#xA; * the set.  If no such object exists, the set should be &quot;wrapped&quot; using the&#xA; * &lt;tt>Collections.synchronizedSet&lt;/tt> method.  This is best done at creation&#xA; * time, to prevent accidental unsynchronized access to the set: &lt;pre>&#xA; *     SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));&#xA; * &lt;/pre>&lt;p>&#xA; *&#xA; * The Iterators returned by this class's &lt;tt>iterator&lt;/tt> method are&#xA; * &lt;i>fail-fast&lt;/i>: if the set is modified at any time after the iterator is&#xA; * created, in any way except through the iterator's own &lt;tt>remove&lt;/tt>&#xA; * method, the iterator will throw a &lt;tt>ConcurrentModificationException&lt;/tt>.&#xA; * Thus, in the face of concurrent modification, the iterator fails quickly&#xA; * and cleanly, rather than risking arbitrary, non-deterministic behavior at&#xA; * an undetermined time in the future.&#xA; *&#xA; * &lt;p>Note that the fail-fast behavior of an iterator cannot be guaranteed&#xA; * as it is, generally speaking, impossible to make any hard guarantees in the&#xA; * presence of unsynchronized concurrent modification.  Fail-fast iterators&#xA; * throw &lt;tt>ConcurrentModificationException&lt;/tt> on a best-effort basis.&#xA; * Therefore, it would be wrong to write a program that depended on this&#xA; * exception for its correctness:   &lt;i>the fail-fast behavior of iterators&#xA; * should be used only to detect bugs.&lt;/i>&lt;p>&#xA; *&#xA; * This class is a member of the&#xA; * &lt;a href=&quot;{@docRoot}/../guide/collections/index.html&quot;>&#xA; * Java Collections Framework&lt;/a>.&#xA; *&#xA; * @author  Josh Bloch&#xA; * @version 1.32, 12/19/03&#xA; * @see&#x9;    Collection&#xA; * @see&#x9;    Set&#xA; * @see&#x9;    HashSet&#xA; * @see     Comparable&#xA; * @see     Comparator&#xA; * @see&#x9;    Collections#synchronizedSortedSet(SortedSet)&#xA; * @see&#x9;    TreeMap&#xA; * @since   1.2&#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="SortedSet.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../lang/Cloneable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <namespaces>java</namespaces>
      <namespaces>io</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../io/Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Class" href="AbstractSet.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
