<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="Calendar.java">
  <comments>/*&#xA; * @(#)Calendar.java&#x9;1.81 04/07/26&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/*&#xA; * (C) Copyright Taligent, Inc. 1996-1998 - All Rights Reserved&#xA; * (C) Copyright IBM Corp. 1996-1998 - All Rights Reserved&#xA; *&#xA; *   The original version of this source code and documentation is copyrighted&#xA; * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These&#xA; * materials are provided under terms of a License Agreement between Taligent&#xA; * and Sun. This technology is protected by multiple US and International&#xA; * patents. This notice and attribution to Taligent may not be removed.&#xA; *   Taligent is a registered trademark of Taligent, Inc.&#xA; *&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/ObjectInputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../io/Serializable.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../security/AccessController.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../security/PrivilegedExceptionAction.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>text</namespaces>
    <classifier xsi:type="classifiers:Class" href="../text/DateFormat.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>text</namespaces>
    <namespaces>resources</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/util/BuddhistCalendar.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>util</namespaces>
    <namespaces>calendar</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/util/calendar/ZoneInfo.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Calendar">
    <members xsi:type="members:Field" name="ERA">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Data flow in Calendar</comments>
        <comments>// ---------------------</comments>
        <comments>// The current time is represented in two ways by Calendar: as UTC</comments>
        <comments>// milliseconds from the epoch (1 January 1970 0:00 UTC), and as local</comments>
        <comments>// fields such as MONTH, HOUR, AM_PM, etc.  It is possible to compute the</comments>
        <comments>// millis from the fields, and vice versa.  The data needed to do this</comments>
        <comments>// conversion is encapsulated by a TimeZone object owned by the Calendar.</comments>
        <comments>// The data provided by the TimeZone object may also be overridden if the</comments>
        <comments>// user sets the ZONE_OFFSET and/or DST_OFFSET fields directly. The class</comments>
        <comments>// keeps track of what information was most recently set by the caller, and</comments>
        <comments>// uses that to compute any other information as needed.</comments>
        <comments>// If the user sets the fields using set(), the data flow is as follows.</comments>
        <comments>// This is implemented by the Calendar subclass's computeTime() method.</comments>
        <comments>// During this process, certain fields may be ignored.  The disambiguation</comments>
        <comments>// algorithm for resolving which fields to pay attention to is described</comments>
        <comments>// in the class documentation.</comments>
        <comments>//   local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)</comments>
        <comments>//           |</comments>
        <comments>//           | Using Calendar-specific algorithm</comments>
        <comments>//           V</comments>
        <comments>//   local standard millis</comments>
        <comments>//           |</comments>
        <comments>//           | Using TimeZone or user-set ZONE_OFFSET / DST_OFFSET</comments>
        <comments>//           V</comments>
        <comments>//   UTC millis (in time data member)</comments>
        <comments>// If the user sets the UTC millis using setTime() or setTimeInMillis(),</comments>
        <comments>// the data flow is as follows.  This is implemented by the Calendar</comments>
        <comments>// subclass's computeFields() method.</comments>
        <comments>//   UTC millis (in time data member)</comments>
        <comments>//           |</comments>
        <comments>//           | Using TimeZone getOffset()</comments>
        <comments>//           V</comments>
        <comments>//   local standard millis</comments>
        <comments>//           |</comments>
        <comments>//           | Using Calendar-specific algorithm</comments>
        <comments>//           V</comments>
        <comments>//   local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)</comments>
        <comments>// In general, a round trip from fields, through local and UTC millis, and</comments>
        <comments>// back out to fields is made when necessary.  This is implemented by the</comments>
        <comments>// complete() method.  Resolving a partial set of fields into a UTC millis</comments>
        <comments>// value allows all remaining fields to be generated from that value.  If</comments>
        <comments>// the Calendar is lenient, the fields are also renormalized to standard</comments>
        <comments>// ranges when they are regenerated.</comments>
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * era, e.g., AD or BC in the Julian calendar. This is a calendar-specific&#xA;     * value; see subclass documentation.&#xA;     *&#xA;     * @see GregorianCalendar#AD&#xA;     * @see GregorianCalendar#BC&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="YEAR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * year. This is a calendar-specific value; see subclass documentation.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="MONTH">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * month. This is a calendar-specific value. The first month of the year is&#xA;     * &lt;code>JANUARY&lt;/code> which is 0; the last depends on the number of months in a year.&#xA;     *&#xA;     * @see #JANUARY&#xA;     * @see #FEBRUARY&#xA;     * @see #MARCH&#xA;     * @see #APRIL&#xA;     * @see #MAY&#xA;     * @see #JUNE&#xA;     * @see #JULY&#xA;     * @see #AUGUST&#xA;     * @see #SEPTEMBER&#xA;     * @see #OCTOBER&#xA;     * @see #NOVEMBER&#xA;     * @see #DECEMBER&#xA;     * @see #UNDECIMBER&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="WEEK_OF_YEAR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * week number within the current year.  The first week of the year, as&#xA;     * defined by &lt;code>getFirstDayOfWeek()&lt;/code> and&#xA;     * &lt;code>getMinimalDaysInFirstWeek()&lt;/code>, has value 1.  Subclasses define&#xA;     * the value of &lt;code>WEEK_OF_YEAR&lt;/code> for days before the first week of&#xA;     * the year.&#xA;     *&#xA;     * @see #getFirstDayOfWeek&#xA;     * @see #getMinimalDaysInFirstWeek&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="WEEK_OF_MONTH">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * week number within the current month.  The first week of the month, as&#xA;     * defined by &lt;code>getFirstDayOfWeek()&lt;/code> and&#xA;     * &lt;code>getMinimalDaysInFirstWeek()&lt;/code>, has value 1.  Subclasses define&#xA;     * the value of &lt;code>WEEK_OF_MONTH&lt;/code> for days before the first week of&#xA;     * the month.&#xA;     *&#xA;     * @see #getFirstDayOfWeek&#xA;     * @see #getMinimalDaysInFirstWeek&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DATE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * day of the month. This is a synonym for &lt;code>DAY_OF_MONTH&lt;/code>.&#xA;     * The first day of the month has value 1.&#xA;     *&#xA;     * @see #DAY_OF_MONTH&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DAY_OF_MONTH">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * day of the month. This is a synonym for &lt;code>DATE&lt;/code>.&#xA;     * The first day of the month has value 1.&#xA;     *&#xA;     * @see #DATE&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DAY_OF_YEAR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the day&#xA;     * number within the current year.  The first day of the year has value 1.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DAY_OF_WEEK">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the day&#xA;     * of the week.  This field takes values &lt;code>SUNDAY&lt;/code>,&#xA;     * &lt;code>MONDAY&lt;/code>, &lt;code>TUESDAY&lt;/code>, &lt;code>WEDNESDAY&lt;/code>,&#xA;     * &lt;code>THURSDAY&lt;/code>, &lt;code>FRIDAY&lt;/code>, and &lt;code>SATURDAY&lt;/code>.&#xA;     *&#xA;     * @see #SUNDAY&#xA;     * @see #MONDAY&#xA;     * @see #TUESDAY&#xA;     * @see #WEDNESDAY&#xA;     * @see #THURSDAY&#xA;     * @see #FRIDAY&#xA;     * @see #SATURDAY&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DAY_OF_WEEK_IN_MONTH">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * ordinal number of the day of the week within the current month. Together&#xA;     * with the &lt;code>DAY_OF_WEEK&lt;/code> field, this uniquely specifies a day&#xA;     * within a month.  Unlike &lt;code>WEEK_OF_MONTH&lt;/code> and&#xA;     * &lt;code>WEEK_OF_YEAR&lt;/code>, this field's value does &lt;em>not&lt;/em> depend on&#xA;     * &lt;code>getFirstDayOfWeek()&lt;/code> or&#xA;     * &lt;code>getMinimalDaysInFirstWeek()&lt;/code>.  &lt;code>DAY_OF_MONTH 1&lt;/code>&#xA;     * through &lt;code>7&lt;/code> always correspond to &lt;code>DAY_OF_WEEK_IN_MONTH&#xA;     * 1&lt;/code>; &lt;code>8&lt;/code> through &lt;code>14&lt;/code> correspond to&#xA;     * &lt;code>DAY_OF_WEEK_IN_MONTH 2&lt;/code>, and so on.&#xA;     * &lt;code>DAY_OF_WEEK_IN_MONTH 0&lt;/code> indicates the week before&#xA;     * &lt;code>DAY_OF_WEEK_IN_MONTH 1&lt;/code>.  Negative values count back from the&#xA;     * end of the month, so the last Sunday of a month is specified as&#xA;     * &lt;code>DAY_OF_WEEK = SUNDAY, DAY_OF_WEEK_IN_MONTH = -1&lt;/code>.  Because&#xA;     * negative values count backward they will usually be aligned differently&#xA;     * within the month than positive values.  For example, if a month has 31&#xA;     * days, &lt;code>DAY_OF_WEEK_IN_MONTH -1&lt;/code> will overlap&#xA;     * &lt;code>DAY_OF_WEEK_IN_MONTH 5&lt;/code> and the end of &lt;code>4&lt;/code>.&#xA;     *&#xA;     * @see #DAY_OF_WEEK&#xA;     * @see #WEEK_OF_MONTH&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="AM_PM">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating&#xA;     * whether the &lt;code>HOUR&lt;/code> is before or after noon.&#xA;     * E.g., at 10:04:15.250 PM the &lt;code>AM_PM&lt;/code> is &lt;code>PM&lt;/code>.&#xA;     *&#xA;     * @see #AM&#xA;     * @see #PM&#xA;     * @see #HOUR&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="HOUR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * hour of the morning or afternoon. &lt;code>HOUR&lt;/code> is used for the&#xA;     * 12-hour clock (0 - 11). Noon and midnight are represented by 0, not by 12.&#xA;     * E.g., at 10:04:15.250 PM the &lt;code>HOUR&lt;/code> is 10.&#xA;     *&#xA;     * @see #AM_PM&#xA;     * @see #HOUR_OF_DAY&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="HOUR_OF_DAY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * hour of the day. &lt;code>HOUR_OF_DAY&lt;/code> is used for the 24-hour clock.&#xA;     * E.g., at 10:04:15.250 PM the &lt;code>HOUR_OF_DAY&lt;/code> is 22.&#xA;     *&#xA;     * @see #HOUR&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="MINUTE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * minute within the hour.&#xA;     * E.g., at 10:04:15.250 PM the &lt;code>MINUTE&lt;/code> is 4.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="SECOND">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="13"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * second within the minute.&#xA;     * E.g., at 10:04:15.250 PM the &lt;code>SECOND&lt;/code> is 15.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="MILLISECOND">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="14"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * millisecond within the second.&#xA;     * E.g., at 10:04:15.250 PM the &lt;code>MILLISECOND&lt;/code> is 250.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="ZONE_OFFSET">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="15"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code>&#xA;     * indicating the raw offset from GMT in milliseconds.&#xA;     * &lt;p>&#xA;     * This field reflects the correct GMT offset value of the time&#xA;     * zone of this &lt;code>Calendar&lt;/code> if the&#xA;     * &lt;code>TimeZone&lt;/code> implementation subclass supports&#xA;     * historical GMT offset changes.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DST_OFFSET">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Field number for &lt;code>get&lt;/code> and &lt;code>set&lt;/code> indicating the&#xA;     * daylight savings offset in milliseconds.&#xA;     * &lt;p>&#xA;     * This field reflects the correct daylight saving offset value of&#xA;     * the time zone of this &lt;code>Calendar&lt;/code> if the&#xA;     * &lt;code>TimeZone&lt;/code> implementation subclass supports&#xA;     * historical Daylight Saving Time schedule changes.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="FIELD_COUNT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="17"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The number of distinct fields recognized by &lt;code>get&lt;/code> and &lt;code>set&lt;/code>.&#xA;     * Field numbers range from &lt;code>0..FIELD_COUNT-1&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="SUNDAY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #DAY_OF_WEEK} field indicating&#xA;     * Sunday.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="MONDAY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #DAY_OF_WEEK} field indicating&#xA;     * Monday.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="TUESDAY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #DAY_OF_WEEK} field indicating&#xA;     * Tuesday.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="WEDNESDAY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #DAY_OF_WEEK} field indicating&#xA;     * Wednesday.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="THURSDAY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #DAY_OF_WEEK} field indicating&#xA;     * Thursday.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="FRIDAY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #DAY_OF_WEEK} field indicating&#xA;     * Friday.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="SATURDAY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #DAY_OF_WEEK} field indicating&#xA;     * Saturday.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="JANUARY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #MONTH} field indicating the&#xA;     * first month of the year.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="FEBRUARY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #MONTH} field indicating the&#xA;     * second month of the year.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="MARCH">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #MONTH} field indicating the&#xA;     * third month of the year.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="APRIL">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #MONTH} field indicating the&#xA;     * fourth month of the year.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="MAY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #MONTH} field indicating the&#xA;     * fifth month of the year.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="JUNE">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #MONTH} field indicating the&#xA;     * sixth month of the year.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="JULY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #MONTH} field indicating the&#xA;     * seventh month of the year.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="AUGUST">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #MONTH} field indicating the&#xA;     * eighth month of the year.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="SEPTEMBER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #MONTH} field indicating the&#xA;     * ninth month of the year.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="OCTOBER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #MONTH} field indicating the&#xA;     * tenth month of the year.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="NOVEMBER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #MONTH} field indicating the&#xA;     * eleventh month of the year.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DECEMBER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #MONTH} field indicating the&#xA;     * twelfth month of the year.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="UNDECIMBER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #MONTH} field indicating the&#xA;     * thirteenth month of the year. Although &lt;code>GregorianCalendar&lt;/code>&#xA;     * does not use this value, lunar calendars do.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="AM">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #AM_PM} field indicating the&#xA;     * period of the day from midnight to just before noon.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="PM">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Value of the {@link #AM_PM} field indicating the&#xA;     * period of the day from noon to just before midnight.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="fields">
      <typeReference xsi:type="types:Int"/>
      <arrayDimensionsAfter/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>// Internal notes:</comments>
        <comments>// Calendar contains two kinds of time representations: current &quot;time&quot; in</comments>
        <comments>// milliseconds, and a set of calendar &quot;fields&quot; representing the current time.</comments>
        <comments>// The two representations are usually in sync, but can get out of sync</comments>
        <comments>// as follows.</comments>
        <comments>// 1. Initially, no fields are set, and the time is invalid.</comments>
        <comments>// 2. If the time is set, all fields are computed and in sync.</comments>
        <comments>// 3. If a single field is set, the time is invalid.</comments>
        <comments>// Recomputation of the time and fields happens when the object needs</comments>
        <comments>// to return a result to the user, or use a result for a computation.</comments>
        <comments>/**&#xA;     * The calendar field values for the currently set time for this calendar.&#xA;     * This is an array of &lt;code>FIELD_COUNT&lt;/code> integers, with index values&#xA;     * &lt;code>ERA&lt;/code> through &lt;code>DST_OFFSET&lt;/code>.&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="isSet">
      <typeReference xsi:type="types:Boolean"/>
      <arrayDimensionsAfter/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The flags which tell if a specified calendar field for the calendar is set.&#xA;     * A new object has no fields set.  After the first call to a method&#xA;     * which generates the fields, they all remain set after that.&#xA;     * This is an array of &lt;code>FIELD_COUNT&lt;/code> booleans, with index values&#xA;     * &lt;code>ERA&lt;/code> through &lt;code>DST_OFFSET&lt;/code>.&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="stamp">
      <typeReference xsi:type="types:Int"/>
      <arrayDimensionsAfter/>
      <annotationsAndModifiers xsi:type="modifiers:Transient">
        <comments>/**&#xA;     * Pseudo-time-stamps which specify when each field was set. There&#xA;     * are two special values, UNSET and COMPUTED. Values from&#xA;     * MINIMUM_USER_SET to Integer.MAX_VALUE are legal user set values.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="time">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The currently set time for this calendar, expressed in milliseconds after&#xA;     * January 1, 1970, 0:00:00 GMT.&#xA;     * @see #isTimeSet&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="isTimeSet">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * True if then the value of &lt;code>time&lt;/code> is valid.&#xA;     * The time is made invalid by a change to an item of &lt;code>field[]&lt;/code>.&#xA;     * @see #time&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="areFieldsSet">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * True if &lt;code>fields[]&lt;/code> are in sync with the currently set time.&#xA;     * If false, then the next attempt to get the value of a field will&#xA;     * force a recomputation of all fields from the current value of&#xA;     * &lt;code>time&lt;/code>.&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="areAllFieldsSet">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient">
        <comments>/**&#xA;     * True if all fields have been set.&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="lenient">
      <initialValue xsi:type="literals:BooleanLiteral" value="true"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * &lt;code>True&lt;/code> if this calendar allows out-of-range field values during computation&#xA;     * of &lt;code>time&lt;/code> from &lt;code>fields[]&lt;/code>.&#xA;     * @see #setLenient&#xA;     * @see #isLenient&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="zone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The &lt;code>TimeZone&lt;/code> used by this calendar. &lt;code>Calendar&lt;/code>&#xA;     * uses the time zone data to translate between locale and GMT time.&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="sharedZone">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient">
        <comments>/**&#xA;     * &lt;code>True&lt;/code> if zone references to a shared TimeZone object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="firstDayOfWeek">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The first day of the week, with possible values &lt;code>SUNDAY&lt;/code>,&#xA;     * &lt;code>MONDAY&lt;/code>, etc.  This is a locale-dependent value.&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="minimalDaysInFirstWeek">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The number of days required for the first week in a month or year,&#xA;     * with possible values from 1 to 7.  This is a locale-dependent value.&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="cachedLocaleData">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="Locale.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </typeArguments>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <arrayDimensionsBefore/>
              <typeReference xsi:type="types:Int"/>
            </typeArguments>
            <target xsi:type="classifiers:Class" href="Hashtable.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="Locale.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <arrayDimensionsBefore/>
            <typeReference xsi:type="types:Int"/>
          </typeArguments>
          <target xsi:type="classifiers:Class" href="Hashtable.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Cache to hold the firstDayOfWeek and minimalDaysInFirstWeek&#xA;     * of a Locale.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="UNSET">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Special values of stamp[]</comments>
        <comments>/**&#xA;     * The corresponding fields[] has no value.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="COMPUTED">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The value of the corresponding fields[] has been calculated internally.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MINIMUM_USER_STAMP">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The value of the corresponding fields[] has been set externally. Stamp&#xA;     * values which are greater than 1 represents the (pseudo) time when the&#xA;     * corresponding fields[] value was set.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ALL_FIELDS">
      <initialValue xsi:type="expressions:AdditiveExpression">
        <children xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ShiftExpression">
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
            <shiftOperators xsi:type="operators:LeftShift"/>
          </expression>
        </children>
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        <additiveOperators xsi:type="operators:Subtraction"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * The mask value that represents all of the fields.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="nextStamp">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The next available value for &lt;code>stamp[]&lt;/code>, an internal array.&#xA;     * This actually should not be written out to the stream, and will probably&#xA;     * be removed from the stream in the near future.  In the meantime,&#xA;     * a value of &lt;code>MINIMUM_USER_STAMP&lt;/code> should be used.&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="currentSerialVersion">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>// the internal serial version which says which version was written</comments>
        <comments>// - 0 (default) for version up to JDK 1.1.5</comments>
        <comments>// - 1 for version from JDK 1.1.6, which writes a correct 'time' value</comments>
        <comments>//     as well as compatible values for other fields.  This is a</comments>
        <comments>//     transitional format.</comments>
        <comments>// - 2 (not implemented yet) a future version, in which fields[],</comments>
        <comments>//     areFieldsSet, and isTimeSet become transient, and isSet[] is</comments>
        <comments>//     removed. In JDK 1.1.6 we write a format compatible with version 2.</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="serialVersionOnStream">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The version of the serialized data on the stream.  Possible values:&#xA;     * &lt;dl>&#xA;     * &lt;dt>&lt;b>0&lt;/b> or not present on stream&lt;/dt>&#xA;     * &lt;dd>&#xA;     * JDK 1.1.5 or earlier.&#xA;     * &lt;/dd>&#xA;     * &lt;dt>&lt;b>1&lt;/b>&lt;/dt>&#xA;     * &lt;dd>&#xA;     * JDK 1.1.6 or later.  Writes a correct 'time' value&#xA;     * as well as compatible values for other fields.  This is a&#xA;     * transitional format.&#xA;     * &lt;/dd>&#xA;     * &lt;/dl>&#xA;     * When streaming out this class, the most recent format&#xA;     * and the highest allowable &lt;code>serialVersionOnStream&lt;/code>&#xA;     * is written.&#xA;     * @serial&#xA;     * @since JDK1.1.6&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="1807547505821590642"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>// Proclaim serialization compatibility with JDK 1.1</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ERA_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>// Mask values for calendar fields</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="YEAR_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="MONTH_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="WEEK_OF_YEAR_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="WEEK_OF_MONTH_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DAY_OF_MONTH_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DATE_MASK">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DAY_OF_YEAR_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DAY_OF_WEEK_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DAY_OF_WEEK_IN_MONTH_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="AM_PM_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="HOUR_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="HOUR_OF_DAY_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="MINUTE_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="SECOND_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="MILLISECOND_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="ZONE_OFFSET_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="DST_OFFSET_MASK">
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:ShiftExpression">
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
          <shiftOperators xsi:type="operators:LeftShift"/>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Constructor" name="Calendar">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="TimeZone.class.xmi#//@classifiers.0/@members.38"/>
            </next>
            <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="Locale.class.xmi#//@classifiers.0"/>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Constructs a Calendar with the default time zone&#xA;     * and locale.&#xA;     * @see     TimeZone#getDefault&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Calendar">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Int"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Boolean"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Int"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.144">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@parameters.1"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="zone">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Constructs a calendar with the specified time zone and locale.&#xA;     *&#xA;     * @param zone the time zone to use&#xA;     * @param aLocale the locale for the week data&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets a calendar using the default time zone and locale. The&#xA;     * &lt;code>Calendar&lt;/code> returned is based on the current time&#xA;     * in the default time zone with the default locale.&#xA;     *&#xA;     * @return a Calendar.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cal">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.86">
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="TimeZone.class.xmi#//@classifiers.0/@members.38"/>
              </next>
              <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Locale.class.xmi#//@classifiers.0/@members.35"/>
              </next>
              <target xsi:type="classifiers:Class" href="Locale.class.xmi#//@classifiers.0"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="zone">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets a calendar using the specified time zone and default locale.&#xA;     * The &lt;code>Calendar&lt;/code> returned is based on the current time&#xA;     * in the given time zone with the default locale. &#xA;     *&#xA;     * @param zone the time zone to use&#xA;     * @return a Calendar.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.86">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.83/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Locale.class.xmi#//@classifiers.0/@members.35"/>
            </next>
            <target xsi:type="classifiers:Class" href="Locale.class.xmi#//@classifiers.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets a calendar using the default time zone and specified locale.&#xA;     * The &lt;code>Calendar&lt;/code> returned is based on the current time&#xA;     * in the default time zone with the given locale.&#xA;     *&#xA;     * @param aLocale the locale for the week data&#xA;     * @return a Calendar.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cal">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.86">
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="TimeZone.class.xmi#//@classifiers.0/@members.38"/>
              </next>
              <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="zone">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets a calendar with the specified time zone and locale.&#xA;     * The &lt;code>Calendar&lt;/code> returned is based on the current time&#xA;     * in the given time zone with the given locale.&#xA;     *&#xA;     * @param zone the time zone to use&#xA;     * @param aLocale the locale for the week data&#xA;     * @return a Calendar.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.86">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createCalendar">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="zone">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <comments>// If the specified locale is a Thai locale, returns a BuddhistCalendar</comments>
        <comments>// instance.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <namespaces>sun</namespaces>
                <namespaces>util</namespaces>
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../sun/util/BuddhistCalendar.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.1"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="references:StringReference" value="th">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Locale.class.xmi#//@classifiers.0/@members.40"/>
                </next>
              </arguments>
            </next>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="references:StringReference" value="TH">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.1">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="Locale.class.xmi#//@classifiers.0/@members.41"/>
                  </next>
                </arguments>
              </next>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// else create the default calendar</comments>
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="GregorianCalendar.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAvailableLocales">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Locale.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an array of all locales for which the &lt;code>getInstance&lt;/code>&#xA;     * methods of this class can return localized instances.&#xA;     * The array returned must contain at least a &lt;code>Locale&lt;/code>&#xA;     * instance equal to {@link java.util.Locale#US Locale.US}.&#xA;     *&#xA;     * @return An array of locales for which localized&#xA;     *         &lt;code>Calendar&lt;/code> instances are available.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../text/DateFormat.class.xmi#//@classifiers.0/@members.42"/>
          </next>
          <target xsi:type="classifiers:Class" href="../text/DateFormat.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="computeTime">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Converts the current calendar field values in {@link #fields fields[]}&#xA;     * to the millisecond time value&#xA;     * {@link #time}.&#xA;     *&#xA;     * @see #complete()&#xA;     * @see #computeFields()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="computeFields">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Converts the current millisecond time value {@link #time}&#xA;     * to calendar field values in {@link #fields fields[]}.&#xA;     * This allows you to sync up the calendar field values with&#xA;     * a new time that is set for the calendar.  The time is &lt;em>not&lt;/em>&#xA;     * recomputed first; to recompute the time, then the fields, call the&#xA;     * {@link #complete()} method.&#xA;     *&#xA;     * @see #computeTime()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getTime">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>Date&lt;/code> object representing this&#xA;     * &lt;code>Calendar&lt;/code>'s time value (millisecond offset from the &lt;a&#xA;     * href=&quot;#Epoch&quot;>Epoch&lt;/a>&quot;).&#xA;     *&#xA;     * @return a &lt;code>Date&lt;/code> representing the time value.&#xA;     * @see #setTime(Date)&#xA;     * @see #getTimeInMillis()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.92"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setTime">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="date">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets this Calendar's time with the given &lt;code>Date&lt;/code>.&#xA;     * &lt;p>&#xA;     * Note: Calling &lt;code>setTime()&lt;/code> with&#xA;     * &lt;code>Date(Long.MAX_VALUE)&lt;/code> or &lt;code>Date(Long.MIN_VALUE)&lt;/code>&#xA;     * may yield incorrect field values from &lt;code>get()&lt;/code>.&#xA;     *&#xA;     * @param date the given Date.&#xA;     * @see #getTime()&#xA;     * @see #setTimeInMillis(long)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.93">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Date.class.xmi#//@classifiers.0/@members.30"/>
            </next>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getTimeInMillis">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns this Calendar's time value in milliseconds. &#xA;     *&#xA;     * @return the current time as UTC milliseconds from the epoch.&#xA;     * @see #getTime()&#xA;     * @see #setTimeInMillis(long)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.145"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setTimeInMillis">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="millis">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets this Calendar's current time from the given long value.&#xA;     *&#xA;     * @param millis the new time in UTC milliseconds from the epoch.&#xA;     * @see #setTime(Date)&#xA;     * @see #getTimeInMillis()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// If we don't need to recalculate the calendar field values,</comments>
        <comments>// do nothing.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@parameters.0"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../sun/util/calendar/ZoneInfo.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
            </expression>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="expressions:NestedExpression">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../sun/util/calendar/ZoneInfo.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <expression xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../sun/util/calendar/ZoneInfo.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
              </expression>
            </child>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.89"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:BooleanLiteral" value="true"/>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of the given calendar field. In lenient mode,&#xA;     * all calendar fields are normalized. In non-lenient mode, all&#xA;     * calendar fields are validated and this method throws an&#xA;     * exception if any calendar fields have out-of-range values. The&#xA;     * normalization and validation are handled by the&#xA;     * {@link #complete()} method, which process is calendar&#xA;     * system dependent.&#xA;     *&#xA;     * @param field the given calendar field.&#xA;     * @return the value for the given calendar field.&#xA;     * @throws ArrayIndexOutOfBoundsException if the specified field is out of range&#xA;     *             (&lt;code>field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code>).&#xA;     * @see #set(int,int)&#xA;     * @see #complete()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.104"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.95">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="internalGet">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Returns the value of the given calendar field. This method does&#xA;     * not involve normalization or validation of the field value.&#xA;     *&#xA;     * @param field the given calendar field.&#xA;     * @return the value for the given calendar field.&#xA;     * @see #get(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
          <arraySelectors>
            <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95/@parameters.0"/>
          </arraySelectors>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="internalSet">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Sets the value of the given calendar field. This method does&#xA;     * not affect any setting state of the field in this&#xA;     * &lt;code>Calendar&lt;/code> instance.&#xA;     *&#xA;     * @throws IndexOutOfBoundsException if the specified field is out of range&#xA;     *             (&lt;code>field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code>).&#xA;     * @see #areFieldsSet&#xA;     * @see #isTimeSet&#xA;     * @see #areAllFieldsSet&#xA;     * @see #set(int,int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@parameters.0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96/@parameters.1"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="set">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the given calendar field to the given value. The value is not&#xA;     * interpreted by this method regardless of the leniency mode.&#xA;     *&#xA;     * @param field the given calendar field.&#xA;     * @param value the value to be set for the given calendar field.&#xA;     * @throws ArrayIndexOutOfBoundsException if the specified field is out of range&#xA;     *             (&lt;code>field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code>).&#xA;     * in non-lenient mode.&#xA;     * @see #set(int,int,int)&#xA;     * @see #set(int,int,int,int,int)&#xA;     * @see #set(int,int,int,int,int,int)&#xA;     * @see #get(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.89"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.128"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.96">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97/@parameters.0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
            <operator xsi:type="operators:PlusPlus"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.148"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
          </children>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="set">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="year">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="month">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="date">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the values for the calendar fields &lt;code>YEAR&lt;/code>,&#xA;     * &lt;code>MONTH&lt;/code>, and &lt;code>DAY_OF_MONTH&lt;/code>.&#xA;     * Previous values of other calendar fields are retained.  If this is not desired,&#xA;     * call {@link #clear()} first.&#xA;     *&#xA;     * @param year the value used to set the &lt;code>YEAR&lt;/code> calendar field.&#xA;     * @param month the value used to set the &lt;code>MONTH&lt;/code> calendar field.&#xA;     * Month value is 0-based. e.g., 0 for January.&#xA;     * @param date the value used to set the &lt;code>DAY_OF_MONTH&lt;/code> calendar field.&#xA;     * @see #set(int,int)&#xA;     * @see #set(int,int,int,int,int)&#xA;     * @see #set(int,int,int,int,int,int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98/@parameters.2"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="set">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="year">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="month">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="date">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hourOfDay">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="minute">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the values for the calendar fields &lt;code>YEAR&lt;/code>,&#xA;     * &lt;code>MONTH&lt;/code>, &lt;code>DAY_OF_MONTH&lt;/code>,&#xA;     * &lt;code>HOUR_OF_DAY&lt;/code>, and &lt;code>MINUTE&lt;/code>.&#xA;     * Previous values of other fields are retained.  If this is not desired,&#xA;     * call {@link #clear()} first.&#xA;     *&#xA;     * @param year the value used to set the &lt;code>YEAR&lt;/code> calendar field.&#xA;     * @param month the value used to set the &lt;code>MONTH&lt;/code> calendar field.&#xA;     * Month value is 0-based. e.g., 0 for January.&#xA;     * @param date the value used to set the &lt;code>DAY_OF_MONTH&lt;/code> calendar field.&#xA;     * @param hourOfDay the value used to set the &lt;code>HOUR_OF_DAY&lt;/code> calendar field.&#xA;     * @param minute the value used to set the &lt;code>MINUTE&lt;/code> calendar field.&#xA;     * @see #set(int,int)&#xA;     * @see #set(int,int,int)&#xA;     * @see #set(int,int,int,int,int,int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@parameters.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@parameters.3"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99/@parameters.4"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="set">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="year">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="month">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="date">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hourOfDay">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="minute">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="second">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the values for the fields &lt;code>YEAR&lt;/code>, &lt;code>MONTH&lt;/code>,&#xA;     * &lt;code>DAY_OF_MONTH&lt;/code>, &lt;code>HOUR&lt;/code>, &lt;code>MINUTE&lt;/code>, and&#xA;     * &lt;code>SECOND&lt;/code>.&#xA;     * Previous values of other fields are retained.  If this is not desired,&#xA;     * call {@link #clear()} first.&#xA;     *&#xA;     * @param year the value used to set the &lt;code>YEAR&lt;/code> calendar field.&#xA;     * @param month the value used to set the &lt;code>MONTH&lt;/code> calendar field.&#xA;     * Month value is 0-based. e.g., 0 for January.&#xA;     * @param date the value used to set the &lt;code>DAY_OF_MONTH&lt;/code> calendar field.&#xA;     * @param hourOfDay the value used to set the &lt;code>HOUR_OF_DAY&lt;/code> calendar field.&#xA;     * @param minute the value used to set the &lt;code>MINUTE&lt;/code> calendar field.&#xA;     * @param second the value used to set the &lt;code>SECOND&lt;/code> calendar field.&#xA;     * @see #set(int,int)&#xA;     * @see #set(int,int,int)&#xA;     * @see #set(int,int,int,int,int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.3"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.4"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100/@parameters.5"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clear">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets all the calendar field values and the time value&#xA;     * (millisecond offset from the &lt;a href=&quot;#Epoch&quot;>Epoch&lt;/a>) of&#xA;     * this &lt;code>Calendar&lt;/code> undefined. This means that {@link&#xA;     * #isSet(int) isSet()} will return &lt;code>false&lt;/code> for all the&#xA;     * calendar fields, and the date and time calculations will treat&#xA;     * the fields as if they had never been set. A&#xA;     * &lt;code>Calendar&lt;/code> implementation class may use its specific&#xA;     * default field values for date/time calculations. For example,&#xA;     * &lt;code>GregorianCalendar&lt;/code> uses 1970 if the&#xA;     * &lt;code>YEAR&lt;/code> field value is undefined.&#xA;     *&#xA;     * @see #clear(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@statements.0/@init"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@statements.0/@init"/>
                  </arraySelectors>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42">
                <comments>// UNSET == 0</comments>
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@statements.0/@init"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101/@statements.0/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:BooleanLiteral"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clear">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the given calendar field value and the time value&#xA;     * (millisecond offset from the &lt;a href=&quot;#Epoch&quot;>Epoch&lt;/a>) of&#xA;     * this &lt;code>Calendar&lt;/code> undefined. This means that {@link&#xA;     * #isSet(int) isSet(field)} will return &lt;code>false&lt;/code>, and&#xA;     * the date and time calculations will treat the field as if it&#xA;     * had never been set. A &lt;code>Calendar&lt;/code> implementation&#xA;     * class may use the field's specific default value for date and&#xA;     * time calculations.&#xA;     *&#xA;     * &lt;p>The {@link #HOUR_OF_DAY}, {@link #HOUR} and {@link #AM_PM}&#xA;     * fields are handled independently and the &lt;a&#xA;     * href=&quot;#time_resolution&quot;>the resolution rule for the time of&#xA;     * day&lt;/a> is applied. Clearing one of the fields doesn't reset&#xA;     * the hour of day value of this &lt;code>Calendar&lt;/code>. Use {@link&#xA;     * #set(int,int) set(Calendar.HOUR_OF_DAY, 0)} to reset the hour&#xA;     * value.&#xA;     *&#xA;     * @param field the calendar field to be cleared.&#xA;     * @see #clear()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102/@parameters.0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:BooleanLiteral"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isSet">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines if the given calendar field has a value set,&#xA;     * including cases that the value has been set by internal fields&#xA;     * calculations triggered by a &lt;code>get&lt;/code> method call.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if the given calendar field has a value set;&#xA;     * &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103/@parameters.0"/>
            </arraySelectors>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="complete">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Fills in any unset fields in the calendar fields. First, the {@link&#xA;     * #computeTime()} method is called if the time value (millisecond offset&#xA;     * from the &lt;a href=&quot;#Epoch&quot;>Epoch&lt;/a>) has not been calculated from&#xA;     * calendar field values. Then, the {@link #computeFields()} method is&#xA;     * called to calculate all calendar field values.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.145"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.89"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47">
                <comments>// fills in unset fields</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral" value="true"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.107">
              <comments>// When a computeTime() call happens to calculate all the</comments>
              <comments>// fields, stamp[] are not modified to preserve what the</comments>
              <comments>// application has set. We need to normalize all stamp</comments>
              <comments>// elements to COMPUTED here. (5078053)</comments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
            </expression>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isExternallySet">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Returns whether the value of the specified calendar field has been set&#xA;     * externally by calling one of the setter methods rather than by the&#xA;     * internal time calculation.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if the field has been set externally,&#xA;     * &lt;code>false&lt;/code> otherwise.&#xA;     * @exception IndexOutOfBoundsException if the specified&#xA;     *                &lt;code>field&lt;/code> is out of range&#xA;     *               (&lt;code>field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code>).&#xA;     * @see #selectFields()&#xA;     * @see #setFieldsComputed(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.105/@parameters.0"/>
            </arraySelectors>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSetStateFields">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Returns a field mask (bit mask) indicating all calendar fields that&#xA;     * have the state of externally or internally set.&#xA;     *&#xA;     * @return a bit mask indicating set state fields&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="mask">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:AssignmentOr"/>
                  <value xsi:type="expressions:ShiftExpression">
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.1/@init"/>
                    <shiftOperators xsi:type="operators:LeftShift"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.1/@init"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.1/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.1/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setFieldsComputed">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fieldMask">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Sets the state of the specified calendar fields to&#xA;     * &lt;em>computed&lt;/em>. This state means that the specified calendar fields&#xA;     * have valid values that have been set by internal time calculation&#xA;     * rather than by calling one of the setter methods.&#xA;     *&#xA;     * @param fieldMask the field to be marked as computed.&#xA;     * @exception IndexOutOfBoundsException if the specified&#xA;     *                &lt;code>field&lt;/code> is out of range&#xA;     *               (&lt;code>field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code>).&#xA;     * @see #isExternallySet(int)&#xA;     * @see #selectFields()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107/@statements.0/@statement/@statements.0/@init"/>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107/@statements.0/@statement/@statements.0/@init"/>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:BooleanLiteral" value="true"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107/@statements.0/@statement/@statements.0/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107/@statements.0/@statement/@statements.0/@init"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral" value="true"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107/@statements.0/@elseStatement/@statements.0/@init"/>
                        </arraySelectors>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107/@statements.0/@elseStatement/@statements.0/@init"/>
                        </arraySelectors>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="literals:BooleanLiteral" value="true"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AndExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107/@parameters.0"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    </expression>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </condition>
                <elseStatement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="literals:BooleanLiteral"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:ConditionalAndExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
                      <children xsi:type="expressions:UnaryExpression">
                        <operators xsi:type="operators:Negate"/>
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42">
                          <arraySelectors>
                            <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107/@statements.0/@elseStatement/@statements.0/@init"/>
                          </arraySelectors>
                        </child>
                      </children>
                    </condition>
                  </statements>
                </elseStatement>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107/@parameters.0"/>
                  <assignmentOperator xsi:type="operators:AssignmentUnsignedRightShift"/>
                  <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107/@statements.0/@elseStatement/@statements.0/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107/@statements.0/@elseStatement/@statements.0/@init"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setFieldsNormalized">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fieldMask">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Sets the state of the calendar fields that are &lt;em>not&lt;/em> specified&#xA;     * by &lt;code>fieldMask&lt;/code> to &lt;em>unset&lt;/em>. If &lt;code>fieldMask&lt;/code>&#xA;     * specifies all the calendar fields, then the state of this&#xA;     * &lt;code>Calendar&lt;/code> becomes that all the calendar fields are in sync&#xA;     * with the time value (millisecond offset from the Epoch).&#xA;     *&#xA;     * @param fieldMask the field mask indicating which calendar fields are in&#xA;     * sync with the time value.&#xA;     * @exception IndexOutOfBoundsException if the specified&#xA;     *                &lt;code>field&lt;/code> is out of range&#xA;     *               (&lt;code>field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code>).&#xA;     * @see #isExternallySet(int)&#xA;     * @see #selectFields()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46">
                <comments>// all calendar fields are in sync with the time value</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral" value="true"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.1/@init"/>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.1/@init"/>
                      </arraySelectors>
                    </child>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42">
                    <comments>// UNSET == 0</comments>
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.1/@init"/>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:BooleanLiteral"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AndExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </expression>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@parameters.0"/>
              <assignmentOperator xsi:type="operators:AssignmentRightShift"/>
              <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.1/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108/@statements.1/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46">
            <comments>// Some fields are in sync with the milliseconds, but not all</comments>
            <comments>// fields have been calculated.</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isPartiallyNormalized">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Returns whether the calendar fields are partially in sync with the time&#xA;     * value.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isFullyNormalized">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Returns whether the calendar fields are fully in sync with the time&#xA;     * value.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setUnnormalized">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Marks this Calendar as not sync'd.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:BooleanLiteral"/>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isFieldSet">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fieldMask">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Returns whether the specified &lt;code>field&lt;/code> is on in the&#xA;     * &lt;code>fieldMask&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AndExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@parameters.0"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112/@parameters.1"/>
                  <shiftOperators xsi:type="operators:LeftShift"/>
                </expression>
              </children>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="selectFields">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Returns a field mask indicating which calendar field values&#xA;     * to be used to calculate the time value. The calendar fields are&#xA;     * returned as a bit mask, each bit of which corresponds to a field, i.e.,&#xA;     * the mask value of &lt;code>field&lt;/code> is &lt;code>(1 &amp;lt;&amp;lt;&#xA;     * field)&lt;/code>. For example, 0x26 represents the &lt;code>YEAR&lt;/code>,&#xA;     * &lt;code>MONTH&lt;/code>, and &lt;code>DAY_OF_MONTH&lt;/code> fields (i.e., 0x26 is&#xA;     * equal to&#xA;     * &lt;code>(1&amp;lt;&amp;lt;YEAR)|(1&amp;lt;&amp;lt;MONTH)|(1&amp;lt;&amp;lt;DAY_OF_MONTH))&lt;/code>.&#xA;     *&#xA;     * &lt;p>This method supports the calendar fields resolution as described in&#xA;     * the class description. If the bit mask for a given field is on and its&#xA;     * field has not been set (i.e., &lt;code>isSet(field)&lt;/code> is&#xA;     * &lt;code>false&lt;/code>), then the default value of the field has to be&#xA;     * used, which case means that the field has been selected because the&#xA;     * selected combination involves the field.&#xA;     *&#xA;     * @return a bit mask of selected fields&#xA;     * @see #isExternallySet(int)&#xA;     * @see #setInternallySetState(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="fieldMask">
          <typeReference xsi:type="types:Int">
            <comments>// This implementation has been taken from the GregorianCalendar class.</comments>
            <comments>// The YEAR field must always be used regardless of its SET</comments>
            <comments>// state because YEAR is a mandatory field to determine the date</comments>
            <comments>// and the default value (EPOCH_YEAR) may change through the</comments>
            <comments>// normalization process.</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:AssignmentOr"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </arraySelectors>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="dowStamp">
          <typeReference xsi:type="types:Int">
            <comments>// Find the most recent group of fields specifying the day within</comments>
            <comments>// the year.  These may be any of the following combinations:</comments>
            <comments>//   MONTH + DAY_OF_MONTH</comments>
            <comments>//   MONTH + WEEK_OF_MONTH + DAY_OF_WEEK</comments>
            <comments>//   MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK</comments>
            <comments>//   DAY_OF_YEAR</comments>
            <comments>//   WEEK_OF_YEAR + DAY_OF_WEEK</comments>
            <comments>// We look for the most recent of the fields in each group to determine</comments>
            <comments>// the age of the group.  For groups involving a week-related field such</comments>
            <comments>// as WEEK_OF_MONTH, DAY_OF_WEEK_IN_MONTH, or WEEK_OF_YEAR, both the</comments>
            <comments>// week-related field and the DAY_OF_WEEK must be set for the group as a</comments>
            <comments>// whole to be considered.  (See bug 4153860 - liu 7/24/98.)</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="monthStamp">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="domStamp">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="womStamp">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.114">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </arraySelectors>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.2/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="dowimStamp">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.114">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
              </arraySelectors>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.2/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="doyStamp">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="woyStamp">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.114">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </arraySelectors>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.2/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bestStamp">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.4/@variable"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.5/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.5/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.6/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.6/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.7/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.7/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.8/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.8/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>/* No complete combination exists.  Look for WEEK_OF_MONTH,&#xA;         * DAY_OF_WEEK_IN_MONTH, or WEEK_OF_YEAR alone.  Treat DAY_OF_WEEK alone&#xA;         * as DAY_OF_WEEK_IN_MONTH.&#xA;         */</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.5/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                </arraySelectors>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.6/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
                    </arraySelectors>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.2/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.8/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                </arraySelectors>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.5/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.6/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.8/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>/* Treat MONTH alone or no fields at all as DAY_OF_MONTH.  This may&#xA;             * result in bestStamp = domStamp = UNSET if no fields are set,&#xA;             * which indicates DAY_OF_MONTH.&#xA;             */</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.4/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.3/@variable"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:AssignmentOr"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:AssignmentOr"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.4/@variable"/>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:Assert">
                <condition xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ConditionalOrExpression">
                    <children xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.5/@variable"/>
                    </children>
                    <children xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.6/@variable"/>
                    </children>
                  </expression>
                </condition>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
                      <assignmentOperator xsi:type="operators:AssignmentOr"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.2/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
                </condition>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
                      <assignmentOperator xsi:type="operators:AssignmentOr"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.5/@variable"/>
                </condition>
                <elseStatement xsi:type="statements:Block">
                  <statements xsi:type="statements:Assert">
                    <condition xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:EqualityExpression">
                        <equalityOperators xsi:type="operators:Equal"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.6/@variable"/>
                      </expression>
                    </condition>
                  </statements>
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
                          <assignmentOperator xsi:type="operators:AssignmentOr"/>
                          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71"/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
                        </arraySelectors>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
                    </condition>
                  </statements>
                </elseStatement>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.4/@variable"/>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.5/@variable"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                  </arraySelectors>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                  </arraySelectors>
                </children>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </children>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.6/@variable"/>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
                  </arraySelectors>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                  </arraySelectors>
                </children>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </children>
            </expression>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Assert">
            <condition xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ConditionalOrExpression">
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.7/@variable"/>
                </children>
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.8/@variable"/>
                </children>
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
                </children>
              </expression>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:AssignmentOr"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.7/@variable"/>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:Assert">
                <condition xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.8/@variable"/>
                  </expression>
                </condition>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
                      <assignmentOperator xsi:type="operators:AssignmentOr"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.2/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:AssignmentOr"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65"/>
                </expression>
              </statements>
            </elseStatement>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="hourOfDayStamp">
          <typeReference xsi:type="types:Int">
            <comments>// Find the best set of fields specifying the time of day.  There</comments>
            <comments>// are only two possibilities here; the HOUR_OF_DAY or the</comments>
            <comments>// AM_PM and the HOUR.</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="hourStamp">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.114">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
              </arraySelectors>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
              </arraySelectors>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.17/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.16/@variable"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </expression>
            </child>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.17/@variable"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.16/@variable"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// if bestStamp is still UNSET, then take HOUR or AM_PM. (See 4846659)</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
                    </arraySelectors>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
                    </arraySelectors>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Hours</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:AssignmentOr"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.16/@variable"/>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:AssignmentOr"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73"/>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
                      <assignmentOperator xsi:type="operators:AssignmentOr"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
                    </arraySelectors>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
                </condition>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.9/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:AssignmentOr"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13"/>
            </arraySelectors>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:AssignmentOr"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
            </arraySelectors>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:AssignmentOr"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15"/>
            </arraySelectors>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:AssignmentOr"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
            </arraySelectors>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:AssignmentOr"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
            </arraySelectors>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="aggregateStamp">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="stamp_a">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="stamp_b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Returns the pseudo-time-stamp for two fields, given their&#xA;     * individual pseudo-time-stamps.  If either of the fields&#xA;     * is unset, then the aggregate is unset.  Otherwise, the&#xA;     * aggregate is the later of the two stamps.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.1"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares this &lt;code>Calendar&lt;/code> to the specified&#xA;     * &lt;code>Object&lt;/code>.  The result is &lt;code>true&lt;/code> if and only if&#xA;     * the argument is a &lt;code>Calendar&lt;/code> object of the same calendar&#xA;     * system that represents the same time value (millisecond offset from the&#xA;     * &lt;a href=&quot;#Epoch&quot;>Epoch&lt;/a>) under the same&#xA;     * &lt;code>Calendar&lt;/code> parameters as this object.&#xA;     *&#xA;     * &lt;p>The &lt;code>Calendar&lt;/code> parameters are the values represented&#xA;     * by the &lt;code>isLenient&lt;/code>, &lt;code>getFirstDayOfWeek&lt;/code>,&#xA;     * &lt;code>getMinimalDaysInFirstWeek&lt;/code> and &lt;code>getTimeZone&lt;/code>&#xA;     * methods. If there is any difference in those parameters&#xA;     * between the two &lt;code>Calendar&lt;/code>s, this method returns&#xA;     * &lt;code>false&lt;/code>.&#xA;     *&#xA;     * &lt;p>Use the {@link #compareTo(Calendar) compareTo} method to&#xA;     * compare only the time values.&#xA;     *&#xA;     * @param obj the object to compare with.&#xA;     * @return &lt;code>true&lt;/code> if this object is equal to &lt;code>obj&lt;/code>;&#xA;     * &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="that">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <initialValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@parameters.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.146">
                <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.147">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@statements.1/@statements.0/@variable"/>
                </arguments>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@statements.1/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48"/>
              </children>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@statements.1/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
              </children>
            </children>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@statements.1/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52"/>
              </children>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.4"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115/@statements.1/@statements.0/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
                </arguments>
              </next>
            </children>
          </returnValue>
        </statements>
        <catcheBlocks>
          <comments>// Note: GregorianCalendar.computeTime throws</comments>
          <comments>// IllegalArgumentException if the ERA value is invalid</comments>
          <comments>// even it's in lenient mode.</comments>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Exception.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a hash code for this calendar.&#xA;     *&#xA;     * @return a hash code value for this object. &#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="otheritems">
          <typeReference xsi:type="types:Int">
            <comments>// 'otheritems' represents the hash code for the previous versions.</comments>
          </typeReference>
          <initialValue xsi:type="expressions:InclusiveOrExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ConditionalExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48"/>
                <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <expressionElse xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <shiftOperators xsi:type="operators:LeftShift"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
                <shiftOperators xsi:type="operators:LeftShift"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.3"/>
                  </next>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
                <shiftOperators xsi:type="operators:LeftShift"/>
              </expression>
            </children>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="t">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.147">
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ExclusiveOrExpression">
          <children xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.1/@variable"/>
          </children>
          <children xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.1/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="32"/>
                <shiftOperators xsi:type="operators:RightShift"/>
              </expression>
            </child>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116/@statements.0/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="before">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="when">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns whether this &lt;code>Calendar&lt;/code> represents a time&#xA;     * before the time represented by the specified&#xA;     * &lt;code>Object&lt;/code>. This method is equivalent to:&#xA;     * &lt;pre>&lt;blockquote>&#xA;     *         compareTo(when) &lt; 0&#xA;     * &lt;/blockquote>&lt;/pre>&#xA;     * if and only if &lt;code>when&lt;/code> is a &lt;code>Calendar&lt;/code>&#xA;     * instance. Otherwise, the method returns &lt;code>false&lt;/code>.&#xA;     *&#xA;     * @param when the &lt;code>Object&lt;/code> to be compared&#xA;     * @return &lt;code>true&lt;/code> if the time of this&#xA;     * &lt;code>Calendar&lt;/code> is before the time represented by&#xA;     * &lt;code>when&lt;/code>; &lt;code>false&lt;/code> otherwise.&#xA;     * @see&#x9;#compareTo(Calendar)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:InstanceOfExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117/@parameters.0"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.119">
              <arguments xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117/@parameters.0"/>
              </arguments>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="after">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="when">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns whether this &lt;code>Calendar&lt;/code> represents a time&#xA;     * after the time represented by the specified&#xA;     * &lt;code>Object&lt;/code>. This method is equivalent to:&#xA;     * &lt;pre>&lt;blockquote>&#xA;     *         compareTo(when) > 0&#xA;     * &lt;/blockquote>&lt;/pre>&#xA;     * if and only if &lt;code>when&lt;/code> is a &lt;code>Calendar&lt;/code>&#xA;     * instance. Otherwise, the method returns &lt;code>false&lt;/code>.&#xA;     *&#xA;     * @param when the &lt;code>Object&lt;/code> to be compared&#xA;     * @return &lt;code>true&lt;/code> if the time of this &lt;code>Calendar&lt;/code> is&#xA;     * after the time represented by &lt;code>when&lt;/code>; &lt;code>false&lt;/code>&#xA;     * otherwise.&#xA;     * @see&#x9;#compareTo(Calendar)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:InstanceOfExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.118/@parameters.0"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.119">
              <arguments xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.118/@parameters.0"/>
              </arguments>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="anotherCalendar">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares the time values (millisecond offsets from the &lt;a&#xA;     * href=&quot;#Epoch&quot;>Epoch&lt;/a>) represented by two&#xA;     * &lt;code>Calendar&lt;/code> objects.&#xA;     *&#xA;     * @param anotherCalendar the &lt;code>Calendar&lt;/code> to be compared.&#xA;     * @return the value &lt;code>0&lt;/code> if the time represented by the argument&#xA;     * is equal to the time represented by this &lt;code>Calendar&lt;/code>; a value&#xA;     * less than &lt;code>0&lt;/code> if the time of this &lt;code>Calendar&lt;/code> is&#xA;     * before the time represented by the argument; and a value greater than&#xA;     * &lt;code>0&lt;/code> if the time of this &lt;code>Calendar&lt;/code> is after the&#xA;     * time represented by the argument.&#xA;     * @exception NullPointerException if the specified &lt;code>Calendar&lt;/code> is&#xA;     *            &lt;code>null&lt;/code>.&#xA;     * @exception IllegalArgumentException if the time value of the&#xA;     * specified &lt;code>Calendar&lt;/code> object can't be obtained due to&#xA;     * any invalid calendar values.&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.146">
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.147">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119/@parameters.0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="add">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="amount">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Adds or subtracts the specified amount of time to the given calendar field,&#xA;     * based on the calendar's rules. For example, to subtract 5 days from&#xA;     * the current time of the calendar, you can achieve it by calling:&#xA;     * &lt;p>&lt;code>add(Calendar.DAY_OF_MONTH, -5)&lt;/code>.&#xA;     *&#xA;     * @param field the calendar field.&#xA;     * @param amount the amount of date or time to be added to the field.&#xA;     * @see #roll(int,int)&#xA;     * @see #set(int,int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="roll">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="up">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Adds or subtracts (up/down) a single unit of time on the given time &#xA;     * field without changing larger fields. For example, to roll the current &#xA;     * date up by one day, you can achieve it by calling:&#xA;     * &lt;p>roll(Calendar.DATE, true).&#xA;     * When rolling on the year or Calendar.YEAR field, it will roll the year&#xA;     * value in the range between 1 and the value returned by calling&#xA;     * &lt;code>getMaximum(Calendar.YEAR)&lt;/code>.&#xA;     * When rolling on the month or Calendar.MONTH field, other fields like&#xA;     * date might conflict and, need to be changed. For instance,&#xA;     * rolling the month on the date 01/31/96 will result in 02/29/96.&#xA;     * When rolling on the hour-in-day or Calendar.HOUR_OF_DAY field, it will&#xA;     * roll the hour value in the range between 0 and 23, which is zero-based.&#xA;     *&#xA;     * @param field the time field.&#xA;     * @param up indicates if the value of the specified time field is to be&#xA;     * rolled up or rolled down. Use true if rolling up, false otherwise.&#xA;     * @see Calendar#add(int,int)&#xA;     * @see Calendar#set(int,int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="roll">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="amount">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Adds the specified (signed) amount to the specified calendar field&#xA;     * without changing larger fields.  A negative amount means to roll&#xA;     * down.&#xA;     *&#xA;     * &lt;p>NOTE:  This default implementation on &lt;code>Calendar&lt;/code> just repeatedly calls the&#xA;     * version of {@link #roll(int,boolean) roll()} that rolls by one unit.  This may not&#xA;     * always do the right thing.  For example, if the &lt;code>DAY_OF_MONTH&lt;/code> field is 31,&#xA;     * rolling through February will leave it set to 28.  The &lt;code>GregorianCalendar&lt;/code>&#xA;     * version of this function takes care of this problem.  Other subclasses&#xA;     * should also provide overrides of this function that do the right thing.&#xA;     *&#xA;     * @param field the calendar field.&#xA;     * @param amount the signed amount to add to the calendar &lt;code>field&lt;/code>.&#xA;     * @since 1.2&#xA;     * @see #roll(int,boolean)&#xA;     * @see #add(int,int)&#xA;     * @see #set(int,int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.121">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
              <arguments xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.1"/>
              <operator xsi:type="operators:MinusMinus"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.121">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.0"/>
              <arguments xsi:type="literals:BooleanLiteral"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.1"/>
              <operator xsi:type="operators:PlusPlus"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.122/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setTimeZone">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the time zone with the given time zone value.&#xA;     *&#xA;     * @param value the given time zone.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.123/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47">
            <comments>/* Recompute the fields from the time using the new zone.  This also&#xA;         * works if isTimeSet is false (after a call to set()).  In that case&#xA;         * the time will be computed from the fields using the new zone, then&#xA;         * the fields will get recomputed from that.  Consider the sequence of&#xA;         * calls: cal.setTimeZone(EST); cal.set(HOUR, 1); cal.setTimeZone(PST).&#xA;         * Is cal set to 1 o'clock EST or 1 o'clock PST?  Answer: PST.  More&#xA;         * generally, a call to setTimeZone() affects calls to set() BEFORE AND&#xA;         * AFTER it up to the next call to complete().&#xA;         */</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:BooleanLiteral"/>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getTimeZone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the time zone.&#xA;     *&#xA;     * @return the time zone object associated with this calendar.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// If the TimeZone object is shared by other Calendar instances, then</comments>
        <comments>// create a clone.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="TimeZone.class.xmi#//@classifiers.0/@members.43"/>
                  </next>
                </child>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getZone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns the time zone (without cloning).&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setZoneShared">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets the sharedZone flag to &lt;code>shared&lt;/code>.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="shared">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.126/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setLenient">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lenient">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Specifies whether or not date/time interpretation is to be lenient.  With&#xA;     * lenient interpretation, a date such as &quot;February 942, 1996&quot; will be&#xA;     * treated as being equivalent to the 941st day after February 1, 1996.&#xA;     * With strict (non-lenient) interpretation, such dates will cause an exception to be&#xA;     * thrown. The default is lenient.&#xA;     *&#xA;     * @param lenient &lt;code>true&lt;/code> if the lenient mode is to be turned&#xA;     * on; &lt;code>false&lt;/code> if it is to be turned off.&#xA;     * @see #isLenient()&#xA;     * @see java.text.DateFormat#setLenient&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.127/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isLenient">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tells whether date/time interpretation is to be lenient.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if the interpretation mode of this calendar is lenient;&#xA;     * &lt;code>false&lt;/code> otherwise.&#xA;     * @see #setLenient(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setFirstDayOfWeek">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets what the first day of the week is; e.g., &lt;code>SUNDAY&lt;/code> in the U.S.,&#xA;     * &lt;code>MONDAY&lt;/code> in France.&#xA;     *&#xA;     * @param value the given first day of the week.&#xA;     * @see #getFirstDayOfWeek()&#xA;     * @see #getMinimalDaysInFirstWeek()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.129/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.129/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.149"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getFirstDayOfWeek">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets what the first day of the week is; e.g., &lt;code>SUNDAY&lt;/code> in the U.S.,&#xA;     * &lt;code>MONDAY&lt;/code> in France.&#xA;     *&#xA;     * @return the first day of the week.&#xA;     * @see #setFirstDayOfWeek(int)&#xA;     * @see #getMinimalDaysInFirstWeek()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setMinimalDaysInFirstWeek">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets what the minimal days required in the first week of the year are;&#xA;     * For example, if the first week is defined as one that contains the first&#xA;     * day of the first month of a year, call this method with value 1. If it&#xA;     * must be a full week, use value 7.&#xA;     *&#xA;     * @param value the given minimal days required in the first week&#xA;     * of the year.&#xA;     * @see #getMinimalDaysInFirstWeek()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@parameters.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.149"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMinimalDaysInFirstWeek">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets what the minimal days required in the first week of the year are;&#xA;     * e.g., if the first week is defined as one that contains the first day&#xA;     * of the first month of a year, this method returns 1. If&#xA;     * the minimal days required must be a full week, this method&#xA;     * returns 7.&#xA;     *&#xA;     * @return the minimal days required in the first week of the year.&#xA;     * @see #setMinimalDaysInFirstWeek(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMinimum">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Returns the minimum value for the given calendar field of this&#xA;     * &lt;code>Calendar&lt;/code> instance. The minimum value is defined as&#xA;     * the smallest value returned by the {@link #get(int) get} method&#xA;     * for any possible time value.  The minimum value depends on&#xA;     * calendar system specific parameters of the instance.&#xA;     *&#xA;     * @param field the calendar field.&#xA;     * @return the minimum value for the given calendar field.&#xA;     * @see #getMaximum(int)&#xA;     * @see #getGreatestMinimum(int)&#xA;     * @see #getLeastMaximum(int)&#xA;     * @see #getActualMinimum(int)&#xA;     * @see #getActualMaximum(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMaximum">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Returns the maximum value for the given calendar field of this&#xA;     * &lt;code>Calendar&lt;/code> instance. The maximum value is defined as&#xA;     * the largest value returned by the {@link #get(int) get} method&#xA;     * for any possible time value. The maximum value depends on&#xA;     * calendar system specific parameters of the instance.&#xA;     *&#xA;     * @param field the calendar field.&#xA;     * @return the maximum value for the given calendar field.&#xA;     * @see #getMinimum(int)&#xA;     * @see #getGreatestMinimum(int)&#xA;     * @see #getLeastMaximum(int)&#xA;     * @see #getActualMinimum(int)&#xA;     * @see #getActualMaximum(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getGreatestMinimum">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Returns the highest minimum value for the given calendar field&#xA;     * of this &lt;code>Calendar&lt;/code> instance. The highest minimum&#xA;     * value is defined as the largest value returned by {@link&#xA;     * #getActualMinimum(int)} for any possible time value. The&#xA;     * greatest minimum value depends on calendar system specific&#xA;     * parameters of the instance.&#xA;     *&#xA;     * @param field the calendar field.&#xA;     * @return the highest minimum value for the given calendar field.&#xA;     * @see #getMinimum(int)&#xA;     * @see #getMaximum(int)&#xA;     * @see #getLeastMaximum(int)&#xA;     * @see #getActualMinimum(int)&#xA;     * @see #getActualMaximum(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLeastMaximum">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Returns the lowest maximum value for the given calendar field&#xA;     * of this &lt;code>Calendar&lt;/code> instance. The lowest maximum&#xA;     * value is defined as the smallest value returned by {@link&#xA;     * #getActualMaximum(int)} for any possible time value. The least&#xA;     * maximum value depends on calendar system specific parameters of&#xA;     * the instance. For example, a &lt;code>Calendar&lt;/code> for the&#xA;     * Gregorian calendar system returns 28 for the&#xA;     * &lt;code>DAY_OF_MONTH&lt;/code> field, because the 28th is the last&#xA;     * day of the shortest month of this calendar, February in a&#xA;     * common year.&#xA;     *&#xA;     * @param field the calendar field.&#xA;     * @return the lowest maximum value for the given calendar field.&#xA;     * @see #getMinimum(int)&#xA;     * @see #getMaximum(int)&#xA;     * @see #getGreatestMinimum(int)&#xA;     * @see #getActualMinimum(int)&#xA;     * @see #getActualMaximum(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getActualMinimum">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the minimum value that the specified calendar field&#xA;     * could have, given the time value of this &lt;code>Calendar&lt;/code>.&#xA;     *&#xA;     * &lt;p>The default implementation of this method uses an iterative&#xA;     * algorithm to determine the actual minimum value for the&#xA;     * calendar field. Subclasses should, if possible, override this&#xA;     * with a more efficient implementation - in many cases, they can&#xA;     * simply return &lt;code>getMinimum()&lt;/code>.&#xA;     *&#xA;     * @param field the calendar field&#xA;     * @return the minimum of the given calendar field for the time&#xA;     * value of this &lt;code>Calendar&lt;/code>&#xA;     * @see #getMinimum(int)&#xA;     * @see #getMaximum(int)&#xA;     * @see #getGreatestMinimum(int)&#xA;     * @see #getLeastMaximum(int)&#xA;     * @see #getActualMaximum(int)&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="fieldValue">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.135">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="endValue">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.133">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// if we know that the minimum value is always the same, just return it</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.0/@variable"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.1/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="work">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>// clone the calendar so we don't mess with the real one, and set it to</comments>
              <comments>// accept anything for the field values</comments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.139"/>
              <self xsi:type="literals:This"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.3/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.127">
            <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Int">
            <comments>// now try each value from getLeastMaximum() to getMaximum() one by one until</comments>
            <comments>// we get a value that normalizes to another value.  The last value that</comments>
            <comments>// normalizes to itself is the actual minimum for the current date</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.0/@variable"/>
        </variable>
      </statements>
      <statements xsi:type="statements:DoWhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.3/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.0/@variable"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Break"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.3/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.94">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@parameters.0"/>
                </next>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.0/@variable"/>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.5/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.0/@variable"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.0/@variable"/>
                  <operator xsi:type="operators:MinusMinus"/>
                </expression>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.137/@statements.5/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getActualMaximum">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the maximum value that the specified calendar field&#xA;     * could have, given the time value of this&#xA;     * &lt;code>Calendar&lt;/code>. For example, the actual maximum value of&#xA;     * the &lt;code>MONTH&lt;/code> field is 12 in some years, and 13 in&#xA;     * other years in the Hebrew calendar system.&#xA;     *&#xA;     * &lt;p>The default implementation of this method uses an iterative&#xA;     * algorithm to determine the actual maximum value for the&#xA;     * calendar field. Subclasses should, if possible, override this&#xA;     * with a more efficient implementation.&#xA;     *&#xA;     * @param field the calendar field&#xA;     * @return the maximum of the given calendar field for the time&#xA;     * value of this &lt;code>Calendar&lt;/code>&#xA;     * @see #getMinimum(int)&#xA;     * @see #getMaximum(int)&#xA;     * @see #getGreatestMinimum(int)&#xA;     * @see #getLeastMaximum(int)&#xA;     * @see #getActualMinimum(int)&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="fieldValue">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="endValue">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.134">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// if we know that the maximum value is always the same, just return it.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.1/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="work">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>// clone the calendar so we don't mess with the real one, and set it to</comments>
              <comments>// accept anything for the field values.</comments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.139"/>
              <self xsi:type="literals:This"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.3/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.127">
            <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// if we're counting weeks, set the day of the week to Sunday.  We know the</comments>
        <comments>// last week of a month or year will contain the first day of the week.</comments>
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.3/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
            </next>
          </expression>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Int">
            <comments>// now try each value from getLeastMaximum() to getMaximum() one by one until</comments>
            <comments>// we get a value that normalizes to another value.  The last value that</comments>
            <comments>// normalizes to itself is the actual maximum for the current date</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
        </variable>
      </statements>
      <statements xsi:type="statements:DoWhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.3/@variable">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.97">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Break"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.3/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.94">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@parameters.0"/>
                </next>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.6/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </expression>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.138/@statements.6/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates and returns a copy of this object.&#xA;     *&#xA;     * @return a copy of this object.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="other">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <initialValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.5"/>
                </next>
                <self xsi:type="literals:Super"/>
              </child>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="arrays:ArrayInstantiationBySize">
              <typeReference xsi:type="types:Int"/>
              <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="arrays:ArrayInstantiationBySize">
              <typeReference xsi:type="types:Boolean"/>
              <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="arrays:ArrayInstantiationBySize">
              <typeReference xsi:type="types:Int"/>
              <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.0/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.4/@init"/>
                    </arraySelectors>
                  </next>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.4/@init"/>
                  </arraySelectors>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.0/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.4/@init"/>
                    </arraySelectors>
                  </next>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.4/@init"/>
                  </arraySelectors>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.0/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.4/@init"/>
                    </arraySelectors>
                  </next>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.4/@init"/>
                  </arraySelectors>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.4/@init"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
          <init xsi:type="variables:LocalVariable" name="i">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </init>
          <updates xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.4/@init"/>
            <operator xsi:type="operators:PlusPlus"/>
          </updates>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="TimeZone.class.xmi#//@classifiers.0/@members.43"/>
                </next>
              </child>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.139/@statements.0/@statements.0/@variable"/>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <comments>// this shouldn't happen, since we are Cloneable</comments>
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/InternalError.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/CloneNotSupportedException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:Field" name="FIELD_NAME">
      <initialValue xsi:type="arrays:ArrayInstantiationByValues">
        <arrayInitializer>
          <initialValues xsi:type="references:StringReference" value="ERA"/>
          <initialValues xsi:type="references:StringReference" value="YEAR"/>
          <initialValues xsi:type="references:StringReference" value="MONTH"/>
          <initialValues xsi:type="references:StringReference" value="WEEK_OF_YEAR"/>
          <initialValues xsi:type="references:StringReference" value="WEEK_OF_MONTH"/>
          <initialValues xsi:type="references:StringReference" value="DAY_OF_MONTH"/>
          <initialValues xsi:type="references:StringReference" value="DAY_OF_YEAR"/>
          <initialValues xsi:type="references:StringReference" value="DAY_OF_WEEK"/>
          <initialValues xsi:type="references:StringReference" value="DAY_OF_WEEK_IN_MONTH"/>
          <initialValues xsi:type="references:StringReference" value="AM_PM"/>
          <initialValues xsi:type="references:StringReference" value="HOUR"/>
          <initialValues xsi:type="references:StringReference" value="HOUR_OF_DAY"/>
          <initialValues xsi:type="references:StringReference" value="MINUTE"/>
          <initialValues xsi:type="references:StringReference" value="SECOND"/>
          <initialValues xsi:type="references:StringReference" value="MILLISECOND"/>
          <initialValues xsi:type="references:StringReference" value="ZONE_OFFSET"/>
          <initialValues xsi:type="references:StringReference" value="DST_OFFSET"/>
        </arrayInitializer>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getFieldName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="field">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Returns the name of the specified calendar field.&#xA;     *&#xA;     * @param field the calendar field&#xA;     * @return the calendar field name&#xA;     * @exception IndexOutOfBoundsException if &lt;code>field&lt;/code> is negative,&#xA;     * equal to or greater then &lt;code>FIELD_COUNT&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.140">
          <arraySelectors>
            <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.141/@parameters.0"/>
          </arraySelectors>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Return a string representation of this calendar. This method &#xA;     * is intended to be used only for debugging purposes, and the &#xA;     * format of the returned string may vary between implementations. &#xA;     * The returned string may be empty but may not be &lt;code>null&lt;/code>.&#xA;     * &#xA;     * @return  a string representation of this calendar.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="buffer">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// NOTE: BuddhistCalendar.toString() interprets the string</comments>
              <comments>// produced by this method so that the Gregorian year number</comments>
              <comments>// is substituted by its B.E. year value. It relies on</comments>
              <comments>// &quot;...,YEAR=&lt;year>,...&quot; or &quot;...,YEAR=?,...&quot;.</comments>
              <target xsi:type="classifiers:Class" href="../lang/StringBuilder.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuilder.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="800"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
              <arguments xsi:type="literals:CharacterLiteral" value="91"/>
            </next>
            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Class.class.xmi#//@classifiers.0/@members.44"/>
              </next>
              <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.143">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.0/@variable"/>
          <arguments xsi:type="references:StringReference" value="time"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.13"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46"/>
            </next>
            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:StringReference" value=",areFieldsSet="/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.13"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47"/>
            </next>
            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:StringReference" value=",areAllFieldsSet="/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.13"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48"/>
            </next>
            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:StringReference" value=",lenient="/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.5"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
            </next>
            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:StringReference" value=",zone="/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.143">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.0/@variable"/>
          <arguments xsi:type="references:StringReference" value=",firstDayOfWeek"/>
          <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Long"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.143">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.0/@variable"/>
          <arguments xsi:type="references:StringReference" value=",minimalDaysInFirstWeek"/>
          <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Long"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                <arguments xsi:type="literals:CharacterLiteral" value="44"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.143">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.140">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.9/@init"/>
                </arraySelectors>
              </arguments>
              <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.103">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.9/@init"/>
              </arguments>
              <arguments xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Long"/>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.9/@init"/>
                  </arraySelectors>
                </child>
              </arguments>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.9/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:PrefixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.9/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="literals:CharacterLiteral" value="93"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.142/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.40"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendValue">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sb">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/StringBuilder.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="item">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="valid">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// =======================privates===============================</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.0">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
              <arguments xsi:type="literals:CharacterLiteral" value="61"/>
            </next>
            <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.1"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.16"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.3"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.2"/>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.143/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuilder.class.xmi#//@classifiers.0/@members.14"/>
                <arguments xsi:type="literals:CharacterLiteral" value="63"/>
              </next>
            </expression>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setWeekCountData">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="desiredLocale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Both firstDayOfWeek and minimalDaysInFirstWeek are locale-dependent.&#xA;     * They are used to figure out the week count for a specific date for&#xA;     * a given locale. These must be set when a Calendar is constructed.&#xA;     * @param desiredLocale the given locale.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="data">
          <typeReference xsi:type="types:Int">
            <comments>/* try to get the Locale data from the cache */</comments>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Hashtable.class.xmi#//@classifiers.0/@members.25"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@parameters.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="resource">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <comments>/* cache miss */</comments>
                  <target xsi:type="classifiers:Class" href="ResourceBundle.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0/@members.8"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../sun/text/resources/LocaleData.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="dateTimePatterns">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arrayDimensionsBefore/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@statements.1/@statement/@statements.0/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="ResourceBundle.class.xmi#//@classifiers.0/@members.12"/>
                  <arguments xsi:type="references:StringReference" value="DateTimeElements"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="arrays:ArrayInstantiationBySize">
                <typeReference xsi:type="types:Int"/>
                <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@statements.0/@variable">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Integer.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@statements.1/@statement/@statements.1/@variable">
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    </arraySelectors>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@statements.0/@variable">
                <arraySelectors>
                  <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Integer.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@statements.1/@statement/@statements.1/@variable">
                    <arraySelectors>
                      <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    </arraySelectors>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Hashtable.class.xmi#//@classifiers.0/@members.27"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@statements.0/@variable"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@statements.0/@variable">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.144/@statements.0/@variable">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arraySelectors>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="updateTime">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Recomputes the time and updates the status fields isTimeSet&#xA;     * and areFieldsSet.  Callers should check isTimeSet and only&#xA;     * call this method if isTimeSet is false.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.88"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45">
            <comments>// The areFieldsSet and areAllFieldsSet values are no longer</comments>
            <comments>// controlled here (as of 1.5).</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="t">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="thisTime">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.147">
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.146/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.146/@parameters.0"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </child>
          <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <expressionElse xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.146/@statements.0/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.146/@parameters.0"/>
              </expression>
            </child>
            <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <expressionElse xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </expressionElse>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMillisOf">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="calendar">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@parameters.0">
          <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cal">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.139"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@statements.1/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.127">
            <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.147/@statements.1/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.92"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="adjustStamp">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Adjusts the stamp[] values before nextStamp overflow. nextStamp&#xA;     * is set to the next stamp value upon the return.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="max">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newStamp">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="min">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="v">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.1/@init"/>
                    </arraySelectors>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.0/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.1/@variable"/>
                    <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                  </children>
                  <children xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.0/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable"/>
                    <relationOperators xsi:type="operators:GreaterThan"/>
                  </children>
                </condition>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.0/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.0/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.1/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.1/@init"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Break"/>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.0/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.0/@variable"/>
              </children>
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.0/@variable"/>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                </children>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.3/@init"/>
                        </arraySelectors>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.1/@variable"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.3/@init"/>
                    </arraySelectors>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.0/@variable"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.3/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.3/@init"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.1/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Break"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.2/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.0/@variable"/>
            </condition>
          </statements>
        </statement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.148/@statements.1/@variable"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="invalidateWeekFields">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Sets the WEEK_OF_MONTH and WEEK_OF_YEAR fields to new values with the&#xA;     * new parameter value if they have been calculated internally.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </arraySelectors>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </arraySelectors>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cal">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0">
              <comments>// We have to check the new values of these fields after changing</comments>
              <comments>// firstDayOfWeek and/or minimalDaysInFirstWeek. If the field values</comments>
              <comments>// have been changed, then set the new values. (4822110)</comments>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.139"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.149/@statements.1/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.127">
            <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.149/@statements.1/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.102">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.149/@statements.1/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.102">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="weekOfMonth">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.149/@statements.1/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.94">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.149/@statements.5/@statement/@statements.0/@variable"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.149/@statements.5/@statement/@statements.0/@variable"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            </arraySelectors>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="weekOfYear">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.149/@statements.1/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.94">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.149/@statements.6/@statement/@statements.0/@variable"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.149/@statements.6/@statement/@statements.0/@variable"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            </arraySelectors>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="stream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Save the state of this object to a stream (i.e., serialize it).&#xA;     *&#xA;     * Ideally, &lt;code>Calendar&lt;/code> would only write out its state data and&#xA;     * the current time, and not write any field data out, such as&#xA;     * &lt;code>fields[]&lt;/code>, &lt;code>isTimeSet&lt;/code>, &lt;code>areFieldsSet&lt;/code>,&#xA;     * and &lt;code>isSet[]&lt;/code>.  &lt;code>nextStamp&lt;/code> also should not be part&#xA;     * of the persistent state. Unfortunately, this didn't happen before JDK 1.1&#xA;     * shipped. To be compatible with JDK 1.1, we will always have to write out&#xA;     * the field values and state flags.  However, &lt;code>nextStamp&lt;/code> can be&#xA;     * removed from the serialization stream; this will probably happen in the&#xA;     * near future.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// Try to compute the time correctly, for the future (stream</comments>
        <comments>// version 2) in which we don't write out fields[] or isSet[].</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:TryBlock">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.145"/>
            </statements>
            <catcheBlocks>
              <parameter name="e">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </parameter>
            </catcheBlocks>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="savedZone">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// If this Calendar has a ZoneInfo, save it and set a</comments>
              <comments>// SimpleTimeZone equivalent (as a single DST schedule) for</comments>
              <comments>// backward compatibility.</comments>
              <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="stz">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="SimpleTimeZone.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:NestedExpression">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../sun/util/calendar/ZoneInfo.class.xmi#//@classifiers.0/@members.43"/>
                </next>
                <expression xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../sun/util/calendar/ZoneInfo.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
                </expression>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.2/@statement/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="SimpleTimeZone.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="TimeZone.class.xmi#//@classifiers.0/@members.19"/>
                      </next>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="TimeZone.class.xmi#//@classifiers.0/@members.20"/>
                      </next>
                    </arguments>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.2/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.2/@statement/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../sun/util/calendar/ZoneInfo.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@parameters.0">
          <comments>// Write out the 1.1 FCS object.</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.17"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@parameters.0">
          <comments>// Write out the ZoneInfo object</comments>
          <comments>// 4802409: we write out even if it is null, a temporary workaround</comments>
          <comments>// the real fix for bug 4844924 in corba-iiop</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.1/@variable"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.1/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.150/@statements.1/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="stream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/ObjectInputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/ClassNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Reconstitutes this object from a stream (i.e., deserialize it).&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="input">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../io/ObjectInputStream.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@parameters.0"/>
          <annotationsAndModifiers xsi:type="modifiers:Final"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectInputStream.class.xmi#//@classifiers.0/@members.19"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Int"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Starting with version 2 (not implemented yet), we expect that</comments>
        <comments>// fields[], isSet[], isTimeSet, and areFieldsSet may not be</comments>
        <comments>// streamed out anymore.  We expect 'time' to be correct.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="arrays:ArrayInstantiationBySize">
                  <typeReference xsi:type="types:Int"/>
                  <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
                </value>
              </expression>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="arrays:ArrayInstantiationBySize">
                  <typeReference xsi:type="types:Boolean"/>
                  <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
                </value>
              </expression>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ForLoop">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.3/@elseStatement/@statement/@statements.0/@init"/>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:ConditionalExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.3/@elseStatement/@statement/@statements.0/@init"/>
                      </arraySelectors>
                    </child>
                    <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55"/>
                    <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54"/>
                  </value>
                </expression>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.3/@elseStatement/@statement/@statements.0/@init"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </condition>
              <init xsi:type="variables:LocalVariable" name="i">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </init>
              <updates xsi:type="expressions:PrefixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.3/@elseStatement/@statement/@statements.0/@init"/>
                <operator xsi:type="operators:PlusPlus"/>
              </updates>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59"/>
        </expression>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <comments>// If there's a ZoneInfo object, use it for zone.</comments>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="zi">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../sun/util/calendar/ZoneInfo.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../sun/util/calendar/ZoneInfo.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../security/AccessController.class.xmi#//@classifiers.0/@members.3"/>
                  <arguments xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Interface" href="../security/PrivilegedExceptionAction.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <anonymousClass>
                      <members xsi:type="members:ClassMethod" name="run">
                        <typeReference xsi:type="types:NamespaceClassifierReference">
                          <classifierReferences>
                            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                          </classifierReferences>
                        </typeReference>
                        <exceptions>
                          <classifierReferences>
                            <target xsi:type="classifiers:Class" href="../lang/Exception.class.xmi#//@classifiers.0"/>
                          </classifierReferences>
                        </exceptions>
                        <annotationsAndModifiers xsi:type="modifiers:Public"/>
                        <statements xsi:type="statements:Return">
                          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.0/@variable">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../io/ObjectInputStream.class.xmi#//@classifiers.0/@members.16"/>
                            </next>
                          </returnValue>
                        </statements>
                      </members>
                    </anonymousClass>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../security/AccessController.class.xmi#//@classifiers.0"/>
              </child>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.5/@statements.0/@variable"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.5/@statements.0/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <catcheBlocks>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Exception.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// If the deserialized object has a SimpleTimeZone, try to</comments>
        <comments>// replace it with a ZoneInfo equivalent (as of 1.4) in order</comments>
        <comments>// to be compatible with the SimpleTimeZone-based</comments>
        <comments>// implementation as much as possible.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="id">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="TimeZone.class.xmi#//@classifiers.0/@members.20"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="zi">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="TimeZone.class.xmi#//@classifiers.0/@members.31"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.6/@statement/@statements.0/@variable"/>
                </next>
                <target xsi:type="classifiers:Class" href="TimeZone.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.6/@statement/@statements.1/@variable"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.6/@statement/@statements.1/@variable"/>
                <children xsi:type="literals:NullLiteral"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.6/@statement/@statements.1/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="TimeZone.class.xmi#//@classifiers.0/@members.42"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
                </next>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.6/@statement/@statements.1/@variable">
                <next xsi:type="references:MethodCall">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.151/@statements.6/@statement/@statements.0/@variable"/>
                  </next>
                  <target xsi:type="members:ClassMethod" href="TimeZone.class.xmi#//@classifiers.0/@members.20"/>
                </next>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="SimpleTimeZone.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
        </condition>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>Calendar&lt;/code> class is an abstract class that provides methods&#xA; * for converting between a specific instant in time and a set of {@link&#xA; * #fields calendar fields} such as &lt;code>YEAR&lt;/code>, &lt;code>MONTH&lt;/code>,&#xA; * &lt;code>DAY_OF_MONTH&lt;/code>, &lt;code>HOUR&lt;/code>, and so on, and for&#xA; * manipulating the calendar fields, such as getting the date of the next&#xA; * week. An instant in time can be represented by a millisecond value that is&#xA; * an offset from the &lt;a name=&quot;Epoch&quot;>&lt;em>Epoch&lt;/em>&lt;/a>, January 1, 1970&#xA; * 00:00:00.000 GMT (Gregorian).&#xA; *&#xA; * &lt;p>The class also provides additional fields and methods for&#xA; * implementing a concrete calendar system outside the package. Those&#xA; * fields and methods are defined as &lt;code>protected&lt;/code>.&#xA; *&#xA; * &lt;p>&#xA; * Like other locale-sensitive classes, &lt;code>Calendar&lt;/code> provides a&#xA; * class method, &lt;code>getInstance&lt;/code>, for getting a generally useful&#xA; * object of this type. &lt;code>Calendar&lt;/code>'s &lt;code>getInstance&lt;/code> method&#xA; * returns a &lt;code>Calendar&lt;/code> object whose&#xA; * calendar fields have been initialized with the current date and time:&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; *     Calendar rightNow = Calendar.getInstance();&#xA; * &lt;/pre>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p>A &lt;code>Calendar&lt;/code> object can produce all the calendar field values&#xA; * needed to implement the date-time formatting for a particular language and&#xA; * calendar style (for example, Japanese-Gregorian, Japanese-Traditional).&#xA; * &lt;code>Calendar&lt;/code> defines the range of values returned by&#xA; * certain calendar fields, as well as their meaning.  For example,&#xA; * the first month of the calendar system has value &lt;code>MONTH ==&#xA; * JANUARY&lt;/code> for all calendars.  Other values are defined by the&#xA; * concrete subclass, such as &lt;code>ERA&lt;/code>.  See individual field&#xA; * documentation and subclass documentation for details.&#xA; *&#xA; * &lt;h4>Getting and Setting Calendar Field Values&lt;/h4>&#xA; *&#xA; * &lt;p>The calendar field values can be set by calling the &lt;code>set&lt;/code>&#xA; * methods. Any field values set in a &lt;code>Calendar&lt;/code> will not be&#xA; * interpreted until it needs to calculate its time value (milliseconds from&#xA; * the Epoch) or values of the calendar fields. Calling the&#xA; * &lt;code>get&lt;/code>, &lt;code>getTimeInMillis&lt;/code>, &lt;code>getTime&lt;/code>,&#xA; * &lt;code>add&lt;/code> and &lt;code>roll&lt;/code> involves such calculation.&#xA; *&#xA; * &lt;h4>Leniency&lt;/h4>&#xA; *&#xA; * &lt;p>&lt;code>Calendar&lt;/code> has two modes for interpreting the calendar&#xA; * fields, &lt;em>lenient&lt;/em> and &lt;em>non-lenient&lt;/em>.  When a&#xA; * &lt;code>Calendar&lt;/code> is in lenient mode, it accepts a wider range of&#xA; * calendar field values than it produces.  When a &lt;code>Calendar&lt;/code>&#xA; * recomputes calendar field values for return by &lt;code>get()&lt;/code>, all of&#xA; * the calendar fields are normalized. For example, a lenient&#xA; * &lt;code>GregorianCalendar&lt;/code> interprets &lt;code>MONTH == JANUARY&lt;/code>,&#xA; * &lt;code>DAY_OF_MONTH == 32&lt;/code> as February 1.&#xA;&#xA; * &lt;p>When a &lt;code>Calendar&lt;/code> is in non-lenient mode, it throws an&#xA; * exception if there is any inconsistency in its calendar fields. For&#xA; * example, a &lt;code>GregorianCalendar&lt;/code> always produces&#xA; * &lt;code>DAY_OF_MONTH&lt;/code> values between 1 and the length of the month. A&#xA; * non-lenient &lt;code>GregorianCalendar&lt;/code> throws an exception upon&#xA; * calculating its time or calendar field values if any out-of-range field&#xA; * value has been set.&#xA; *&#xA; * &lt;h4>First Week&lt;/h4>&#xA; *&#xA; * &lt;code>Calendar&lt;/code> defines a locale-specific seven day week using two&#xA; * parameters: the first day of the week and the minimal days in first week&#xA; * (from 1 to 7).  These numbers are taken from the locale resource data when a&#xA; * &lt;code>Calendar&lt;/code> is constructed.  They may also be specified explicitly&#xA; * through the methods for setting their values.&#xA; *&#xA; * &lt;p>When setting or getting the &lt;code>WEEK_OF_MONTH&lt;/code> or&#xA; * &lt;code>WEEK_OF_YEAR&lt;/code> fields, &lt;code>Calendar&lt;/code> must determine the&#xA; * first week of the month or year as a reference point.  The first week of a&#xA; * month or year is defined as the earliest seven day period beginning on&#xA; * &lt;code>getFirstDayOfWeek()&lt;/code> and containing at least&#xA; * &lt;code>getMinimalDaysInFirstWeek()&lt;/code> days of that month or year.  Weeks&#xA; * numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow&#xA; * it.  Note that the normalized numbering returned by &lt;code>get()&lt;/code> may be&#xA; * different.  For example, a specific &lt;code>Calendar&lt;/code> subclass may&#xA; * designate the week before week 1 of a year as week &lt;code>&lt;i>n&lt;/i>&lt;/code> of&#xA; * the previous year.&#xA; *&#xA; * &lt;h4>Calendar Fields Resolution&lt;/h4>&#xA; *&#xA; * When computing a date and time from the calendar fields, there&#xA; * may be insufficient information for the computation (such as only&#xA; * year and month with no day of month), or there may be inconsistent&#xA; * information (such as Tuesday, July 15, 1996 (Gregorian) -- July 15,&#xA; * 1996 is actually a Monday). &lt;code>Calendar&lt;/code> will resolve&#xA; * calendar field values to determine the date and time in the&#xA; * following way.&#xA; *&#xA; * &lt;p>If there is any conflict in calendar field values,&#xA; * &lt;code>Calendar&lt;/code> gives priorities to calendar fields that have been set&#xA; * more recently. The following are the default combinations of the&#xA; * calendar fields. The most recent combination, as determined by the&#xA; * most recently set single field, will be used.&#xA; *&#xA; * &lt;p>&lt;a name=&quot;date_resolution&quot;>For the date fields&lt;/a>:&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * YEAR + MONTH + DAY_OF_MONTH&#xA; * YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK&#xA; * YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK&#xA; * YEAR + DAY_OF_YEAR&#xA; * YEAR + DAY_OF_WEEK + WEEK_OF_YEAR&#xA; * &lt;/pre>&lt;/blockquote>&#xA; *&#xA; * &lt;a name=&quot;time_resolution&quot;>For the time of day fields&lt;/a>:&#xA; * &lt;blockquote>&#xA; * &lt;pre>&#xA; * HOUR_OF_DAY&#xA; * AM_PM + HOUR&#xA; * &lt;/pre>&lt;/blockquote>&#xA; *&#xA; * &lt;p>If there are any calendar fields whose values haven't been set in the selected&#xA; * field combination, &lt;code>Calendar&lt;/code> uses their default values. The default&#xA; * value of each field may vary by concrete calendar systems. For example, in&#xA; * &lt;code>GregorianCalendar&lt;/code>, the default of a field is the same as that&#xA; * of the start of the Epoch: i.e., &lt;code>YEAR = 1970&lt;/code>, &lt;code>MONTH =&#xA; * JANUARY&lt;/code>, &lt;code>DAY_OF_MONTH = 1&lt;/code>, etc.&#xA; *&#xA; * &lt;p>&#xA; * &lt;strong>Note:&lt;/strong> There are certain possible ambiguities in&#xA; * interpretation of certain singular times, which are resolved in the&#xA; * following ways:&#xA; * &lt;ol>&#xA; *     &lt;li> 23:59 is the last minute of the day and 00:00 is the first&#xA; *          minute of the next day. Thus, 23:59 on Dec 31, 1999 &amp;lt; 00:00 on&#xA; *          Jan 1, 2000 &amp;lt; 00:01 on Jan 1, 2000.&#xA; *&#xA; *     &lt;li> Although historically not precise, midnight also belongs to &quot;am&quot;,&#xA; *          and noon belongs to &quot;pm&quot;, so on the same day,&#xA; *          12:00 am (midnight) &amp;lt; 12:01 am, and 12:00 pm (noon) &amp;lt; 12:01 pm&#xA; * &lt;/ol>&#xA; *&#xA; * &lt;p>&#xA; * The date or time format strings are not part of the definition of a&#xA; * calendar, as those must be modifiable or overridable by the user at&#xA; * runtime. Use {@link DateFormat}&#xA; * to format dates.&#xA; *&#xA; * &lt;h4>Field Manipulation&lt;/h4>&#xA; * &#xA; * The calendar fields can be changed using three methods:&#xA; * &lt;code>set()&lt;/code>, &lt;code>add()&lt;/code>, and &lt;code>roll()&lt;/code>.&lt;/p>&#xA; * &#xA; * &lt;p>&lt;strong>&lt;code>set(f, value)&lt;/code>&lt;/strong> changes calendar field&#xA; * &lt;code>f&lt;/code> to &lt;code>value&lt;/code>.  In addition, it sets an&#xA; * internal member variable to indicate that calendar field &lt;code>f&lt;/code> has&#xA; * been changed. Although calendar field &lt;code>f&lt;/code> is changed immediately,&#xA; * the calendar's time value in milliseconds is not recomputed until the next call to&#xA; * &lt;code>get()&lt;/code>, &lt;code>getTime()&lt;/code>, &lt;code>getTimeInMillis()&lt;/code>,&#xA; * &lt;code>add()&lt;/code>, or &lt;code>roll()&lt;/code> is made. Thus, multiple calls to&#xA; * &lt;code>set()&lt;/code> do not trigger multiple, unnecessary&#xA; * computations. As a result of changing a calendar field using&#xA; * &lt;code>set()&lt;/code>, other calendar fields may also change, depending on the&#xA; * calendar field, the calendar field value, and the calendar system. In addition,&#xA; * &lt;code>get(f)&lt;/code> will not necessarily return &lt;code>value&lt;/code> set by&#xA; * the call to the &lt;code>set&lt;/code> method&#xA; * after the calendar fields have been recomputed. The specifics are determined by&#xA; * the concrete calendar class.&lt;/p>&#xA; * &#xA; * &lt;p>&lt;em>Example&lt;/em>: Consider a &lt;code>GregorianCalendar&lt;/code>&#xA; * originally set to August 31, 1999. Calling &lt;code>set(Calendar.MONTH,&#xA; * Calendar.SEPTEMBER)&lt;/code> sets the date to September 31,&#xA; * 1999. This is a temporary internal representation that resolves to&#xA; * October 1, 1999 if &lt;code>getTime()&lt;/code>is then called. However, a&#xA; * call to &lt;code>set(Calendar.DAY_OF_MONTH, 30)&lt;/code> before the call to&#xA; * &lt;code>getTime()&lt;/code> sets the date to September 30, 1999, since&#xA; * no recomputation occurs after &lt;code>set()&lt;/code> itself.&lt;/p>&#xA; * &#xA; * &lt;p>&lt;strong>&lt;code>add(f, delta)&lt;/code>&lt;/strong> adds &lt;code>delta&lt;/code>&#xA; * to field &lt;code>f&lt;/code>.  This is equivalent to calling &lt;code>set(f,&#xA; * get(f) + delta)&lt;/code> with two adjustments:&lt;/p>&#xA; * &#xA; * &lt;blockquote>&#xA; *   &lt;p>&lt;strong>Add rule 1&lt;/strong>. The value of field &lt;code>f&lt;/code>&#xA; *   after the call minus the value of field &lt;code>f&lt;/code> before the&#xA; *   call is &lt;code>delta&lt;/code>, modulo any overflow that has occurred in&#xA; *   field &lt;code>f&lt;/code>. Overflow occurs when a field value exceeds its&#xA; *   range and, as a result, the next larger field is incremented or&#xA; *   decremented and the field value is adjusted back into its range.&lt;/p>&#xA; * &#xA; *   &lt;p>&lt;strong>Add rule 2&lt;/strong>. If a smaller field is expected to be&#xA; *   invariant, but it is impossible for it to be equal to its&#xA; *   prior value because of changes in its minimum or maximum after field&#xA; *   &lt;code>f&lt;/code> is changed or other constraints, such as time zone&#xA; *   offset changes, then its value is adjusted to be as close&#xA; *   as possible to its expected value. A smaller field represents a&#xA; *   smaller unit of time. &lt;code>HOUR&lt;/code> is a smaller field than&#xA; *   &lt;code>DAY_OF_MONTH&lt;/code>. No adjustment is made to smaller fields&#xA; *   that are not expected to be invariant. The calendar system&#xA; *   determines what fields are expected to be invariant.&lt;/p>&#xA; * &lt;/blockquote>&#xA; * &#xA; * &lt;p>In addition, unlike &lt;code>set()&lt;/code>, &lt;code>add()&lt;/code> forces&#xA; * an immediate recomputation of the calendar's milliseconds and all&#xA; * fields.&lt;/p>&#xA; * &#xA; * &lt;p>&lt;em>Example&lt;/em>: Consider a &lt;code>GregorianCalendar&lt;/code>&#xA; * originally set to August 31, 1999. Calling &lt;code>add(Calendar.MONTH,&#xA; * 13)&lt;/code> sets the calendar to September 30, 2000. &lt;strong>Add rule&#xA; * 1&lt;/strong> sets the &lt;code>MONTH&lt;/code> field to September, since&#xA; * adding 13 months to August gives September of the next year. Since&#xA; * &lt;code>DAY_OF_MONTH&lt;/code> cannot be 31 in September in a&#xA; * &lt;code>GregorianCalendar&lt;/code>, &lt;strong>add rule 2&lt;/strong> sets the&#xA; * &lt;code>DAY_OF_MONTH&lt;/code> to 30, the closest possible value. Although&#xA; * it is a smaller field, &lt;code>DAY_OF_WEEK&lt;/code> is not adjusted by&#xA; * rule 2, since it is expected to change when the month changes in a&#xA; * &lt;code>GregorianCalendar&lt;/code>.&lt;/p>&#xA; * &#xA; * &lt;p>&lt;strong>&lt;code>roll(f, delta)&lt;/code>&lt;/strong> adds&#xA; * &lt;code>delta&lt;/code> to field &lt;code>f&lt;/code> without changing larger&#xA; * fields. This is equivalent to calling &lt;code>add(f, delta)&lt;/code> with&#xA; * the following adjustment:&lt;/p>&#xA; * &#xA; * &lt;blockquote>&#xA; *   &lt;p>&lt;strong>Roll rule&lt;/strong>. Larger fields are unchanged after the&#xA; *   call. A larger field represents a larger unit of&#xA; *   time. &lt;code>DAY_OF_MONTH&lt;/code> is a larger field than&#xA; *   &lt;code>HOUR&lt;/code>.&lt;/p>&#xA; * &lt;/blockquote>&#xA; * &#xA; * &lt;p>&lt;em>Example&lt;/em>: See {@link java.util.GregorianCalendar#roll(int, int)}.&#xA; * &#xA; * &lt;p>&lt;strong>Usage model&lt;/strong>. To motivate the behavior of&#xA; * &lt;code>add()&lt;/code> and &lt;code>roll()&lt;/code>, consider a user interface&#xA; * component with increment and decrement buttons for the month, day, and&#xA; * year, and an underlying &lt;code>GregorianCalendar&lt;/code>. If the&#xA; * interface reads January 31, 1999 and the user presses the month&#xA; * increment button, what should it read? If the underlying&#xA; * implementation uses &lt;code>set()&lt;/code>, it might read March 3, 1999. A&#xA; * better result would be February 28, 1999. Furthermore, if the user&#xA; * presses the month increment button again, it should read March 31,&#xA; * 1999, not March 28, 1999. By saving the original date and using either&#xA; * &lt;code>add()&lt;/code> or &lt;code>roll()&lt;/code>, depending on whether larger&#xA; * fields should be affected, the user interface can behave as most users&#xA; * will intuitively expect.&lt;/p>&#xA; *&#xA; * @see          java.lang.System#currentTimeMillis()&#xA; * @see          Date&#xA; * @see          GregorianCalendar&#xA; * @see          TimeZone&#xA; * @see          java.text.DateFormat&#xA; * @version      1.81, 07/26/04&#xA; * @author Mark Davis, David Goldsmith, Chen-Lieh Huang, Alan Liu&#xA; * @since JDK1.1&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../io/Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../lang/Cloneable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="../lang/Comparable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
