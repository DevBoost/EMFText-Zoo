<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="Set.java">
  <comments>/*&#xA; * @(#)Set.java&#x9;1.35 04/02/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Set">
    <typeParameters name="E"/>
    <members xsi:type="members:InterfaceMethod" name="size">
      <typeReference xsi:type="types:Int">
        <comments>// Query Operations</comments>
        <comments>/**&#xA;     * Returns the number of elements in this set (its cardinality).  If this&#xA;     * set contains more than &lt;tt>Integer.MAX_VALUE&lt;/tt> elements, returns&#xA;     * &lt;tt>Integer.MAX_VALUE&lt;/tt>.&#xA;     *&#xA;     * @return the number of elements in this set (its cardinality).&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isEmpty">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this set contains no elements.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if this set contains no elements.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="contains">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this set contains the specified element.  More&#xA;     * formally, returns &lt;tt>true&lt;/tt> if and only if this set contains an&#xA;     * element &lt;code>e&lt;/code> such that &lt;code>(o==null ? e==null :&#xA;     * o.equals(e))&lt;/code>.&#xA;     *&#xA;     * @param o element whose presence in this set is to be tested.&#xA;     * @return &lt;tt>true&lt;/tt> if this set contains the specified element.&#xA;     * @throws ClassCastException if the type of the specified element&#xA;     * &#x9;       is incompatible with this set (optional).&#xA;     * @throws NullPointerException if the specified element is null and this&#xA;     *         set does not support null elements (optional).&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="iterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns an iterator over the elements in this set.  The elements are&#xA;     * returned in no particular order (unless this set is an instance of some&#xA;     * class that provides a guarantee).&#xA;     *&#xA;     * @return an iterator over the elements in this set.&#xA;     */</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toArray">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns an array containing all of the elements in this set.&#xA;     * Obeys the general contract of the &lt;tt>Collection.toArray&lt;/tt> method.&#xA;     *&#xA;     * @return an array containing all of the elements in this set.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toArray">
      <comments>/**&#xA;     * Returns an array containing all of the elements in this set; the &#xA;     * runtime type of the returned array is that of the specified array. &#xA;     * Obeys the general contract of the &#xA;     * &lt;tt>Collection.toArray(Object[])&lt;/tt> method.&#xA;     *&#xA;     * @param a the array into which the elements of this set are to&#xA;     *&#x9;&#x9;be stored, if it is big enough; otherwise, a new array of the&#xA;     * &#x9;&#x9;same runtime type is allocated for this purpose.&#xA;     * @return an array containing the elements of this set.&#xA;     * @throws    ArrayStoreException the runtime type of a is not a supertype&#xA;     *            of the runtime type of every element in this set.&#xA;     * @throws NullPointerException if the specified array is &lt;tt>null&lt;/tt>.&#xA;     */</comments>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.5/@typeParameters.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <typeParameters name="T"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="a">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.5/@typeParameters.0"/>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="add">
      <typeReference xsi:type="types:Boolean">
        <comments>// Modification Operations</comments>
        <comments>/**&#xA;     * Adds the specified element to this set if it is not already present&#xA;     * (optional operation).  More formally, adds the specified element,&#xA;     * &lt;code>o&lt;/code>, to this set if this set contains no element&#xA;     * &lt;code>e&lt;/code> such that &lt;code>(o==null ? e==null :&#xA;     * o.equals(e))&lt;/code>.  If this set already contains the specified&#xA;     * element, the call leaves this set unchanged and returns &lt;tt>false&lt;/tt>.&#xA;     * In combination with the restriction on constructors, this ensures that&#xA;     * sets never contain duplicate elements.&lt;p>&#xA;     *&#xA;     * The stipulation above does not imply that sets must accept all&#xA;     * elements; sets may refuse to add any particular element, including&#xA;     * &lt;tt>null&lt;/tt>, and throwing an exception, as described in the&#xA;     * specification for &lt;tt>Collection.add&lt;/tt>.  Individual set&#xA;     * implementations should clearly document any restrictions on the&#xA;     * elements that they may contain.&#xA;     *&#xA;     * @param o element to be added to this set.&#xA;     * @return &lt;tt>true&lt;/tt> if this set did not already contain the specified&#xA;     *         element.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>add&lt;/tt> method is not&#xA;     * &#x9;       supported by this set.&#xA;     * @throws ClassCastException if the class of the specified element&#xA;     * &#x9;       prevents it from being added to this set.&#xA;     * @throws NullPointerException if the specified element is null and this&#xA;     *         set does not support null elements.&#xA;     * @throws IllegalArgumentException if some aspect of the specified element&#xA;     *         prevents it from being added to this set.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="remove">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Removes the specified element from this set if it is present (optional&#xA;     * operation).  More formally, removes an element &lt;code>e&lt;/code> such that&#xA;     * &lt;code>(o==null ?  e==null : o.equals(e))&lt;/code>, if the set contains&#xA;     * such an element.  Returns &lt;tt>true&lt;/tt> if the set contained the&#xA;     * specified element (or equivalently, if the set changed as a result of&#xA;     * the call).  (The set will not contain the specified element once the&#xA;     * call returns.)&#xA;     *&#xA;     * @param o object to be removed from this set, if present.&#xA;     * @return true if the set contained the specified element.&#xA;     * @throws ClassCastException if the type of the specified element&#xA;     * &#x9;       is incompatible with this set (optional).&#xA;     * @throws NullPointerException if the specified element is null and this&#xA;     *         set does not support null elements (optional).&#xA;     * @throws UnsupportedOperationException if the &lt;tt>remove&lt;/tt> method is&#xA;     *         not supported by this set.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="containsAll">
      <typeReference xsi:type="types:Boolean">
        <comments>// Bulk Operations</comments>
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this set contains all of the elements of the&#xA;     * specified collection.  If the specified collection is also a set, this&#xA;     * method returns &lt;tt>true&lt;/tt> if it is a &lt;i>subset&lt;/i> of this set.&#xA;     *&#xA;     * @param  c collection to be checked for containment in this set.&#xA;     * @return &lt;tt>true&lt;/tt> if this set contains all of the elements of the&#xA;     * &#x9;       specified collection.&#xA;     * @throws ClassCastException if the types of one or more elements&#xA;     *         in the specified collection are incompatible with this&#xA;     *         set (optional).&#xA;     * @throws NullPointerException if the specified collection contains one&#xA;     *         or more null elements and this set does not support null&#xA;     *         elements (optional).&#xA;     * @throws NullPointerException if the specified collection is&#xA;     *         &lt;tt>null&lt;/tt>.&#xA;     * @see    #contains(Object)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addAll">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Adds all of the elements in the specified collection to this set if&#xA;     * they're not already present (optional operation).  If the specified&#xA;     * collection is also a set, the &lt;tt>addAll&lt;/tt> operation effectively&#xA;     * modifies this set so that its value is the &lt;i>union&lt;/i> of the two&#xA;     * sets.  The behavior of this operation is unspecified if the specified&#xA;     * collection is modified while the operation is in progress.&#xA;     *&#xA;     * @param c collection whose elements are to be added to this set.&#xA;     * @return &lt;tt>true&lt;/tt> if this set changed as a result of the call.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>addAll&lt;/tt> method is&#xA;     * &#x9;&#x9;  not supported by this set.&#xA;     * @throws ClassCastException if the class of some element of the&#xA;     * &#x9;&#x9;  specified collection prevents it from being added to this&#xA;     * &#x9;&#x9;  set.&#xA;     * @throws NullPointerException if the specified collection contains one&#xA;     *           or more null elements and this set does not support null&#xA;     *           elements, or if the specified collection is &lt;tt>null&lt;/tt>.&#xA;     * @throws IllegalArgumentException if some aspect of some element of the&#xA;     *&#x9;&#x9;  specified collection prevents it from being added to this&#xA;     *&#x9;&#x9;  set.&#xA;     * @see #add(Object)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="retainAll">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Retains only the elements in this set that are contained in the&#xA;     * specified collection (optional operation).  In other words, removes&#xA;     * from this set all of its elements that are not contained in the&#xA;     * specified collection.  If the specified collection is also a set, this&#xA;     * operation effectively modifies this set so that its value is the&#xA;     * &lt;i>intersection&lt;/i> of the two sets.&#xA;     *&#xA;     * @param c collection that defines which elements this set will retain.&#xA;     * @return &lt;tt>true&lt;/tt> if this collection changed as a result of the&#xA;     *         call.&#xA;     * @throws UnsupportedOperationException if the &lt;tt>retainAll&lt;/tt> method&#xA;     * &#x9;&#x9;  is not supported by this Collection.&#xA;     * @throws ClassCastException if the types of one or more elements in this&#xA;     *            set are incompatible with the specified collection&#xA;     *            (optional).&#xA;     * @throws NullPointerException if this set contains a null element and&#xA;     *            the specified collection does not support null elements&#xA;     *            (optional). &#xA;     * @throws NullPointerException if the specified collection is&#xA;     *           &lt;tt>null&lt;/tt>.&#xA;     * @see #remove(Object)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removeAll">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Removes from this set all of its elements that are contained in the&#xA;     * specified collection (optional operation).  If the specified&#xA;     * collection is also a set, this operation effectively modifies this&#xA;     * set so that its value is the &lt;i>asymmetric set difference&lt;/i> of&#xA;     * the two sets.&#xA;     *&#xA;     * @param  c collection that defines which elements will be removed from&#xA;     *           this set.&#xA;     * @return &lt;tt>true&lt;/tt> if this set changed as a result of the call.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>removeAll&lt;/tt>&#xA;     * &#x9;&#x9;  method is not supported by this Collection.&#xA;     * @throws ClassCastException if the types of one or more elements in this&#xA;     *            set are incompatible with the specified collection&#xA;     *            (optional).&#xA;     * @throws NullPointerException if this set contains a null element and&#xA;     *            the specified collection does not support null elements&#xA;     *            (optional). &#xA;     * @throws NullPointerException if the specified collection is&#xA;     *           &lt;tt>null&lt;/tt>.&#xA;     * @see    #remove(Object)&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="clear">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Removes all of the elements from this set (optional operation).&#xA;     * This set will be empty after this call returns (unless it throws an&#xA;     * exception).&#xA;     *&#xA;     * @throws UnsupportedOperationException if the &lt;tt>clear&lt;/tt> method&#xA;     * &#x9;&#x9;  is not supported by this set.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="equals">
      <typeReference xsi:type="types:Boolean">
        <comments>// Comparison and hashing</comments>
        <comments>/**&#xA;     * Compares the specified object with this set for equality.  Returns&#xA;     * &lt;tt>true&lt;/tt> if the specified object is also a set, the two sets&#xA;     * have the same size, and every member of the specified set is&#xA;     * contained in this set (or equivalently, every member of this set is&#xA;     * contained in the specified set).  This definition ensures that the&#xA;     * equals method works properly across different implementations of the&#xA;     * set interface.&#xA;     *&#xA;     * @param o Object to be compared for equality with this set.&#xA;     * @return &lt;tt>true&lt;/tt> if the specified Object is equal to this set.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="hashCode">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * &#xA;     * Returns the hash code value for this set.  The hash code of a set is&#xA;     * defined to be the sum of the hash codes of the elements in the set,&#xA;     * where the hashcode of a &lt;tt>null&lt;/tt> element is defined to be zero.&#xA;     * This ensures that &lt;code>s1.equals(s2)&lt;/code> implies that&#xA;     * &lt;code>s1.hashCode()==s2.hashCode()&lt;/code> for any two sets&#xA;     * &lt;code>s1&lt;/code> and &lt;code>s2&lt;/code>, as required by the general&#xA;     * contract of the &lt;tt>Object.hashCode&lt;/tt> method.&#xA;     *&#xA;     * @return the hash code value for this set.&#xA;     * @see Object#hashCode()&#xA;     * @see Object#equals(Object)&#xA;     * @see Set#equals(Object)&#xA;     */</comments>
      </typeReference>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A collection that contains no duplicate elements.  More formally, sets&#xA; * contain no pair of elements &lt;code>e1&lt;/code> and &lt;code>e2&lt;/code> such that&#xA; * &lt;code>e1.equals(e2)&lt;/code>, and at most one null element.  As implied by&#xA; * its name, this interface models the mathematical &lt;i>set&lt;/i> abstraction.&lt;p>&#xA; *&#xA; * The &lt;tt>Set&lt;/tt> interface places additional stipulations, beyond those&#xA; * inherited from the &lt;tt>Collection&lt;/tt> interface, on the contracts of all&#xA; * constructors and on the contracts of the &lt;tt>add&lt;/tt>, &lt;tt>equals&lt;/tt> and&#xA; * &lt;tt>hashCode&lt;/tt> methods.  Declarations for other inherited methods are&#xA; * also included here for convenience.  (The specifications accompanying these&#xA; * declarations have been tailored to the &lt;tt>Set&lt;/tt> interface, but they do&#xA; * not contain any additional stipulations.)&lt;p>&#xA; *&#xA; * The additional stipulation on constructors is, not surprisingly,&#xA; * that all constructors must create a set that contains no duplicate elements&#xA; * (as defined above).&lt;p>&#xA; *&#xA; * Note: Great care must be exercised if mutable objects are used as set&#xA; * elements.  The behavior of a set is not specified if the value of an object&#xA; * is changed in a manner that affects equals comparisons while the object is&#xA; * an element in the set.  A special case of this prohibition is that it is&#xA; * not permissible for a set to contain itself as an element.&#xA; *&#xA; * &lt;p>Some set implementations have restrictions on the elements that&#xA; * they may contain.  For example, some implementations prohibit null elements,&#xA; * and some have restrictions on the types of their elements.  Attempting to&#xA; * add an ineligible element throws an unchecked exception, typically&#xA; * &lt;tt>NullPointerException&lt;/tt> or &lt;tt>ClassCastException&lt;/tt>.  Attempting&#xA; * to query the presence of an ineligible element may throw an exception,&#xA; * or it may simply return false; some implementations will exhibit the former&#xA; * behavior and some will exhibit the latter.  More generally, attempting an&#xA; * operation on an ineligible element whose completion would not result in&#xA; * the insertion of an ineligible element into the set may throw an&#xA; * exception or it may succeed, at the option of the implementation.&#xA; * Such exceptions are marked as &quot;optional&quot; in the specification for this&#xA; * interface. &#xA; *&#xA; * &lt;p>This interface is a member of the &#xA; * &lt;a href=&quot;{@docRoot}/../guide/collections/index.html&quot;>&#xA; * Java Collections Framework&lt;/a>.&#xA; *&#xA; * @author  Josh Bloch&#xA; * @author  Neal Gafter&#xA; * @version 1.35, 02/19/04&#xA; * @see Collection&#xA; * @see List&#xA; * @see SortedSet&#xA; * @see HashSet&#xA; * @see TreeSet&#xA; * @see AbstractSet&#xA; * @see Collections#singleton(java.lang.Object)&#xA; * @see Collections#EMPTY_SET&#xA; * @since 1.2&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
