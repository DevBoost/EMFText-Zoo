<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="AbstractList.java">
  <comments>/*&#xA; * @(#)AbstractList.java&#x9;1.46 04/02/10&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <classifiers xsi:type="classifiers:Class" name="AbstractList">
    <typeParameters name="E"/>
    <members xsi:type="members:Constructor" name="AbstractList">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Sole constructor.  (For invocation by subclass constructors, typically&#xA;     * implicit.)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="add">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the specified element to the end of this List (optional&#xA;     * operation). &lt;p>&#xA;     *&#xA;     * This implementation calls &lt;tt>add(size(), o)&lt;/tt>.&lt;p>&#xA;     *&#xA;     * Note that this implementation throws an&#xA;     * &lt;tt>UnsupportedOperationException&lt;/tt> unless &lt;tt>add(int, Object)&lt;/tt>&#xA;     * is overridden.&#xA;     *&#xA;     * @param o element to be appended to this list.&#xA;     * &#xA;     * @return &lt;tt>true&lt;/tt> (as per the general contract of&#xA;     * &lt;tt>Collection.add&lt;/tt>).&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>add&lt;/tt> method is not&#xA;     * &#x9;&#x9;  supported by this Set.&#xA;     * &#xA;     * @throws ClassCastException if the class of the specified element&#xA;     * &#x9;&#x9;  prevents it from being added to this set.&#xA;     * &#xA;     * @throws IllegalArgumentException some aspect of this element prevents&#xA;     *            it from being added to this collection.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.4">
          <arguments xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractCollection.class.xmi#//@classifiers.0/@members.2"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>/**&#xA;     * Returns the element at the specified position in this list.&#xA;     *&#xA;     * @param index index of element to return.&#xA;     * &#xA;     * @return the element at the specified position in this list.&#xA;     * @throws IndexOutOfBoundsException if the given index is out of range&#xA;     * &#x9;&#x9;  (&lt;tt>index &amp;lt; 0 || index &amp;gt;= size()&lt;/tt>).&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:ClassMethod" name="set">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="element">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Replaces the element at the specified position in this list with the&#xA;     * specified element (optional operation). &lt;p>&#xA;     *&#xA;     * This implementation always throws an&#xA;     * &lt;tt>UnsupportedOperationException&lt;/tt>.&#xA;     *&#xA;     * @param index index of element to replace.&#xA;     * @param element element to be stored at the specified position.&#xA;     * @return the element previously at the specified position.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>set&lt;/tt> method is not&#xA;     *&#x9;&#x9;  supported by this List.&#xA;     * @throws ClassCastException if the class of the specified element&#xA;     * &#x9;&#x9;  prevents it from being added to this list.&#xA;     * @throws IllegalArgumentException if some aspect of the specified&#xA;     *&#x9;&#x9;  element prevents it from being added to this list.&#xA;     * &#xA;     * @throws IndexOutOfBoundsException if the specified index is out of&#xA;     *            range (&lt;tt>index &amp;lt; 0 || index &amp;gt;= size()&lt;/tt>).&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="add">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="element">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts the specified element at the specified position in this list&#xA;     * (optional operation).  Shifts the element currently at that position&#xA;     * (if any) and any subsequent elements to the right (adds one to their&#xA;     * indices).&lt;p>&#xA;     *&#xA;     * This implementation always throws an UnsupportedOperationException.&#xA;     *&#xA;     * @param index index at which the specified element is to be inserted.&#xA;     * @param element element to be inserted.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>add&lt;/tt> method is not&#xA;     *&#x9;&#x9;  supported by this list.&#xA;     * @throws ClassCastException if the class of the specified element&#xA;     * &#x9;&#x9;  prevents it from being added to this list.&#xA;     * @throws IllegalArgumentException if some aspect of the specified&#xA;     *&#x9;&#x9;  element prevents it from being added to this list.&#xA;     * @throws IndexOutOfBoundsException index is out of range (&lt;tt>index &amp;lt;&#xA;     *&#x9;&#x9;  0 || index &amp;gt; size()&lt;/tt>).&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="remove">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Removes the element at the specified position in this list (optional&#xA;     * operation).  Shifts any subsequent elements to the left (subtracts one&#xA;     * from their indices).  Returns the element that was removed from the&#xA;     * list.&lt;p>&#xA;     *&#xA;     * This implementation always throws an&#xA;     * &lt;tt>UnsupportedOperationException&lt;/tt>.&#xA;     *&#xA;     * @param index the index of the element to remove.&#xA;     * @return the element previously at the specified position.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>remove&lt;/tt> method is&#xA;     *&#x9;&#x9;  not supported by this list.&#xA;     * @throws IndexOutOfBoundsException if the specified index is out of&#xA;     * &#x9;&#x9;  range (&lt;tt>index &amp;lt; 0 || index &amp;gt;= size()&lt;/tt>).&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="indexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Search Operations</comments>
        <comments>/**&#xA;     * Returns the index in this list of the first occurence of the specified&#xA;     * element, or -1 if the list does not contain this element.  More&#xA;     * formally, returns the lowest index &lt;tt>i&lt;/tt> such that &lt;tt>(o==null ?&#xA;     * get(i)==null : o.equals(get(i)))&lt;/tt>, or -1 if there is no such&#xA;     * index.&lt;p>&#xA;     *&#xA;     * This implementation first gets a list iterator (with&#xA;     * &lt;tt>listIterator()&lt;/tt>).  Then, it iterates over the list until the&#xA;     * specified element is found or the end of the list is reached.&#xA;     *&#xA;     * @param o element to search for.&#xA;     * &#xA;     * @return the index in this List of the first occurence of the specified&#xA;     * &#x9;       element, or -1 if the List does not contain this element.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="e">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <target xsi:type="classifiers:Interface" href="ListIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:WhileLoop">
            <statement xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.5"/>
                  </next>
                </returnValue>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                </children>
                <children xsi:type="literals:NullLiteral"/>
              </condition>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:WhileLoop">
            <statement xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.5"/>
                  </next>
                </returnValue>
              </statement>
              <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.4"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.1"/>
                    </next>
                  </arguments>
                </next>
              </condition>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </condition>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lastIndexOf">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the index in this list of the last occurence of the specified&#xA;     * element, or -1 if the list does not contain this element.  More&#xA;     * formally, returns the highest index &lt;tt>i&lt;/tt> such that &lt;tt>(o==null ?&#xA;     * get(i)==null : o.equals(get(i)))&lt;/tt>, or -1 if there is no such&#xA;     * index.&lt;p>&#xA;     *&#xA;     * This implementation first gets a list iterator that points to the end&#xA;     * of the list (with listIterator(size())).  Then, it iterates backwards&#xA;     * over the list until the specified element is found, or the beginning of&#xA;     * the list is reached.&#xA;     *&#xA;     * @param o element to search for.&#xA;     * &#xA;     * @return the index in this list of the last occurence of the specified&#xA;     * &#x9;       element, or -1 if the list does not contain this element.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="e">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <target xsi:type="classifiers:Interface" href="ListIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
            <arguments xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractCollection.class.xmi#//@classifiers.0/@members.2"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:WhileLoop">
            <statement xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.4"/>
                  </next>
                </returnValue>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.3"/>
                  </next>
                </children>
                <children xsi:type="literals:NullLiteral"/>
              </condition>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.2"/>
              </next>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:WhileLoop">
            <statement xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.4"/>
                  </next>
                </returnValue>
              </statement>
              <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.4"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.3"/>
                    </next>
                  </arguments>
                </next>
              </condition>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.2"/>
              </next>
            </condition>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clear">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Bulk Operations</comments>
        <comments>/**&#xA;     * Removes all of the elements from this collection (optional operation).&#xA;     * The collection will be empty after this call returns (unless it throws&#xA;     * an exception).&lt;p>&#xA;     *&#xA;     * This implementation calls &lt;tt>removeRange(0, size())&lt;/tt>.&lt;p>&#xA;     *&#xA;     * Note that this implementation throws an&#xA;     * &lt;tt>UnsupportedOperationException&lt;/tt> unless &lt;tt>remove(int&#xA;     * index)&lt;/tt> or &lt;tt>removeRange(int fromIndex, int toIndex)&lt;/tt> is&#xA;     * overridden.&#xA;     *&#xA;     * @throws UnsupportedOperationException if the &lt;tt>clear&lt;/tt> method is&#xA;     * &#x9;&#x9;  not supported by this Collection.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AbstractCollection.class.xmi#//@classifiers.0/@members.2"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="addAll">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Inserts all of the elements in the specified collection into this list&#xA;     * at the specified position (optional operation).  Shifts the element&#xA;     * currently at that position (if any) and any subsequent elements to the&#xA;     * right (increases their indices).  The new elements will appear in the&#xA;     * list in the order that they are returned by the specified collection's&#xA;     * iterator.  The behavior of this operation is unspecified if the&#xA;     * specified collection is modified while the operation is in progress.&#xA;     * (Note that this will occur if the specified collection is this list,&#xA;     * and it's nonempty.)&lt;p>&#xA;     *&#xA;     * This implementation gets an iterator over the specified collection and&#xA;     * iterates over it, inserting the elements obtained from the iterator&#xA;     * into this list at the appropriate position, one at a time, using&#xA;     * &lt;tt>add(int, Object)&lt;/tt>.  Many implementations will override this&#xA;     * method for efficiency.&lt;p>&#xA;     *&#xA;     * Note that this implementation throws an&#xA;     * &lt;tt>UnsupportedOperationException&lt;/tt> unless &lt;tt>add(int, Object)&lt;/tt>&#xA;     * is overridden.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if this list changed as a result of the call.&#xA;     * @param index index at which to insert the first element from the&#xA;     *&#x9;&#x9;    specified collection.&#xA;     * @param c elements to be inserted into this List.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>addAll&lt;/tt> method is&#xA;     *&#x9;&#x9;  not supported by this list.&#xA;     * &#xA;     * @throws ClassCastException if the class of an element of the specified&#xA;     * &#x9;&#x9;  collection prevents it from being added to this List.&#xA;     * &#xA;     * @throws IllegalArgumentException some aspect an element of the&#xA;     *&#x9;&#x9;  specified collection prevents it from being added to this&#xA;     *&#x9;&#x9;  List.&#xA;     * &#xA;     * @throws IndexOutOfBoundsException index out of range (&lt;tt>index &amp;lt; 0&#xA;     *            || index &amp;gt; size()&lt;/tt>).&#xA;     *&#xA;     * @throws NullPointerException if the specified collection is null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="modified">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="e">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <typeArguments xsi:type="generics:ExtendsTypeArgument">
                <extendTypes xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </extendTypes>
              </typeArguments>
              <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="Collection.class.xmi#//@classifiers.0/@members.3"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.4">
              <arguments xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
                <operator xsi:type="operators:PlusPlus"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="Iterator.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </arguments>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.1/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="Iterator.class.xmi#//@classifiers.0/@members.0"/>
          </next>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="iterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Iterators</comments>
        <comments>/**&#xA;     * Returns an iterator over the elements in this list in proper&#xA;     * sequence. &lt;p>&#xA;     *&#xA;     * This implementation returns a straightforward implementation of the&#xA;     * iterator interface, relying on the backing list's &lt;tt>size()&lt;/tt>,&#xA;     * &lt;tt>get(int)&lt;/tt>, and &lt;tt>remove(int)&lt;/tt> methods.&lt;p>&#xA;     *&#xA;     * Note that the iterator returned by this method will throw an&#xA;     * &lt;tt>UnsupportedOperationException&lt;/tt> in response to its&#xA;     * &lt;tt>remove&lt;/tt> method unless the list's &lt;tt>remove(int)&lt;/tt> method is&#xA;     * overridden.&lt;p>&#xA;     *&#xA;     * This implementation can be made to throw runtime exceptions in the face&#xA;     * of concurrent modification, as described in the specification for the&#xA;     * (protected) &lt;tt>modCount&lt;/tt> field.&#xA;     *&#xA;     * @return an iterator over the elements in this list in proper sequence.&#xA;     * &#xA;     * @see #modCount&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.13"/>
          </typeReference>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="listIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="ListIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an iterator of the elements in this list (in proper sequence).&#xA;     * This implementation returns &lt;tt>listIterator(0)&lt;/tt>.&#xA;     * &#xA;     * @return an iterator of the elements in this list (in proper sequence).&#xA;     * &#xA;     * @see #listIterator(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="listIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="ListIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a list iterator of the elements in this list (in proper&#xA;     * sequence), starting at the specified position in the list.  The&#xA;     * specified index indicates the first element that would be returned by&#xA;     * an initial call to the &lt;tt>next&lt;/tt> method.  An initial call to&#xA;     * the &lt;tt>previous&lt;/tt> method would return the element with the&#xA;     * specified index minus one.&lt;p>&#xA;     *&#xA;     * This implementation returns a straightforward implementation of the&#xA;     * &lt;tt>ListIterator&lt;/tt> interface that extends the implementation of the&#xA;     * &lt;tt>Iterator&lt;/tt> interface returned by the &lt;tt>iterator()&lt;/tt> method.&#xA;     * The &lt;tt>ListIterator&lt;/tt> implementation relies on the backing list's&#xA;     * &lt;tt>get(int)&lt;/tt>, &lt;tt>set(int, Object)&lt;/tt>, &lt;tt>add(int, Object)&lt;/tt>&#xA;     * and &lt;tt>remove(int)&lt;/tt> methods.&lt;p>&#xA;     *&#xA;     * Note that the list iterator returned by this implementation will throw&#xA;     * an &lt;tt>UnsupportedOperationException&lt;/tt> in response to its&#xA;     * &lt;tt>remove&lt;/tt>, &lt;tt>set&lt;/tt> and &lt;tt>add&lt;/tt> methods unless the&#xA;     * list's &lt;tt>remove(int)&lt;/tt>, &lt;tt>set(int, Object)&lt;/tt>, and&#xA;     * &lt;tt>add(int, Object)&lt;/tt> methods are overridden.&lt;p>&#xA;     *&#xA;     * This implementation can be made to throw runtime exceptions in the&#xA;     * face of concurrent modification, as described in the specification for&#xA;     * the (protected) &lt;tt>modCount&lt;/tt> field.&#xA;     *&#xA;     * @param index index of the first element to be returned from the list&#xA;     *&#x9;&#x9;    iterator (by a call to the &lt;tt>next&lt;/tt> method).&#xA;     * &#xA;     * @return a list iterator of the elements in this list (in proper&#xA;     * &#x9;       sequence), starting at the specified position in the list.&#xA;     * &#xA;     * @throws IndexOutOfBoundsException if the specified index is out of&#xA;     *&#x9;&#x9;  range (&lt;tt>index &amp;lt; 0 || index &amp;gt; size()&lt;/tt>).&#xA;     * &#xA;     * @see #modCount&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="Index: "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
            <children xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractCollection.class.xmi#//@classifiers.0/@members.2"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.14"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="classifiers:Class" name="Itr">
      <members xsi:type="members:Field" name="cursor">
        <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        <typeReference xsi:type="types:Int">
          <comments>/**&#xA;&#x9; * Index of element to be returned by subsequent call to next.&#xA;&#x9; */</comments>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="lastRet">
        <initialValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </initialValue>
        <typeReference xsi:type="types:Int">
          <comments>/**&#xA;&#x9; * Index of element returned by most recent call to next or&#xA;&#x9; * previous.  Reset to -1 if this element is deleted by a call&#xA;&#x9; * to remove.&#xA;&#x9; */</comments>
        </typeReference>
      </members>
      <members xsi:type="members:Field" name="expectedModCount">
        <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
        <typeReference xsi:type="types:Int">
          <comments>/**&#xA;&#x9; * The modCount value that the iterator believes that the backing&#xA;&#x9; * List should have.  If this expectation is violated, the iterator&#xA;&#x9; * has detected concurrent modification.&#xA;&#x9; */</comments>
        </typeReference>
      </members>
      <members xsi:type="members:ClassMethod" name="hasNext">
        <typeReference xsi:type="types:Boolean"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
            <children xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractCollection.class.xmi#//@classifiers.0/@members.2"/>
            </children>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="next">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.6"/>
        </statements>
        <statements xsi:type="statements:TryBlock">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="next">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </typeReference>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.2">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                <operator xsi:type="operators:PlusPlus"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.4/@statements.1/@statements.0/@variable"/>
          </statements>
          <catcheBlocks>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.6"/>
            </statements>
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="NoSuchElementException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </throwable>
            </statements>
            <parameter name="e">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </parameter>
          </catcheBlocks>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="remove">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
            <children xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.6"/>
        </statements>
        <statements xsi:type="statements:TryBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0">
              <next xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.5">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
                </next>
                <self xsi:type="literals:This"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                <operator xsi:type="operators:MinusMinus"/>
              </expression>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
            </expression>
          </statements>
          <catcheBlocks>
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="ConcurrentModificationException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </throwable>
            </statements>
            <parameter name="e">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </parameter>
          </catcheBlocks>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="checkForComodification">
        <typeReference xsi:type="types:Void"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="ConcurrentModificationException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2"/>
          </condition>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <implements xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </implements>
    </members>
    <members xsi:type="classifiers:Class" name="ListItr">
      <members xsi:type="members:Constructor" name="ListItr">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.0/@parameters.0"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="index">
          <typeReference xsi:type="types:Int"/>
        </parameters>
      </members>
      <members xsi:type="members:ClassMethod" name="hasPrevious">
        <typeReference xsi:type="types:Boolean"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="previous">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.6"/>
        </statements>
        <statements xsi:type="statements:TryBlock">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="previous">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </typeReference>
              <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.2">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.2/@statements.1/@statements.0/@variable"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.2/@statements.1/@statements.0/@variable"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.2/@statements.1/@statements.1/@variable"/>
          </statements>
          <catcheBlocks>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.6"/>
            </statements>
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="NoSuchElementException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </throwable>
            </statements>
            <parameter name="e">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </parameter>
          </catcheBlocks>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="nextIndex">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="previousIndex">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="set">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="o">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
            <children xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.6"/>
        </statements>
        <statements xsi:type="statements:TryBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0">
              <next xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.5/@parameters.0"/>
                </next>
                <self xsi:type="literals:This"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
            </expression>
          </statements>
          <catcheBlocks>
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="ConcurrentModificationException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </throwable>
            </statements>
            <parameter name="e">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </parameter>
          </catcheBlocks>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="add">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="o">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13/@members.6"/>
        </statements>
        <statements xsi:type="statements:TryBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0">
              <next xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.4">
                  <arguments xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.0"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@members.6/@parameters.0"/>
                </next>
                <self xsi:type="literals:This"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@members.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
            </expression>
          </statements>
          <catcheBlocks>
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="ConcurrentModificationException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </throwable>
            </statements>
            <parameter name="e">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </parameter>
          </catcheBlocks>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <implements xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="ListIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </implements>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.13"/>
      </extends>
    </members>
    <members xsi:type="members:ClassMethod" name="subList">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="List.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a view of the portion of this list between &lt;tt>fromIndex&lt;/tt>,&#xA;     * inclusive, and &lt;tt>toIndex&lt;/tt>, exclusive.  (If &lt;tt>fromIndex&lt;/tt> and&#xA;     * &lt;tt>toIndex&lt;/tt> are equal, the returned list is empty.)  The returned&#xA;     * list is backed by this list, so changes in the returned list are&#xA;     * reflected in this list, and vice-versa.  The returned list supports all&#xA;     * of the optional list operations supported by this list.&lt;p>&#xA;     *&#xA;     * This method eliminates the need for explicit range operations (of the&#xA;     * sort that commonly exist for arrays).  Any operation that expects a&#xA;     * list can be used as a range operation by operating on a subList view&#xA;     * instead of a whole list.  For example, the following idiom removes a&#xA;     * range of elements from a list:&#xA;     * &lt;pre>&#xA;     *     list.subList(from, to).clear();&#xA;     * &lt;/pre>&#xA;     * Similar idioms may be constructed for &lt;tt>indexOf&lt;/tt> and&#xA;     * &lt;tt>lastIndexOf&lt;/tt>, and all of the algorithms in the&#xA;     * &lt;tt>Collections&lt;/tt> class can be applied to a subList.&lt;p>&#xA;     * &#xA;     * The semantics of the list returned by this method become undefined if&#xA;     * the backing list (i.e., this list) is &lt;i>structurally modified&lt;/i> in&#xA;     * any way other than via the returned list.  (Structural modifications are&#xA;     * those that change the size of the list, or otherwise perturb it in such&#xA;     * a fashion that iterations in progress may yield incorrect results.)&lt;p>&#xA;     *&#xA;     * This implementation returns a list that subclasses&#xA;     * &lt;tt>AbstractList&lt;/tt>.  The subclass stores, in private fields, the&#xA;     * offset of the subList within the backing list, the size of the subList&#xA;     * (which can change over its lifetime), and the expected&#xA;     * &lt;tt>modCount&lt;/tt> value of the backing list.  There are two variants&#xA;     * of the subclass, one of which implements &lt;tt>RandomAccess&lt;/tt>.&#xA;     * If this list implements &lt;tt>RandomAccess&lt;/tt> the returned list will&#xA;     * be an instance of the subclass that implements &lt;tt>RandomAccess&lt;/tt>.&lt;p>&#xA;     *&#xA;     * The subclass's &lt;tt>set(int, Object)&lt;/tt>, &lt;tt>get(int)&lt;/tt>,&#xA;     * &lt;tt>add(int, Object)&lt;/tt>, &lt;tt>remove(int)&lt;/tt>, &lt;tt>addAll(int,&#xA;     * Collection)&lt;/tt> and &lt;tt>removeRange(int, int)&lt;/tt> methods all&#xA;     * delegate to the corresponding methods on the backing abstract list,&#xA;     * after bounds-checking the index and adjusting for the offset.  The&#xA;     * &lt;tt>addAll(Collection c)&lt;/tt> method merely returns &lt;tt>addAll(size,&#xA;     * c)&lt;/tt>.&lt;p>&#xA;     *&#xA;     * The &lt;tt>listIterator(int)&lt;/tt> method returns a &quot;wrapper object&quot; over a&#xA;     * list iterator on the backing list, which is created with the&#xA;     * corresponding method on the backing list.  The &lt;tt>iterator&lt;/tt> method&#xA;     * merely returns &lt;tt>listIterator()&lt;/tt>, and the &lt;tt>size&lt;/tt> method&#xA;     * merely returns the subclass's &lt;tt>size&lt;/tt> field.&lt;p>&#xA;     *&#xA;     * All methods first check to see if the actual &lt;tt>modCount&lt;/tt> of the&#xA;     * backing list is equal to its expected value, and throw a&#xA;     * &lt;tt>ConcurrentModificationException&lt;/tt> if it is not.&#xA;     *&#xA;     * @param fromIndex low endpoint (inclusive) of the subList.&#xA;     * @param toIndex high endpoint (exclusive) of the subList.&#xA;     * @return a view of the specified range within this list.&#xA;     * @throws IndexOutOfBoundsException endpoint index value out of range&#xA;     *         &lt;tt>(fromIndex &amp;lt; 0 || toIndex &amp;gt; size)&lt;/tt>&#xA;     * @throws IllegalArgumentException endpoint indices out of order&#xA;     * &lt;tt>(fromIndex &amp;gt; toIndex)&lt;/tt> */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="RandomAccess.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </child>
            </child>
            <expressionIf xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.2">
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                    </typeReference>
                  </typeArguments>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
            </expressionIf>
            <expressionElse xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.1">
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                    </typeReference>
                  </typeArguments>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
            </expressionElse>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Comparison and hashing</comments>
        <comments>/**&#xA;     * Compares the specified object with this list for equality.  Returns&#xA;     * &lt;tt>true&lt;/tt> if and only if the specified object is also a list, both&#xA;     * lists have the same size, and all corresponding pairs of elements in&#xA;     * the two lists are &lt;i>equal&lt;/i>.  (Two elements &lt;tt>e1&lt;/tt> and&#xA;     * &lt;tt>e2&lt;/tt> are &lt;i>equal&lt;/i> if &lt;tt>(e1==null ? e2==null :&#xA;     * e1.equals(e2))&lt;/tt>.)  In other words, two lists are defined to be&#xA;     * equal if they contain the same elements in the same order.&lt;p>&#xA;     *&#xA;     * This implementation first checks if the specified object is this&#xA;     * list. If so, it returns &lt;tt>true&lt;/tt>; if not, it checks if the&#xA;     * specified object is a list. If not, it returns &lt;tt>false&lt;/tt>; if so,&#xA;     * it iterates over both lists, comparing corresponding pairs of elements.&#xA;     * If any comparison returns &lt;tt>false&lt;/tt>, this method returns&#xA;     * &lt;tt>false&lt;/tt>.  If either iterator runs out of elements before the&#xA;     * other it returns &lt;tt>false&lt;/tt> (as the lists are of unequal length);&#xA;     * otherwise it returns &lt;tt>true&lt;/tt> when the iterations complete.&#xA;     *&#xA;     * @param o the object to be compared for equality with this list.&#xA;     * &#xA;     * @return &lt;tt>true&lt;/tt> if the specified object is equal to this list.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          <children xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="List.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="e1">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <target xsi:type="classifiers:Interface" href="ListIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="e2">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="ListIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:NestedExpression">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="List.class.xmi#//@classifiers.0/@members.22"/>
            </next>
            <expression xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Interface" href="List.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="o1">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.2/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="o2">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.3/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="literals:BooleanLiteral"/>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ConditionalExpression">
                  <child xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.4/@statement/@statements.0/@variable"/>
                    <children xsi:type="literals:NullLiteral"/>
                  </child>
                  <expressionIf xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.4/@statement/@statements.1/@variable"/>
                    <children xsi:type="literals:NullLiteral"/>
                  </expressionIf>
                  <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.4/@statement/@statements.0/@variable">
                    <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.4/@statement/@statements.1/@variable"/>
                    </next>
                  </expressionElse>
                </expression>
              </child>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.2/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.3/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.2/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.3/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </children>
            </expression>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the hash code value for this list. &lt;p>&#xA;     *&#xA;     * This implementation uses exactly the code that is used to define the&#xA;     * list hash function in the documentation for the &lt;tt>List.hashCode&lt;/tt>&#xA;     * method.&#xA;     *&#xA;     * @return the hash code value for this list.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="hashCode">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="i">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.10"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="obj">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.1/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="Iterator.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:AdditiveExpression">
                <children xsi:type="expressions:MultiplicativeExpression">
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="31"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
                  <multiplicativeOperators xsi:type="operators:Multiplication"/>
                </children>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ConditionalExpression">
                    <child xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.2/@statement/@statements.0/@variable"/>
                      <children xsi:type="literals:NullLiteral"/>
                    </child>
                    <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.2/@statement/@statements.0/@variable">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.17"/>
                    </expressionElse>
                  </expression>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.1/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="Iterator.class.xmi#//@classifiers.0/@members.0"/>
          </next>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeRange">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Removes from this list all of the elements whose index is between&#xA;     * &lt;tt>fromIndex&lt;/tt>, inclusive, and &lt;tt>toIndex&lt;/tt>, exclusive.&#xA;     * Shifts any succeeding elements to the left (reduces their index).  This&#xA;     * call shortens the ArrayList by &lt;tt>(toIndex - fromIndex)&lt;/tt>&#xA;     * elements.  (If &lt;tt>toIndex==fromIndex&lt;/tt>, this operation has no&#xA;     * effect.)&lt;p>&#xA;     *&#xA;     * This method is called by the &lt;tt>clear&lt;/tt> operation on this list&#xA;     * and its subLists.  Overriding this method to take advantage of&#xA;     * the internals of the list implementation can &lt;i>substantially&lt;/i>&#xA;     * improve the performance of the &lt;tt>clear&lt;/tt> operation on this list&#xA;     * and its subLists.&lt;p>&#xA;     *&#xA;     * This implementation gets a list iterator positioned before&#xA;     * &lt;tt>fromIndex&lt;/tt>, and repeatedly calls &lt;tt>ListIterator.next&lt;/tt>&#xA;     * followed by &lt;tt>ListIterator.remove&lt;/tt> until the entire range has&#xA;     * been removed.  &lt;b>Note: if &lt;tt>ListIterator.remove&lt;/tt> requires linear&#xA;     * time, this implementation requires quadratic time.&lt;/b>&#xA;     *&#xA;     * @param fromIndex index of first element to be removed.&#xA;     * @param toIndex index after last element to be removed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="it">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <target xsi:type="classifiers:Interface" href="ListIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.6"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@init/@additionalLocalVariables.0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <additionalLocalVariables name="n">
            <initialValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </initialValue>
          </additionalLocalVariables>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:Field" name="modCount">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The number of times this list has been &lt;i>structurally modified&lt;/i>.&#xA;     * Structural modifications are those that change the size of the&#xA;     * list, or otherwise perturb it in such a fashion that iterations in&#xA;     * progress may yield incorrect results.&lt;p>&#xA;     *&#xA;     * This field is used by the iterator and list iterator implementation&#xA;     * returned by the &lt;tt>iterator&lt;/tt> and &lt;tt>listIterator&lt;/tt> methods.&#xA;     * If the value of this field changes unexpectedly, the iterator (or list&#xA;     * iterator) will throw a &lt;tt>ConcurrentModificationException&lt;/tt> in&#xA;     * response to the &lt;tt>next&lt;/tt>, &lt;tt>remove&lt;/tt>, &lt;tt>previous&lt;/tt>,&#xA;     * &lt;tt>set&lt;/tt> or &lt;tt>add&lt;/tt> operations.  This provides&#xA;     * &lt;i>fail-fast&lt;/i> behavior, rather than non-deterministic behavior in&#xA;     * the face of concurrent modification during iteration.&lt;p>&#xA;     *&#xA;     * &lt;b>Use of this field by subclasses is optional.&lt;/b> If a subclass&#xA;     * wishes to provide fail-fast iterators (and list iterators), then it&#xA;     * merely has to increment this field in its &lt;tt>add(int, Object)&lt;/tt> and&#xA;     * &lt;tt>remove(int)&lt;/tt> methods (and any other methods that it overrides&#xA;     * that result in structural modifications to the list).  A single call to&#xA;     * &lt;tt>add(int, Object)&lt;/tt> or &lt;tt>remove(int)&lt;/tt> must add no more than&#xA;     * one to this field, or the iterators (and list iterators) will throw&#xA;     * bogus &lt;tt>ConcurrentModificationExceptions&lt;/tt>.  If an implementation&#xA;     * does not wish to provide fail-fast iterators, this field may be&#xA;     * ignored.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This class provides a skeletal implementation of the &lt;tt>List&lt;/tt>&#xA; * interface to minimize the effort required to implement this interface&#xA; * backed by a &quot;random access&quot; data store (such as an array).  For sequential&#xA; * access data (such as a linked list), &lt;tt>AbstractSequentialList&lt;/tt> should&#xA; * be used in preference to this class.&lt;p>&#xA; *&#xA; * To implement an unmodifiable list, the programmer needs only to extend this&#xA; * class and provide implementations for the &lt;tt>get(int index)&lt;/tt> and&#xA; * &lt;tt>size()&lt;/tt> methods.&lt;p>&#xA; *&#xA; * To implement a modifiable list, the programmer must additionally override&#xA; * the &lt;tt>set(int index, Object element)&lt;/tt> method (which otherwise throws&#xA; * an &lt;tt>UnsupportedOperationException&lt;/tt>.  If the list is variable-size&#xA; * the programmer must additionally override the &lt;tt>add(int index, Object&#xA; * element)&lt;/tt> and &lt;tt>remove(int index)&lt;/tt> methods.&lt;p>&#xA; *&#xA; * The programmer should generally provide a void (no argument) and collection&#xA; * constructor, as per the recommendation in the &lt;tt>Collection&lt;/tt> interface&#xA; * specification.&lt;p>&#xA; *&#xA; * Unlike the other abstract collection implementations, the programmer does&#xA; * &lt;i>not&lt;/i> have to provide an iterator implementation; the iterator and&#xA; * list iterator are implemented by this class, on top the &quot;random access&quot;&#xA; * methods: &lt;tt>get(int index)&lt;/tt>, &lt;tt>set(int index, Object element)&lt;/tt>,&#xA; * &lt;tt>set(int index, Object element)&lt;/tt>, &lt;tt>add(int index, Object&#xA; * element)&lt;/tt> and &lt;tt>remove(int index)&lt;/tt>.&lt;p>&#xA; *&#xA; * The documentation for each non-abstract methods in this class describes its&#xA; * implementation in detail.  Each of these methods may be overridden if the&#xA; * collection being implemented admits a more efficient implementation.&lt;p>&#xA; *&#xA; * This class is a member of the &#xA; * &lt;a href=&quot;{@docRoot}/../guide/collections/index.html&quot;>&#xA; * Java Collections Framework&lt;/a>.&#xA; *&#xA; * @author  Josh Bloch&#xA; * @author  Neal Gafter&#xA; * @version 1.37, 01/18/03&#xA; * @see Collection&#xA; * @see List&#xA; * @see AbstractSequentialList&#xA; * @see AbstractCollection&#xA; * @since 1.2&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="List.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Class" href="AbstractCollection.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
  <classifiers xsi:type="classifiers:Class" name="SubList">
    <typeParameters name="E"/>
    <members xsi:type="members:Field" name="l">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0">
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="offset">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="size">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="expectedModCount">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Constructor" name="SubList">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="fromIndex = "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@parameters.1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="toIndex = "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@parameters.2"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@parameters.2"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AbstractCollection.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="fromIndex("/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@parameters.1"/>
              <children xsi:type="references:StringReference" value=") > toIndex("/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@parameters.2"/>
              <children xsi:type="references:StringReference" value=")"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@parameters.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@parameters.2"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@parameters.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.4/@parameters.1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.3"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="list">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0">
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:ClassMethod" name="set">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="element">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.1/@members.16">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.5/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.1/@members.17"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.5/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.5/@parameters.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.1/@members.16">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.6/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.1/@members.17"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.6/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="size">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.1/@members.17"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="add">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="element">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.8/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.8/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.1/@members.17"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.4">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.8/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.8/@parameters.1"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.3"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
          <operator xsi:type="operators:PlusPlus"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
          <operator xsi:type="operators:PlusPlus"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="remove">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.1/@members.16">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.9/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.1/@members.17"/>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.5">
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.9/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.3"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
          <operator xsi:type="operators:MinusMinus"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
          <operator xsi:type="operators:PlusPlus"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.9/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeRange">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.1/@members.17"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.10/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.10/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.3"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
          <assignmentOperator xsi:type="operators:AssignmentMinus"/>
          <value xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.10/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.10/@parameters.0"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </expression>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
          <operator xsi:type="operators:PlusPlus"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="addAll">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.1/@members.12">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.11/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="addAll">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="Index: "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.12/@parameters.0"/>
              <children xsi:type="references:StringReference" value=", Size: "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.12/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.12/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cSize">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.12/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="Collection.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.12/@statements.1/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.1/@members.17"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.9">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.12/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.12/@parameters.1"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.3"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.12/@statements.1/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
          <operator xsi:type="operators:PlusPlus"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="iterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Iterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="listIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="ListIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.1/@members.17"/>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="Index: "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.14/@parameters.0"/>
              <children xsi:type="references:StringReference" value=", Size: "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.14/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.14/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
              <target xsi:type="classifiers:Interface" href="ListIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <anonymousClass>
            <members xsi:type="members:Field" name="i">
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.14/@parameters.0"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </next>
              </initialValue>
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <typeArguments xsi:type="generics:QualifiedTypeArgument">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
                    </typeReference>
                  </typeArguments>
                  <target xsi:type="classifiers:Interface" href="ListIterator.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <annotationsAndModifiers xsi:type="modifiers:Private"/>
            </members>
            <members xsi:type="members:ClassMethod" name="hasNext">
              <typeReference xsi:type="types:Boolean"/>
              <annotationsAndModifiers xsi:type="modifiers:Public"/>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:MethodCall" target="//@classifiers.1/@members.14/@statements.2/@returnValue/@anonymousClass/@members.5"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </returnValue>
              </statements>
            </members>
            <members xsi:type="members:ClassMethod" name="next">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
              </typeReference>
              <annotationsAndModifiers xsi:type="modifiers:Public"/>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Return">
                  <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.14/@statements.2/@returnValue/@anonymousClass/@members.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.1"/>
                    </next>
                  </returnValue>
                </statement>
                <condition xsi:type="references:MethodCall" target="//@classifiers.1/@members.14/@statements.2/@returnValue/@anonymousClass/@members.1"/>
                <elseStatement xsi:type="statements:Throw">
                  <throwable xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="NoSuchElementException.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                  </throwable>
                </elseStatement>
              </statements>
            </members>
            <members xsi:type="members:ClassMethod" name="hasPrevious">
              <typeReference xsi:type="types:Boolean"/>
              <annotationsAndModifiers xsi:type="modifiers:Public"/>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:MethodCall" target="//@classifiers.1/@members.14/@statements.2/@returnValue/@anonymousClass/@members.6"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                </returnValue>
              </statements>
            </members>
            <members xsi:type="members:ClassMethod" name="previous">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
              </typeReference>
              <annotationsAndModifiers xsi:type="modifiers:Public"/>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Return">
                  <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.14/@statements.2/@returnValue/@anonymousClass/@members.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.3"/>
                    </next>
                  </returnValue>
                </statement>
                <condition xsi:type="references:MethodCall" target="//@classifiers.1/@members.14/@statements.2/@returnValue/@anonymousClass/@members.3"/>
                <elseStatement xsi:type="statements:Throw">
                  <throwable xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="NoSuchElementException.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                  </throwable>
                </elseStatement>
              </statements>
            </members>
            <members xsi:type="members:ClassMethod" name="nextIndex">
              <typeReference xsi:type="types:Int"/>
              <annotationsAndModifiers xsi:type="modifiers:Public"/>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.14/@statements.2/@returnValue/@anonymousClass/@members.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.4"/>
                    </next>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </returnValue>
              </statements>
            </members>
            <members xsi:type="members:ClassMethod" name="previousIndex">
              <typeReference xsi:type="types:Int"/>
              <annotationsAndModifiers xsi:type="modifiers:Public"/>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.14/@statements.2/@returnValue/@anonymousClass/@members.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.5"/>
                    </next>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.1"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </returnValue>
              </statements>
            </members>
            <members xsi:type="members:ClassMethod" name="remove">
              <typeReference xsi:type="types:Void"/>
              <annotationsAndModifiers xsi:type="modifiers:Public"/>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.14/@statements.2/@returnValue/@anonymousClass/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.6"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.3"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
                  <operator xsi:type="operators:MinusMinus"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </expression>
              </statements>
            </members>
            <members xsi:type="members:ClassMethod" name="set">
              <typeReference xsi:type="types:Void"/>
              <parameters xsi:type="parameters:OrdinaryParameter" name="o">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
                </typeReference>
              </parameters>
              <annotationsAndModifiers xsi:type="modifiers:Public"/>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.14/@statements.2/@returnValue/@anonymousClass/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.7"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.14/@statements.2/@returnValue/@anonymousClass/@members.8/@parameters.0"/>
                  </next>
                </expression>
              </statements>
            </members>
            <members xsi:type="members:ClassMethod" name="add">
              <typeReference xsi:type="types:Void"/>
              <parameters xsi:type="parameters:OrdinaryParameter" name="o">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
                </typeReference>
              </parameters>
              <annotationsAndModifiers xsi:type="modifiers:Public"/>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.14/@statements.2/@returnValue/@anonymousClass/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="ListIterator.class.xmi#//@classifiers.0/@members.8"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.14/@statements.2/@returnValue/@anonymousClass/@members.9/@parameters.0"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.3"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </expression>
              </statements>
            </members>
          </anonymousClass>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="subList">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="List.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.1">
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.15/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.15/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="rangeCheck">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="Index: "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.16/@parameters.0"/>
              <children xsi:type="references:StringReference" value=",Size: "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.16/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.16/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.2"/>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkForComodification">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="ConcurrentModificationException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.1/@members.3"/>
        </condition>
      </statements>
    </members>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences target="//@classifiers.0">
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.1/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
      </classifierReferences>
    </extends>
  </classifiers>
  <classifiers xsi:type="classifiers:Class" name="RandomAccessSubList">
    <typeParameters name="E"/>
    <members xsi:type="members:Constructor" name="RandomAccessSubList">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.0/@parameters.2"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="list">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0">
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.2/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:ClassMethod" name="subList">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.2/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="List.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fromIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="toIndex">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.2">
              <typeArguments xsi:type="generics:QualifiedTypeArgument">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.2/@typeParameters.0"/>
                </typeReference>
              </typeArguments>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.2/@members.1/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="RandomAccess.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences target="//@classifiers.1">
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.2/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
