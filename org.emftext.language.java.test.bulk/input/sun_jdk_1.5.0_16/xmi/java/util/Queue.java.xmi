<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="Queue.java">
  <comments>/*&#xA; * @(#)Queue.java&#x9;1.5 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Queue">
    <typeParameters name="E"/>
    <members xsi:type="members:InterfaceMethod" name="offer">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Inserts the specified element into this queue, if possible.  When&#xA;     * using queues that may impose insertion restrictions (for&#xA;     * example capacity bounds), method &lt;tt>offer&lt;/tt> is generally&#xA;     * preferable to method {@link Collection#add}, which can fail to&#xA;     * insert an element only by throwing an exception.&#xA;     *&#xA;     * @param o the element to insert.&#xA;     * @return &lt;tt>true&lt;/tt> if it was possible to add the element to&#xA;     * this queue, else &lt;tt>false&lt;/tt>&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="poll">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0">
          <comments>/**&#xA;     * Retrieves and removes the head of this queue, or &lt;tt>null&lt;/tt>&#xA;     * if this queue is empty.&#xA;     *&#xA;     * @return the head of this queue, or &lt;tt>null&lt;/tt> if this&#xA;     *         queue is empty.&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="remove">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0">
          <comments>/**&#xA;     * Retrieves and removes the head of this queue.  This method&#xA;     * differs from the &lt;tt>poll&lt;/tt> method in that it throws an&#xA;     * exception if this queue is empty.&#xA;     *&#xA;     * @return the head of this queue.&#xA;     * @throws NoSuchElementException if this queue is empty.&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="peek">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0">
          <comments>/**&#xA;     * Retrieves, but does not remove, the head of this queue,&#xA;     * returning &lt;tt>null&lt;/tt> if this queue is empty.&#xA;     *&#xA;     * @return the head of this queue, or &lt;tt>null&lt;/tt> if this queue&#xA;     * is empty.&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="element">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.0">
          <comments>/**&#xA;     * Retrieves, but does not remove, the head of this queue.  This method&#xA;     * differs from the &lt;tt>peek&lt;/tt> method only in that it throws an&#xA;     * exception if this queue is empty.&#xA;     *&#xA;     * @return the head of this queue.&#xA;     * @throws NoSuchElementException if this queue is empty.&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A collection designed for holding elements prior to processing.&#xA; * Besides basic {@link java.util.Collection Collection} operations, queues provide&#xA; * additional insertion, extraction, and inspection operations.&#xA; *&#xA; * &lt;p>Queues typically, but do not necessarily, order elements in a&#xA; * FIFO (first-in-first-out) manner.  Among the exceptions are&#xA; * priority queues, which order elements according to a supplied&#xA; * comparator, or the elements' natural ordering, and LIFO queues (or&#xA; * stacks) which order the elements LIFO (last-in-first-out).&#xA; * Whatever the ordering used, the &lt;em>head&lt;/em> of the queue is that&#xA; * element which would be removed by a call to {@link #remove() } or&#xA; * {@link #poll()}.  In a FIFO queue, all new elements are inserted at&#xA; * the &lt;em> tail&lt;/em> of the queue. Other kinds of queues may use&#xA; * different placement rules.  Every &lt;tt>Queue&lt;/tt> implementation&#xA; * must specify its ordering properties.&#xA; *&#xA; * &lt;p>The {@link #offer offer} method inserts an element if possible,&#xA; * otherwise returning &lt;tt>false&lt;/tt>.  This differs from the {@link&#xA; * java.util.Collection#add Collection.add} method, which can fail to&#xA; * add an element only by throwing an unchecked exception.  The&#xA; * &lt;tt>offer&lt;/tt> method is designed for use when failure is a normal,&#xA; * rather than exceptional occurrence, for example, in fixed-capacity&#xA; * (or &amp;quot;bounded&amp;quot;) queues.&#xA; *&#xA; * &lt;p>The {@link #remove()} and {@link #poll()} methods remove and&#xA; * return the head of the queue.&#xA; * Exactly which element is removed from the queue is a&#xA; * function of the queue's ordering policy, which differs from&#xA; * implementation to implementation. The &lt;tt>remove()&lt;/tt> and&#xA; * &lt;tt>poll()&lt;/tt> methods differ only in their behavior when the&#xA; * queue is empty: the &lt;tt>remove()&lt;/tt> method throws an exception,&#xA; * while the &lt;tt>poll()&lt;/tt> method returns &lt;tt>null&lt;/tt>.&#xA; *&#xA; * &lt;p>The {@link #element()} and {@link #peek()} methods return, but do&#xA; * not remove, the head of the queue.&#xA; *&#xA; * &lt;p>The &lt;tt>Queue&lt;/tt> interface does not define the &lt;i>blocking queue&#xA; * methods&lt;/i>, which are common in concurrent programming.  These methods,&#xA; * which wait for elements to appear or for space to become available, are&#xA; * defined in the {@link java.util.concurrent.BlockingQueue} interface, which&#xA; * extends this interface.&#xA; *&#xA; * &lt;p>&lt;tt>Queue&lt;/tt> implementations generally do not allow insertion&#xA; * of &lt;tt>null&lt;/tt> elements, although some implementations, such as&#xA; * {@link LinkedList}, do not prohibit insertion of &lt;tt>null&lt;/tt>.&#xA; * Even in the implementations that permit it, &lt;tt>null&lt;/tt> should&#xA; * not be inserted into a &lt;tt>Queue&lt;/tt>, as &lt;tt>null&lt;/tt> is also&#xA; * used as a special return value by the &lt;tt>poll&lt;/tt> method to&#xA; * indicate that the queue contains no elements.&#xA; *&#xA; * &lt;p>&lt;tt>Queue&lt;/tt> implementations generally do not define&#xA; * element-based versions of methods &lt;tt>equals&lt;/tt> and&#xA; * &lt;tt>hashCode&lt;/tt> but instead inherit the identity based versions&#xA; * from class &lt;tt>Object&lt;/tt>, because element-based equality is not&#xA; * always well-defined for queues with the same elements but different&#xA; * ordering properties.&#xA; *&#xA; *&#xA; * &lt;p>This interface is a member of the&#xA; * &lt;a href=&quot;{@docRoot}/../guide/collections/index.html&quot;>&#xA; * Java Collections Framework&lt;/a>.&#xA; *&#xA; * @see java.util.Collection&#xA; * @see LinkedList&#xA; * @see PriorityQueue&#xA; * @see java.util.concurrent.LinkedBlockingQueue&#xA; * @see java.util.concurrent.BlockingQueue&#xA; * @see java.util.concurrent.ArrayBlockingQueue&#xA; * @see java.util.concurrent.LinkedBlockingQueue&#xA; * @see java.util.concurrent.PriorityBlockingQueue&#xA; * @since 1.5&#xA; * @author Doug Lea&#xA; * @param &lt;E> the type of elements held in this collection&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
