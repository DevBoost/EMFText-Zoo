<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="LinkedHashSet.java">
  <comments>/*&#xA; * @(#)LinkedHashSet.java&#x9;1.14 04/02/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <classifiers xsi:type="classifiers:Class" name="LinkedHashSet">
    <typeParameters name="E"/>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="2851667679971038690"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="LinkedHashSet">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.1"/>
          <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="initialCapacity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="loadFactor">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new, empty linked hash set with the specified initial&#xA;     * capacity and load factor. &#xA;     *&#xA;     * @param      initialCapacity the initial capacity of the linked hash set&#xA;     * @param      loadFactor      the load factor of the linked hash set.&#xA;     * @throws     IllegalArgumentException  if the initial capacity is less&#xA;     *               than zero, or if the load factor is nonpositive.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="LinkedHashSet">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          <arguments xsi:type="literals:DecimalFloatLiteral" decimalValue="0.75"/>
          <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="initialCapacity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new, empty linked hash set with the specified initial&#xA;     * capacity and the default load factor (0.75).&#xA;     *&#xA;     * @param   initialCapacity   the initial capacity of the LinkedHashSet.&#xA;     * @throws  IllegalArgumentException if the initial capacity is less&#xA;     *              than zero.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="LinkedHashSet">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
          <arguments xsi:type="literals:DecimalFloatLiteral" decimalValue="0.75"/>
          <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new, empty linked hash set with the default initial&#xA;     * capacity (16) and load factor (0.75).&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="LinkedHashSet">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="Collection.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                </children>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </arguments>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
          </arguments>
          <arguments xsi:type="literals:DecimalFloatLiteral" decimalValue="0.75"/>
          <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="AbstractCollection.class.xmi#//@classifiers.0/@members.10"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new linked hash set with the same elements as the&#xA;     * specified collection.  The linked hash set is created with an initial&#xA;     * capacity sufficient to hold the elements in the specified collection&#xA;     * and the default load factor (0.75).&#xA;     *&#xA;     * @param c  the collection whose elements are to be placed into &#xA;     *           this set.&#xA;     * @throws NullPointerException if the specified collection is null.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;p>Hash table and linked list implementation of the &lt;tt>Set&lt;/tt> interface,&#xA; * with predictable iteration order.  This implementation differs from&#xA; * &lt;tt>HashSet&lt;/tt> in that it maintains a doubly-linked list running through&#xA; * all of its entries.  This linked list defines the iteration ordering,&#xA; * which is the order in which elements were inserted into the set&#xA; * (&lt;i>insertion-order&lt;/i>).  Note that insertion order is &lt;i>not&lt;/i> affected&#xA; * if an element is &lt;i>re-inserted&lt;/i> into the set.  (An element &lt;tt>e&lt;/tt>&#xA; * is reinserted into a set &lt;tt>s&lt;/tt> if &lt;tt>s.add(e)&lt;/tt> is invoked when&#xA; * &lt;tt>s.contains(e)&lt;/tt> would return &lt;tt>true&lt;/tt> immediately prior to&#xA; * the invocation.)&#xA; *&#xA; * &lt;p>This implementation spares its clients from the unspecified, generally&#xA; * chaotic ordering provided by {@link HashSet}, without incurring the&#xA; * increased cost associated with {@link TreeSet}.  It can be used to&#xA; * produce a copy of a set that has the same order as the original, regardless&#xA; * of the original set's implementation:&#xA; * &lt;pre>&#xA; *     void foo(Set m) {&#xA; *         Set copy = new LinkedHashSet(m);&#xA; *         ...&#xA; *     }&#xA; * &lt;/pre>&#xA; * This technique is particularly useful if a module takes a set on input,&#xA; * copies it, and later returns results whose order is determined by that of&#xA; * the copy.  (Clients generally appreciate having things returned in the same&#xA; * order they were presented.)&#xA; *&#xA; * &lt;p>This class provides all of the optional &lt;tt>Set&lt;/tt> operations, and&#xA; * permits null elements.  Like &lt;tt>HashSet&lt;/tt>, it provides constant-time&#xA; * performance for the basic operations (&lt;tt>add&lt;/tt>, &lt;tt>contains&lt;/tt> and&#xA; * &lt;tt>remove&lt;/tt>), assuming the hash function disperses elements&#xA; * properly among the buckets.  Performance is likely to be just slightly&#xA; * below that of &lt;tt>HashSet&lt;/tt>, due to the added expense of maintaining the&#xA; * linked list, with one exception: Iteration over a &lt;tt>LinkedHashSet&lt;/tt>&#xA; * requires time proportional to the &lt;i>size&lt;/i> of the set, regardless of&#xA; * its capacity.  Iteration over a &lt;tt>HashSet&lt;/tt> is likely to be more&#xA; * expensive, requiring time proportional to its &lt;i>capacity&lt;/i>.&#xA; * &#xA; * &lt;p>A linked hash set has two parameters that affect its performance:&#xA; * &lt;i>initial capacity&lt;/i> and &lt;i>load factor&lt;/i>.  They are defined precisely&#xA; * as for &lt;tt>HashSet&lt;/tt>.  Note, however, that the penalty for choosing an&#xA; * excessively high value for initial capacity is less severe for this class&#xA; * than for &lt;tt>HashSet&lt;/tt>, as iteration times for this class are unaffected&#xA; * by capacity.&#xA; * &#xA; * &lt;p>&lt;strong>Note that this implementation is not synchronized.&lt;/strong> If&#xA; * multiple threads access a linked hash set concurrently, and at least one of&#xA; * the threads modifies the set, it &lt;em>must&lt;/em> be synchronized externally.&#xA; * This is typically accomplished by synchronizing on some object that&#xA; * naturally encapsulates the set.  If no such object exists, the set should&#xA; * be &quot;wrapped&quot; using the &lt;tt>Collections.synchronizedSet&lt;/tt>method.  This is&#xA; * best done at creation time, to prevent accidental unsynchronized access:&#xA; * &lt;pre>&#xA; *     Set s = Collections.synchronizedSet(new LinkedHashSet(...));&#xA; * &lt;/pre>&#xA; *&#xA; * &lt;p>The iterators returned by the this class's &lt;tt>iterator&lt;/tt> method are&#xA; * &lt;em>fail-fast&lt;/em>: if the set is modified at any time after the iterator&#xA; * is created, in any way except through the iterator's own remove method, the&#xA; * iterator will throw a &lt;tt>ConcurrentModificationException&lt;/tt>.  Thus, in&#xA; * the face of concurrent modification, the Iterator fails quickly and&#xA; * cleanly, rather than risking arbitrary, non-deterministic behavior at an&#xA; * undetermined time in the future.&#xA; *&#xA; * &lt;p>Note that the fail-fast behavior of an iterator cannot be guaranteed&#xA; * as it is, generally speaking, impossible to make any hard guarantees in the&#xA; * presence of unsynchronized concurrent modification.  Fail-fast iterators&#xA; * throw &lt;tt>ConcurrentModificationException&lt;/tt> on a best-effort basis. &#xA; * Therefore, it would be wrong to write a program that depended on this&#xA; * exception for its correctness:   &lt;i>the fail-fast behavior of iterators&#xA; * should be used only to detect bugs.&lt;/i>&#xA; *&#xA; * &lt;p>This class is a member of the &#xA; * &lt;a href=&quot;{@docRoot}/../guide/collections/index.html&quot;>&#xA; * Java Collections Framework&lt;/a>.&#xA; *&#xA; * @author  Josh Bloch&#xA; * @version 1.14 04/02/19&#xA; * @see     Object#hashCode()&#xA; * @see     Collection&#xA; * @see     Set&#xA; * @see     HashSet&#xA; * @see     TreeSet&#xA; * @see     Hashtable&#xA; * @since   1.4&#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="Set.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../lang/Cloneable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <namespaces>java</namespaces>
      <namespaces>io</namespaces>
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../io/Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Class" href="HashSet.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
