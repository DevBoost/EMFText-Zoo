<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="Map.java">
  <comments>/*&#xA; * @(#)Map.java&#x9;1.48 04/06/28&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>util</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Map">
    <typeParameters name="K"/>
    <typeParameters name="V"/>
    <members xsi:type="members:InterfaceMethod" name="size">
      <typeReference xsi:type="types:Int">
        <comments>// Query Operations</comments>
        <comments>/**&#xA;     * Returns the number of key-value mappings in this map.  If the&#xA;     * map contains more than &lt;tt>Integer.MAX_VALUE&lt;/tt> elements, returns&#xA;     * &lt;tt>Integer.MAX_VALUE&lt;/tt>.&#xA;     *&#xA;     * @return the number of key-value mappings in this map.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isEmpty">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this map contains no key-value mappings.&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if this map contains no key-value mappings.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="containsKey">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this map contains a mapping for the specified&#xA;     * key.  More formally, returns &lt;tt>true&lt;/tt> if and only if&#xA;     * this map contains a mapping for a key &lt;tt>k&lt;/tt> such that&#xA;     * &lt;tt>(key==null ? k==null : key.equals(k))&lt;/tt>.  (There can be&#xA;     * at most one such mapping.)&#xA;     *&#xA;     * @param key key whose presence in this map is to be tested.&#xA;     * @return &lt;tt>true&lt;/tt> if this map contains a mapping for the specified&#xA;     *         key.&#xA;     * &#xA;     * @throws ClassCastException if the key is of an inappropriate type for&#xA;     * &#x9;&#x9;  this map (optional).&#xA;     * @throws NullPointerException if the key is &lt;tt>null&lt;/tt> and this map&#xA;     *            does not permit &lt;tt>null&lt;/tt> keys (optional).&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="containsValue">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns &lt;tt>true&lt;/tt> if this map maps one or more keys to the&#xA;     * specified value.  More formally, returns &lt;tt>true&lt;/tt> if and only if&#xA;     * this map contains at least one mapping to a value &lt;tt>v&lt;/tt> such that&#xA;     * &lt;tt>(value==null ? v==null : value.equals(v))&lt;/tt>.  This operation&#xA;     * will probably require time linear in the map size for most&#xA;     * implementations of the &lt;tt>Map&lt;/tt> interface.&#xA;     *&#xA;     * @param value value whose presence in this map is to be tested.&#xA;     * @return &lt;tt>true&lt;/tt> if this map maps one or more keys to the&#xA;     *         specified value.&#xA;     * @throws ClassCastException if the value is of an inappropriate type for&#xA;     * &#x9;&#x9;  this map (optional).&#xA;     * @throws NullPointerException if the value is &lt;tt>null&lt;/tt> and this map&#xA;     *            does not permit &lt;tt>null&lt;/tt> values (optional).&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.1">
          <comments>/**&#xA;     * Returns the value to which this map maps the specified key.  Returns&#xA;     * &lt;tt>null&lt;/tt> if the map contains no mapping for this key.  A return&#xA;     * value of &lt;tt>null&lt;/tt> does not &lt;i>necessarily&lt;/i> indicate that the&#xA;     * map contains no mapping for the key; it's also possible that the map&#xA;     * explicitly maps the key to &lt;tt>null&lt;/tt>.  The &lt;tt>containsKey&lt;/tt>&#xA;     * operation may be used to distinguish these two cases.&#xA;     *&#xA;     * &lt;p>More formally, if this map contains a mapping from a key&#xA;     * &lt;tt>k&lt;/tt> to a value &lt;tt>v&lt;/tt> such that &lt;tt>(key==null ? k==null :&#xA;     * key.equals(k))&lt;/tt>, then this method returns &lt;tt>v&lt;/tt>; otherwise&#xA;     * it returns &lt;tt>null&lt;/tt>.  (There can be at most one such mapping.)&#xA;     *&#xA;     * @param key key whose associated value is to be returned.&#xA;     * @return the value to which this map maps the specified key, or&#xA;     *&#x9;       &lt;tt>null&lt;/tt> if the map contains no mapping for this key.&#xA;     * &#xA;     * @throws ClassCastException if the key is of an inappropriate type for&#xA;     * &#x9;&#x9;  this map (optional).&#xA;     * @throws NullPointerException if the key is &lt;tt>null&lt;/tt> and this map&#xA;     *&#x9;&#x9;  does not permit &lt;tt>null&lt;/tt> keys (optional).&#xA;     * &#xA;     * @see #containsKey(Object)&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.1">
          <comments>// Modification Operations</comments>
          <comments>/**&#xA;     * Associates the specified value with the specified key in this map&#xA;     * (optional operation).  If the map previously contained a mapping for&#xA;     * this key, the old value is replaced by the specified value.  (A map&#xA;     * &lt;tt>m&lt;/tt> is said to contain a mapping for a key &lt;tt>k&lt;/tt> if and only&#xA;     * if {@link #containsKey(Object) m.containsKey(k)} would return&#xA;     * &lt;tt>true&lt;/tt>.)) &#xA;     *&#xA;     * @param key key with which the specified value is to be associated.&#xA;     * @param value value to be associated with the specified key.&#xA;     * @return previous value associated with specified key, or &lt;tt>null&lt;/tt>&#xA;     *&#x9;       if there was no mapping for key.  A &lt;tt>null&lt;/tt> return can&#xA;     *&#x9;       also indicate that the map previously associated &lt;tt>null&lt;/tt>&#xA;     *&#x9;       with the specified key, if the implementation supports&#xA;     *&#x9;       &lt;tt>null&lt;/tt> values.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>put&lt;/tt> operation is&#xA;     *&#x9;          not supported by this map.&#xA;     * @throws ClassCastException if the class of the specified key or value&#xA;     * &#x9;          prevents it from being stored in this map.&#xA;     * @throws IllegalArgumentException if some aspect of this key or value&#xA;     *&#x9;          prevents it from being stored in this map.&#xA;     * @throws NullPointerException if this map does not permit &lt;tt>null&lt;/tt>&#xA;     *            keys or values, and the specified key or value is&#xA;     *            &lt;tt>null&lt;/tt>.&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="remove">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@typeParameters.1">
          <comments>/**&#xA;     * Removes the mapping for this key from this map if it is present&#xA;     * (optional operation).   More formally, if this map contains a mapping&#xA;     * from key &lt;tt>k&lt;/tt> to value &lt;tt>v&lt;/tt> such that&#xA;     * &lt;code>(key==null ?  k==null : key.equals(k))&lt;/code>, that mapping&#xA;     * is removed.  (The map can contain at most one such mapping.)&#xA;     *&#xA;     * &lt;p>Returns the value to which the map previously associated the key, or&#xA;     * &lt;tt>null&lt;/tt> if the map contained no mapping for this key.  (A&#xA;     * &lt;tt>null&lt;/tt> return can also indicate that the map previously&#xA;     * associated &lt;tt>null&lt;/tt> with the specified key if the implementation&#xA;     * supports &lt;tt>null&lt;/tt> values.)  The map will not contain a mapping for&#xA;     * the specified  key once the call returns.&#xA;     *&#xA;     * @param key key whose mapping is to be removed from the map.&#xA;     * @return previous value associated with specified key, or &lt;tt>null&lt;/tt>&#xA;     *&#x9;       if there was no mapping for key.&#xA;     *&#xA;     * @throws ClassCastException if the key is of an inappropriate type for&#xA;     * &#x9;&#x9;  this map (optional).&#xA;     * @throws NullPointerException if the key is &lt;tt>null&lt;/tt> and this map&#xA;     *            does not permit &lt;tt>null&lt;/tt> keys (optional).&#xA;     * @throws UnsupportedOperationException if the &lt;tt>remove&lt;/tt> method is&#xA;     *         not supported by this map.&#xA;     */</comments>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="key">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putAll">
      <typeReference xsi:type="types:Void">
        <comments>// Bulk Operations</comments>
        <comments>/**&#xA;     * Copies all of the mappings from the specified map to this map&#xA;     * (optional operation).  The effect of this call is equivalent to that&#xA;     * of calling {@link #put(Object,Object) put(k, v)} on this map once&#xA;     * for each mapping from key &lt;tt>k&lt;/tt> to value &lt;tt>v&lt;/tt> in the &#xA;     * specified map.  The behavior of this operation is unspecified if the&#xA;     * specified map is modified while the operation is in progress.&#xA;     *&#xA;     * @param t Mappings to be stored in this map.&#xA;     * &#xA;     * @throws UnsupportedOperationException if the &lt;tt>putAll&lt;/tt> method is&#xA;     * &#x9;&#x9;  not supported by this map.&#xA;     * &#xA;     * @throws ClassCastException if the class of a key or value in the&#xA;     * &#x9;          specified map prevents it from being stored in this map.&#xA;     * &#xA;     * @throws IllegalArgumentException some aspect of a key or value in the&#xA;     *&#x9;          specified map prevents it from being stored in this map.&#xA;     * @throws NullPointerException if the specified map is &lt;tt>null&lt;/tt>, or if&#xA;     *         this map does not permit &lt;tt>null&lt;/tt> keys or values, and the&#xA;     *         specified map contains &lt;tt>null&lt;/tt> keys or values.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="t">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0">
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
              </extendTypes>
            </typeArguments>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
              </extendTypes>
            </typeArguments>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="clear">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Removes all mappings from this map (optional operation).&#xA;     *&#xA;     * @throws UnsupportedOperationException clear is not supported by this&#xA;     * &#x9;&#x9;  map.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="keySet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>// Views</comments>
          <comments>/**&#xA;     * Returns a set view of the keys contained in this map.  The set is&#xA;     * backed by the map, so changes to the map are reflected in the set, and&#xA;     * vice-versa.  If the map is modified while an iteration over the set is&#xA;     * in progress (except through the iterator's own &lt;tt>remove&lt;/tt>&#xA;     * operation), the results of the iteration are undefined.  The set&#xA;     * supports element removal, which removes the corresponding mapping from&#xA;     * the map, via the &lt;tt>Iterator.remove&lt;/tt>, &lt;tt>Set.remove&lt;/tt>,&#xA;     * &lt;tt>removeAll&lt;/tt> &lt;tt>retainAll&lt;/tt>, and &lt;tt>clear&lt;/tt> operations.&#xA;     * It does not support the add or &lt;tt>addAll&lt;/tt> operations.&#xA;     *&#xA;     * @return a set view of the keys contained in this map.&#xA;     */</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Set.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="values">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns a collection view of the values contained in this map.  The&#xA;     * collection is backed by the map, so changes to the map are reflected in&#xA;     * the collection, and vice-versa.  If the map is modified while an&#xA;     * iteration over the collection is in progress (except through the&#xA;     * iterator's own &lt;tt>remove&lt;/tt> operation), the results of the&#xA;     * iteration are undefined.  The collection supports element removal,&#xA;     * which removes the corresponding mapping from the map, via the&#xA;     * &lt;tt>Iterator.remove&lt;/tt>, &lt;tt>Collection.remove&lt;/tt>,&#xA;     * &lt;tt>removeAll&lt;/tt>, &lt;tt>retainAll&lt;/tt> and &lt;tt>clear&lt;/tt> operations.&#xA;     * It does not support the add or &lt;tt>addAll&lt;/tt> operations.&#xA;     *&#xA;     * @return a collection view of the values contained in this map.&#xA;     */</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="entrySet">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Returns a set view of the mappings contained in this map.  Each element&#xA;     * in the returned set is a {@link Map.Entry}.  The set is backed by the&#xA;     * map, so changes to the map are reflected in the set, and vice-versa.&#xA;     * If the map is modified while an iteration over the set is in progress&#xA;     * (except through the iterator's own &lt;tt>remove&lt;/tt> operation, or through&#xA;     * the &lt;tt>setValue&lt;/tt> operation on a map entry returned by the iterator)&#xA;     * the results of the iteration are undefined.  The set supports element&#xA;     * removal, which removes the corresponding mapping from the map, via the&#xA;     * &lt;tt>Iterator.remove&lt;/tt>, &lt;tt>Set.remove&lt;/tt>, &lt;tt>removeAll&lt;/tt>,&#xA;     * &lt;tt>retainAll&lt;/tt> and &lt;tt>clear&lt;/tt> operations.  It does not support&#xA;     * the &lt;tt>add&lt;/tt> or &lt;tt>addAll&lt;/tt> operations.&#xA;     *&#xA;     * @return a set view of the mappings contained in this map.&#xA;     */</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <namespaces>Map</namespaces>
              <classifierReferences target="//@classifiers.0/@members.12">
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.0"/>
                  </typeReference>
                </typeArguments>
                <typeArguments xsi:type="generics:QualifiedTypeArgument">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0/@typeParameters.1"/>
                  </typeReference>
                </typeArguments>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="Set.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="classifiers:Interface" name="Entry">
      <comments>/**&#xA;     * A map entry (key-value pair).  The &lt;tt>Map.entrySet&lt;/tt> method returns&#xA;     * a collection-view of the map, whose elements are of this class.  The&#xA;     * &lt;i>only&lt;/i> way to obtain a reference to a map entry is from the&#xA;     * iterator of this collection-view.  These &lt;tt>Map.Entry&lt;/tt> objects are&#xA;     * valid &lt;i>only&lt;/i> for the duration of the iteration; more formally,&#xA;     * the behavior of a map entry is undefined if the backing map has been&#xA;     * modified after the entry was returned by the iterator, except through&#xA;     * the &lt;tt>setValue&lt;/tt> operation on the map entry.&#xA;     *&#xA;     * @see Map#entrySet()&#xA;     * @since 1.2&#xA;     */</comments>
      <typeParameters name="K"/>
      <typeParameters name="V"/>
      <members xsi:type="members:InterfaceMethod" name="getKey">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.12/@typeParameters.0">
            <comments>/**&#xA;&#x9; * Returns the key corresponding to this entry.&#xA;&#x9; *&#xA;&#x9; * @return the key corresponding to this entry.&#xA;         * @throws IllegalStateException implementations may, but are not&#xA;         *         required to, throw this exception if the entry has been&#xA;         *         removed from the backing map&#xA;&#x9; */</comments>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:InterfaceMethod" name="getValue">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.12/@typeParameters.1">
            <comments>/**&#xA;&#x9; * Returns the value corresponding to this entry.  If the mapping&#xA;&#x9; * has been removed from the backing map (by the iterator's&#xA;&#x9; * &lt;tt>remove&lt;/tt> operation), the results of this call are undefined.&#xA;&#x9; *&#xA;&#x9; * @return the value corresponding to this entry.&#xA;         * @throws IllegalStateException implementations may, but are not&#xA;         *         required to, throw this exception if the entry has been&#xA;         *         removed from the backing map&#xA;&#x9; */</comments>
          </classifierReferences>
        </typeReference>
      </members>
      <members xsi:type="members:InterfaceMethod" name="setValue">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.12/@typeParameters.1">
            <comments>/**&#xA;&#x9; * Replaces the value corresponding to this entry with the specified&#xA;&#x9; * value (optional operation).  (Writes through to the map.)  The&#xA;&#x9; * behavior of this call is undefined if the mapping has already been&#xA;&#x9; * removed from the map (by the iterator's &lt;tt>remove&lt;/tt> operation).&#xA;&#x9; *&#xA;&#x9; * @param value new value to be stored in this entry.&#xA;&#x9; * @return old value corresponding to the entry.&#xA;         * &#xA;&#x9; * @throws UnsupportedOperationException if the &lt;tt>put&lt;/tt> operation&#xA;&#x9; *&#x9;      is not supported by the backing map.&#xA;&#x9; * @throws ClassCastException if the class of the specified value&#xA;&#x9; * &#x9;      prevents it from being stored in the backing map.&#xA;&#x9; * @throws    IllegalArgumentException if some aspect of this value&#xA;&#x9; *&#x9;      prevents it from being stored in the backing map.&#xA;&#x9; * @throws NullPointerException if the backing map does not permit&#xA;&#x9; *&#x9;      &lt;tt>null&lt;/tt> values, and the specified value is&#xA;&#x9; *&#x9;      &lt;tt>null&lt;/tt>.&#xA;         * @throws IllegalStateException implementations may, but are not&#xA;         *         required to, throw this exception if the entry has been&#xA;         *         removed from the backing map&#xA;         */</comments>
          </classifierReferences>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="value">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.12/@typeParameters.1"/>
          </typeReference>
        </parameters>
      </members>
      <members xsi:type="members:InterfaceMethod" name="equals">
        <typeReference xsi:type="types:Boolean">
          <comments>/**&#xA;&#x9; * Compares the specified object with this entry for equality.&#xA;&#x9; * Returns &lt;tt>true&lt;/tt> if the given object is also a map entry and&#xA;&#x9; * the two entries represent the same mapping.  More formally, two&#xA;&#x9; * entries &lt;tt>e1&lt;/tt> and &lt;tt>e2&lt;/tt> represent the same mapping&#xA;&#x9; * if&lt;pre>&#xA;         *     (e1.getKey()==null ?&#xA;         *      e2.getKey()==null : e1.getKey().equals(e2.getKey()))  &amp;&amp;&#xA;         *     (e1.getValue()==null ?&#xA;         *      e2.getValue()==null : e1.getValue().equals(e2.getValue()))&#xA;         * &lt;/pre>&#xA;&#x9; * This ensures that the &lt;tt>equals&lt;/tt> method works properly across&#xA;&#x9; * different implementations of the &lt;tt>Map.Entry&lt;/tt> interface.&#xA;&#x9; *&#xA;&#x9; * @param o object to be compared for equality with this map entry.&#xA;&#x9; * @return &lt;tt>true&lt;/tt> if the specified object is equal to this map&#xA;&#x9; *         entry.&#xA;         */</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="o">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
      </members>
      <members xsi:type="members:InterfaceMethod" name="hashCode">
        <typeReference xsi:type="types:Int">
          <comments>/**&#xA;&#x9; * Returns the hash code value for this map entry.  The hash code&#xA;&#x9; * of a map entry &lt;tt>e&lt;/tt> is defined to be: &lt;pre>&#xA;&#x9; *     (e.getKey()==null   ? 0 : e.getKey().hashCode()) ^&#xA;&#x9; *     (e.getValue()==null ? 0 : e.getValue().hashCode())&#xA;         * &lt;/pre>&#xA;&#x9; * This ensures that &lt;tt>e1.equals(e2)&lt;/tt> implies that&#xA;&#x9; * &lt;tt>e1.hashCode()==e2.hashCode()&lt;/tt> for any two Entries&#xA;&#x9; * &lt;tt>e1&lt;/tt> and &lt;tt>e2&lt;/tt>, as required by the general&#xA;&#x9; * contract of &lt;tt>Object.hashCode&lt;/tt>.&#xA;&#x9; *&#xA;&#x9; * @return the hash code value for this map entry.&#xA;&#x9; * @see Object#hashCode()&#xA;&#x9; * @see Object#equals(Object)&#xA;&#x9; * @see #equals(Object)&#xA;&#x9; */</comments>
        </typeReference>
      </members>
    </members>
    <members xsi:type="members:InterfaceMethod" name="equals">
      <typeReference xsi:type="types:Boolean">
        <comments>// Comparison and hashing</comments>
        <comments>/**&#xA;     * Compares the specified object with this map for equality.  Returns&#xA;     * &lt;tt>true&lt;/tt> if the given object is also a map and the two Maps&#xA;     * represent the same mappings.  More formally, two maps &lt;tt>t1&lt;/tt> and&#xA;     * &lt;tt>t2&lt;/tt> represent the same mappings if&#xA;     * &lt;tt>t1.entrySet().equals(t2.entrySet())&lt;/tt>.  This ensures that the&#xA;     * &lt;tt>equals&lt;/tt> method works properly across different implementations&#xA;     * of the &lt;tt>Map&lt;/tt> interface.&#xA;     *&#xA;     * @param o object to be compared for equality with this map.&#xA;     * @return &lt;tt>true&lt;/tt> if the specified object is equal to this map.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="o">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="hashCode">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Returns the hash code value for this map.  The hash code of a map&#xA;     * is defined to be the sum of the hashCodes of each entry in the map's&#xA;     * entrySet view.  This ensures that &lt;tt>t1.equals(t2)&lt;/tt> implies&#xA;     * that &lt;tt>t1.hashCode()==t2.hashCode()&lt;/tt> for any two maps&#xA;     * &lt;tt>t1&lt;/tt> and &lt;tt>t2&lt;/tt>, as required by the general&#xA;     * contract of Object.hashCode.&#xA;     *&#xA;     * @return the hash code value for this map.&#xA;     * @see Map.Entry#hashCode()&#xA;     * @see Object#hashCode()&#xA;     * @see Object#equals(Object)&#xA;     * @see #equals(Object)&#xA;     */</comments>
      </typeReference>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * An object that maps keys to values.  A map cannot contain duplicate keys;&#xA; * each key can map to at most one value.&#xA; *&#xA; * &lt;p>This interface takes the place of the &lt;tt>Dictionary&lt;/tt> class, which&#xA; * was a totally abstract class rather than an interface.&#xA; *&#xA; * &lt;p>The &lt;tt>Map&lt;/tt> interface provides three &lt;i>collection views&lt;/i>, which&#xA; * allow a map's contents to be viewed as a set of keys, collection of values,&#xA; * or set of key-value mappings.  The &lt;i>order&lt;/i> of a map is defined as&#xA; * the order in which the iterators on the map's collection views return their&#xA; * elements.  Some map implementations, like the &lt;tt>TreeMap&lt;/tt> class, make&#xA; * specific guarantees as to their order; others, like the &lt;tt>HashMap&lt;/tt>&#xA; * class, do not.&#xA; *&#xA; * &lt;p>Note: great care must be exercised if mutable objects are used as map&#xA; * keys.  The behavior of a map is not specified if the value of an object is&#xA; * changed in a manner that affects equals comparisons while the object is a&#xA; * key in the map.  A special case of this prohibition is that it is not&#xA; * permissible for a map to contain itself as a key.  While it is permissible&#xA; * for a map to contain itself as a value, extreme caution is advised: the&#xA; * equals and hashCode methods are no longer well defined on a such a map.&#xA; *&#xA; * &lt;p>All general-purpose map implementation classes should provide two&#xA; * &quot;standard&quot; constructors: a void (no arguments) constructor which creates an&#xA; * empty map, and a constructor with a single argument of type &lt;tt>Map&lt;/tt>,&#xA; * which creates a new map with the same key-value mappings as its argument.&#xA; * In effect, the latter constructor allows the user to copy any map,&#xA; * producing an equivalent map of the desired class.  There is no way to&#xA; * enforce this recommendation (as interfaces cannot contain constructors) but&#xA; * all of the general-purpose map implementations in the JDK comply.&#xA; *&#xA; * &lt;p>The &quot;destructive&quot; methods contained in this interface, that is, the&#xA; * methods that modify the map on which they operate, are specified to throw&#xA; * &lt;tt>UnsupportedOperationException&lt;/tt> if this map does not support the&#xA; * operation.  If this is the case, these methods may, but are not required&#xA; * to, throw an &lt;tt>UnsupportedOperationException&lt;/tt> if the invocation would&#xA; * have no effect on the map.  For example, invoking the {@link #putAll(Map)}&#xA; * method on an unmodifiable map may, but is not required to, throw the&#xA; * exception if the map whose mappings are to be &quot;superimposed&quot; is empty.&#xA; *&#xA; * &lt;p>Some map implementations have restrictions on the keys and values they&#xA; * may contain.  For example, some implementations prohibit null keys and&#xA; * values, and some have restrictions on the types of their keys.  Attempting&#xA; * to insert an ineligible key or value throws an unchecked exception,&#xA; * typically &lt;tt>NullPointerException&lt;/tt> or &lt;tt>ClassCastException&lt;/tt>.&#xA; * Attempting to query the presence of an ineligible key or value may throw an&#xA; * exception, or it may simply return false; some implementations will exhibit&#xA; * the former behavior and some will exhibit the latter.  More generally,&#xA; * attempting an operation on an ineligible key or value whose completion&#xA; * would not result in the insertion of an ineligible element into the map may&#xA; * throw an exception or it may succeed, at the option of the implementation.&#xA; * Such exceptions are marked as &quot;optional&quot; in the specification for this&#xA; * interface.&#xA; *&#xA; * &lt;p>This interface is a member of the &#xA; * &lt;a href=&quot;{@docRoot}/../guide/collections/index.html&quot;>&#xA; * Java Collections Framework&lt;/a>.&#xA; *&#xA; * &lt;p>Many methods in Collections Framework interfaces are defined&#xA; * in terms of the {@link Object#equals(Object) equals} method.  For&#xA; * example, the specification for the {@link #containsKey(Object)&#xA; * contains(Object key)} method says: &quot;returns &lt;tt>true&lt;/tt> if and&#xA; * only if this map contain a mapping for a key &lt;tt>k&lt;/tt> such that&#xA; * &lt;tt>(key==null ? k==null : key.equals(k))&lt;/tt>.&quot; This specification should&#xA; * &lt;i>not&lt;/i> be construed to imply that invoking &lt;tt>Map.containsKey&lt;/tt>&#xA; * with a non-null argument &lt;tt>key&lt;/tt> will cause &lt;tt>key.equals(k)&lt;/tt> to&#xA; * be invoked for any key &lt;tt>k&lt;/tt>.  Implementations are free to&#xA; * implement optimizations whereby the &lt;tt>equals&lt;/tt> invocation is avoided,&#xA; * for example, by first comparing the hash codes of the two keys.  (The&#xA; * {@link Object#hashCode()} specification guarantees that two objects with&#xA; * unequal hash codes cannot be equal.)  More generally, implementations of&#xA; * the various Collections Framework interfaces are free to take advantage of&#xA; * the specified behavior of underlying {@link Object} methods wherever the&#xA; * implementor deems it appropriate.&#xA; *&#xA; * @author  Josh Bloch&#xA; * @version 1.48, 06/28/04&#xA; * @see HashMap&#xA; * @see TreeMap&#xA; * @see Hashtable&#xA; * @see SortedMap&#xA; * @see Collection&#xA; * @see Set&#xA; * @since 1.2&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
